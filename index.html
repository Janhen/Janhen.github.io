<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-大数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2021-03-09T15:23:13.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用 Notion 做笔记，博客为 Notion 的部分导出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/" data-id="ckm733rto001aivvx6fovax8l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hive-基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-03-09T14:57:00.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/">Hive-基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p><img src="http://img.janhen.com/20210309213549Hive.png" alt="http://img.janhen.com/20210309213549Hive.png"></p>
<p>[TOC]</p>
<h2 id="基础说明"><a href="#基础说明" class="headerlink" title="基础说明"></a>基础说明</h2><blockquote>
<p><strong>将 SQL 转换成 MapReduce 任务的工具。</strong> 基于 Hadoop 的数据仓库工具，存储和处理海量结构化的数据，可将结构化的数据映射成一张表</p>
</blockquote>
<p>FaceBook 开发的海量数据查询工具，基本实现了 <code>SQL-92</code> 标准。</p>
<p>可以与 Druid, Kudu 进行集成 与 HBase 集成</p>
<p><strong>说明</strong></p>
<p>处理 HDFS 中的海量数据</p>
<p>通过 SQL 完成计算</p>
<p>基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能.</p>
<p>最适合数据仓库程序</p>
<p>缺点：</p>
<p>HQL 表达能力有限： 无法表示迭代计算，数据挖掘方面不擅长</p>
<p>效率低： 自动生成的 MR 效率，调优较困难</p>
<p>Pig: Hive 的替代品，apache 顶级项目 一种数据流语言，不是查询语言 常用语 ETL 中的一部分</p>
<p>HBase: 已经可以结合 Hive 使用</p>
<p>Thrift: 提供了可远程访问其他进程的功能，提供了使用 JDBC, ODBC 访问 Hive 的功能</p>
<p>HWI: 简单的网页界面</p>
<p>HQL：</p>
<p>Hive:</p>
<ul>
<li>解释器: AST 抽象语法树</li>
<li>编译器</li>
<li>优化器</li>
<li>执行期</li>
<li>MetaStore</li>
</ul>
<p>Hive 的元数据默认存储在自带的 derby 数据库中 derby: java 开发、但进程、单用户</p>
<h3 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h3><p>// TODO</p>
<p>Client： Hive、Beeline、Hue</p>
<p>元数据库： 存放元数据的地方，数据库、表、分区、列的名称和属性，数据所在位置等信息</p>
<p>Meta store 元数据服务： 提供统一的服务接口，Client 通过 metastore 访问元数据。三种模式，内嵌、本地、远程模式。</p>
<p>。。。</p>
<p>Hive Driver： 解释器、编译器、优化器、执行器</p>
<p>HSQL 转化为 MapReduce 的过程</p>
<p>HiveSQL</p>
<ul>
<li>-&gt; AST 抽象语法树</li>
<li>-&gt; QB 查询块</li>
<li>-&gt; OperatorTree 操作树</li>
<li>-&gt; 优化后的 OperatorTree</li>
<li>-&gt; MapReduce 树</li>
<li>-&gt; 优化后的 MapReduce 任务树</li>
</ul>
<p>Q: Hive 关联表对应 MapReduce 如何实现？</p>
<h3 id="Hive-的优缺点"><a href="#Hive-的优缺点" class="headerlink" title="Hive 的优缺点"></a>Hive 的优缺点</h3><p><strong>Hive 的优点</strong></p>
<ul>
<li>学习成本低。Hive提供了类似SQL的查询语言，开发人员能快速上手；</li>
<li>处理海量数据。底层执行的是MapReduce 任务；</li>
<li>系统可以水平扩展。底层基于Hadoop； 功能可以扩展。</li>
<li>Hive允许用户自定义函数；</li>
<li>良好的容错性。某个节点发生故障，HQL仍然可以正常完成；</li>
<li>统一的元数据管理。元数据包括：有哪些表、表有什么字段、字段是什么类型</li>
</ul>
<p><strong>Hive 的缺点</strong></p>
<ul>
<li>HQL表达能力有限；</li>
<li>迭代计算无法表达；</li>
<li>Hive的执行效率不高(基于MR的执行引擎)；</li>
<li>Hive自动生成的MapReduce作业，某些情况下不够智能；</li>
<li>Hive的调优困难；</li>
</ul>
<h3 id="Hive-架构"><a href="#Hive-架构" class="headerlink" title="Hive 架构"></a>Hive 架构</h3><p><img src="http://img.janhen.com/20210302225729OHxiB9.png" alt="http://img.janhen.com/20210302225729OHxiB9.png"></p>
<ul>
<li>CLI: Hive  命令行</li>
<li>Thrift Server: Hive 可选组件，一个软件框架服务，可通过编程方式访问 Hive</li>
<li>MetaStore:  元数据存储在 RDBMS 中，元数据包括数据库名、表名和类型、字段名和数据类型、数据所在的位置等</li>
<li>Driver： 驱动程序<ul>
<li>解析器： 第三方工具(antlr) 将 HQL 字符串转换成 AST，对 AST 进行语法分析，如字段是否存在、SQL 语义正确性、表的存在</li>
<li>编译器： 将 AST 编译成逻辑执行计划</li>
<li>优化器： 对逻辑执行计划进行优化，减少不必要的列、使用分区、进行谓词下推等</li>
<li>执行器： 将逻辑执行计划转换成可以运行的物理计划</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型与转换"><a href="#数据类型与转换" class="headerlink" title="数据类型与转换"></a>数据类型与转换</h3><p><strong>基本数据类型</strong></p>
<ul>
<li>整数类型： Integer 、TINYINT、SMALINT、INT、BIGINT</li>
<li>浮点数类型： FLOAT、DOUBLE、DECIMAL(17byte)</li>
<li>字符类型： STRING(任意长度)、VARCHAR(1-65535)</li>
<li>日期类型：</li>
</ul>
<p><strong>类型转换</strong></p>
<ul>
<li>String 可隐式转换</li>
<li>整形科转换为更广的类型，TINYINT → INT, INT → BIGINT</li>
<li>整数类型、FLOAT、STRING 类型可隐式转换成 DOUBLE</li>
<li>cast 进行强制类型转换，失败返回空</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="string">&#x27;11111&#x27;</span> <span class="keyword">AS</span> <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure>

<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p><strong>四种集合类型</strong></p>
<ul>
<li>array: 有序的相同类型集合</li>
<li>map: key 为基本类型</li>
<li>struct: 不同类型字段的集合</li>
<li>union: 不同类型元素存储在统一字段的不同行中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAMED_STRUCT(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;usernamexx&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="number">7</span>, <span class="string">&quot;salary&quot;</span>, <span class="string">&quot;111111.23&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用案例</strong></p>
<p>原始的 JSON 数据</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;songsong&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;friends&quot;</span>: [<span class="string">&quot;bingbing&quot;</span> , <span class="string">&quot;lili&quot;</span>] ,       <span class="comment">//列表Array,</span></span><br><span class="line">    <span class="attr">&quot;children&quot;</span>: &#123;                      <span class="comment">//键值Map,</span></span><br><span class="line">        <span class="attr">&quot;xiao song&quot;</span>: <span class="number">18</span> ,</span><br><span class="line">        <span class="attr">&quot;xiaoxiao song&quot;</span>: <span class="number">19</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: &#123;                      <span class="comment">//结构Struct,</span></span><br><span class="line">        <span class="attr">&quot;street&quot;</span>: <span class="string">&quot;hui long guan&quot;</span> ,</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式好的行数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijing</span><br><span class="line">yangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing</span><br><span class="line">-- 表创建</span><br><span class="line">create table <span class="built_in">test</span>(</span><br><span class="line">  name string,</span><br><span class="line">  friends array&lt;string&gt;,</span><br><span class="line">  children map&lt;string, int&gt;,</span><br><span class="line">  address struct&lt;street:string, city:string&gt;</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by <span class="string">&#x27;,&#x27;</span></span><br><span class="line">collection items terminated by <span class="string">&#x27;_&#x27;</span></span><br><span class="line">map keys terminated by <span class="string">&#x27;:&#x27;</span></span><br><span class="line">lines terminated by <span class="string">&#x27;\\\\n&#x27;</span>;</span><br><span class="line">-- 测试结构查询</span><br><span class="line">SELECT friends[1], children[<span class="string">&#x27;xiao song&#x27;</span>], address.city </span><br><span class="line">FROM <span class="built_in">test</span> WHERE name = <span class="string">&#x27;songsong&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h3><ul>
<li>外部表： 指定 external 关键字，元数据 + 数据分开管理，删除表定义，数据不会删除</li>
<li>内部表： 删除表的时候数据会删除</li>
<li>分桶表： 实现 DML 事务时必须</li>
<li>分区表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket (</span><br><span class="line">  empno <span class="built_in">INT</span>,</span><br><span class="line">  ename <span class="keyword">STRING</span>,</span><br><span class="line">  job <span class="keyword">STRING</span>,</span><br><span class="line">  mgr <span class="built_in">INT</span>,</span><br><span class="line">  hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm DECIM</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Q: 为何分区？</p>
<p>可避免全表扫描，提高查询效率，通常根据事件、地区等信息进行分区</p>
<p>Q: 为何分桶？</p>
<p>分区或表数据量过大，分桶降数据划分成更细粒度。</p>
<p>通过 分桶字段.hashCode % 分桶个数。</p>
<p>不能使用 load data local inpath 方式加载数据</p>
<p>在数据仓库中</p>
<p>ODS 外部表，从外部进来</p>
<p>DW 内部表</p>
<p>ADS 内部表</p>
<p>计算过程中使用到的临时表，数据随用随删，使用内部表。</p>
<h3 id="文本文件编码"><a href="#文本文件编码" class="headerlink" title="文本文件编码"></a>文本文件编码</h3><p>支持自定义文件存储格式</p>
<p>默认的文件分割</p>
<ul>
<li>行与行 <code>\\n</code></li>
<li>字段之间 <code>^A</code></li>
<li>元素之间 <code>^B</code></li>
<li>k-v 之间： <code>^C</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示 ^A/^B 特殊的控制字符</span></span><br><span class="line">cat -A emp</span><br></pre></td></tr></table></figure>

<h3 id="读时模式"><a href="#读时模式" class="headerlink" title="读时模式"></a>读时模式</h3><p>写时模式 -&gt; 写数据检查 -&gt; RDBMS 读时模式 -&gt; 读时检查 -&gt; Hive</p>
<p>写时模式： 在加载时发现数据不符合表的定义，则拒绝加载数据。数据在写入 数据库时对照表模式进行检。</p>
<p>读时模式： 加载数据时不进行数据格 式的校验，读取数据时如果不合法则显示NULL。</p>
<h2 id="元数据管理"><a href="#元数据管理" class="headerlink" title="元数据管理"></a>元数据管理</h2><p><img src="http://img.janhen.com/2021022510200471tjjj.jpg" alt="http://img.janhen.com/2021022510200471tjjj.jpg"></p>
<p>通常是独立的 RDBMS</p>
<p>元数据信息包括： 存在的表、表的列、权限 …</p>
<h2 id="Thrift-服务"><a href="#Thrift-服务" class="headerlink" title="Thrift 服务"></a>Thrift 服务</h2><p>开启 hiveserver2，搭配 groovy / maven 使用 默认情况下，管理表在 <code>/usr/hive/warehouse</code> 目录下</p>
<p>hive.start.cleanup.scratchdir  默认为 false 每次重启 Hiveserver 时清理掉历史目录</p>
<h3 id="HiveServer2"><a href="#HiveServer2" class="headerlink" title="HiveServer2"></a>HiveServer2</h3><blockquote>
<p>管理元数据，生产环境中常使用。</p>
</blockquote>
<h3 id="beeline"><a href="#beeline" class="headerlink" title="beeline"></a>beeline</h3><p>beeline 可以连接 Hive， MySQL…</p>
<h3 id="HCatalog"><a href="#HCatalog" class="headerlink" title="HCatalog"></a>HCatalog</h3><p>Hive 的元数据服务 统一的元数据服务</p>
<p>可不启动 MR 任务执行 主要是 DDL 对元数据的操作</p>
<p>hcat -e “create database tt2”;</p>
<p>hcat -f xxx.hql</p>
<h2 id="数据存储格式"><a href="#数据存储格式" class="headerlink" title="数据存储格式"></a>数据存储格式</h2><p>TEXTFILE（默认格式） 、 SEQUENCEFILE、 RCFILE、 ORCFILE、 PARQUET。</p>
<p>TEXTFILE、SEQUENCEFILE 的存储格式是基于行存储的； ORC和PARQUET 是基于列式存储的。</p>
<p>TEXTFILE</p>
<p>通常先导入到 textfile，之后执行 insert … select 到其他格式的表中</p>
<p><strong>行和列的存储</strong> 行存储： insert 与 update 比较容易 select 需要查询大多无用的数据</p>
<p>textfile,sequencefile 行 rcrile, orc, parout   列存储</p>
<p>sequencefile: 可分割 可压缩 record, none, block 压缩  …</p>
<p>RCFile: 列式记录文件，结合列和行存储的优势</p>
<p><font color="green">先按水平划分，后让垂直划分</font></p>
<p>使用列唯独的压缩，有效提升存储空间利用率</p>
<h3 id="textfile"><a href="#textfile" class="headerlink" title="textfile"></a>textfile</h3><p>默认格式，数据不压缩</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">STRING</span>,</span><br><span class="line">age <span class="built_in">INT</span>,</span><br><span class="line">cource <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,</span><br><span class="line"><span class="keyword">body</span> <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>, <span class="built_in">FLOAT</span>&gt;,</span><br><span class="line">address <span class="keyword">STRUCT</span>&lt;STREET:<span class="keyword">STRING</span>, CITY:<span class="keyword">STRING</span>, STATE:<span class="keyword">STRING</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\\001&#x27;</span></span><br><span class="line">COLLECTION ITEMS <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;002&#x27;</span></span><br><span class="line"><span class="keyword">MAP</span> <span class="keyword">KEYS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\\003&#x27;</span></span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\\n&#x27;</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE;</span><br></pre></td></tr></table></figure>

<h3 id="ORCFile"><a href="#ORCFile" class="headerlink" title="ORCFile"></a>ORCFile</h3><blockquote>
<p>表位 ORC 可支持事务操作</p>
</blockquote>
<p>组成 文件脚注(file footer)： postscript： stripe: 条带  ，默认 250M</p>
<ul>
<li>Index Data: 1W行一个, 条带统计信息, 数据在条带中的位置</li>
<li>Row data: 水平 –&gt; 垂直, 列为单位存储数据</li>
<li>Stripe Footer: stripe 元数据信息</li>
</ul>
<p>三个级别的索引：</p>
<p>文件级别、条带级、行组级</p>
<p>无需指定分割符，自动处理</p>
<h3 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h3><blockquote>
<p>apache 顶级项目site</p>
</blockquote>
<p>由 Twitter 和 Cloudera 合作开发</p>
<p>支持使用重复级别/定义级别的方法来对数据结构进行编码</p>
<p>通用型强</p>
<p><strong>与语言和平台无关</strong></p>
<p>二进制存储的</p>
<p>文件中包含数据和元数据</p>
<p>Row group:  文件有多个行组组成，写入数据最大的缓存单元，50M ~ 1GB 之间</p>
<p>Column Chunk: 存储当前行组内的某一行数据 最小的 I/O 并发单元</p>
<p>Page: 压缩读取数据的最小单元 8K ~ 1M 之间，越大压缩率越高</p>
<p>Footer: 数据的 schema 信息 每个行组的元数据信息： 每个 column chunk 的元数据信息：</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>压缩比 ORC &gt; Parquet &gt; text</p>
<p>执行查询 ORC 与 Parquet  相当</p>
<ul>
<li>TextFile文件更多的是作为跳板来使用(即方便将数据转为其他格式)</li>
<li>有update、delete和事务性操作的需求，通常选择ORCFile</li>
<li>没有事务性要求，希望支持 Impala、Spark，多种计算框架/查询引擎，建议选择 Parquet</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Hive-与-RDBMS-的对比"><a href="#Hive-与-RDBMS-的对比" class="headerlink" title="Hive 与 RDBMS 的对比"></a>Hive 与 RDBMS 的对比</h3><p>Hive 是基于 Hadoop 的数据仓库分析工具，  可以将 SQL 转换成 MR 任务运行。</p>
<ul>
<li>查询语言类似， HQL, 与 SQL 高度类似，实现了 SQL-92 的标准。</li>
<li>数据规模，Hive 处理海量数据，RDBMS 只能处理有限的数据集</li>
<li>执行引擎，Hive 的执行引擎可以是 MR / Tex / Spark / Flink, RDBMS使用自己的执行引擎</li>
<li>数据存储，Hive 的数据一般存储在 HDFS 上，RDBMS 通常存储在贝蒂文件系统或者裸设备</li>
<li>执行速度，Hive 执行速度相对比较慢(MR/数据量)，RDBMS 相对快，Hive 没有索引，默认使用 MapReduce 作为执行引擎，会产生较高的延迟。RDBMS 一般会定义索引，执行延迟较低。</li>
<li>可扩展性，Hive 方便进行水平扩展，通常 RDBMS 对水平扩展支持不友好。Hive 建立在 Hadoop 上，可扩展性与 Hadoop 的可扩展性是一致的，RDBMS 优于 ACID 语义的严格限制，扩展行有限。</li>
<li>数据更新，Hive 对数据更新不友好，RDBMS 支持频繁快速的数据更新</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/2704bd84d3a140e09582d547cff004d6">Hive 与 RDBMS 对比</a></p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Hive</th>
<th>RMDBMS</th>
</tr>
</thead>
<tbody><tr>
<td>查询语言</td>
<td>HQL</td>
<td>SQL</td>
</tr>
<tr>
<td>数据存储位置</td>
<td>HDFS</td>
<td>Raw Device / 本地文件系统</td>
</tr>
<tr>
<td>数据格式</td>
<td>用户定义</td>
<td>系统决定</td>
</tr>
<tr>
<td>数据更新</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>索引</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>执行引擎</td>
<td>MapReduce</td>
<td>Executor</td>
</tr>
<tr>
<td>执行延迟</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>可扩展性</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>数据规模</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>子查询</td>
<td>只可 from 子句中</td>
<td>完全支持</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/731b58068cc74fa883e545fc47a07063">HiveQL 于 SQL 的比较</a></p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>SQL</th>
<th>HiveQL</th>
</tr>
</thead>
<tbody><tr>
<td>ANSI SQL 更新</td>
<td>支持 UPDATEVINSERT\DELETE  。。。</td>
<td>不完全支持 insert OVERWRITEVINTO TABLE</td>
</tr>
<tr>
<td>事务</td>
<td>支持</td>
<td>可支持(分桶、ORCFile 文件格式)</td>
</tr>
<tr>
<td>模式</td>
<td>写模式</td>
<td>读模式</td>
</tr>
<tr>
<td>数据保存</td>
<td>块设备、本地文件系统</td>
<td>HDFS</td>
</tr>
<tr>
<td>延时</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>多表播入</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>子查询</td>
<td>完全支持</td>
<td>只能用在 From 子句中</td>
</tr>
<tr>
<td>视图</td>
<td>Updatable</td>
<td>Read-only</td>
</tr>
<tr>
<td>可扩展性</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>数据规模</td>
<td>小</td>
<td>大</td>
</tr>
</tbody></table>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/hive">Github-Hive</a></li>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual">LanguageManual</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/" data-id="ckm733rt70009ivvx3ncvg5sx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hive/" rel="tag">Hive</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hive-优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Hive-%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2021-03-09T13:33:13.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Hive-%E4%BC%98%E5%8C%96/">Hive-优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>影响 Hive 效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、Job / IO过多、MapReduce 分配不合理等。</p>
<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><h3 id="执行引擎选择"><a href="#执行引擎选择" class="headerlink" title="执行引擎选择"></a>执行引擎选择</h3><p>通过参数 hive.execution.engine 控制，可选 MapReduce, Tez, Spark, Flink 作为执行引擎，在离线数仓中，批处理方面主要使用 Spark</p>
<h3 id="优化器的使用"><a href="#优化器的使用" class="headerlink" title="优化器的使用"></a>优化器的使用</h3><p>在真正执行计算之前，生成和优化逻辑执行计划与物理执行计划。</p>
<ul>
<li>Vectorize 矢量化查询执行</li>
<li>Cost-Based Optimization: CBO 成本优化器</li>
</ul>
<p><strong>矢量化查询执行</strong> 要求执行引擎为Tez, 执行通过一次批量执行1024行而不是每行一行来提高扫描，聚合，过滤器和连接等操作的性能, 可一显着缩短查询执行时间。 需要使用 orc 格式存储数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启 </span></span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.enabled = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.reduce.enabled = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>成本优化器</strong> 基于apache Calcite的，Hive的CBO通过查询成本(有analyze收集的统计信息)会生成有效率的执行计划，最终会减少执行的时间和资源的利用</p>
<p>可定期执行表的分析，分析后数据存放在元数据库中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从 v0.14.0默认</span></span><br><span class="line"><span class="keyword">SET</span> hive.cbo.enable=<span class="literal">true</span>; </span><br><span class="line">true</span><br><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.compute.query.using.stats=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.stats.fetch.column.stats=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认true</span></span><br><span class="line"><span class="keyword">SET</span> hive.stats.fetch.partition.stats=<span class="literal">true</span>; </span><br></pre></td></tr></table></figure>

<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>Parquet 和 ORC 都是 Apache 旗下的开源列式存储格式。列式存储比起传统的行式存 储更适合批量 OLAP 查询，并且也支持更好的压缩和编码。 选择 Parquet 的原因主要是它支持 Impala 查询引擎，并且对 update、delete 和事务性操作需求很低。</p>
<p>选择 ORCFile 支持事务操作。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>压缩的配置可以在hive的命令行中或者hive-site.xml文件中进行配置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.compress.intermediate=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>DEFLATE</li>
<li>GZIP: 扩展名 .gz</li>
<li>Bzip2: 支持分割, 扩展名 .gz</li>
<li>LZO：</li>
<li>LZ4：</li>
<li>Snappy: 不支持分割</li>
</ul>
<p>可在mapred-site.xml, hive-site.xml 配置，命令行配置</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.intermediate.compression.codec=org.apache.hadoop.io.compress</span><br><span class="line">.SnappyCodec;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.compress.output=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">SET</span> mapreduce.output.fileoutputformat.compress.codec =</span><br><span class="line">org.apache.hadoop.io.compress.SnappyCodc</span><br></pre></td></tr></table></figure>

<h3 id="分区、分桶表"><a href="#分区、分桶表" class="headerlink" title="分区、分桶表"></a>分区、分桶表</h3><p>设计成分区表可以提升查询的性能，对于一个特定分区的查询，只会加载对应分区路  径的文件数据</p>
<p>尽量避免层级较深的分区</p>
<ul>
<li>日期或时间。如year、month、day或者hour，</li>
<li>地理位置。如国家、省份、城市</li>
<li>业务逻辑。如部门、销售区域、客户</li>
</ul>
<p>分桶表 分桶表的组织方式是将HDFS上的文件分割成多个文件。 分桶可以加快数据采样，也可以提升join的性能(join的字段是分桶字段)，因为分桶可 以确保某个key对应的数据在一个特定的桶内(文件)，巧妙地选择分桶字段可以大幅 度提升join的性能。</p>
<p>分桶字段可以选择经常用在过滤操作或者join操作的字段。</p>
<h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>支持将作业动态地转为本地模式, 当Hive处理的数据量较小时，启动分布式去处理数据会有点浪费。</p>
<p>一个作业只要满足下面的条件，会启用本地模式</p>
<ul>
<li>输入文件的大小小于 <code>hive.exec.mode.local.auto.inputbytes.max</code> 配置的大小</li>
<li>map 任务的数量小于 <code>hive.exec.mode.local.auto.input.files.max</code> 配置的大小</li>
<li>reduce 任务的数量是1或者0</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto=<span class="literal">true</span>; <span class="comment">-- 默认 false</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto.inputbytes.max=<span class="number">50000000</span>;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto.input.files.max=<span class="number">5</span>; <span class="comment">-- 默认 4</span></span><br></pre></td></tr></table></figure>

<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>强制不允许用户执行3种有风险的HiveQL语句，一旦执行会直接失败。</p>
<ul>
<li>查询分区表时不限定分区列的语句；</li>
<li>两表 join 产生了笛卡尔积的语句；</li>
<li>用 order by 来排序，但没有指定 limit 的语句。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DEFAULT strict</span></span><br><span class="line"><span class="keyword">set</span> hive.mapred.mode=nostrict</span><br></pre></td></tr></table></figure>

<h3 id="JVM-重用"><a href="#JVM-重用" class="headerlink" title="JVM 重用"></a>JVM 重用</h3><p>Hadoop可以重用 JVM，通过共享 JVM 以串行而非并行的方式运行 map 或者 reduce。 避免 JVM 启动进程所耗费的时间会比作业执行的时间还要长。</p>
<p>JVM的重用<font color="green">适用于同一个作业的 map 和 reduce，对于不同作业的 task 不能够共享 JVM。</font></p>
<p>开启JVM重用将一直占用使用到的 task 插槽，以便进行重用，直到任务完成后才能释放。</p>
<p>如果某个“不平衡的”job中有某几个reduce task执行的时间要比其他Reduce task消耗的时间多的多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 代表同一个MR job中顺序执行的5个task重复使用一个JVM，减少启动和关闭的开销</span></span><br><span class="line"><span class="keyword">SET</span> mapreduce.job.jvm.numtasks=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>Hive 将查询转换成一个或多个阶段，MapReduce 阶段、抽样阶段、合并阶段、Limit 阶段..</p>
<p>默认情况下一次只执行一个阶段，对于特定 Job 有多个阶段，阶段间非完全相互依赖，并行执行，可以缩短 job 的执行时间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.parallel=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认8</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.parallel.thread.number=<span class="number">16</span>; </span><br></pre></td></tr></table></figure>

<h3 id="推测执行"><a href="#推测执行" class="headerlink" title="推测执行"></a>推测执行</h3><p>在分布式集群环境下，因为程序Bug、负载不均衡、资源分布不均、网络情况等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务, 这些任务会拖慢作业的整体执行进度。</p>
<p>Hadoop采用了推测执行机制，它根据一定的规则推测出 “拖后腿” 的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.map.speculative=<span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.reduce.speculative=<span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> hive.mapred.reduce.tasks.speculative.execution=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="合并小文件"><a href="#合并小文件" class="headerlink" title="合并小文件"></a>合并小文件</h3><p>在map执行前合并小文件，减少map数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 缺省参数</span></span><br><span class="line"><span class="keyword">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</span><br></pre></td></tr></table></figure>

<p>在Map-Reduce的任务结束时合并小文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 map-only 任务结束时合并小文件，默认true</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.mapfiles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 map-reduce 任务结束时合并小文件，默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.mapredfiles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 合并文件的大小，默认256M</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.size.per.task = <span class="number">268435456</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当输出文件的平均大小小于该值时，启动一个独立的 map-reduce 任务进行文件merge</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.smallfiles.avgsize = <span class="number">16777216</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Fetch-模式"><a href="#Fetch-模式" class="headerlink" title="Fetch 模式"></a>Fetch 模式</h3><p>Fetch 模式是指 Hive 中对某些情况的查询可以不必使用 MapReduce 计算 在开启 fetch 模式之后，在全局查找、字段查找、limit 查找等都不启动 MapReduce</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Default Value: minimal in Hive 0.10.0 through 0.13.1, </span></span><br><span class="line"><span class="comment">-- more in Hive 0.14.0 and later</span></span><br><span class="line">hive.fetch.task.conversion=more</span><br></pre></td></tr></table></figure>

<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="列裁剪和分区裁剪"><a href="#列裁剪和分区裁剪" class="headerlink" title="列裁剪和分区裁剪"></a>列裁剪和分区裁剪</h3><p>列裁剪： SELECT 只查需要的列。少用 SELECT * 分区裁剪:  只读取需要的列。在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where 后面，那么就会先全表关联，之后再过滤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列裁剪优化相关的配置项, default true</span></span><br><span class="line">hive.optimize.cp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 分区裁剪优化, default true</span></span><br><span class="line">hive.optimize.pruner=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h3><p>在 RDBMS 中，如 MySQL 也有 Predicate Pushdown(PPD) 的概念，将 SQL 语句中的 where 谓词逻辑尽可能提前执行，减少下游处理的数据量。</p>
<p>如下的 SQQ， forum_topic 表过滤的 where 语句卸载子查询内部，而不是外部，Hive 谓词下推逻辑优化器是 PredicatePushDown，该优化器将 OperatorTree 中的 FilterOperator 向上提。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.uid,a.event_type,b.topic_id,b.title</span><br><span class="line"><span class="keyword">from</span> calendar_record_log a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> uid,topic_id,title <span class="keyword">from</span> forum_topic</span><br><span class="line"><span class="keyword">where</span> pt_date = <span class="number">20190224</span> <span class="keyword">and</span> <span class="keyword">length</span>(<span class="keyword">content</span>) &gt;= <span class="number">100</span></span><br><span class="line">) b <span class="keyword">on</span> a.uid = b.uid</span><br><span class="line"><span class="keyword">where</span> a.pt_date = <span class="number">20190224</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment"># 谓词下推优化的配置项, default true</span></span><br><span class="line">hive.optimize.ppd = true</span><br></pre></td></tr></table></figure>

<h3 id="sort-by-代替-order-by"><a href="#sort-by-代替-order-by" class="headerlink" title="sort by 代替 order by"></a>sort by 代替 order by</h3><p>为了控制 map 端数据分配到 reducer 的 key, 需要配置 distribute by 一起使用，如果不加 distribute by 的话，map 端数据就会随机分配到 reducer。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以UID为key，以上传时间倒序、记录类型倒序输出记录数据</span></span><br><span class="line"><span class="keyword">select</span> uid,upload_time,event_type,record_data</span><br><span class="line"><span class="keyword">from</span> calendar_record_log</span><br><span class="line"><span class="keyword">where</span> pt_date &gt;= <span class="number">20190201</span> <span class="keyword">and</span> pt_date &lt;= <span class="number">20190224</span></span><br><span class="line"><span class="keyword">distribute</span> <span class="keyword">by</span> uid</span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> upload_time <span class="keyword">desc</span>,event_type <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h3 id="group-by-代替-count-distinct"><a href="#group-by-代替-count-distinct" class="headerlink" title="group by 代替 count(distinct)"></a>group by 代替 count(distinct)</h3><p>去重计算数据量大时不好处理，数据量大的时候用一个 ReduceTask 来完成，导致整个 Job 很难完成  。 一般 COUNT DISTINCT 使用先 GROUP BY 再 COUNT 的方式替换。使用 group by 替换后， SQL 如下，会启动两个 MR Job，确保启动 Job 开销远小于计算耗时的时候使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> uid <span class="keyword">from</span> calendar_record_log</span><br><span class="line">	<span class="keyword">where</span> pt_date &gt;= <span class="number">20190101</span></span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<h3 id="group-by-配置调整"><a href="#group-by-配置调整" class="headerlink" title="group by 配置调整"></a>group by 配置调整</h3><p>并不是所有的聚合操作都需要在 Reduce 端完成，可现在 Map 端进行部分聚合，最后在 Reduce 端得出最终结果</p>
<ul>
<li><code>hive.map.aggr=true</code>: 是否在 Map 端进行聚合</li>
<li><code>hive.groupby.napaggr.checkinterva=10000</code>: 在 Map 端进行聚合操作的条目数目</li>
<li><code>hive.groupby.skewindata=true</code>: 有数据倾斜的时候进行负载均衡，默认 false</li>
</ul>
<p>当选项设定为 true，生成的查询计划会有两个 MR Job。第一个MR Job中，Map的输出结果会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的Group By Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；第二个MR Job再根据预处理的数据结果按照Group By Key分布到Reduce中（这个过程可以保证相同的Group By Key被分布到同一个Reduce中），最后完成最终的聚合操作。</p>
<h3 id="join-基础优化"><a href="#join-基础优化" class="headerlink" title="join 基础优化"></a>join 基础优化</h3><p>map join</p>
<p>分桶 join</p>
<h3 id="大表-join-大表处理空值或无意义值"><a href="#大表-join-大表处理空值或无意义值" class="headerlink" title="大表 join 大表处理空值或无意义值"></a>大表 join 大表处理空值或无意义值</h3><p>(1) 空 key 过滤 大表 Join 大表时，key 有大量的异常数据，相同的 key 发送到相同的 reducer 上，从而导致内存不够，结果 Join 的时候耗时长，可先通过 SQL 对其进行过滤。</p>
<p>(2) 空 key 转化 空 Key 转化，key 非异常数据，必须包含在 join 的结果中，可对为空的 key 设置随机值，使数据随机均匀分到不同的 reducer 上，防止数据的倾斜问题 …</p>
<h3 id="单独处理倾斜-key"><a href="#单独处理倾斜-key" class="headerlink" title="单独处理倾斜 key"></a>单独处理倾斜 key</h3><h3 id="调整-Map-数"><a href="#调整-Map-数" class="headerlink" title="调整 Map 数"></a>调整 Map 数</h3><p>通常情况下，作业通过 Input 目录产生一个/多个 map 任务 input 文件总个数、文件大小，集群设置的文件快大小。</p>
<p>Q:  是不是map数越多越好？ 答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</p>
<p>Q:  是不是保证每个map处理接近128m的文件块，就高枕无忧了？ 答案也是不一定。比如有一个127m的文件，正常会用一个 map 去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果 map 处理的逻辑比较复杂，用一个 map 任务去做，肯定也比较耗时。</p>
<p>增加 Map 的方法：</p>
<p>调整 maxSize 最大值，使 maxSize 小于 blockSize 增加 map 个数</p>
<p>// TODO maxSize 对应的配置参数…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))&#x3D;blocksize&#x3D;128M</span><br></pre></td></tr></table></figure>

<h3 id="调整-Reduce-数"><a href="#调整-Reduce-数" class="headerlink" title="调整 Reduce 数"></a>调整 Reduce 数</h3><p>过多的 reduce 问题</p>
<ul>
<li>过多的 reduce， 会过多启动、初始化 reduce 消耗时间和资源</li>
<li>有多少个 reduce 就会有多少个输出文件，生成很多小文件，如果这些小文件作为下一个任务的输入，会出现小文件过多的问题</li>
<li><code>hive.exec.reducers.bytes.per.reducer=256000000</code>: 每个 reduce 处理的数据量默认为 256MB</li>
<li><code>hive.exec.reducers.max=1009</code>: 每个任务最大的 reduce 数，默认 1009</li>
<li><code>mapreduce.job.reduces</code>： 设置每个 job 的 reduce 个数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置每个 job 的 reduce 个数</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>优化小结 Hadoop/Hive 处理数据过程，有几个显著特征：</p>
<ul>
<li>不怕数据多，就怕数据倾斜</li>
<li>对 job 数比较多的作业运行效率相对比较低</li>
<li>对 sum、count 等聚合操作而言，不存在数据倾斜问题</li>
<li>count(distinct) 效率较低，数据量大容易出问题</li>
</ul>
<p>优化可以从几个方面着手：</p>
<ul>
<li>好的模型设计，事半功倍</li>
<li>解决数据倾斜问题。根据配置和业务进行处理</li>
<li>减少 job 数</li>
<li>设置合理的map、reduce task 数</li>
<li>对小文件进行合并，是行之有效的提高 Hive 效率的方法</li>
<li>优化把握整体，单一作业的优化不如整体最优</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Hive 自带的序列化与反序列化</p>
<p><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe">https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe</a></p>
<p>Hive 参数说明的官方文档：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties">https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html">Hive SQL的编译过程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DfvN7S_00oYw1hqAQDr48g">Hive/HiveSQL常用优化方法全面总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Hive-%E4%BC%98%E5%8C%96/" data-id="ckm733rt10004ivvxcfzf62w2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hive/" rel="tag">Hive</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hive-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Hive-%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2021-03-09T13:30:52.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Hive-%E5%87%BD%E6%95%B0/">Hive-函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>函数分类</p>
<ul>
<li><p>标准函数： 一列或多列作为参数传入，返回值是一个值的函数</p>
<p>如 to_date(string timestamp), sqrt(double a)</p>
</li>
<li><p>聚合函数： 接收0行、多行的列，返回单一的值</p>
</li>
<li><p>表生成函数： 接收 0 、 多个输入，产生多列 、 多行输出 如 explode</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> functions;</span><br><span class="line">desc function upper;</span><br><span class="line">desc function extended upper;</span><br></pre></td></tr></table></figure>

<h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul>
<li>current_date:</li>
<li>current_timestamp：</li>
<li>year(string date)</li>
<li>month(string date)</li>
<li>hour(string date)</li>
<li>minute(string date)</li>
<li>second(string date)</li>
<li><code>from_unixtime(bigint unixtime[, string format])</code>：转换从 1970-01-01 00:00:00 UTC 开始的秒为日期</li>
<li><code>datediff(string enddate, string startdate)</code>: 计算时间差</li>
<li><code>day(string date)</code> / <code>dayofmonth(date)</code>:  查询当月第几天</li>
<li><code>weekofyear(string date)</code>: 如weekofyear(“1970-11-01 00:00:00”) = 44, weekofyear(“1970-11-01”) = 44.</li>
<li><code>last_day(string date)</code>：查询月末的最后一天</li>
<li><code>date_add(date/timestamp/string startdate, tinyint/smallint/int days)</code>： 增加指定多少天</li>
<li><code>date_sub(date/timestamp/string startdate, tinyint/smallint/int days)</code>： 减少指定多少天</li>
<li>date_sub(current_date, dayofmonth(current_date)-1)：当月第一天</li>
<li>add_months(string start_date, int num_months, output_date_format)，<ul>
<li>如 add_months(date_sub(current_date, dayofmonth(current_date)-1), 1)： 下月第一天</li>
</ul>
</li>
<li>to_date(string timestamp)： 字符串转日期，2.1.0- 返回 String 类型，2.1.0+ 返回 date 类型</li>
<li><code>date_format(date/timestamp/string ts, string fmt)</code>： 日期、时间戳、字符串类型格式化输出标准时间格式</li>
<li><code>next_day(string start_date, string day_of_week)</code>： 返回第一个日期，该日期晚于start_date并命名为day_of_week。day_of_week 为两个或三个字符，如 “Mo”, “tue”, “FRIDAY”，next_day(‘2015-01-14’, ‘TU’) = 2015-01-20</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">current_date</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURRENT_TIMESTAMP</span>();</span><br><span class="line"><span class="comment">-- unix 时间戳转换成日期</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">11111111</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">11111</span>, <span class="string">&#x27;yyyyMMdd&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1111111</span>, <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br><span class="line"><span class="comment">-- 日期转成时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">&#x27;2019-09-15 14:23:00&#x27;</span>);</span><br><span class="line"><span class="comment">-- 时间差, 返回日期相差的天数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2020-04-18&#x27;</span>, <span class="string">&#x27;2019-11-21&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">abs</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-04-18&#x27;</span>, <span class="string">&#x27;2019-11-21&#x27;</span>));</span><br><span class="line"><span class="comment">-- 日期为所处月的第几天</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>);</span><br><span class="line"><span class="comment">-- 日期所处月的最后一天日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">last_day</span>(<span class="keyword">current_date</span>);</span><br><span class="line"><span class="comment">-- 当月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">current_date</span>, <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 下月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> add_months(<span class="keyword">date_sub</span>(<span class="keyword">current_date</span>, <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>) - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- must 字符串转换成 date yyyy-MM-dd</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020-01-01 12:12:12&#x27;</span>);</span><br><span class="line"><span class="comment">-- 日期格式化成指定的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="keyword">current_timestamp</span>(), <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="keyword">current_date</span>(), <span class="string">&#x27;yyyyMMdd&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="string">&#x27;2020-06-01&#x27;</span>, <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>常用的日期处理</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 近3天的</span></span><br><span class="line"><span class="comment">-- 近一周的</span></span><br><span class="line">where dt &gt;= date_add(next_day(&#x27;$do_date&#x27;, &#x27;mo&#x27;), -7)</span><br><span class="line">    and dt &lt;= &#x27;$do_date&#x27;</span><br><span class="line"><span class="comment">-- 近一月的</span></span><br><span class="line">where dt &gt;= date_format(&#x27;$do_date&#x27;, &#x27;yyyy-MM-01&#x27;)</span><br><span class="line">    and dt &lt;= &#x27;$do_date&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul>
<li><code>IF .. else</code></li>
<li><code>case when.. end &lt;column-name&gt;</code>: 多个条件的时候使用</li>
<li><code>nvl(T value, T default_value)</code>: value 为空的时候返回默认值</li>
<li><code>COALESCE(T v1, T v2, ...)</code>: 返回参数中第一个非空值</li>
<li><code>nullif(x, y)</code>:  相等为空，否则为x</li>
<li>isnull / isnull( a ):</li>
<li>assert_true(boolean condition): 不满足抛出异常</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试表定义</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> emp</span><br><span class="line">(</span><br><span class="line">    empno    <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;员工号&#x27;</span>,</span><br><span class="line">    ename    <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;员工姓名&#x27;</span>,</span><br><span class="line">    job      <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;工作名称&#x27;</span>,</span><br><span class="line">    mgr      <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    hiredate <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;雇佣日期&#x27;</span>,</span><br><span class="line">    sal      <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;薪水&#x27;</span>,</span><br><span class="line">    comm     <span class="built_in">int</span>,</span><br><span class="line">    deptno   <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;部门号&#x27;</span></span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- if (boolean testCondition, T valueTrue, T valueFalseOrNull)</span></span><br><span class="line"><span class="comment">-- 将 emp 表的员工工资等级分类：0-1500、1500-3000、3000以上</span></span><br><span class="line"><span class="keyword">SELECT</span> sal,</span><br><span class="line">       <span class="keyword">if</span>(sal &lt;= <span class="number">1500</span>, <span class="string">&#x27;primary&#x27;</span>, </span><br><span class="line">       <span class="keyword">if</span>(sal &lt;= <span class="number">3000</span>, <span class="string">&#x27;middle&#x27;</span>, <span class="string">&#x27;advanced&#x27;</span>))</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">-- case when 判断</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">CASE</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;accounting&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">20</span> <span class="keyword">THEN</span> <span class="string">&#x27;research&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">30</span> <span class="keyword">THEN</span> <span class="string">&#x27;sales&#x27;</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="string">&#x27;unknown&#x27;</span> <span class="keyword">END</span> deptname</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">-- 返回参数中的第一个非空值；如果所有值都为 NULL，那么返回NULL</span></span><br><span class="line"><span class="keyword">select</span> sal, <span class="keyword">coalesce</span>(comm, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- null 判断</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> isnotnull(comm);</span><br><span class="line"><span class="comment">-- 空值转换函数 nvl(T value, T default_value)</span></span><br><span class="line"><span class="keyword">select</span> empno,</span><br><span class="line">       ename,</span><br><span class="line">       job,</span><br><span class="line">       mgr,</span><br><span class="line">       hiredate,</span><br><span class="line">       deptno,</span><br><span class="line">       sal + nvl(comm, <span class="number">0</span>) sumsal</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- nullif(x, y) 相等为空，否则为x  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">nullif</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>), <span class="keyword">nullif</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><code>lower</code>：</li>
<li><code>length</code>:</li>
<li><code>concat</code> / <code>||</code> ：字符拼接</li>
<li><code>concat_ws(separator, [string | array(string)]+)</code>: 可指定分隔符进行拼接</li>
<li><code>substr</code>： 求子串, 指定开始和结束索引</li>
<li><code>split</code>： <code>.</code> 需要进行正则转义</li>
<li>instr(string str, string substr)： 返回substr在str中第一次出现的位置</li>
<li>parse_url(string urlString, string partToExtract [, string keyToExtract])： 从 url 中抽取值，可抽取的值包括 HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.<ul>
<li>如 parse_url(‘<a target="_blank" rel="noopener" href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;</a>, ‘HOST’) returns ‘<a target="_blank" rel="noopener" href="http://facebook.com/">facebook.com</a>‘。</li>
</ul>
</li>
<li>regexp_extract(string subject, string pattern, int index)： 按照正则匹配值<ul>
<li>如 regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2)， Index 参数为 Java 的 group</li>
</ul>
</li>
<li>regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT):正则替换<ul>
<li>如 regexp_replace(“foobar”, “oo|ar”, “”) returns ‘fb.’</li>
</ul>
</li>
<li>get_json_object(string json_string, string path)： 从 JSON 字符串中获取特定路径值<ul>
<li>JSON 路径只能为 [0-9a-z_], 没有大写或特殊字符, keys 不可以以 数字开头</li>
</ul>
</li>
<li>str_to_map(text[, delimiter1, delimiter2])： 返回 map</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子串截取</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">split</span>(<span class="string">&quot;www.lagou.com&quot;</span>, <span class="string">&quot;\\\\.&quot;</span>);</span><br><span class="line"><span class="keyword">select</span> empno || <span class="string">&quot; &quot;</span> || ename idname</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串拼接  指定分割符拼接 concat_ws(separator, [string | array(string)]+)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="built_in">array</span>(<span class="string">&#x27;lagou&#x27;</span>, <span class="string">&#x27;com&#x27;</span>));</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.lagou.com&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.lagou.com&#x27;</span>, <span class="number">-5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.lagou.com&#x27;</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><strong>get_json_object 获取 JSON 字符串信息</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;store&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;fruit&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;weight&quot;</span>: <span class="number">8</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;apple&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;weight&quot;</span>: <span class="number">9</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pear&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;bicycle&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: <span class="number">19.95</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;amy@only_for_json_udf_test.net&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;owner&quot;</span>: <span class="string">&quot;amy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">-- 获取值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.owner&#x27;) FROM src_json;</span><br><span class="line">amy</span><br><span class="line">-- 获取数组值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.store.fruit\\[0]&#x27;) FROM src_json;</span><br><span class="line">&#123;<span class="attr">&quot;weight&quot;</span>:<span class="number">8</span>,<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line">-- 获取不存在的值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.non_exist_key&#x27;) FROM src_json;</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure>

<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li><code>round</code>: round x to d decimal places，可用于控制小数保留几位</li>
<li><code>ceil</code>:  向上取整</li>
<li><code>floor</code>:  向下取整。</li>
<li><code>exp(DOUBLE a)</code>, <code>exp(DECIMAL a)</code>:  指数函数</li>
<li>log10(DOUBLE a), log10(DECIMAL a)</li>
<li>log(DOUBLE base, DOUBLE a)</li>
<li>abs(DOUBLE a)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">314.15926</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">314.15926</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="number">3.1415926</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="number">3.1415926</span>);</span><br></pre></td></tr></table></figure>

<h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul>
<li><code>size(Map&lt;K.V&gt;)</code> / <code>size(Array&lt;T&gt;)</code>： 返回元素个数</li>
<li><code>map_keys(Map&lt;K.V&gt;)</code> / <code>map_values(Map&lt;K.V&gt;)</code>: 将 Map 所有的 key、value 进行返回</li>
<li><code>array_contains(Array&lt;T&gt;, value):</code> 数组中是否包含某个值</li>
<li><code>sort_array(Array&lt;T&gt;)</code>： 对数组元素进行排序</li>
</ul>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><ul>
<li>binary(string|binary)： 转换成二进制</li>
<li>cast(expr as <type>)： 类型转换，无法转换时，返回 NULL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="string">&#x27;23232&#x27;</span> <span class="keyword">AS</span> <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>UDTF</p>
</blockquote>
<h3 id="聚集函数-UDAF"><a href="#聚集函数-UDAF" class="headerlink" title="聚集函数(UDAF)"></a>聚集函数(UDAF)</h3><ul>
<li>count / sum / avg / min / max</li>
<li>collect_set(col)</li>
<li>collect_list(col)</li>
<li>ntile(INTEGER x): 将有序分区划分为x个称为存储桶的组，并为该分区中的每一行分配存储桶编号。</li>
</ul>
<h3 id="表生成函数-UDTF"><a href="#表生成函数-UDTF" class="headerlink" title="表生成函数(UDTF)"></a>表生成函数(UDTF)</h3><blockquote>
<p>一行输入，多行输出</p>
</blockquote>
<p>配合 lateral view 进行使用，解决 UDTF 不能添加额外列的问题。</p>
<ul>
<li>explode(ARRAY<T> a)</li>
<li>explode(MAP&lt;Tkey,Tvalue&gt; m)</li>
<li>posexplode (array)： 带有原始位置的炸裂函数</li>
<li>json_tuple(string jsonStr,string k1,…,string kn)</li>
<li>parse_url_tuple(string urlStr,string p1,…,string pn)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lateral view 常与 表生成函数explode结合使用，处理上述问题</span></span><br><span class="line"><span class="comment">-- ==&gt;  解决 UDTF 不能添加额外列的问题</span></span><br><span class="line"><span class="comment">-- lateral view udtf(expression) tableALias as  ...</span></span><br><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">&#x27;OK&#x27;</span> cola, <span class="keyword">split</span>(<span class="string">&#x27;www.lagou.com&#x27;</span>, <span class="string">&#x27;\\\\.&#x27;</span>) colb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> cola, colc</span><br><span class="line"><span class="keyword">from</span> t1 <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(colb) t2 <span class="keyword">as</span> colc;</span><br><span class="line">lateral view udtf(expression) tableALias as  ...</span><br><span class="line"><span class="comment">-- 炸裂 map 并给定别名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">explode</span>(<span class="keyword">map</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">30</span>)) <span class="keyword">as</span> (<span class="keyword">key</span>,<span class="keyword">value</span>);</span><br><span class="line">key value</span><br><span class="line">A	10</span><br><span class="line">B	20</span><br><span class="line">C	30</span><br><span class="line"><span class="keyword">select</span> posexplode(<span class="built_in">array</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)) <span class="keyword">as</span> (pos,val);</span><br><span class="line">pos val</span><br><span class="line">2	C</span><br><span class="line">1	B</span><br><span class="line">0	A</span><br></pre></td></tr></table></figure>

<p><strong>json_tuple 获取 JSON 多个值拆开</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.timestamp, b.*</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">log</span> a <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(a.appevent, <span class="string">&#x27;eventid&#x27;</span>, <span class="string">&#x27;eventname&#x27;</span>) b <span class="keyword">as</span> f1, f2;</span><br></pre></td></tr></table></figure>

<p><strong>parse_url_tuple 获取 URL 中的多个信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.*</span><br><span class="line"><span class="keyword">FROM</span> src <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> parse_url_tuple(fullurl, <span class="string">&#x27;HOST&#x27;</span>, <span class="string">&#x27;PATH&#x27;</span>, <span class="string">&#x27;QUERY&#x27;</span>, <span class="string">&#x27;QUERY:id&#x27;</span>) b <span class="keyword">as</span> host, <span class="keyword">path</span>, <span class="keyword">query</span>, query_id <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>脱敏函数： 对姓名、电话号码进行脱敏，不显示全部内容</p>
<ul>
<li>mask(string str[, string upper[, string lower[, string number]]]):<ul>
<li>如 mask(“abcd-EFGH-8765-4321”, “U”, “l”, “#”) results in llll-UUUU-####-####.</li>
</ul>
</li>
<li>collect_list： 列出该字段的所有值，不去重</li>
<li>current_user()： 当前用户</li>
<li>md5(string/binary)</li>
<li>version()†</li>
</ul>
<h2 id="窗口与分析函数"><a href="#窗口与分析函数" class="headerlink" title="窗口与分析函数"></a>窗口与分析函数</h2><blockquote>
<p>和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。数据窗口大小可能会随着行的变化而变化。</p>
</blockquote>
<p><strong>窗口函数</strong></p>
<ul>
<li>使用窗口函数之前一般要要通过 over() 进行开窗</li>
<li>窗口函数是针对每一行数据的，如果 over 中没有参数，默认是全部的结果集</li>
</ul>
<p><strong>partition by 子句</strong></p>
<ul>
<li>在 over 窗口中进行分区，对某一列进行分区统计，窗口的大小就是分区的大小</li>
</ul>
<p><strong>order by 子句</strong></p>
<ul>
<li>对输入的数据进行排序，有 order by 缺少 window 子句，默认窗口为 range between unbounded preceding and current row</li>
</ul>
<p><strong>over 子句</strong></p>
<ul>
<li>后面可指定标准的聚集函数， count, sum, min, max, avg</li>
<li>使用 PARTITION BY 语句，具有任何原始数据类型的一个或多个分区列。</li>
<li>带有 PARTITION BY 和 ORDER BY 以及任何数据类型的一个或多个分区和/或排序列，<ul>
<li>带有窗口规格，Windows 可以在 WINDOW 子句中单独定义。</li>
</ul>
</li>
</ul>
<p><strong>Window 子句</strong></p>
<ul>
<li>窗口规范支持以下格式：</li>
<li>指定 order by 并缺少 window 子句时，window 默认被指定为 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</li>
<li>当同时缺少 order by 和 window 子句时，默认窗口指定为 ROW BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</li>
<li>不支持 Rank 函数， rank、ntile、denseRank、cusmeDis、percentRank，不支持 Lead 和 Lag 函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ROWS | RANGE) BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)</span><br><span class="line">(ROWS | RANGE) BETWEEN CURRENT ROW AND (CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)</span><br><span class="line">(ROWS | RANGE) BETWEEN [num] FOLLOWING AND (UNBOUNDED | [num]) FOLLOWING</span><br></pre></td></tr></table></figure>

<h3 id="窗口范围"><a href="#窗口范围" class="headerlink" title="窗口范围"></a>窗口范围</h3><ul>
<li>unbounded preceding: 组内第一行数据</li>
<li>n preceding: 组内当前行的前n行数据</li>
<li>current row: 当前行数据</li>
<li>n following: 组内当前行的后 n 行数据</li>
<li>unbounded following: 组内最后一行数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工姓名、薪水、部门薪水总和、占部门薪水的百分比</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno) depsalsum,</span><br><span class="line">       <span class="keyword">round</span>(sal / <span class="keyword">sum</span>(sal) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno) * <span class="number">100</span>, <span class="number">2</span>) || <span class="string">&#x27;%&#x27;</span> salofdeptsumpercent</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 等价。组内，第一行 ~ 当前行的和</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 组内，第一行 ~ 最后一行的和</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 组内，按照分区前后两行和当前行的总和，前一行 + 当前行 + 后一行</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h3 id="排名函数"><a href="#排名函数" class="headerlink" title="排名函数"></a>排名函数</h3><ul>
<li>row_number(): 排名顺序增加不会重复</li>
<li>RANK(): 排名相等会在名次中留下空位；如1、2、2、4、5、… …</li>
<li>DENSE_RANK(): 排名相等会在名次中不会留下空位 ；如1、2、2、3、4、… …</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t2</span><br><span class="line">(</span><br><span class="line">    cname <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;课程名&#x27;</span>,</span><br><span class="line">    sname <span class="keyword">string</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学生名&#x27;</span>,</span><br><span class="line">    score <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;课程分数&#x27;</span></span><br><span class="line">) <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">-- 求每个班级前3名的学员 </span></span><br><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cname, </span><br><span class="line">           sname, </span><br><span class="line">           score, </span><br><span class="line">           <span class="keyword">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cname <span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">rank</span></span><br><span class="line">    <span class="keyword">FROM</span> t2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> cname, sname, score, <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> tmp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rank</span> &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h3><ul>
<li>lag: 返回当前数据行的上一行数据 常用</li>
<li>lead: 返回当前数据行的下一行数据 常用</li>
<li>first_value: 取分组内排序后，截止到当前行，第一个值</li>
<li>last_value: 分组内排序后，截止到当前行，最后一个值</li>
<li>ntile: 将分组的数据按照顺序切分成n片，返回当前切片值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> userpv</span><br><span class="line">(</span><br><span class="line">    cid   <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    ctime <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;时间&#x27;</span>,</span><br><span class="line">    pv    <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;页面访问次数&#x27;</span></span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="comment">-- 上两行数据， 下三行数据</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       lag(pv, <span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime)  lagpv,</span><br><span class="line">       <span class="keyword">lead</span>(pv, <span class="number">3</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime) leadpv</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- first_value 分组排序截止到当前行第一个值 / last_value 分组排序后截止到当前行最后一个值</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       <span class="keyword">first_value</span>(pv) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) firstpv,</span><br><span class="line">       <span class="keyword">last_value</span>(pv) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) lastpv</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- ntile 按照cid进行分组并按照 ctime 排序，将分组内的数据平均分成 2 份</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       ntile(<span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime) ntile</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br></pre></td></tr></table></figure>

<h2 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h2><p><strong>临时性添加函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- hive add jar</span></span><br><span class="line">add jar /home/hadoop/udf.jar</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">function</span> myconcat <span class="keyword">as</span> <span class="string">&#x27;con.janhen.hive.udaf.ConcatUDAF&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> FUNCTIONS;</span><br></pre></td></tr></table></figure>

<p><strong>永久添加到 Hive 中</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jar ==&gt; hdfs </span></span><br><span class="line">hdfs dfs -put hiveudf.jar /user/hadoop/jar/</span><br><span class="line">-- 加载函数</span><br><span class="line">create <span class="keyword">function</span> mynvl2 as <span class="string">&#x27;com.janhen.bigdata.hive.nvl&#x27;</span></span><br><span class="line">    using jar <span class="string">&#x27;hdfs:/user/hadoop/jar/hiveudf.jar&#x27;</span>;</span><br><span class="line">show <span class="built_in">functions</span>;</span><br><span class="line">drop <span class="keyword">function</span> mynvl2;</span><br></pre></td></tr></table></figure>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-Built-inFunctions">Built-in Functions</a></li>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics">Windowing and Analytics Functions</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Hive-%E5%87%BD%E6%95%B0/" data-id="ckm733rt50007ivvx7ej0hrhx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hive/" rel="tag">Hive</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hive-HQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Hive-HQL/" class="article-date">
  <time datetime="2021-03-09T13:28:56.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Hive-HQL/">Hive-HQL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>并不是所有的 HQL 都会被 Hive 转换成 MR 作业执行</p>
<p>HQL 是一种 SQL 方案，支持绝大部分的 SQL-92 标准</p>
<p>不支持行级别草俎哦、不支持事务</p>
<p>对于简单不需要聚合的操作，如 <code>SELECT .. FROM xx LIMIT n</code>，直接通过 FetchTask 获取数据</p>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p><strong>装载数据</strong></p>
<ul>
<li>LOCAL：<ul>
<li>LOAD DATA LOCAL …：从本地文件系统加载数据到Hive表中</li>
<li>LOAD DATA …：从HDFS加载数据到Hive表中</li>
</ul>
</li>
<li>INPATH：加载数据的路径</li>
<li>OVERWRITE：覆盖表中已有数据；否则表示追加数据</li>
<li>PARTITION：将数据加载到指定的分区</li>
</ul>
<p>一旦该表存在分区，那么在数据在加载时必须加载进入指定分区中，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加载数据并指定分区，HDFS文件，已经被转移</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;/user/hadoop/data&#x27;</span> <span class="keyword">INTO</span> student_info <span class="keyword">PARTITION</span>(province=<span class="string">&#x27;sichuan&#x27;</span>, city=<span class="string">&#x27;chengdu&#x27;</span>);</span><br><span class="line"><span class="comment">-- 加载数据覆盖表中已有数据</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;data/sourceA.txt&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tabA;</span><br><span class="line"><span class="comment">-- 加载数据，覆盖表的数据，到指定的分区</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;/user/hadoop/o&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test3 <span class="keyword">PARTITION</span> (part = <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">-- 更改表的存储位置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (x = x1, y = y2) <span class="keyword">SET</span> LOCATION <span class="string">&#x27;/user/test/x1/y1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> tabC <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">&#x27;202001&#x27;</span>) <span class="keyword">values</span> (<span class="number">5</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;BJ&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;lishi&#x27;</span>, <span class="string">&#x27;SH&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;TJ&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入查询的结果数据 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> tabC <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">&#x27;202002&#x27;</span>) <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, area <span class="keyword">from</span> tabC <span class="keyword">where</span> <span class="keyword">month</span>=<span class="string">&#x27;202001&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建表并插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> tabD <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> tabC;</span><br></pre></td></tr></table></figure>

<p><strong>多表（多分区）插入模式</strong></p>
<p>一次查询，产生多个不相交的输出</p>
<p>Hive还有一个很有用的特性，可以通过一次查询，产生多个不相交的输出。</p>
<p>这样只通过对source表的一次查询，就将符合条件的数据插入test表的各个分区，非常方便</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个查询差生多个不相交的输出</span></span><br><span class="line">FROM source</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">0</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">100</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">100</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">200</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">200</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p><strong>import 导入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import table student2 partition(month=&#x27;201709&#x27;) from &#x27;/user/hive/warehouse/export/student&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><ul>
<li>将结果导出到本地</li>
<li>将查询结果格式化到本地</li>
<li>将结果导出到 HDFS</li>
<li>通过 DataX、Sqoop 等工具将结果导出到 HBase、MySQL等其他地方</li>
</ul>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">change</span> <span class="keyword">column</span> <span class="keyword">id</span> cid <span class="built_in">int</span>;</span><br><span class="line"><span class="comment">-- 增加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">add</span> <span class="keyword">columns</span> (common <span class="keyword">string</span>);</span><br><span class="line"><span class="comment">-- 删除字段：replace columns</span></span><br><span class="line"><span class="comment">-- 在元数据中删除了字段，并没有改动hdfs上的数据文件</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">replace</span> <span class="keyword">columns</span>( <span class="keyword">id</span> <span class="keyword">string</span>, cname <span class="keyword">string</span>, score <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>

<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p><img src="http://img.janhen.com/202103030859484G2IXM.png" alt="http://img.janhen.com/202103030859484G2IXM.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dfs -ls /user/hive/warehouse;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exit</span> <span class="keyword">comment</span> <span class="string">&#x27;test comment&#x27;</span> location <span class="string">&#x27;/usr/hive/mydb2.dbe&#x27;</span>;</span><br><span class="line">desc database extended mydb2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连同表一起删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">test</span> <span class="keyword">CASCADE</span>;</span><br><span class="line">DESC EXTENDED student;</span><br><span class="line">DESC FORMATTED student;</span><br><span class="line"><span class="comment">-- 根据其他表创建新的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test.student2 <span class="keyword">LIKE</span> test.student;</span><br></pre></td></tr></table></figure>

<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><ul>
<li>CREATE TABLE [IF NOT EXISTS]：创建表</li>
<li>EXTERNAL： 外部表创建，生产中一般创建的都是外部表，删除表不删除数据</li>
<li>comment： 表注释</li>
<li>partition by： 对表中数据进行分区</li>
<li>clustered by： 建立分桶表</li>
<li>sorted by： 对表中的一个或多个字段进行排序，较少使用</li>
<li>存储子句:  可指定 SerDe, 默认没有使用 ROW FORMAT 或者 ROW FORMAT DELIMITED，会默认使用 SerDe。建表时需要为表指定列在指定列的同 时也会指定自定义的 SerDe。<strong>hive使用 Serde 进行行对象的序列与反序列化。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] </span><br><span class="line">[COLLECTION ITEMS TERMINATED BY char] </span><br><span class="line">[MAP KEYS TERMINATED BY char] </span><br><span class="line">[LINES TERMINATED BY char] | </span><br><span class="line">SERDE serde_name </span><br><span class="line">[<span class="keyword">WITH</span> SERDEPROPERTIES (property_name=property_value, </span><br><span class="line">  property_name=property_value, ...)]</span><br></pre></td></tr></table></figure>

<ul>
<li>stored as SEQUENCEFILE|TEXTFILE|RCFILE</li>
<li>LOCATION： 表在 HDFS 上的位置</li>
<li>TBLPROPERTIES：定义表的属性</li>
<li>AS： 接查询语句，根据查询结果建表</li>
<li>LIKE： 复制现有的表结构，不会复制数据</li>
</ul>
<h3 id="内外部表"><a href="#内外部表" class="headerlink" title="内外部表"></a>内外部表</h3><p>表的类型有两种，分别是内部表(管理表)、外部 表。</p>
<ul>
<li>默认情况下，创建内部表</li>
<li>删除内部表，表的元数据和数据一起删除</li>
<li>删除外部表，删除表的定义，数据保留</li>
<li>生产环境中，多使用外部表</li>
<li>外部表不能执行 <code>TRUNCATE</code></li>
</ul>
<p>表类型转换</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内部表转外部表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">SET</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;TRUE&#x27;</span>);</span><br><span class="line"><span class="comment">-- 外部表转内部表。EXTERNAL 大写，false 不区分大小</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;FALSE&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><blockquote>
<p>按照分区字段将表中的数据放置在不同的目录中，提高SQL查询的 性能</p>
</blockquote>
<p>Hive没有索引，分区的作用和索引非常类似，可将其看做一种简易索引。对于直接命中分区的查询，Hive不会执行MapReduce作业。</p>
<p><strong>分区字段不是表中已经存在的数据，可以将分区字段看成伪列。</strong></p>
<p><strong>分区查看</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看分区</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> student_info;</span><br></pre></td></tr></table></figure>

<p><strong>新增分区，加载数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加分区，不加载数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-03&#x27;</span>);</span><br><span class="line"><span class="comment">-- 增加多个分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-05&#x27;</span>) <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-06&#x27;</span>);</span><br><span class="line"><span class="comment">-- 增加分区，加载数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-07&#x27;</span>) location <span class="string">&#x27;/user/hive/warehouse/mydb.db/t3/dt=2020-06-07&#x27;</span> </span><br><span class="line"><span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-08&#x27;</span>) location <span class="string">&#x27;/user/hive/warehouse/mydb.db/t3/dt=2020-06-08&#x27;</span>;</span><br><span class="line"><span class="comment">-- 单独为外部表的分区键指定值和存储位置：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student _info <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (province = sichuan, city = chengdu) LOCATION <span class="string">&#x27;hdfs://master:9000/student/sichuan/chengdu&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改分区的hdfs路径</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-01&#x27;</span>) <span class="keyword">set</span> location <span class="string">&#x27;/user/hive/warehouse/t3/dt=2020-06-03&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除分区</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">drop</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-03&#x27;</span>), <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-04&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>动态分区</strong></p>
<p>Hive 会根据 SELECT 语句中的最后一个查询字段作为动态分区的依据，而不是根据字段名来选择。如果指定了 n 个动态分区的字段，Hive 会将 select 语句中最后 n 个字段作为动态分区的依据。 Hive 默认没有开启动态分区，在执行这条语句前，必须对Hive进行一些参数设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启自动分区</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span>(<span class="built_in">time</span>) <span class="keyword">SELECT</span> <span class="keyword">id</span>, modify_time <span class="keyword">FROM</span> <span class="keyword">source</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分桶表"><a href="#分桶表" class="headerlink" title="分桶表"></a>分桶表</h3><blockquote>
<p>分区不能更细粒度的划分数据，就需要使用分桶 技术将数据划分成更细的粒度。 使用 <code>cluster by &lt;col-name&gt; into &lt;num&gt; buckets</code></p>
</blockquote>
<p>分桶的原理</p>
<ul>
<li>MR 中： key.hashCode % reduceTask</li>
<li>Hive 中： 分桶字段.hashCode % 分桶个数</li>
</ul>
<p><strong>分桶表创建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course( </span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>, </span><br><span class="line">  <span class="keyword">name</span> <span class="keyword">string</span>, </span><br><span class="line">  score <span class="built_in">int</span> ) </span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) <span class="keyword">into</span> <span class="number">3</span> buckets </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;\\t&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>分桶表加载数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通表加载数据 </span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/data/course.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> course_common;</span><br><span class="line"><span class="comment">-- 通过 insert ... select ... 给桶表加载数据 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> course <span class="keyword">select</span> * <span class="keyword">from</span> course_common;</span><br></pre></td></tr></table></figure>

<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>SELECT</p>
<ul>
<li>SQL语句对大小写不敏感</li>
<li>各子句一般要分行</li>
</ul>
<h3 id="where-过滤"><a href="#where-过滤" class="headerlink" title="where 过滤"></a>where 过滤</h3><p><strong>正则匹配过滤</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正则匹配，使用 rlike。正则表达式，名字以A或S开头</span></span><br><span class="line"><span class="keyword">select</span> ename, </span><br><span class="line">		   salfrom emp</span><br><span class="line"><span class="keyword">where</span> ename <span class="keyword">rlike</span> <span class="string">&#x27;^(A|S).*&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="lateral-view"><a href="#lateral-view" class="headerlink" title="lateral view"></a>lateral view</h3><blockquote>
<p>lateral view 首先将UDTF应用于基础表的每一行，然后将结果输出行与输入行连接起来以形成具有提供的表别名的虚拟表。</p>
</blockquote>
<p>语法</p>
<ul>
<li>从 0.12.0 开始列别名可省略，从 UTDF 返回的 StructObjectInspector 的字段名称继承</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateralView: LATERAL VIEW udtf(expression) tableAlias AS columnAlias (&#x27;,&#x27; columnAlias)*</span><br><span class="line">fromClause: FROM baseTable (lateralView)*</span><br></pre></td></tr></table></figure>

<p><strong>使用案例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> pageAds(</span><br><span class="line">  pageid <span class="keyword">string</span>,</span><br><span class="line">  adid_list <span class="built_in">Array</span>&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">);</span><br><span class="line">pageid      adid_list</span><br><span class="line">front_page   [1,2,3]</span><br><span class="line">contact_page [3,4,5]</span><br><span class="line"><span class="comment">-- 页面对应的广告</span></span><br><span class="line"><span class="keyword">SELECT</span> pageid, adid</span><br><span class="line"><span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br><span class="line"><span class="comment">-- 查看特定广告的展示次数</span></span><br><span class="line"><span class="keyword">SELECT</span> adid, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> adcnt</span><br><span class="line"><span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br><span class="line">pageid(string)    adid(int)</span><br><span class="line">&quot;front_page&quot;      1</span><br><span class="line">&quot;front_page&quot;      2</span><br><span class="line">&quot;front_page&quot;      3</span><br><span class="line">&quot;contact_page&quot;    3</span><br><span class="line">&quot;contact_page&quot;    4</span><br><span class="line">&quot;contact_page&quot;    5</span><br><span class="line"></span><br><span class="line">adid    adcnt</span><br><span class="line">1          1</span><br><span class="line">2          1</span><br><span class="line">3          2</span><br><span class="line">4          1</span><br><span class="line">5          1</span><br></pre></td></tr></table></figure>

<p><strong>多个 lateral view</strong></p>
<ul>
<li>from clause 可有多个 lateral view</li>
<li>后续的 LATERAL VIEWS可以引用 LATERAL VIEW 左侧出现的任何表中的列。</li>
</ul>
<h3 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br><span class="line"><span class="comment">-- 左外连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">left</span> <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br><span class="line"><span class="comment">-- 全外连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">full</span> <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br></pre></td></tr></table></figure>

<p><strong>多表连接</strong></p>
<p>Hive 总是按照从左到右的顺序执行，Hive 会对每对 JOIN 连接对象启动一个 MapReduce 任务。</p>
<p>会首先启动一个 MapReduce job 对表 t 和表 c 进行连接操作；然后再 启动一个 MapReduce job 将第一个 MapReduce job 的输出和表 s 进行连接操作； 然后再继续直到全部操作；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> techer t </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> score s <span class="keyword">on</span> s.c_id = c.c_id </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> student stu <span class="keyword">on</span> s.s_id = stu.s_id;</span><br></pre></td></tr></table></figure>

<p><strong>笛卡尔积</strong></p>
<p>满足下列条件</p>
<ul>
<li>没有连接条件</li>
<li>连接条件无效</li>
<li>所有表中的所有行互相连接</li>
</ul>
<p>Hive 默认不支持笛卡尔积</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.strict.checks.cartesian.product=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1, u2;</span><br></pre></td></tr></table></figure>

<h3 id="排序子句"><a href="#排序子句" class="headerlink" title="排序子句"></a>排序子句</h3><p><strong>MR 全局排序</strong></p>
<ul>
<li>排序字段需要出现在 select 字段中</li>
<li>ORDER BY 执行全局排序，只有一个 reduce</li>
<li>输出规模较大时，耗时高</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多列排序 </span></span><br><span class="line"><span class="keyword">select</span> empno, </span><br><span class="line">       ename, </span><br><span class="line">       job, mgr, </span><br><span class="line">			 sal + nvl(comm, <span class="number">0</span>) salcomm, </span><br><span class="line">		   deptno </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> deptno, salcomm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>MR 的内部排序(sort by)</strong></p>
<p>sort by 为每个 reduce 产生排序文件，在 reduce 内部进行排序，得到局部有序的结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置reduce个数</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 按照工资降序查看员工信息 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">sort</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 将查询结果导入到文件中（按照工资降序）。生成两个输出文件，每个文件内部数据按 工资降序排列 </span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/home/hadoop/output/sortsal&#x27;</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">sort</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>MR 分区排序(distribute by)</strong></p>
<ul>
<li>将特定的行发送到特定的 reducer 中</li>
<li>distribute by 要写在 sort by 之前</li>
<li>可结合 sort by 操作，使分区数据有序</li>
<li>类似于 MR 中的分区操作</li>
<li>按照指定的条件将数据分组，常结合 sort by 使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先按 deptno 分区，在分区内按照 sal + comm 排序</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  empno,       </span><br><span class="line">  ename,       </span><br><span class="line">  job,       </span><br><span class="line">  deptno,       </span><br><span class="line">  sal + nvl(comm, <span class="number">0</span>) salcomm</span><br><span class="line"><span class="keyword">FROM</span> emp    </span><br><span class="line"><span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> deptno    </span><br><span class="line"><span class="keyword">SORT</span> <span class="keyword">BY</span> sal comm <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 将数据分到 3 个区中，每个分区都有数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/home/hadoop/output/distBy1&#x27;</span> </span><br><span class="line"><span class="keyword">select</span> empno, </span><br><span class="line">			 ename, </span><br><span class="line">			 job, </span><br><span class="line">			 deptno, </span><br><span class="line">			 sal + nvl(comm, <span class="number">0</span>) salcomm </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">distribute</span> <span class="keyword">by</span> deptno </span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> salcomm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Cluster By</strong></p>
<ul>
<li>distribute by 与 sort by 为同一个字段时，使用 cluster by 简化语法</li>
<li>只能是升序，不能指定排序规则</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="HQL-与-MR"><a href="#HQL-与-MR" class="headerlink" title="HQL 与 MR"></a>HQL 与 MR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hive SQL </span><br><span class="line">&#x3D;&#x3D;&gt; AST(抽象语法树) </span><br><span class="line">&#x3D;&#x3D;&gt; QB(查询块) </span><br><span class="line">&#x3D;&#x3D;&gt; OperatorTree(操作树) </span><br><span class="line">&#x3D;&#x3D;&gt; 优化后的操作树 </span><br><span class="line">&#x3D;&#x3D;&gt; MapReduce 任务树 </span><br><span class="line">&#x3D;&#x3D;&gt; 优化后的 MapReduce 任务树</span><br></pre></td></tr></table></figure>

<p>过程描述如下：</p>
<ul>
<li>SQL Parser：Antlr定义SQL的语法规则，完成SQL词法，语法解析，将SQL转化为抽象语法树AST Tree；</li>
<li>Semantic Analyzer：遍历AST Tree，抽象出查询的基本组成单元QueryBlock；</li>
<li>Logical plan：遍历QueryBlock，翻译为执行操作树OperatorTree；</li>
<li>Logical plan optimizer: 逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量；</li>
<li>Physical plan：遍历OperatorTree，翻译为MapReduce任务；</li>
<li>Logical plan optimizer：物理层优化器进行MapReduce任务的变换，生成最终的执行计划。</li>
</ul>
<h3 id="Join-与-MR"><a href="#Join-与-MR" class="headerlink" title="Join 与 MR"></a>Join 与 MR</h3><ul>
<li>如果其中有一张表为小表，直接使用 map 端 join 的方式（map端加载小表）进行聚合。</li>
<li>如果两张都是大表，那么采用联合 key，联合 key 的第一个组成部分是 join on 中的公共字段，第二部分是一个 flag，0 代表表 A，1 代表表 B，由此让 Reduce 区分 join 表的信息；在Mapper中同时处理两张表的信息，将 join on 公共字段相同的数据划分到同一个分区中，进而传递到一个 Reduce 中，然后在 Reduce 中实现聚合。</li>
</ul>
<p>如果对于每个表在 join 子句中使用相同的列，则 Hive 将多个表上的联接转换为单个map / reduce作业</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.val, b.val, c.val </span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key = b.key1) </span><br><span class="line"><span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key = b.key1)</span><br></pre></td></tr></table></figure>

<p>对于 join 使用不同的列，</p>
<ul>
<li>第一个 map / reduce 作业将 a 与 b 联接在一起，然后将结果与 c 联接到第二个 map / reduce 作业中。</li>
<li>第一个将 a 与 b 连接起来，并缓冲a的值，同时在减速器中流式传输b的值</li>
<li>第二个将缓冲第一个连接的结果，同时将c的值通过简化器流式传输</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.val, b.val, c.val </span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key = b.key1) </span><br><span class="line"><span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key = b.key2)</span><br></pre></td></tr></table></figure>

<p>可指定流式传输的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ STREAMTABLE(a) */</span> a.val, b.val, c.val <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key = b.key1) <span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key = b.key1)</span><br></pre></td></tr></table></figure>

<p>如果除一个要连接的表之外的所有表都很小，则可以将其作为仅 Map 作业执行。</p>
<p>无需进行 reduce, 对于 A 的 mapper B 都会完全读取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MAPJOIN(b) */</span> a.key, a.value</span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.key = b.key;</span><br></pre></td></tr></table></figure>

<p>Join 相关的配置参数：</p>
<ul>
<li>hive.auto.convert.join： 如果可能，在运行时自动将联接转换为mapjoins</li>
<li>hive.auto.convert.join.noconditionaltask：Hive是否启用基于输入文件大小的有关将公共联接转换为mapjoin的优化。</li>
<li>hive.auto.convert.join.noconditionaltask.size： 如果hive.auto.convert.join.noconditionaltask关闭，则此参数不起作用。</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>HQL 的执行过程</p>
<p>通常情况下NULL参与运算，返回值为 NULL</p>
<p><strong>NULL&lt;=&gt;NULL 的结果为 true</strong>，一般对 NULL 的比较实用 ISNULL 函数</p>
<h3 id="Json-数据处理"><a href="#Json-数据处理" class="headerlink" title="Json 数据处理"></a>Json 数据处理</h3><p>Hive 处理 json 数据的方式</p>
<ul>
<li>内建的函数 get_json_object</li>
<li>自定义 UDF 函数</li>
<li>使用序列化反序列化工具</li>
</ul>
<p><strong>方式一:  内建的函数处理</strong></p>
<p>处理简单的 json 串。</p>
<ul>
<li><code>get_json_object(string json_string, string path)</code>: 解析 json 字符串 json_string，返回 path 指定的内容；</li>
<li><code>json_tuple(jsonStr, k1, k2, ...)</code>: ：参数为一组键k1，k2，…和json字符串，返回值的元组。该方法比  get_json_object 高效，可以在一次调用中输入多个键, 对嵌套结果的解析操作复杂；</li>
<li><code>explode</code> / <code>lateral view</code>，使用explod将Hive一行中复杂的 array 或 map 结构拆分成多行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> jsont1( </span><br><span class="line">  username <span class="keyword">string</span>, </span><br><span class="line">  age <span class="built_in">int</span>, </span><br><span class="line">  sex <span class="keyword">string</span>, </span><br><span class="line">  <span class="keyword">json</span> <span class="keyword">string</span> </span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/root/lagoudw/data/weibo.json&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> jsont1;</span><br><span class="line"><span class="comment">-- get 单层值 </span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.id&quot;</span>) <span class="keyword">id</span>, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids&quot;</span>) ids, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.total_number&quot;</span>) <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br><span class="line"><span class="comment">-- get 数组</span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.id&quot;</span>) <span class="keyword">id</span>, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[0]&quot;</span>) ids0, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[1]&quot;</span>) ids1, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[2]&quot;</span>) ids2, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[3]&quot;</span>) ids3, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.total_number&quot;</span>) <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br><span class="line"><span class="comment">-- json_tuple 一次处理多个字段</span></span><br><span class="line"><span class="keyword">select</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ids&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br></pre></td></tr></table></figure>

<p>含其他字段时，不能直接展开，需要使用 explod 展开</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 拆分 json</span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, ids, <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ids&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, ids, <span class="keyword">num</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拆分 JSON -&gt; 拆分 jsonarray</span></span><br><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span>( <span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, ids, <span class="keyword">num</span></span><br><span class="line">            <span class="keyword">from</span> jsont1 </span><br><span class="line">            <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ids&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, ids, <span class="keyword">num</span> ) </span><br><span class="line"><span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, ids1, <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> tmp </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(<span class="keyword">split</span>(regexp_replace(ids, <span class="string">&quot;\\\\[|\\\\]&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="string">&quot;,&quot;</span>)) t1 <span class="keyword">as</span> ids1;</span><br></pre></td></tr></table></figure>

<p><strong>方式二: 使用 UDF 处理</strong></p>
<p>能处理大部分数据，更灵活。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建临时函数</span></span><br><span class="line">add jar /root/lagoudw/jars/bigdata-hive-1.0-SNAPSHOT.jar;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">function</span> json_json_array <span class="keyword">as</span> <span class="string">&quot;com.janhen.bigdata.hive.ParseJsonArray&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username, age, sex, parse_json_array(<span class="keyword">json</span>, <span class="string">&quot;ids&quot;</span>) ids </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username, age, sex, ids1 </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(parse_json_array(<span class="keyword">json</span>, <span class="string">&quot;ids&quot;</span>)) t1 <span class="keyword">as</span> ids1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, <span class="keyword">num</span>;</span><br><span class="line"><span class="comment">-- 合并</span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, ids1, <span class="keyword">id</span>, <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(parse_json_array(<span class="keyword">json</span>, <span class="string">&quot;ids&quot;</span>)) t1 <span class="keyword">as</span> ids1 </span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>

<p><strong>方式三: 使用SerDe处理</strong></p>
<p>对象的序列化用途：</p>
<ul>
<li>把对象转换成字节序列后保存到文件中</li>
<li>对象数据的网络传送</li>
<li>可以在表创建的时候指定 SerDe，之后无需指定分割符之类的信息</li>
</ul>
<p>Read : HDFS files =&gt; InputFileFormat =&gt; &lt;key, value&gt; =&gt; Deserializer =&gt; Row object</p>
<p>Write : Row object =&gt; Seriallizer =&gt; &lt;key, value&gt; =&gt; OutputFileFormat =&gt; HDFS files</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;: 1,&quot;ids&quot;: [101,102,103],&quot;total_number&quot;: 3&#125;</span><br><span class="line">&#123;&quot;id&quot;: 2,&quot;ids&quot;: [201,202,203,204],&quot;total_number&quot;: 4&#125;</span><br><span class="line">&#123;&quot;id&quot;: 3,&quot;ids&quot;: [301,302,303,304,305],&quot;total_number&quot;: 5&#125;</span><br><span class="line">&#123;&quot;id&quot;: 4,&quot;ids&quot;: [401,402,403,304],&quot;total_number&quot;: 5&#125;</span><br><span class="line">&#123;&quot;id&quot;: 5,&quot;ids&quot;: [501,502,503],&quot;total_number&quot;: 3&#125;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> jsont2(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">  ids <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">  total_number <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE <span class="string">&#x27;org.apache.hive.hcatalog.data.JsonSerDe&#x27;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/data/lagoudw/data/json2.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> jsont2;</span><br></pre></td></tr></table></figure>

<p><strong>JSON 处理方式比较</strong></p>
<p>1、简单格式的json数据，使用 <code>get_json_object</code>、<code>json_tuple</code> 处理</p>
<p>2、对于嵌套数据类型，可以使用 UDF</p>
<p>3、纯 json 串可使用 JsonSerDe 处理更简单</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+LateralView">LanguageManual LateralView</a></li>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins">LanguageManual Joins</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Hive-HQL/" data-id="ckm733ru00023ivvx88fheoaj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hive/" rel="tag">Hive</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Scala集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Scala%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2021-03-09T13:26:10.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Scala%E9%9B%86%E5%90%88/">Scala集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>集合操作都有可变和不可变两种</p>
<p>集合的三大类：Seq、Set、Map</p>
<ul>
<li>scala.collection.mutable：定义了可变集合的特质和具体实现类</li>
<li>scala.collection.immutable：定义了不可变集合的特质和具体实现类</li>
</ul>
<p>所有的集合都扩展自 Iterable 特质。</p>
<p><img src="http://img.janhen.com/20210306175511R0KtKd.png" alt="http://img.janhen.com/20210306175511R0KtKd.png"></p>
<ul>
<li>String 属于 IndexedSeq</li>
<li>Queue 队列和 Stack 堆这两个经典的数据结构属于 LinearSeq</li>
<li>List列表属于 Seq 中的 LinearSeq</li>
</ul>
<h2 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h2><p>按照一定顺序排列的元素序列；</p>
<p>元素的顺序是确定的，每个元素对应一个索引值；</p>
<p>两个重要的子特质：</p>
<ul>
<li>IndexedSeq：提供了快速随机访问元素的功能，它通过索引来查找和定位的</li>
<li>LinearSeq：提供了访问 head、tail 的功能，它是线型的，有头部和尾部的概念，通过遍历来查找。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List一旦被定义，其值就不能改变。</p>
<p>有头部和尾部的概念</p>
<ul>
<li>head 返回的是列表第一个元素的值</li>
<li>tail 返回的是除第一个元素外的其它元素构成的新列表</li>
</ul>
<p>定义了一个空列表对象Nil，定义为List[Nothing]</p>
<p>借助 Nil <strong>可将多个元素用操作符 <code>::</code> 添加到列表头部</strong>，常用来初始化列表；</p>
<p><strong>操作符 <code>:::</code> 用于拼接两个列表；</strong></p>
<p>使用案例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// :: 操作符表示向集合中添加元素</span></span><br><span class="line">  <span class="keyword">val</span> list1 = <span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">val</span> list2 = <span class="number">5</span> :: <span class="number">6</span> :: <span class="number">7</span> :: <span class="number">8</span> :: <span class="type">Nil</span></span><br><span class="line">  println(<span class="string">s&quot;list1: <span class="subst">$list1</span>&quot;</span>)</span><br><span class="line">  println(<span class="string">s&quot;list2: <span class="subst">$list2</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 ::: 操作符进行了拼接 list</span></span><br><span class="line">  <span class="keyword">val</span> list3 = list1 ::: list2</span><br><span class="line">  println(<span class="string">s&quot;list3: <span class="subst">$list3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">s&quot;list3.head: <span class="subst">$&#123;list3.head&#125;</span>&quot;</span>)</span><br><span class="line">  println(<span class="string">s&quot;list3.last: <span class="subst">$&#123;list3.last&#125;</span>&quot;</span>)</span><br><span class="line">  println(<span class="string">s&quot;list3.init: <span class="subst">$&#123;list3.init&#125;</span>&quot;</span>) <span class="comment">// 返回除最后一个元素之外的其他元素构成的新列表</span></span><br><span class="line">  println(<span class="string">s&quot;list3.tail: <span class="subst">$&#123;list3.tail&#125;</span>&quot;</span>) <span class="comment">// 返回除第一个元系之外的其他元素构成的新列表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> list4 = <span class="type">List</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">  println(<span class="string">s&quot;sorted: <span class="subst">$&#123;quickSort(list4)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> head :: tail =&gt;</span><br><span class="line">      <span class="keyword">val</span> (less, greater) = tail.partition(_ &lt; head)</span><br><span class="line">      quickSort(less) ::: head :: quickSort(greater)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list1: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">list2: <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">list3: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">list3.head: <span class="number">1</span></span><br><span class="line">list3.last: <span class="number">8</span></span><br><span class="line">list3.init: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">list3.tail: <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">sorted: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraversableLike</span>[+<span class="type">A</span>, +<span class="type">Repr</span>] <span class="keyword">extends</span> <span class="title">Any</span></span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">HasNewBuilder</span>[<span class="type">A</span>, <span class="type">Repr</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">FilterMonadic</span>[<span class="type">A</span>, <span class="type">Repr</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">TraversableOnce</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">GenTraversableLike</span>[<span class="type">A</span>, <span class="type">Repr</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">Parallelizable</span>[<span class="type">A</span>, <span class="type">ParIterable</span>[<span class="type">A</span>]]</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  self =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Traversable</span>.breaks._</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">partition</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): (<span class="type">Repr</span>, <span class="type">Repr</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> l, r = newBuilder</span><br><span class="line">    <span class="keyword">for</span> (x &lt;- <span class="keyword">this</span>) (<span class="keyword">if</span> (p(x)) l <span class="keyword">else</span> r) += x</span><br><span class="line">    (l.result, r.result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul>
<li>+=:</li>
<li>++=:</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> queue1 = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">Int</span>]()</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">queue1 += <span class="number">1</span></span><br><span class="line">queue1 ++= <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dequeue: <span class="type">Int</span> = queue1.dequeue()</span><br><span class="line">println(<span class="string">s&quot;dequeue: <span class="subst">$dequeue</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">queue1.enqueue(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">s&quot;queue1.head: <span class="subst">$&#123;queue1.head&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1.last: <span class="subst">$&#123;queue1.last&#125;</span>&quot;</span>)</span><br><span class="line">queue1: <span class="type">Queue</span>()</span><br><span class="line">queue1: <span class="type">Queue</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">dequeue: <span class="number">1</span></span><br><span class="line">queue1: <span class="type">Queue</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">queue1: <span class="type">Queue</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">queue1.head: <span class="number">2</span></span><br><span class="line">queue1.last: <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li><code>&amp;</code> / <code>intersect</code>:</li>
<li><code>++</code> / <code>|</code> / <code>union</code>：</li>
<li><code>--</code> / <code>&amp;~</code> / <code>diff</code></li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">map.keys.foreach(println(_))</span><br><span class="line">map.values.foreach(println)</span><br><span class="line">map.foreach(e =&gt; println(e._1 + <span class="string">&quot; ==&gt; &quot;</span> + e._2))</span><br><span class="line"></span><br><span class="line">println(<span class="string">s&quot;map1(&#x27;b&#x27;): <span class="subst">$&#123;map(&quot;b&quot;)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 访问不存在的 Key 值时，抛出异常</span></span><br><span class="line"><span class="comment">// println(map(&quot;c&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get 方法访问元素，返回一个 Option 对象</span></span><br><span class="line"><span class="keyword">val</span> num: <span class="type">Option</span>[<span class="type">Int</span>] = map.get(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">num <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Key值所对应的Value值，如果键Key不存在，那么就返回指定的默认值</span></span><br><span class="line"><span class="keyword">val</span> num2: <span class="type">Int</span> = map.getOrElse(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>)</span><br><span class="line">println(<span class="string">s&quot;num2: <span class="subst">$num2</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> map3 = scala.collection.mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>)</span><br><span class="line">println(map3)</span><br><span class="line">map3(<span class="string">&quot;a&quot;</span>) = <span class="number">10</span></span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">map3(<span class="string">&quot;c&quot;</span>) = <span class="number">3</span></span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +=添加元素，-=删除元素</span></span><br><span class="line">map3 += (<span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>, <span class="string">&quot;f&quot;</span> -&gt; <span class="number">5</span>)</span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line">map3 -= <span class="string">&quot;d&quot;</span></span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key, Value swap</span></span><br><span class="line"><span class="keyword">val</span> kv: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = <span class="keyword">for</span> ((k, v) &lt;- map3) <span class="keyword">yield</span> (v, k)</span><br><span class="line">println(kv)</span><br><span class="line"><span class="comment">// Key, Value swap(R)</span></span><br><span class="line">map3.map(x =&gt; (x._2, x._1)).foreach(println(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉链操作创建Map</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> b = <span class="type">Array</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> c: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = a.zip(b)</span><br><span class="line"><span class="keyword">val</span> d: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = a.zip(b).toMap</span><br><span class="line">println(<span class="string">s&quot;zip: <span class="subst">$&#123;c.toBuffer&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;zip: <span class="subst">$d</span>&quot;</span>)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">a ==&gt; <span class="number">1</span></span><br><span class="line">b ==&gt; <span class="number">2</span></span><br><span class="line">map1(&#x27;b&#x27;): <span class="number">2</span></span><br><span class="line"><span class="type">None</span></span><br><span class="line">num2: <span class="number">0</span></span><br><span class="line"><span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">1</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">10</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">10</span>, c -&gt; <span class="number">3</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, d -&gt; <span class="number">4</span>, a -&gt; <span class="number">10</span>, c -&gt; <span class="number">3</span>, f -&gt; <span class="number">5</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">10</span>, c -&gt; <span class="number">3</span>, f -&gt; <span class="number">5</span>)</span><br><span class="line"><span class="type">Map</span>(<span class="number">2</span> -&gt; b, <span class="number">5</span> -&gt; f, <span class="number">10</span> -&gt; a, <span class="number">3</span> -&gt; c)</span><br><span class="line">(<span class="number">2</span>,b)</span><br><span class="line">(<span class="number">5</span>,f)</span><br><span class="line">(<span class="number">10</span>,a)</span><br><span class="line">(<span class="number">3</span>,c)</span><br><span class="line">zip: <span class="type">ArrayBuffer</span>((<span class="number">1</span>,a), (<span class="number">2</span>,b), (<span class="number">3</span>,c))</span><br><span class="line">zip: <span class="type">Map</span>(<span class="number">1</span> -&gt; a, <span class="number">2</span> -&gt; b, <span class="number">3</span> -&gt; c)</span><br></pre></td></tr></table></figure>

<p>操作</p>
<ul>
<li>collect： collect通过执行一个并行计算（偏函数），得到一个新的数组对象</li>
<li>reduce：</li>
<li><code>sorted</code> / <code>sortwith</code> / <code>sortby</code>：</li>
</ul>
<h2 id="与-Java-集合转换"><a href="#与-Java-集合转换" class="headerlink" title="与 Java 集合转换"></a>与 Java 集合转换</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line"><span class="keyword">val</span> list: java.util.<span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).asJava</span><br><span class="line">println(<span class="string">s&quot;java list: <span class="subst">$list</span>&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> buffer: scala.collection.mutable.<span class="type">Buffer</span>[<span class="type">Int</span>] = list.asScala</span><br><span class="line">println(<span class="string">s&quot;scala buffer: <span class="subst">$buffer</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Scala%E9%9B%86%E5%90%88/" data-id="ckm733rtg000sivvxhv2b0wph" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Scala语言基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-03-09T13:23:27.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">Scala语言基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Scala-基础"><a href="#Scala-基础" class="headerlink" title="Scala 基础"></a>Scala 基础</h2><p>语言起源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">马丁·奥德斯基（Martin Odersky）是编译器及编程的狂热爱好者。</span><br><span class="line"></span><br><span class="line">主流JVM的Javac编译器就是马丁·奥德斯基编写出来的，JDK5.0、JDK8.0的编译器就是他写的。 </span><br><span class="line">长时间的编程之后，他希望发明一种语言，能够让写程序这样的基础工作变得高效，简单。 </span><br><span class="line">当接触到Java语言后，对Java这门语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到Java中，由此发 明了Scala。</span><br></pre></td></tr></table></figure>

<p>语言特性：</p>
<ul>
<li>OOP</li>
<li>函数式编程</li>
<li>静态类型，参考 Haskell、Errlang</li>
<li>并发性，使用 Actor 作为并发模型，可复用线程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>Kafka、Spar 等框架底层都是使用 Scala 作为底层源码开发语言</li>
<li>融合大数据生态，Flink 支持 Scala 开发</li>
</ul>
<p><strong>Scala 的 REPL</strong></p>
<p>REPL 是一个交互式解析器环境，R(read)、E(evaluate) 、P（print）、L（loop） 输入值，交互式解析器会读取输入内容并对它求值，再打印结果，并重复此过程。</p>
<p>在命令行输入Scala可启动Scala REPL。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul>
<li>区分大小写 - Scala语言对大小写敏感</li>
<li>类名 - 对于所有的类名的第一个字母要大写。</li>
<li>方法名 - 所有方法名的第一个字母用小写。</li>
<li>程序文件名 - Scala程序文件的后缀名是 .scala，程序文件的名称可以不与对象名称完全匹配。</li>
<li>main()方法 - Scala程序从main()方法开始处理</li>
</ul>
<h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><ul>
<li>Int:</li>
<li>Unit: 无值，用于不返回任何结果的方法的返回类型。</li>
<li>Null</li>
<li>Nothing： 在Scala类层级的最低端，它是任何其他类型的子类型</li>
<li>Any: 是Scala中所有类的超类</li>
<li>AnyRef: 是Scala中所有引用类的超类</li>
</ul>
<p>Scala和Java一样，有8种数值类型 Byte、Short、Int、Long、Float、Double、Char、Boolean 类型；</p>
<p>Scala 并不刻意的区分基本类型和引用类型。</p>
<p>每一种数据类型都有对应的Rich类型，如RichInt、RichChar等，为基本类型提供了更多的有用操作。</p>
<h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p>Scala中，所有的类，包括值类型和引用类型，都最终继承自一个统一的根类型Any。</p>
<p><img src="http://img.janhen.com/20210306153957XEmR1i.png" alt="http://img.janhen.com/20210306153957XEmR1i.png"></p>
<ul>
<li>Null<ul>
<li>Null是所有引用类型的子类型</li>
<li>Null类只有一个实例对象null</li>
<li>null可以赋值给任意引用类型，但是不能赋值给值类型。</li>
</ul>
</li>
<li>Nothing<ul>
<li>Nothing位于Scala类继承关系的底部，它是其他所有其他类型的子类型</li>
<li>Nothing对泛型结构有用 。比如，空列表Nil的类型就是List[Nothing]</li>
<li>Nothing的可以给出非正常终止的信号。比如，使用Nothing处理异常</li>
</ul>
</li>
</ul>
<p>在Scala中，鼓励使用val。</p>
<p>简单数据类型可以省略，对于复杂的数据类型建议明确声明；</p>
<p><strong>操作符</strong></p>
<p>Scala中的操作符都是方法</p>
<p><strong>对象相等性</strong></p>
<p>Scala中，要比较两个基础类型的对象是否相等，可以使用 == 或 !=；</p>
<p>== 或 != 还可以比较不同类型的两个对象</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串插值器</p>
<ul>
<li>s 插值器： 对内嵌的每个表达式求值，对求值结果调用toString</li>
<li>f 插值器： 除s插值器的功能外，还能进行格式化输出，在变量后用%指定输出格式</li>
<li>raw 插值器： 按照字符串原样进行输出</li>
</ul>
<h2 id="控制结构和函数"><a href="#控制结构和函数" class="headerlink" title="控制结构和函数"></a>控制结构和函数</h2><p><strong>if 表达式</strong></p>
<p>if 表达式有返回值。</p>
<p>如果if 和 else 的返回值类型不一样，那么就返回两个返回值类型公共的父类。</p>
<p><strong>for 表达式</strong></p>
<p>for (i &lt;- 表达式 / 集合)，让变量 i遍历&lt;-右边的表达式/集合的所有值。</p>
<p>Scala为for循环提供了很多的特性，这些特性被称之为 for守卫式 或 for推导式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">10</span>) &#123;</span><br><span class="line">	println(<span class="string">s&quot;i = <span class="subst">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重循环。条件之间使用分号分隔</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">5</span>; j &lt;- <span class="number">2</span> until <span class="number">5</span>)&#123;</span><br><span class="line">	println(i * j )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 守卫语句。</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; j &lt;- <span class="number">1</span> to <span class="number">10</span> <span class="keyword">if</span> i==j)&#123;</span><br><span class="line">  println(<span class="string">s&quot;i * j = <span class="subst">$i</span> * <span class="subst">$j</span> = <span class="subst">$&#123;i * j&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for推导式, yield 接收返回的结果</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用大括号将生成器、守卫、定义包含在其中；并以换行的方式来隔开它们</span></span><br><span class="line"><span class="keyword">for</span> &#123; i &lt;- <span class="number">1</span> to <span class="number">3</span></span><br><span class="line">  from = <span class="number">4</span> - i</span><br><span class="line">  j &lt;- from to <span class="number">3</span> &#125;</span><br><span class="line">  println(<span class="string">s&quot;i = <span class="subst">$i</span>; j = <span class="subst">$j</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>while 表达式</strong></p>
<p>while语句的本身没有任何返回值类型，即while语句的返回结果是Unit类型的 () 。</p>
<p>Scala内置控制结构特地去掉了 break 和 continue。</p>
<p>终止循环的方式：</p>
<ul>
<li>使用Boolean类型的控制变量</li>
<li>使用 return</li>
<li>使用 breakable和break，需要导入scala.util.control.Breaks包</li>
</ul>
<h3 id="懒值"><a href="#懒值" class="headerlink" title="懒值"></a>懒值</h3><p>当 val 被声明为lazy时(var不能声明为lazy)，初始化将被推迟，直到首次对此取值，适用于初始化开销较大的场景。</p>
<p><strong>惰性求值</strong></p>
<p>可根据 if 短路求值，避免不必要的 expensive  计算操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(input: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s&quot;evaluate called with <span class="subst">$input</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; expensiveComputation())</span><br><span class="line">    println(<span class="string">&quot;doing work...&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    println(<span class="string">&quot;skipping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evaluate(<span class="number">0</span>)</span><br><span class="line">evaluate(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>通过 scala 的懒加载处理</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> perform = expensiveComputation() </span><br><span class="line"><span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; perform) </span><br><span class="line">  println(“doing work…”)</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>导入scala.io.Source后，可引用Source中的方法读取文本文件的内容</p>
<p>Scala没有内建的对写入文件的支持。要写入文本文件，可使用 java.io.PrintWriter</p>
<h2 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h2><p>使用ArrayBuffer时，需要导包 import scala.collection.mutable.ArrayBuffer；</p>
<p><strong>多维数组</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dim = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">dim(<span class="number">1</span>)(<span class="number">1</span>) = <span class="number">11.11</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">2</span>; j &lt;- <span class="number">0</span> to <span class="number">3</span>) &#123;</span><br><span class="line">  print(dim(i)(j) + <span class="string">&quot; &quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">3</span>) println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元组和操作</strong></p>
<p>内建了 22 个 Tuple 类</p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>在Scala中，类并不用声明为public；</p>
<ul>
<li>val修饰的变量（常量），值不能改变，只提供getter方法，没有setter方法；</li>
<li>var修饰的变量，值可以改变，对外提供getter、setter方法；</li>
</ul>
<p><strong>自定义getter和setter方法</strong></p>
<p>Scala 类中的每一个属性，编译后会有一个私有的字段和相应的getter、setter方法生成。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getter方法</span></span><br><span class="line">println(person age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//setter方法</span></span><br><span class="line">person age_= (<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter方法</span></span><br><span class="line">println(person.age)</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>默认情况下，Scala 不遵循 JavaBean 约定，必须要使用 <code>@scala.reflect.BeanProperty</code> 注解来生成满足 JavaBean 约定的 getter 和 setter 方法</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>没有定义构造器，Scala类中会有一个默认的无参构造器；</p>
<p>的构造器分为两种：主构造器和辅助构造器；</p>
<p>主构造器的定义与类的定义交织在一起，将主构造器的参数直接放在类名之后。</p>
<p>当主构造器的参数不用var或val修饰时，参数会生成类的私有val成员。</p>
<p>Scala中，所有的辅助构造器都必须调用另外一个构造器</p>
<h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>没有提供Java那样的静态方法或静态字段；</p>
<p>可以采用object关键字实现单例对象，具备和Java静态方法同样的功能；</p>
<p>使用object语法结构【object是Scala中的一个关键字】达到静态方法和静态字段的目的；对象本质上可以拥有类的所有特性，除了不能提供构造器参数；</p>
<p>任何在Java中用单例对象的地方，在Scala中都可以用object实现：</p>
<ul>
<li>作为存放工具函数或常量的地方</li>
<li>高效地共享单个不可变实例</li>
</ul>
<p>Scala中的单例对象具有如下特点：</p>
<ul>
<li>创建单例对象不需要使用new关键字</li>
<li>object中只有无参构造器</li>
<li>主构造代码块只能执行一次，因为它是单例的</li>
</ul>
<p><strong>应用程序对象</strong></p>
<p>可以扩展App特质（trait) 来运行。</p>
<h3 id="伴生类与伴生对象"><a href="#伴生类与伴生对象" class="headerlink" title="伴生类与伴生对象"></a>伴生类与伴生对象</h3><p>单例对象与某个类具有相同的名称时，它被称为这个类的“伴生对象”；</p>
<p>类和它的伴生对象必须存在于同一个文件中，而且可以相互访问私有成员（字段和方法）；</p>
<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h3><p>object 中的特殊方法</p>
<ul>
<li>apply方法通常定义在伴生对象中，目的是通过伴生类的构造函数功能，来实现伴生对象的构造函数功能；</li>
<li>当遇到类名(参数1,…参数n)时apply方法会被调用；</li>
<li>在创建伴生对象或伴生类的对象时，通常不会使用new class/class() 的方式，而是<strong>直接使用 class()隐式的调用伴生对象的 apply 方法</strong></li>
</ul>
<p><strong>借助 apply 实现工厂设计模式</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">Dog</span> <span class="title">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;woof&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(str: <span class="type">String</span>): <span class="type">Animal</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;dog&quot;</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Dog</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cat = <span class="type">Animal</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">  cat.speak</span><br><span class="line">  <span class="keyword">val</span> dog = <span class="type">Animal</span>(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">  dog.speak</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>override方法重写</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">coding</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;coding...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaProgrammer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, workNo: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Programmer</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">coding</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">super</span>.coding()</span><br><span class="line">    println(<span class="string">&quot;我在写Scala代码。。。&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型检查与转换"><a href="#类型检查与转换" class="headerlink" title="类型检查与转换"></a>类型检查与转换</h3><ul>
<li>isInstanceOf： 测试某个对象是否属于某个给定的类</li>
<li>getClass</li>
<li>classOf</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Person...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Student...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">InstanceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">    <span class="keyword">var</span> student: <span class="type">Student</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    println(student.isInstanceOf[<span class="type">Student</span>])</span><br><span class="line">    <span class="comment">// function check</span></span><br><span class="line">    <span class="keyword">if</span> (person.isInstanceOf[<span class="type">Student</span>]) &#123;</span><br><span class="line">      student = person.asInstanceOf[<span class="type">Student</span>]</span><br><span class="line">      student.say()</span><br><span class="line">    &#125;</span><br><span class="line">    println(student.isInstanceOf[<span class="type">Student</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getClass check</span></span><br><span class="line">    println(person.getClass == classOf[<span class="type">Person</span>])</span><br><span class="line">    println(person.getClass == classOf[<span class="type">Student</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern match check</span></span><br><span class="line">    person <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> s: <span class="type">Student</span> =&gt;</span><br><span class="line">        s.say()</span><br><span class="line">        println(<span class="string">&quot;Student2 type match&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;default...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><p><strong>作为接口使用</strong></p>
<ul>
<li>在trait中可以定义抽象方法，与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。</li>
<li>类可以使用extends关键字继承trait。</li>
<li>在Scala中没有implement的概念，无论继承类还是trait特质，统一都是extends。</li>
<li>类继承trait特质后，必须实现其中的抽象方法，实现时可以省略 override 关键字。</li>
<li>Scala不支持对类进行多继承，但是<strong>支持多重继承trait特质</strong>，使用with关键字即可。</li>
</ul>
<p><strong>特质构造顺序</strong></p>
<ul>
<li>执行父类的构造器；</li>
<li>执行trait的构造器，多个trait从左到右依次执行；</li>
<li>构造trait时会先构造父trait，如果多个trait继承同一个父trait，则父trait只会构造一次；</li>
<li>所有trait构造完毕之后，子类的构造器才执行</li>
</ul>
<h3 id="Ordered和Ordering"><a href="#Ordered和Ordering" class="headerlink" title="Ordered和Ordering"></a>Ordered和Ordering</h3><p>Ordered 特质混入 Java 的 Comparable 接口，它定义了相同类型间的比较方式，但这种内部比较方式是单一的；</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordered</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">A</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;  <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;  <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;= <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;= <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compareTo</span></span>(that: <span class="type">A</span>): <span class="type">Int</span> = compare(that)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ordering 特质混入 Comparator 接口，提供第三方比较器，可以自定义多种比较方式，在实际开发中也是使用比较多的，灵活解耦合。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation</span>.implicitNotFound(msg = <span class="string">&quot;No implicit Ordering defined for $&#123;T&#125;.&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Comparator</span>[<span class="type">T</span>] <span class="keyword">with</span> <span class="title">PartialOrdering</span>[<span class="type">T</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  outer =&gt;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tryCompare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="type">Some</span>(compare(x, y))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Int</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &lt;= <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &gt;= <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &lt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &gt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equiv</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) == <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">if</span> (gteq(x, y)) x <span class="keyword">else</span> y</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">if</span> (lteq(x, y)) x <span class="keyword">else</span> y</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reverse</span> </span>= outer</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = outer.compare(y, x)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">on</span></span>[<span class="type">U</span>](f: <span class="type">U</span> =&gt; <span class="type">T</span>): <span class="type">Ordering</span>[<span class="type">U</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">U</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">U</span>, y: <span class="type">U</span>) = outer.compare(f(x), f(y))</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Ops</span>(<span class="params">lhs: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(rhs: <span class="type">T</span>) = lt(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(rhs: <span class="type">T</span>) = lteq(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(rhs: <span class="type">T</span>) = gt(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(rhs: <span class="type">T</span>) = gteq(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equiv</span></span>(rhs: <span class="type">T</span>) = <span class="type">Ordering</span>.<span class="keyword">this</span>.equiv(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(rhs: <span class="type">T</span>): <span class="type">T</span> = <span class="type">Ordering</span>.<span class="keyword">this</span>.max(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(rhs: <span class="type">T</span>): <span class="type">T</span> = <span class="type">Ordering</span>.<span class="keyword">this</span>.min(lhs, rhs)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">mkOrderingOps</span></span>(lhs: <span class="type">T</span>): <span class="type">Ops</span> = <span class="keyword">new</span> <span class="type">Ops</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Ordering</span> <span class="keyword">extends</span> <span class="title">LowPriorityOrderingImplicits</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]) = ord</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">by</span></span>[<span class="type">T</span>, <span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">S</span>]): <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">T</span>] &#123;</span><br><span class="line">	    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = ord.compare(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.lt(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.gt(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.gteq(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.lteq(f(x), f(y))</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Sorting</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span>(<span class="params">tag: <span class="type">String</span>, score: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Project</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Project</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    tag.compareTo(that.tag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">Project</span>(<span class="string">&quot;hadoop&quot;</span>, <span class="number">40</span>), <span class="type">Project</span>(<span class="string">&quot;flink&quot;</span>, <span class="number">90</span>), <span class="type">Project</span>(<span class="string">&quot;spark&quot;</span>, <span class="number">80</span>), <span class="type">Project</span>(<span class="string">&quot;hive&quot;</span>, <span class="number">60</span>))</span><br><span class="line">    println(list.sorted)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pairs = <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">7</span>, <span class="number">2</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">9</span>, <span class="number">1</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="comment">// Ordering.by[(String,Int,Int),Int](_._2) 从 Tuple3 转到 Int 型，根据 Tuple3 第二个元素进行排序</span></span><br><span class="line">    <span class="type">Sorting</span>.quickSort(pairs)(<span class="type">Ordering</span>.by[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>), <span class="type">Int</span>](_._2))</span><br><span class="line">    println(pairs.toBuffer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配和样例类"><a href="#模式匹配和样例类" class="headerlink" title="模式匹配和样例类"></a>模式匹配和样例类</h2><ul>
<li>Scala没有Java中的switch case</li>
<li>Scala的模式匹配可以匹配各种情况，比如变量的类型、集合的元素、有值或无值。</li>
<li>模式匹配match case中，只要有一个case分支满足并处理了，就不会继续判断下一个case分支了</li>
</ul>
<h3 id="守卫式匹配"><a href="#守卫式匹配" class="headerlink" title="守卫式匹配"></a>守卫式匹配</h3><p>可增加 if 条件判断</p>
<h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><ul>
<li>可以直接匹配类型，而不是值</li>
</ul>
<h3 id="匹配数组、元组、集合"><a href="#匹配数组、元组、集合" class="headerlink" title="匹配数组、元组、集合"></a>匹配数组、元组、集合</h3><h3 id="case-class"><a href="#case-class" class="headerlink" title="case class"></a>case class</h3><p>样例类 默认实现了常用的方法，如 getter/setter, 默认序列化</p>
<ul>
<li>主构造器函数结构的参数不需要显示 var/val 修饰，自动使用 val 修饰</li>
<li>自动定义了伴生对象，提供 apply 方法，无需 new 关键字就可构造出对象</li>
<li>生成 toString,equals,hashCode,copy 方法</li>
<li>继承了 Product, Serializable 两个特质</li>
<li>case class 为多例的， case object 为单例的</li>
</ul>
<h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><p>Option通常与模式匹配结合使用，用于判断某个变量是有值还是无值。</p>
<h2 id="函数与抽象化"><a href="#函数与抽象化" class="headerlink" title="函数与抽象化"></a>函数与抽象化</h2><ul>
<li>不仅可以定义一个函数然后调用它，还可以写一个未命名的函数字面量，然后可以把它当成一个值传递到其它函数或是赋值给其它变量。</li>
<li>函数字面量体现了函数式编程的核心理念。字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、函数字面量等。</li>
<li>函数类型：(输入参数类型列表) =&gt; (输出参数类型列表)只有一个参数时，小括号可省略；函数体中只有1行语句时</li>
</ul>
<h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><ul>
<li>使用 val 定义的是函数(function)，使用 def 定义的是方法(method)。</li>
<li>Scala 中的方法与 Java 的类似，方法是组成类的一部分</li>
<li>Scala 中的函数则是一个完整的对象。Scala 中用 22 个特质(从 Function1 到 Function22)抽象出了函数的概念</li>
<li>Scala 中用 val 语句定义函数，def 语句定义方法</li>
<li>方法不能作为单独的表达式而存在，而函数可以；</li>
<li>函数必须要有参数列表，而方法可以没有参数列表；</li>
<li>方法名是方法调用，而函数名只是代表函数对象本身；</li>
<li>在需要函数的地方，如果传递一个方法，会自动把方法转换为函数</li>
<li>一般情况下，不对二者做区分，认为都是函数，<strong>更多的时候使用def定义函数。</strong></li>
</ul>
<p><strong>方法转换成函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span></span>(x: <span class="type">Int</span>) = x*x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span> </span>= double _</span><br></pre></td></tr></table></figure>

<p><strong>匿名函数</strong></p>
<p>函数没有名字就是匿名函数；</p>
<p>匿名函数，又被称为 Lambda 表达式。</p>
<p><strong>占位符</strong></p>
<ul>
<li>第一个下划线代表第一个参数</li>
<li>第二个下划线代表第二个参数</li>
<li>第三个……，如此类推</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote>
<p>接收一个或多个函数作为输入或输出一个函数。</p>
</blockquote>
<p>常用的高阶函数：map、reduce、flatMap、foreach、filter、count。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包是一种函数，是<strong>在其上下文中引用了自由变量的函数</strong>；</p>
</blockquote>
<p>闭包引用到函数外面定义的变量，定义这个函数的过程就是将这个自由变量捕获而构成的一个封闭的函数，也可理解为”把函数外部的一个自由变量关闭进来“。</p>
<p>闭包满足的条件：</p>
<ul>
<li>闭包是一个函数</li>
<li>函数必须要有返回值</li>
<li>返回值依赖声明在函数外部的一个或多个变量，用 Java 的话说，就是返回值和定义全局变量有关</li>
</ul>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><blockquote>
<p>函数编程中，<strong>接收多个参数的函数都可以转化为接收单个参数的函数，</strong>这个转化过程就叫柯里化(Currying)。</p>
</blockquote>
<p>柯里化函数拥有多组参数列表，每组参数用小括号括起来。</p>
<p>Scala 源码中的柯里化</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraversableOnce</span>[+<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">GenTraversableOnce</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  self =&gt;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = foldLeft(z)(op)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">B</span>](z: =&gt;<span class="type">B</span>)(seqop: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>, combop: (<span class="type">B</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = foldLeft(z)(seqop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h3><blockquote>
<p>部分应用函数（Partial Applied Function）也叫偏应用函数，是指缺少部分（甚至全部）参数的函数</p>
</blockquote>
<p>如果一个函数有n个参数, 而为其提供少于n个参数, 那就得到了一个部分应用函数。</p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><blockquote>
<p>并不处理所有可能的输入，而只处理那些能与至少一个 case 语句匹配的输入；</p>
</blockquote>
<p>偏函数中只能使用 case 语句，整个函数必须用大括号包围。与普通的函数字面量不同，普通的函数字面量可以使用大括号，也可以用小括号；</p>
<p>Scala中的 Partial Function 是一个 trait。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PartialFunction</span>[-<span class="type">A</span>, +<span class="type">B</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">A</span> =&gt; <span class="type">B</span></span>) </span>&#123; self =&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PartialFunction</span>._</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">A</span>): <span class="type">Boolean</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>[<span class="type">A1</span> &lt;: <span class="type">A</span>, <span class="type">B1</span> &gt;: <span class="type">B</span>](that: <span class="type">PartialFunction</span>[<span class="type">A1</span>, <span class="type">B1</span>]): <span class="type">PartialFunction</span>[<span class="type">A1</span>, <span class="type">B1</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OrElse</span>[<span class="type">A1</span>, <span class="type">B1</span>] (<span class="keyword">this</span>, that)</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">C</span>](k: <span class="type">B</span> =&gt; <span class="type">C</span>): <span class="type">PartialFunction</span>[<span class="type">A</span>, <span class="type">C</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">AndThen</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>] (<span class="keyword">this</span>, k)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lift</span></span>: <span class="type">A</span> =&gt; <span class="type">Option</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Lifted</span>(<span class="keyword">this</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">applyOrElse</span></span>[<span class="type">A1</span> &lt;: <span class="type">A</span>, <span class="type">B1</span> &gt;: <span class="type">B</span>](x: <span class="type">A1</span>, <span class="keyword">default</span>: <span class="type">A1</span> =&gt; <span class="type">B1</span>): <span class="type">B1</span> =</span><br><span class="line">    <span class="keyword">if</span> (isDefinedAt(x)) apply(x) <span class="keyword">else</span> <span class="keyword">default</span>(x)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">runWith</span></span>[<span class="type">U</span>](action: <span class="type">B</span> =&gt; <span class="type">U</span>): <span class="type">A</span> =&gt; <span class="type">Boolean</span> = &#123; x =&gt;</span><br><span class="line">    <span class="keyword">val</span> z = applyOrElse(x, checkFallback[<span class="type">B</span>])</span><br><span class="line">    <span class="keyword">if</span> (!fallbackOccurred(z)) &#123; action(z); <span class="literal">true</span> &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 Int 类型的元素加 1</span></span><br><span class="line"><span class="keyword">val</span> partialFunction = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    x.isInstanceOf[<span class="type">Int</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    v1.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">10</span>, <span class="string">&quot;hadoop&quot;</span>, <span class="number">20</span>, <span class="string">&quot;spark&quot;</span>, <span class="number">30</span>, <span class="string">&quot;flink&quot;</span>)</span><br><span class="line">list.collect(partialFunction).foreach(println)</span><br><span class="line"><span class="comment">// simple    </span></span><br><span class="line">list.collect(&#123;<span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span>&#125;).foreach(println)</span><br></pre></td></tr></table></figure>

<h2 id="隐式机制"><a href="#隐式机制" class="headerlink" title="隐式机制"></a>隐式机制</h2><blockquote>
<p>根据隐式转换函数的签名，在程序中使用到隐式转换函数接收的参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回，这就是“隐式转换”</p>
</blockquote>
<p>隐式转换和隐式参数是Scala中两个非常强大的功能，利用隐式转换和隐式参数，可以提供类库，对类库的使用者隐匿掉具体的细节。</p>
<p>使用限制</p>
<ul>
<li>implicit 关键字只能用来修饰方法、变量、参数</li>
<li>隐式转换的函数只在当前范围内才有效。如果隐式转换不在当前范围内定义，那么必须通过 import 语句将其导入</li>
</ul>
<h3 id="隐式转换函数"><a href="#隐式转换函数" class="headerlink" title="隐式转换函数"></a>隐式转换函数</h3><p>定义的隐式转换函数，只要在编写的程序内引入，就会被Scala自动使用。</p>
<p>隐式转换函数由Scala自动调用，通常建议将隐式转换函数的名称命名为“one2one”的形式。</p>
<h3 id="隐式参数和隐式值"><a href="#隐式参数和隐式值" class="headerlink" title="隐式参数和隐式值"></a>隐式参数和隐式值</h3><p>在函数定义的时候，支持在<strong>最后一组参数</strong>中使用 implicit ，表明这是一组隐式参数。</p>
<p>在调用该函数的时候，可以不用传递隐式参数，而编译器会自动寻找一个implicit 标记过的合适的值作为参数。</p>
<p>查看范围</p>
<ul>
<li>当前作用域内可见的 val 或 var 定义隐式变量</li>
<li>隐式参数类型的伴生对象内隐式值</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://www.scala-lang.org/">The Scala Programming Language</a></p>
<p>Scala 官网</p>
<p><a target="_blank" rel="noopener" href="https://www.scala-lang.org/download/2.11.8.html">Scala 2.11.8</a></p>
<p>Scala官网下载Scala 2.11.8安装包</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vGLVmgcjK3jmK6ibYIONew">为什么 Haskell 是我们构建生产软件系统的首选</a></p>
<p>Haskell</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" data-id="ckm733ru10026ivvx5z4xg1tv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vagrent" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Vagrent/" class="article-date">
  <time datetime="2021-03-09T13:17:56.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/Vagrent/">Vagrent</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC] </p>
<h1 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h1><blockquote>
<p>快速搭建虚拟机环境，可通过 Vagrantfile 配置文件进行定制，类似 Docker 管理容器。</p>
</blockquote>
<p>一些特性：</p>
<ul>
<li>多种虚拟器支持，如 VirsualBox(默认)、 Vmware、Docker、Hyper-V</li>
<li>方便网络配置，支持端口转发，配置私有、公有网络</li>
<li>方便进行宿主机与虚拟机之间共享文件提供丰富的插件，简化日常使用</li>
</ul>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>Virtual Box</strong></p>
<p>Oracle 开源的虚拟机软件，跨平台</p>
<p>在 winows 上无法同时运行 Hyper-V 和 VisualBox，两者都是基于 CPU 等底层硬件的 Hypervisor 机制来实现的，而他们必须独占管理 Hypervisor。通过开启启动项选择是否加载 Hyper-V 服务，实现伪同时运行。</p>
<p>问题由来： Docker 安装在 win10 上需要开启 Hyper-V，方便进行本地镜像的打包部署，同时需要 VirtualBox 进行模拟集群。</p>
<p>问题处理：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/enweitech/article/details/52180373">解决Win7/8/10系统中的Hyper-V和VMware虚拟机软件共存问题</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31642333/virtualbox-callee-rc-regdb-e-classnotreg-0x80040154">Virtualbox “Callee RC: REGDB_E_CLASSNOTREG” (0x80040154)?</a></p>
<p><strong>Hyper-V</strong></p>
<p>Win10 自带虚拟化工具，实现在 Win10 上运行 Docker 环境，而无需开启 Docker 的远程访问，开启后无法使用其他虚拟器</p>
<p>对应的 vagrant 设置内存和CPU参数参考文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boxes &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        :name &#x3D;&gt; &quot;docker-kubernetes&quot;,</span><br><span class="line">        :eth1 &#x3D;&gt; &quot;192.168.205.12&quot;,</span><br><span class="line">        :mem &#x3D;&gt; &quot;2048&quot;,</span><br><span class="line">        :cpu &#x3D;&gt; &quot;2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">  config.vm.provider &quot;hyperv&quot; do |v|</span><br><span class="line">    v.ip_address_timeout&#x3D;121</span><br><span class="line">    v.memory&#x3D;opts[:mem]</span><br><span class="line">    v.cpus&#x3D;opts[:cpu]</span><br><span class="line">  end</span><br><span class="line">bcdedit &#x2F;set hypervisorlaunchtype off</span><br><span class="line">bcdedit &#x2F; set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure>

<p><strong>XShell</strong></p>
<p>SSH 命令工具</p>
<p>一些特性</p>
<ul>
<li>标签化页面管理，方便管理打开的连接</li>
<li>支持连接目录管理，方便进行多种环境管理</li>
<li>支持分屏，方便对集群中的主从进行区分</li>
<li>支持透明图，无需切换窗口查看遗忘的命令</li>
<li>侧栏显示连接信息，方便集群中配置 IP 地址</li>
</ul>
<p><strong>Vagrant 管理</strong></p>
<p>通过 Vagrantfile 文件设置好一些数值进行控制虚拟机，通过命令管理虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 全局管理</span><br><span class="line">vagrant global-status</span><br><span class="line">vagrant global-status --prune</span><br><span class="line">vagrant destroy &lt;vm_id&gt;</span><br><span class="line">vagrant halt &lt;vm_id&gt; &lt;vm_id2&gt;</span><br><span class="line">vagrant reload &lt;vm_id1&gt; &lt;vm_id2&gt;..</span><br><span class="line">vagrant up &lt;vm_id1&gt; &lt;vm_id2&gt;..</span><br></pre></td></tr></table></figure>

<p><strong>安装虚拟机环境</strong></p>
<p>快速安装环境，支持从远程获取对应的 Vagrantfile，之后拉取远程镜像；支持导入本地的 box 作为镜像；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vagrant 命令</span><br><span class="line"># 初始化一个安装 centos&#x2F;7 虚拟机的 Vagrantfile</span><br><span class="line"># 根据目录下的 Vagrantfile 进行启动</span><br><span class="line"># 删除虚拟机</span><br><span class="line"># 查案虚拟机运行状态</span><br><span class="line">vagrant init centos&#x2F;7</span><br><span class="line">vagrant up</span><br><span class="line">vagrant status</span><br></pre></td></tr></table></figure>

<p><strong>多种虚拟机支持</strong></p>
<p>支持多种虚拟机，对应的配置memory、Cpu 方式不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 vmware 虚拟机</span><br><span class="line"># 使用 hyper-v，需要管理员权限运行 vagrant，通过 Cmder 默认使用 admin 启动的 powershell 处理</span><br><span class="line">vagrant up --provider&#x3D;vmware_fusion</span><br><span class="line">vagrant up --provider&#x3D;hyperv</span><br></pre></td></tr></table></figure>

<h2 id="Vagrant-插件"><a href="#Vagrant-插件" class="headerlink" title="Vagrant 插件"></a>Vagrant 插件</h2><p><strong>vagrant-hostmanager</strong></p>
<p>实现多台虚拟机之间直接通过名称访问，原理为更改 host 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 安装并验证插件</span><br><span class="line">vagrant plugin install vagrant-hostmanager</span><br><span class="line">vagrant plugin list</span><br><span class="line"># 在 Vagrantfile 中修改</span><br><span class="line">config.hostmanager.enabled &#x3D; true</span><br><span class="line">config.hostmanager.manage_guest &#x3D; true</span><br><span class="line">config.hostmanager.manage_host &#x3D; true</span><br><span class="line"># 执行命令，更新虚拟机上的hosts，同时更新主机上的 hosts</span><br><span class="line">vagrant hostmanager</span><br></pre></td></tr></table></figure>

<p><strong>vagrant-vbguest</strong></p>
<p>处理 VisualBox 中无法设置共享目录问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant vbguest --status</span><br><span class="line">vagrant vbguest --do install node1</span><br><span class="line"># 配置 vagrantfile</span><br><span class="line">config.vbguest.auto_update&#x3D;false</span><br></pre></td></tr></table></figure>

<p><strong>vagrant-bindfs</strong></p>
<p>非使用 visualBox 自带的共享目录，自定义使用文件系统 nfs，性能更高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-bindfs</span><br><span class="line"># 。。。</span><br><span class="line">node1. vm. synced_folder &quot;.&#x2F;app&quot;,&quot;&#x2F;mnt&#x2F;app-data&quot;, type:&quot;nfs</span><br><span class="line">node1. bindfs. bind_folder &quot;&#x2F;mnt&#x2F;app-data&quot;,&quot;&#x2F;app&quot;, force_user:&quot;root&quot;, force_group:&quot;root&quot;,o:&quot;nonempty&quot;</span><br><span class="line"># 代理设置插件</span><br><span class="line"># 在Vagrantfile中的config部分添加代理配置, 全部网络都走主机代理</span><br><span class="line">vagrant plugin install vagrant-proxyconf</span><br><span class="line">vim Vagrantfile</span><br><span class="line">  Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">    if Vagrant.has_plugin?(&quot;vagrant-proxyconf&quot;)</span><br><span class="line">      config.proxy.http     &#x3D; &quot;&lt;http:&#x2F;&#x2F;192.168.0.2:3128&#x2F;&gt;&quot;</span><br><span class="line">      config.proxy.https    &#x3D; &quot;&lt;http:&#x2F;&#x2F;192.168.0.2:3128&#x2F;&gt;&quot;</span><br><span class="line">      config.proxy.no_proxy &#x3D; &quot;localhost,127.0.0.1,.example.com&quot;</span><br><span class="line">    end</span><br><span class="line">    # ... other stuff</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line"># 复用虚拟机环境插件安装</span><br><span class="line">vagrant plugin list</span><br><span class="line">vagrant plugin install vagrant-scp</span><br><span class="line">vagrant scp</span><br><span class="line"></span><br><span class="line"># 处理虚拟机安装进行目录文件映射权限问题</span><br><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant plugin list</span><br></pre></td></tr></table></figure>

<h2 id="Vagrantfile"><a href="#Vagrantfile" class="headerlink" title="Vagrantfile"></a>Vagrantfile</h2><blockquote>
<p>构建虚拟机的硬件情况，实现控制 CPU、内存、Ip 等资源，同时支持虚拟机启动后执行初始化脚本，实现一些必要工具的安装，如 Docker。</p>
</blockquote>
<p>通过配置可实现：</p>
<ul>
<li>进行虚拟机目录与本地目录映射</li>
<li>选择网络</li>
<li>安装成功后执行特定脚本，直接安装要必要的工具以及 Docker 环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># config.vm.box 配置使用哪个box</span><br><span class="line">config.vm.box &#x3D; &quot;ubuntu16.04_louis&quot;# box ∈ vagrant box list</span><br><span class="line">config.vm.hostname               # 机器应该有的主机名</span><br><span class="line">aa.vm.hostname &#x3D; &quot;aa.test.com&quot;</span><br><span class="line">config.vm.network                # 在机器上配置网络</span><br><span class="line">config.vm.network&quot;forwarded_port&quot;,guest:80,host:8080</span><br><span class="line">aa.vm.network &quot;private_network&quot;, ip: &quot;192.168.55.100&quot;</span><br><span class="line">config.vm.provider               # 配置提供程序特定的配置，用于修改特定于某个 提供程序的设置</span><br><span class="line">config.vm.provision              # 配置置备 在机器上，使软件可以自动安装并创建机器时配置</span><br><span class="line">config.vm.synced_folder          # 配置 机器上的同步文件夹</span><br></pre></td></tr></table></figure>

<p>配置实例：</p>
<ul>
<li>参数注入</li>
<li>脚本执行，进行必要软件(vim,git…)、必要环境(如pip,java,docker) 的安装</li>
<li>资源配置，可 CPU、内存…. 等硬件资源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boxes &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        :name &#x3D;&gt; &quot;docker-host&quot;,</span><br><span class="line">        :eth1 &#x3D;&gt; &quot;192.168.205.10&quot;,</span><br><span class="line">        :mem &#x3D;&gt; &quot;1024&quot;,</span><br><span class="line">        :cpu &#x3D;&gt; &quot;1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">boxes.each do |opts|</span><br><span class="line">    config.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">      v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]]</span><br><span class="line">      v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]]</span><br><span class="line">    end</span><br><span class="line">    config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line">    # 从主机特定文件读入脚本执行</span><br><span class="line">    config.vm.provision &quot;shell&quot;, privileged: true, path: &quot;.&#x2F;setup.sh&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>根据需要设置虚拟机网络 IP 地址固定，实现虚拟机中的软件根据名称访问，设置虚拟机可以访问外部的网络。</p>
<p><strong>端口转发</strong></p>
<p>将宿主机的端口与虚拟机的端口绑定，从而让外部通过端口可以访问虚拟机</p>
<p>若 guest_ip 和 host_ip 两项配置为空，则局域网下的所有设备都可以访问该虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(2&quot;) do |config|</span><br><span class="line">config.vm.network</span><br><span class="line">&quot;forwarded_port&quot;(必选) &#x2F;&#x2F;端口转发标示</span><br><span class="line">,guest(必选):       # 虚拟端口</span><br><span class="line">,host(必选):        # 宿主机端口，值必须大于1024</span><br><span class="line">,gust_ip(可选):     # 虚拟机端口绑定虚拟机ip地址</span><br><span class="line">,host_ip(可选):     # 虚拟机端口绑定宿主机端口ip</span><br><span class="line">,protocol(可选):    # 指定通信协议，可以使用tcp&#x2F;udp,默认tcp</span><br><span class="line">,auto_correct(可选): # ture&#x2F;fasle,开机是否自动检测端口冲突</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 实际配置</span><br><span class="line"># 配置2个端口映射，把物理机的8080映射到虚拟机80，物理机的2100映射到虚拟机的22</span><br><span class="line"># host_ip 在主机 IP 较为固定情况下配置使用</span><br><span class="line">config.vm.network :&quot;forwarded_port&quot;, guest: 80, host: 8060,host_ip: &quot;10.2.11.203&quot;</span><br><span class="line">config.vm.network :&quot;forwarded_port&quot;, guest: 22, host: 2100, host_ip: &quot;10.2.11.203&quot;</span><br></pre></td></tr></table></figure>

<p><strong>私有网络</strong></p>
<p>虚拟机之间处在同一网段的地址可相互访问，主机可以访问虚拟机，无法通过虚拟机进行团队合作，不与宿主机的 IP 在同一个网段，防止冲突</p>
<p>配置 vagrant 里面的虚拟机的私有网段的时候，切记不能和企业（公司）内部的 DHCP 分配的 IP 地址在同一网段，否则会发生冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置 Static IP</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.10&quot;</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.55.20&quot;</span><br><span class="line"># 配置通过 DHCP 进行获取 IP，之后执行 &#96;vagrant reload&#96;</span><br><span class="line">config.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;</span><br><span class="line"></span><br><span class="line"># 实际使用</span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.10&quot;,</span><br><span class="line">auto_config: false</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>公有网络</strong></p>
<p>与宿主机一样的网络配置， vagrant1.3+ 支持设置固定 IP，虚拟机 IP 与主机 IP 处在同一个网段时，实现局域网之间的互通，需要有路由器分配 IP.一般来说开发和测试使用较为封闭的网络模型是比较好的方式，通常不建议 vm 配置有 public_network 的网卡关联</p>
<p>配置虚拟机自动获取公司内部DHCP服务器分配的IP地址，在局域网任何一台电脑上，都可以ssh到虚拟机，或访问虚拟机上提供的服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;192.168.1.120&quot;</span><br><span class="line"></span><br><span class="line"># 配置动态 IP</span><br><span class="line"># 配置共有网络，使用主机上可以访问外网的接口(ipconfig)</span><br><span class="line"># 配置默认网关</span><br><span class="line">config.vm.network &quot;public_network&quot;,bridge: &quot;ens33&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;route add default gw 10.2.11.1&quot;</span><br><span class="line"></span><br><span class="line"># 配置静态 IP</span><br><span class="line"># auto_config：关闭自动配置</span><br><span class="line"># ifconfig enp0s8 10.2.11.196 netmask 255.255.255.0 up: 配置静态ip（这里的ip不能和公司内部的地址冲突）</span><br><span class="line"># route add default gw 10.2.11.1 指定网关（添加默认路由）</span><br><span class="line"># bridge： 绑定接口（物理机哪个接口可以上网）</span><br><span class="line">config.vm.network &quot;public_network&quot;, auto_config: false ,bridge: &quot;ens33&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;ifconfig eth1 10.2.11.196 netmask 255.255.0.0 up&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;alway&quot;,inline: &quot;route add default gw 10.2.11.1&quot;</span><br><span class="line">config.vm.network &quot;public_network&quot;, auto_config: false </span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;ip addr add 172.17.10.51&#x2F;21 dev eth1&quot; </span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;alway&quot;,inline: &quot;ip route add 172.17.8.0&#x2F;21 via 172.17.0.49&quot;</span><br></pre></td></tr></table></figure>

<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>配置宿主机中的数据与虚拟机的数据映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># src： 是物理机的目录，相对路径，（相对于项目目录（&#x2F;vagrant&#x2F;ubuntu））</span><br><span class="line"># &#x2F;srv&#x2F;website: 虚拟机的目录，绝对路径，如果没有，会自动创建</span><br><span class="line">config.vm.synced_folder &quot;src&#x2F;&quot;, &quot;&#x2F;srv&#x2F;website&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">config.vm.synced_folder &quot;.&quot;, &quot;&#x2F;vagrant&quot;, disabled: true</span><br><span class="line">config.vm.synced_folder &quot;src&#x2F;&quot;,&quot;&#x2F;srv&#x2F;website&quot;,owner: &quot;root&quot;,group: &quot;root&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<p>出现的问题以及对应的处理</p>
</blockquote>
<p>@Q: 处理本地下载对应镜像慢问题：</p>
<p>直接下载、设置代理</p>
<p>执行 <code>vagrant up --provider=hyperv</code>，在控制台找到下载地址，使用本地下载工具下载(代理)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 执行下载</span><br><span class="line"># 获取地址重新下载</span><br><span class="line"># 重命名为指定格式</span><br><span class="line">vagrant up --provider&#x3D;hyperv</span><br><span class="line"># 将下载的 .box 添加</span><br><span class="line"># 使用下载的 .box 进行初始化 </span><br><span class="line">vagrant box add centos-7_hyperv hyperv.box</span><br><span class="line">vagrant init centos-7_hyperv</span><br></pre></td></tr></table></figure>

<p>@Q: 卸载重装 Vagrant 无法删除之前构建的虚拟机</p>
<p>@Q: 公有网络设置静态 IP 的接口选择问题，无法选择 Wifi、以太网接口?? 待验证 选择不同的连接网卡是否可相互通信？</p>
<p>选择以太网的桥接可实现内网互通</p>
<p>@Q: 使用以太网接口指定公司网关显示网络不可达? 公司内网的安全性??</p>
<p>相当于占用内网的一个 IP</p>
<p>@Q: 二次使用 vagrantfile 时，报错 chmod: cannot access ‘/etc/systemd/system/docker.service.d/http-proxy.conf’: No such file or directory</p>
<p>A： 通过 ssh 进入主机，创建该文件 // todo 搜寻更好的处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</span><br></pre></td></tr></table></figure>

<p>原因是修改了网络配置(改成桥接)，重新配置 docker 的代理，需要创建文件的方式来配置代理，而默认情况下无权限访问</p>
<p>@Q: 同步文件夹显示编码问题， ==&gt; Test-Node: Rsyncing folder: /cygdrive/d/develop/Env2/Test-Node/ =&gt; /vagrant D:/ProgramFile/Vagrant/embedded/gems/2.2.5/gems/vagrant-2.2.5/lib/vagrant/util/io.rb:32:in `encode’: “5” from GBK to UTF-8 (Encoding::UndefinedConversionError)</p>
<p>管理员权限编辑对应的 io.rb 文件，更改 vagrant 源码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hashicorp/vagrant/issues/9368">https://github.com/hashicorp/vagrant/issues/9368</a></p>
<h2 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a>Ref：</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.vagrantup.com/intro/getting-started/providers.html">多种类型虚拟机支持</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuyasen.com/post/vv_evn.html">使用vagrant和vitrualBox搭建虚拟开发环境</a></li>
<li><a target="_blank" rel="noopener" href="https://app.vagrantup.com/boxes/search?provider=hyperv">Box-Search: hyperv</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.lujun9972.win/blog/2018/07/29/vagrant%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html">Vagrant使用指南</a>: 插件、vagrant 代理、对应虚拟机代理</li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/579015868ac247005ffa76ad">windows 下 使用 vagrant 来管理 linux 虚机开发环境</a></li>
<li><a target="_blank" rel="noopener" href="https://superuser.com/questions/1354658/hyperv-static-ip-with-vagrant/1355010">HyperV - Static Ip with Vagrant</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hafiz/p/9175484.html">征服诱人的Vagrant！</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kancloud.cn/louis1986/vagrant">Vagrant学习文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.hedzr.com/2017/05/02/vagrant-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">VAGRANT 网络配置</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/xslwahaha/1438669">ifconfig命令和ip命令及route命令</a>： 配置公有网络设定 IP、掩码、网关</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Vagrent/" data-id="ckm733rtm0014ivvx175gb6we" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-并发学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-17T14:53:30.000Z" itemprop="datePublished">2020-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Java 并发学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>Java 代码首先会编译成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上进行执行。</p>
<p>Java中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。</p>
</blockquote>
<h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>(1) extends Thread</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p>(2) Runnable</p>
<p>(3) Callable</p>
<p>与 Runnable 相比，Callable 可以有返回值，且可以跑出异常，返回值通过 FutureTask 进行封装。</p>
<p>(4) ThreadPool</p>
<p><strong>继承与实现接口的比较</strong></p>
<p>优先实现接口</p>
<p>① Thread 只能够通过单继承来实现；</p>
<p>② Thread 创建开销大，Runnable 创建的开销小；</p>
<p>③ Runnable 实现解耦； 可以配合线程池使用</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="http://img.janhen.com/20201217224805image-20201217224803962.png" alt="image-20201217224803962" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING, </span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(1) 新建(NEW)</strong></p>
<p>创建后尚未启动。</p>
<p>当程序使用   new 关键字  创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。</p>
<p><strong>(2) 可运行(Runnable)</strong><br>可能正在运行，也可能正在等待 CPU 时间片。</p>
<p>包含了操作系统线程状态中的 Running 和 Ready。</p>
<p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<p><strong>(3) 阻塞(Blocked)</strong><br>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p>
<p>主要分为三种阻塞方式：</p>
<p>① 同步阻塞： </p>
<p>等待获取锁，获取同步锁时该同步锁被别的线程占用，JVM 将线程放入到锁池 (lock pool) 中。</p>
<p>② 等待阻塞</p>
<p>执行 o.wait() ，JVM会把该线程放入等待队列(waitting queue)中。</p>
<p>③ 其他阻塞</p>
<p>I/O 阻塞： 等待 I/O 操作完成；</p>
<p>执行 Thread.sleep() ；</p>
<p>执行 t.join() 方法；</p>
<p><strong>(4) 无限期等待(Waiting)</strong><br>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片；</p>
<p>都是交互性质的方法；</p>
<p>Object.wait()、Thread.join()、LockSupport.part() </p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<p><strong>(5) 限期等待(Timed Waiting)</strong></p>
<p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<p><strong>(6) 死亡(Terminated)</strong></p>
<p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><p><strong>(1) 正常终止</strong></p>
<p>运行结束，正常终止；</p>
<p><strong>(2) 退出标志</strong></p>
<p>定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false.在定义exit时，<strong>使用了一个Java关键字volatile，这个关键字的目的是使exit同步</strong>，也就是说在同一时刻只能由一个线程来修改exit的值。</p>
<p>volatile 无锁同步的应用场景之一；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;   <span class="comment">// volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3) Interrupt 方法结束</strong></p>
<p>①  阻塞下的结束</p>
<p>在线程处于阻塞状态下，调用 interrupt() 会抛出 InterrupteException，<u>一定要先捕获InterruptedException异常<strong>之后通过break来跳出循环，才能正常结束run方法</strong></u>。</p>
<p>死循环中的退出，只有在捕获后进行显示的 break 才能实现；</p>
<p>② 未阻塞下的结束</p>
<p>使用 isInterrupted() 判断线程的中断标志来退出循环。当使用 interrupt() 方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">// <span class="doctag">NOTE:</span> after catch exception must break to skip loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4) stop 方法终止</strong></p>
<p>程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后  <u>导致了该线程所持有的所有锁的突然释放(不可控制)</u>  ，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。</p>
<p><strong>(5) Callable 通过 Future.camcel 来进行终止</strong></p>
<h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<p><strong>(1) InterruptedException</strong></p>
<p>该线程<u>处于阻塞、限期等待或者无限期等待</u>状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>Thread.sleep()；</p>
<p>synchronized；</p>
<p>join()；</p>
<p><strong>(2) interrupted()</strong></p>
<p>无限循环不跳出，只有在该循环中执行 sleep() 等会抛出 InterruptedException 操作，</p>
<p>可通过其返回值来防止无线循环，作为一种退出标志；</p>
<p>调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<p><strong>(3) Executor 的中断操作</strong></p>
<p>① 关闭池子操作</p>
<p>shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>② 关闭指定的线程(Future)</p>
<p>只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>(1) join</p>
<p>进行线程之间的流程控制，进行线程通信的一种方式；</p>
<p>(2) yield()</p>
<p>让出当前 CPU，之后重新进行竞争；</p>
<p>(3) sleep()</p>
<p>不释放锁，在等待一定时间后自动唤醒；</p>
<p><strong>sleep() 与 wait() 的区别</strong></p>
<p>想到对应在阻塞队列中、以及延时双删策略中的场景；</p>
<p>① 设计|定义： sleep() 是 Thread 的静态方法，wait() 是 Object 的成员方法；</p>
<p>② 锁的占用： sleep() 导致程序暂停执行指定的时间，它的监控状态依然保持着，不释放锁， 而 wait() 释放对象锁，进入等待此对象的等待池中；</p>
<p>③ 使用范围： sleep() 可以用在任何地方， wait() 只能够用在同步控制方法或同步控制块中使用；</p>
<p>④ 唤醒方式： sleep() 给定时间内自动唤醒，wait() 需要调用 notify 显视唤醒；</p>
<p><strong>start() 与 run() 的区别</strong></p>
<ol>
<li>start() 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 </li>
<li> 通过调用 Thread 类的 start() 方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，直接运行。</li>
<li> 方法 run() 称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li>
</ol>
<h2 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h2><img src="http://img.janhen.com/20201217224608image-20201031111430904.png" alt="image-20201031111430904" style="zoom: 33%;" />

<p><strong>(1) 进程与线程的比较</strong></p>
<p>进程是 OS 资源分配的单位，有自己独立的寻址空间；</p>
<p>线程是 OS 独立运行的单元，其共享同一个进程内的所有数据；</p>
<p>线程相较于进程更加轻量；</p>
<p>⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的元空间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈。</p>
<p><strong>(2) 实现多线程的方式</strong></p>
<p>Java 中通过将每个线程映射为一个进程实现的；</p>
<p>线程的实现<br>3种模型:<br>内核线程；<br>用户线程；<br>两者结合。 </p>
<p><strong>(3) 守护线程</strong></p>
<p>是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种。</p>
<p>① 停止执行情况</p>
<p>专门用于服务其他的线程，如果其他的线程(即用户自定义线程)都执行完毕，连main线程也执行完毕，那么jvm就会退出(即停止运行)——此时，连jvm都停止运行了，守护线程当然也就停止执行了。</p>
<p>② 优先级</p>
<p>优先级较低</p>
<p>③ 设置</p>
<ul>
<li><p>通过 setDaemon(true) 在 Thread 未 start() 之前显视设置</p>
</li>
<li><p>Daemon 线程产生的新线程也是 Daemon 的</p>
</li>
</ul>
<p>④ 性质</p>
<p>为 JVM 级别的线程，<u>即使你停止了Web应用，这个线程依旧是活跃的</u>。</p>
<p><strong>(4) 线程派生的联系</strong></p>
<p>继承对应的优先级、daemon等属性；</p>
<p>(5) 并发和并行</p>
<p>并发： 同⼀时间段，多个任务都在执⾏ (单位时间内不⼀定同时执⾏)； </p>
<p>并⾏： 单位时间内，多个任务同时执⾏。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>while 循环监测</p>
<p>线程B是一直执行着while(true) 循环的，直到长度为5才终止执行，显然这种方式是很消耗资源的。所以，就需要一种机制能避免上述的操作又能实现多个线程之间的通信，这就是接下来需要学习的“wait/notify线程间通信”。</p>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p><strong>(1) 进程间的通信方式</strong></p>
<p>① 管道(pipe)、有名管道(named pipe)</p>
<p>② 信号量(semophore)</p>
<p>③ 消息队列(message queue)</p>
<p>④ 信号(signal)</p>
<p>⑤ 共享内存(shared memory)</p>
<p>⑥ 套接字(socket)</p>
<p><strong>(2) 线程间的通信方式</strong></p>
<p>1、锁机制：<br>  1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。<br>  1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。<br>  1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。<br>对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br>2、信号量机制：包括无名线程信号量与有名线程信号量<br>3、信号机制：类似于进程间的信号处理。<br>线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的<br>通信机制。</p>
<h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><blockquote>
<p> Object.wait, notify 机制，需要配合 synchronized 一起使用</p>
</blockquote>
<p>1、wait()/notify 方法</p>
<p>(1)wait() 和 notify() 方法要在同步块或同步方法中(synchronized 关键字) 调用，即在调用前，线程也必须获得该对象的对象级别锁。<br>(2)wait方法是释放锁，notify方法是不释放锁的；<br>(3)notify 每次唤醒 wait 等待状态的线程都是随机的，且每次只唤醒一个；<br>(4)notifAll 每次唤醒 wait 等待状态的线程使之重新竞争获取对象锁，优先级最高的那个线程会最先执行；<br>(5)当线程处于 wait() 状态时，调用线程对象的 interrupt() 方法会出现 InterruptedException 异常；</p>
<p><strong>通过 等待通知模式实现阻塞队列</strong></p>
<p>(1) 结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">5</span>;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();      <span class="comment">// use for thread communication</span></span><br></pre></td></tr></table></figure>

<p>(2) 入队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object task)</span> </span>&#123;</span><br><span class="line">    synchronzied(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(task);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        lock.notify();         <span class="comment">// not empty conditon</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 出队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obejct oldFront = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait()；</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        oldFront = queue.poll();</span><br><span class="line">        count.getAndDecrment();</span><br><span class="line">        lock.notify();       <span class="comment">// not full condition</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>应用</strong></p>
<p>(1) MyBatis 中</p>
<p>在数据库连接这个地方使用<br>到的：<br>org.apache.ibatis.datasource.pooled.PooledDataSource 类中，所以不用花<br>太多的时间去深究。<br>1、获取连接的时候，如果数据库连接池没有空闲的连接，那么当前线程就会进入等<br>待，直到被通知，这个地方就是popConnection()方法</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="*ThreadLocal"></a>*ThreadLocal</h2><blockquote>
<p>实现每⼀个线程都有⾃⼰的专属本地变量。</p>
<p>如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。</p>
</blockquote>
<p>如果使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本，  副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p>(1)概述</p>
<p>原理： 为每个使用该变量的线程都提供独立的变量副本，从而不会影响到其他线程所对应的副本。</p>
<p>是一种<u>多线程间并发访问变量的解决方案</u>，不使用锁来保证并发访问，本质是以空间换时间的方式，为每个线程提供变量的独立副本，以保证线程的安全。</p>
<p>(2) 作用</p>
<p>ThreadLocal 的作用是<font color="green">提供线程内的局部变量</font> ，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p>
<p><strong>底层结构</strong></p>
<img src="http://img.janhen.com/20201217224620394b8da0-ba21-11e8-87f1-559c9b456754.jpg" alt="img" style="zoom:67%;" />

<p>一个Thread中只有一个ThreadLocalMap，</p>
<p>一个ThreadLocalMap中可以有多个ThreadLocal对象，</p>
<p>其中一个ThreadLocal对象对应一个ThreadLocalMap中一个的Entry实体</p>
<p>(也就是说：一个Thread可以依附有多个ThreadLocal对象)。</p>
<p>(1) Thread 中持有的结构</p>
<p><u>线程局部变量</u>  ，那么理所当然就应该存储在自己的线程对象中</p>
<p>线程局部变量存储在 Thread 对象的 threadLocals 属性中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) ThreadLocal.ThreadLocalMap</p>
<p>是实现 ThreadLocal 的原理，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p>
<p>KEY: 线程对象；</p>
<p>VALUE: 对应线程的变量副本；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>一些操作</strong></p>
<p>(1) ThreadLocal 4 大 public 方法</p>
<p>根据当前线程获取到对应的 ThreadLocalMap，借助该 Map 操作实现；</p>
<p>get()、 set()、 remove()、 withInitial()。</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上， ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与同步机制的比较</strong></p>
<pre><code>    a.ThreadLocal与同步机制都是为了 &lt;u&gt;解决多线程中相同变量的访问冲突问题&lt;/u&gt;。 

    b.前者采用以&quot;空间换时间&quot;的方法，后者采用以&quot;时间换空间&quot;的方式 </code></pre>
<p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal<br>采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后<br>者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<p><strong>Thread 造成的内存溢出问题</strong></p>
<p>(1) 与线程池协作引发的内存溢出问题</p>
<p><u>ThreadLocal变量是维护在Thread内部的</u>，线程不退出，对象的引用就会一直存在。</p>
<p>当我们使用线程池的时候，就意味着当前线程未必会退出(比如<u>固定大小的线程池，线程总是存在的</u>)。如果这样的话，将一些很大的对象设置到ThreadLocal中(这个很大的对象实际保存在Thread的threadLocals属性中)，这样的话就可能会出现内存溢出的情况。</p>
<p>一种场景就是说如果使用了线程池并且设置了固定的线程，处理一次业务的时候存放到ThreadLocalMap中一个大对象，处理另一个业务的时候，又一个线程存放到ThreadLocalMap中一个大对象，但是这个线程由于是线程池创建的他会一直存在，不会被销毁，这样的话，以前执行业务的时候存放到ThreadLocalMap中的对象可能不会被再次使用，但是由于线程不会被关闭，因此无法释放Thread 中的ThreadLocalMap对象，造成内存溢出。</p>
<p>也就是说，ThreadLocal在没有线程池使用的情况下，正常情况下不会存在内存泄露，但是如果使用了线程池的话，就依赖于线程池的实现，如果线程池不销毁线程的话，那么就会存在内存泄露。所以我们在使用线程池的时候，使用ThreadLocal要格外小心！</p>
<p>(2) 原因</p>
<p>ThreadLocal内存泄漏的根源是：由于  <u>ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏</u>  ，而不是因为弱引用。</p>
<p><strong>弱引用与内存泄漏</strong></p>
<p>弱引用被回收了只是回收了Entry的key引用，但是Entry应该还是存在的吧？</p>
<p>ThreadLocal的get(),set(),remove() 的时候都会清除线程ThreadLocalMap里所有key为null的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123; <span class="comment">/** The value associated with this ThreadLocal. */</span> </span><br><span class="line">  Object value;</span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; </span><br><span class="line">    <span class="keyword">super</span>(k); </span><br><span class="line">    value = v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就需要重新认识一下，什么是：<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>，这里的重点是：<strong>只被弱引用关联的对象</strong></p>
<p>上述过程尽管 GC 执行了垃圾收集，但是弱引用还是可以访问到结果的，也就是没有被回收，这是因为除了一个弱引用 userWeakReference 指向了User实例对象，还有 user 指向 User 的实例对象，只有当user和User实例对象的引用断了的时候，弱引用的对象才会被真正的回收</p>
<p>并不是所有弱引用的对象都会在第二次GC回收的时候被回收，而是  <u>回收掉只被弱引用关联的对象</u> 。因此，使用弱引用的时候要注意到！希望以后在面试的时候，不要上来张口就说，弱引用在第二次执行GC之后就会被回收！</p>
<p><strong>应用场景</strong></p>
<p>(1) 解决数据库连接</p>
<p>避免方法中总是出现 Connection 参数，每个线程每次使用的都是用一个  Connection；</p>
<p>(2) MyBatis 中用于 Session 管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">    Session s = (Session) threadSession.get(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">    &#125; <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="线程池"><a href="#线程池" class="headerlink" title="*线程池"></a>*线程池</h1><p>(1) new Thread 弊端：</p>
<ul>
<li><p>每次<code>new Thread</code>新建对象，Thread 为大对象，性能差 ；</p>
</li>
<li><p>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或 OOM；</p>
</li>
<li><p>缺少更多功能，如更多执行、定期执行、线程中断；</p>
</li>
</ul>
<p>(2) 线程池好处</p>
<p>重用性： 重用存在的线程，减少对象创建、消亡的开销，性能佳 ；</p>
<p>可控性： 可有效控制最大井发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞 ；</p>
<p>功能性： 提供定时执行、定期执行、单线程、井发数控制等功能；</p>
<p><strong>线程池参数</strong></p>
<ul>
<li>corePoolSize: &lt;= x</li>
<li>maximumPoolSize: 最大线程数</li>
<li>workQueue: 工作队列，为BlockingQueue</li>
<li>threadFactory: 默认非守护，同优先级，名称</li>
<li>rejectHandler:  BlockingQueue 满，无空闲的线程池，拒绝cel，默认直接抛出 exception</li>
<li>keepAliveTime，unit: corePoolSize  –&gt;&gt; maximumPoolSize </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>四种拒绝策略： ThreadPoolExecutor 类中提供</p>
<ul>
<li><p>AbortPolicythrows exception</p>
</li>
<li><p>DiscardPolicy： 直接丢弃</p>
</li>
<li><p>CallerRunPolicy： 使用调用者 thread 执行</p>
</li>
<li><p>DiscardOldestPolicy： 丢弃 BlockingQueue 中最靠前的 task，执行当前 task</p>
</li>
</ul>
<p><strong>方法</strong></p>
<p>(1) 主要方法</p>
<p>生命周期及 ExecutorService：</p>
<p>- execute()</p>
<p>- submit(): execute + Future</p>
<p>- shutdown() : handle BlockingQueue in </p>
<p>- shutdownNow() : BlockingQueue not handler</p>
<p>(2) 监控方法：</p>
<ul>
<li>getTaskCount()：线程池已执行和未执行的任务总数 </li>
<li>getCompIetedTaskCount()：已完成的任务数量 </li>
<li>getPoolSize()：线程池当前的线程数量</li>
<li>getActiveCount()：当前线程池中正在执行任务的线程数量</li>
</ul>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>① Executors.newCachedThreadPool </p>
<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<strong>调用 execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程</strong>。因此，长时间保持空闲的线程池不会使用任何资源。</p>
<p>② Executors.newFixedThreadPool</p>
<p><strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</strong>。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务(如果需要)。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<p>③ Executors.newSingleThreadExecutor</p>
<p>Executors.newSingleThreadExecutor()返回一个线程池(这个线程池只有一个线程)<strong>,这个线程池可以在线程死后(或发生异常时)重新启动一个线程来替代原来的线程继续执行下去</strong>！</p>
<p>④ Executors.newScheduIedThreadPool </p>
<p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="number">3</span>); scheduledThreadPool.schedule(newRunnable()&#123; <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;延迟三秒&quot;</span>); &#125; &#125;, <span class="number">3</span>, TimeUnit.SECONDS); scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123; <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;延迟1秒后每三秒执行一次&quot;</span>); &#125; &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>⑤ <strong>线程池配置</strong></p>
<p>CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU + 1IO 密集型任务，参考值可以设置为 2 * NCPU；</p>
<p>选用基础：</p>
<p>- 小型应用不适合</p>
<p>- 线程调度时间开销大</p>
<p>@@计算密集型与IO密集型</p>
<p>密集型：  CPU 核 + 1<br>IO 密集： CPU 核数 / (1-阻塞系数)   一般0。8~0.9</p>
<p>@@如何正确的使用线程池</p>
<p>设置线程池，比设置界限；</p>
<p>hook 机制嵌入行为，由 beforeMethod, afterMethod 记录线程执行前和后做日志，异常结果；</p>
<p>优雅的关闭，hook 机制，推荐使用 JavaBean 创建线程池，在 destoryMethod 里面在销毁时调用 shutdown；</p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>(1) 概述</p>
<p>Java 并发采用的是共享内存模型，线程之间的通信总是隐式执行。</p>
<p>定义： Java 线程之间的通信由 JMM 控制， <u>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</u>。</p>
<p>Java内存模型(JMM)解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”</p>
<ol>
<li><p>主内存与工作内存<br> 主内存副本拷贝，非对整个obj拷贝。<br> Java借助共享内存实现线程间的通信</p>
</li>
<li><p>内存间的交互操作<br> 8中操作, 主内存，保证原子性；<br> 对于long和double的特殊规则(了)<br> 64位</p>
</li>
<li><p>对于volatile变量的特殊规则<br> 语义：</p>
</li>
</ol>
<ul>
<li>可见性, 实现对于其修改立即写回主内存中, 非保证原子性;</li>
<li>有序性, 禁止指令重排序, 是一种同步机制, 轻量, 与DCL实现安全的单例.  </li>
</ul>
<ol start="4">
<li>原子性、可见性与有序性<br>volatile：<br>finale: this 引用逃逸(读初始化一般的data)；<br>synchronized: “万能”, 重量, 阻塞</li>
</ol>
<p>硬件的效率与一致性:<br>缓存一致性协议</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="*volatile"></a>*volatile</h3><img src="http://img.janhen.com/20201217224645image-20201031124307603.png" alt="image-20201031124307603"  />

<p>能够在线程之间保持可见性，能够被 <strong>多线程同时读</strong>，并且保证不会读到过期的值，但 <strong>只能被单线程写</strong>。<br>基于 happens-before 原则，对 volatile 字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile 变量。</p>
<p>volatile是轻量级的synchronized，他的意思是：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度</p>
<p>(1) 特性</p>
<p>a.volatile关键字为域变量的访问提供了一种免锁机制， </p>
<p>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， </p>
<p>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 </p>
<p>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 </p>
<p><strong>volatile 保证可见性</strong></p>
<p>有volatile变量修饰的共享变量进行写操作的时候会引发了两件事情：<br>(1)将当前处理器缓存行的数据写回到系统内存；<br>(2)这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效；</p>
<p>底层实现细节(了)：</p>
<p>① 发生 volatile  W， JVM 向处理器发送 Lock 前缀的汇编命令，将该变量缓存行写到系统内存；</p>
<p>② 为了保证写回到的数据被其他线程立即可见，借助  缓存一致性协议  实现，每个处理器 嗅探总线 上传播的数据检查自己是否过期，过期强制从系统内存中把数据读到处理器缓存中。</p>
<p><img src="http://img.janhen.com/202012172246521553822343527.png" alt="1553822343527"></p>
<p><strong>volatile 如何禁止指令重排序</strong> </p>
<p>借助内存屏障和禁止指令重排实现</p>
<ul>
<li>对 volatile 变量写操作时，会在<strong>写操作之后</strong>加上一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；</li>
<li>对 volatile 变量的读操作，会在<strong>读操作之前</strong>加上一条 load 屏障指令，从主内存中读取共享变量。</li>
</ul>
<p>使用volatile关键字修饰共享变量可以禁止重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序<br>volatile禁止指令重排序的一些规则：<br>　　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序</p>
<p>　　2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序</p>
<p>　　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</p>
<p>涉及到内存屏障(Memory Barrier)，它是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p>
<p><strong>一些应用</strong></p>
<ul>
<li><p>无锁读取数据： ConcurrencyHashMap 的 get 操作，通过 volatile 替换锁，AQS 中 state 变量；</p>
</li>
<li><p>作为终止标识，exit 来进行终止，类似 interrupt 终止；</p>
</li>
<li><p>那么在禁止重排序时是一个较好的使用场景，否则我们不需要再使用它，如 DCL 中通过 volatile 修饰；</p>
</li>
<li><p>热部署的变量： 通过线程修改之后立即被其他线程可见；</p>
</li>
</ul>
<p>适用场景： </p>
<p>(1) 对变量的写操作不依赖于当前值(比如 i++)，或者说是单纯的变量赋值(boolean flag = true)。 </p>
<p>(2)该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>字解决的是多个线程之间访问资源的同步性。</p>
<p>(1) 一些性质：</p>
<ul>
<li>提供原子性，实现同步功能；</li>
<li>是 JVM 提供的同步工具，使用 lock 和 unlock 字节码指令，保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏；</li>
<li>与 CAS 比较： 相比于 CAS 可以保证 <strong>一块</strong> 而非一个变量的原子性；</li>
<li>与 Lock 比较： 相比于 JDK Lock 可以保存 <strong>程序运行信息</strong> ，便于解决死锁和异常；</li>
</ul>
<p>(2) 使用的位置：</p>
<ul>
<li>code bloker： 显视锁住当前调用对象  synchronized(this)，通过监视器锁实现；</li>
<li>method: 锁住调用对象，通过访问标识位实现；</li>
<li>static method: 锁住该类的所有对象；</li>
<li>class: 显视锁住类对象 synchronized(xxx.class)；</li>
</ul>
<p>适用同一个对象调用锁住 obj 的可以实现同步，使其中的一个线程阻塞等待另一个线程执行完毕；不同对象调用时不适用；</p>
<p><strong>synchronized 保证可见性原理</strong></p>
<p>通过 javap -v xxx.class 获取字节码指令分析</p>
<p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>JMM 对 synchronized 的规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存；</li>
<li>线程加锁时，将<em>清空工作内存</em> 中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值(注意，<code>加锁与解锁是同一把锁</code>)；</li>
</ul>
<p>本质是对一个对象的监视器(monitor) 进行获取，而这个获取过程是排他的，也就是说同一时刻只有一个线程<br>获取到由 synchronized 所保护对象的监视器。</p>
<p><strong>(1) 对代码块同步</strong></p>
<p>monitorenter 和 monitorexit 指令</p>
<p>Synchronized 每个对象有一个  <u>内置的监视器锁(monitor)</u>  。当 monitor 被占用时就会处于锁定状态，线程执行monitorenter 指令时尝试获取monitor的所有权，过程如下：<br>1、如果 monitor 的进入数为0，则该线程进入 monitor，然后将进入数设置为1，该线程即<br>为 monitor 的所有者。<br>2、如果线程己经占有该 monitor，只是重新进入，则进入monitor 的进入数加1．<br>3．如果其他线程巳经占用了 monitor ,则该线程进入阻塞状态，直到 monitor 的进入数为0，再重新尝试获取monitor的所有权。</p>
<p><strong>(2) 同步方法</strong></p>
<p>调用指令将会检查方法的 <code>ACC_SYNCHRONIZED</code> 访问标志是否被设置，如果设置了，  <u>执行线程将先获取 monitor，获取成功之后才能执行方法体</u>  ，方法执行完后再释放 monitor Synchronize和lock都属于同步阻塞。 </p>
<p><strong>synchronized 其他性质</strong></p>
<p>(1) 作为锁</p>
<p>见下部分锁相关</p>
<p>(2) 原子性</p>
<p>@Q: CAS 机制与 synchronized 保证原子性的区别？</p>
<p>① CAS 仅能够保证一个变量的原子性，而 synchronized 可用于方法、类、字段等多处；</p>
<p>② CAS 通过不断循环重试实现，存在不必要的开销，但是是一种无锁的实现；</p>
<p>③ CAS 存在 ABA 问题；</p>
<p>Q: JDK1.6+ 的 synchronized 关键字做了哪些优化?</p>
<p>对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗 化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：⽆锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈⽽逐渐升级。锁可以升级不可降级，提⾼获得锁和释放锁的效率。</p>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p><strong>原子性</strong></p>
<p>提供了互斥访问，同一时刻只能有一个线程对它进行操作。</p>
<p>(1) 实现方式：</p>
<ul>
<li>锁的同步机制：  synchronized | Lock</li>
<li>CAS 机制： 包括 AtomicInteger 等原子类</li>
</ul>
<p><strong>可见性</strong> </p>
<p>一个线程对主内存中共享变量的修改，能够及时地被其他线程观察到。</p>
<p>(1) 不可见的原因： </p>
<ul>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主存间及时更新</li>
</ul>
<p>(2) 实现方式</p>
<p>volatile 关键字可以保证共享变量的可⻅性。</p>
<p><strong>有序性：</strong> </p>
<p>代码在执⾏的过程中的先后顺序。</p>
<ul>
<li>Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性，导致代码的执⾏顺 序未必就是编写代码时候的顺序。</li>
<li>volatile、synchronized、Lock</li>
</ul>
<h2 id="happen-before-原则"><a href="#happen-before-原则" class="headerlink" title="*happen-before 原则"></a>*happen-before 原则</h2><ol>
<li>单一线程原则</li>
</ol>
<blockquote>
<p>Single Thread Rule</p>
</blockquote>
<p>一个线程内，程序前面的操作先于后面的操作。也叫程序次序原则。</p>
<ol start="2">
<li>管程锁定原则</li>
</ol>
<blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock option 先于后面同一个锁的 lock option。</p>
<ol start="3">
<li>volatile 变量规则</li>
</ol>
<blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先于后面对这个变量的读操作。</p>
<ol start="4">
<li>传递性原则</li>
</ol>
<blockquote>
<p>Transitivity</p>
</blockquote>
<p>A –&gt; B, B –&gt; C  ==&gt;&gt; A –&gt; C</p>
<ol start="5">
<li>线程启动规则</li>
</ol>
<blockquote>
<p>Thread Start Rule丶。 入</p>
</blockquote>
<p>Thread 对象的 start() 先于此线程的每一个动作</p>
<ol start="6">
<li>线程中断规则</li>
</ol>
<blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 的调用先于被中断线程的代码检测到中断事件的发生，即 isInterrupt().</p>
<ol start="7">
<li>线程加入规则</li>
</ol>
<blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先于 join() 方法返回</p>
<ol start="8">
<li>对象终结规则</li>
</ol>
<blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成(构造函数结束)先于它的 finalize() 方法的开始</p>
<h2 id="线程同步的实现"><a href="#线程同步的实现" class="headerlink" title="线程同步的实现"></a>线程同步的实现</h2><p>说明： 需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<p><strong>1、 互斥同步</strong> </p>
<p>(1) 同步方法 、同步代码块 </p>
<p>(2) 使用重入锁实现线程同步</p>
<p>(3) 使用阻塞队列实现线程同步</p>
<p><strong>2、 非阻塞同步</strong></p>
<p>主要是 CAS 不断尝试实现</p>
<p>(1) 使用原子变量实现线程同步</p>
<p><strong>3、 无同步方案</strong></p>
<p>(1) 使用局部变量实现线程同步<br>    如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p>(2) 使用特殊域变量(volatile)实现线程同步</p>
<p> 注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 </p>
<h1 id="锁与锁优化"><a href="#锁与锁优化" class="headerlink" title="锁与锁优化"></a>锁与锁优化</h1><p><strong>线程安全</strong></p>
<ol>
<li>Java语言中的线程安全<br>绝对线程安全<br>相对线程安全<br>线程兼容<br>线程对立</li>
</ol>
<p><strong>2. 线程安全的实现方法</strong><br><em>1)同步互斥</em><br><strong>Synchronized：</strong>存在挂起、恢复，是<em><u>阻塞</u></em>  实现的，且java线程直接映射到OS原生线程上的，存在用户态到内核态的_<u>转换</u>_，因而性能较差。</p>
<p><strong>Lock：</strong>可重用锁</p>
<p>2)非阻塞<br>基于CAS+Loop实现</p>
<p>3)无同步</p>
<ul>
<li>可重入代码</li>
<li>TLC，线程本地， 是消息队列架构模式</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><strong>乐观锁</strong></p>
<p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是  <u>在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</u>  (比较跟上一次的版本号，如果一样则更新)，如果失败则要重复读-比较-写的操作。 java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，  <u>  比较当前值跟传入值是否一样，一样则更新，否则失败</u>。</p>
<p><strong>悲观锁</strong></p>
<p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是  <u>Synchronized</u>,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>
<h2 id="JVM-锁优化"><a href="#JVM-锁优化" class="headerlink" title="JVM 锁优化"></a>JVM 锁优化</h2><p>锁有四种状态，无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>通过 对象头实现</p>
<p>(1) 原理：</p>
<p>基于对象头的Mark Word， 23位表示偏向的线程ID</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁的目的是在某个线程获得锁之后，<u>消除这个线程锁重入(CAS)的开销</u>，看起来让这个线程得到了偏护</p>
<p>而偏向锁只需要在置换 ThreadID 的时候依赖一次CAS原子指令</p>
<p><strong>如果一个线程获得了锁，那么锁就进入了偏向模式。当这个线程再次请求锁时，无需再做任何同步操作</strong></p>
<p>(1) 设计原因</p>
<p>为什么会出现这种设计的方式那？这是因为根据HotSpot的作者研究，他发现  <u>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</u>  ，为了让线程获得锁的代价更低而引入了的偏向锁这个概念。</p>
<p>(2) 锁的升级</p>
<p>在锁竞争比较激烈的场景，最有可能的情况是每次不同的线程来请求相同的锁，这样的话偏向锁就会失效，倒不如不开启这种模式，幸运的是Java虚拟机提供了参数可以让我们有选择的设置是否开启偏向锁。<br>如果偏向锁失败，虚拟机并不会立即挂起线程，而是使用轻量级锁进行操作。</p>
<p>(3) 性质：</p>
<p>线程获取到锁之后，消除这个线程的重入开销；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking</span><br></pre></td></tr></table></figure>





<p><strong>轻量级锁</strong></p>
<p>轻量级锁是为了<u>在线程交替执行同步块时提高性能</u>，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<p>如果偏向锁失败，虚拟机并不会立即挂起线程，而是使用轻量级锁进行操作。轻<u>量级锁他只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。</u>  如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先夺到锁，那么当前线程的轻量级锁就会膨胀为重<br>量级锁。</p>
<p>轻量级锁所适应的场景是 <u>线程交替执行同步块</u> 的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p>(1) 说明：</p>
<p>嵌入在线程栈中的对象<br>使用 Displaced Mark Word 复制对象头到堆栈中，借助CAS实现同步。<br>还是需要进行 CAS , 出现竞争时，会尝试自旋</p>
<p>(2) 原理：</p>
<p>绝大部分锁在整个同步周期内都是不存在竞争的</p>
<p><strong>自旋锁(无锁)</strong></p>
<p>(1) 原理</p>
<p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>(2) 优缺点</p>
<p>(3) 时间阈值</p>
<p>在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是  <u>由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</u>，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p>(4) 一些实现</p>
<p>在通过一定的自旋失败后，通常转化为加悲观锁实现，如 ConcurrentHashMap 中对于 put 在尝试 3 次失败后进行转换成对链表头进行加锁；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSpinning</span><br></pre></td></tr></table></figure>



<p><strong>自适应锁</strong><br>原来默认是10，现在可以实现自适应自旋</p>
<p>自适应，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p>如ConcurrentHashMap的tryLock()</p>
<blockquote>
<p>-XX:+UseSpinning      1.7默认开启<br>-XX:PreBlockSpin     默认为10，代表</p>
</blockquote>
<p><strong>锁消除</strong><br>不存在共享数据竞争，需要对其进行<code>逃逸分析</code>，从而减少不必要的锁。</p>
<p><strong>锁粗化</strong><br>防止在循环中加锁，进行资源的浪费</p>
<p><strong>锁的对比</strong></p>
<h2 id="程序锁优化"><a href="#程序锁优化" class="headerlink" title="程序锁优化"></a>程序锁优化</h2><p><strong>1.减少锁粒度</strong></p>
<p>将大对象(这个对象可能会被很多线程访问)，拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。</p>
<p>() 应用</p>
<p>① 最最典型的减小锁粒度的案例就是ConcurrentHashMap。进而提高并发程度<br>如将 HashMap –&gt; ConcurrentHashMap使用Segment(16)增加并行度。</p>
<p><strong>2. 减少锁持有时间</strong></p>
<p>只用在有线程安全要求的程序上加锁</p>
<p>只在有必要的时候进行同步，这样就明显减少了线程持有锁的时间，从而<br>提高系统的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method1();                             <span class="comment">// cost much time</span></span><br><span class="line">    mutextMethod();   <span class="comment">// 实际需要进行同步的方法</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 锁分离</strong><br>如根据功能进行锁分离<br>(1) 应用</p>
<p>① ReadWriteLock，即保证了线程安全，又提高了性能。</p>
<p>在读多写少的情况下，通过 ReentrantReadWriteLock 替换 ReentrantLock，实现对于 Read 的不加锁实现；</p>
<p>② 读写分离思想可以延伸，  <u>只要操作互不影响，锁就可以分离</u>  。比如LinkedBlockingQueue 从头部取出，从尾部放数据。</p>
<p>如果使用独占锁的话，则要求两个操作在进行时首先要获取当前队列的锁，那么take<br>和put就不是先真正的并发了，因此，在JDK中正是实现了两种不同的锁，一个<br>是takeLock一个是putLock。</p>
<p><strong>4. 锁粗化</strong><br>不在循环中加锁，来回加和释放的开销大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第一次加锁</span></span><br><span class="line">    	method1();</span><br><span class="line">    &#125;</span><br><span class="line">    method3();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第二次加锁</span></span><br><span class="line">    	mutextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    method4();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第三次加锁</span></span><br><span class="line">    	method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第一次和第二次加锁和线程上下文切换的时间超过了method1()、method2()method3()、method4() 的时间.</p>
<p>改进后的代码的执行时间可能小于上述分别加锁的时间，这就是锁粗化，也是一种锁<br>优化的方式，但是要根据具体的场景；</p>
<p><strong>5. 锁消除</strong></p>
<p>锁消除是在  <u>编译器级别的事情</u>。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。</p>
<p>引发原因：</p>
<p>① 多数是因为程序员编码不规范引起。</p>
<p>② 有时这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector<br>和StringBuffer 这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线<br>程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性<br>能。</p>
<p>**6. JVM 锁优化(volatile, synchronized) **</p>
<p>见上部分</p>
<h2 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="*synchronized"></a>*synchronized</h2><p>(1) 作用范围</p>
<p>(2) 核心组件</p>
<ol>
<li><p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； </p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<p>() 底层实现</p>
<p><img src="http://img.janhen.com/202012172247111553496683656.png" alt="1553496683656"></p>
<p>是非公平锁，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList；</p>
<p>每个对象后有个 monitor 对象， <u>加锁就是在竞争 monitor 对象</u> ， 代码块加锁是在前后分别加上monitorenter和monitorexit指令来实现的，方法加锁是通过一个标记位来判断的。</p>
<p><strong>与 ReentrantLock 对比</strong></p>
<p>相同点： 都是可重入锁。</p>
<p>① 底层实现：ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的，为关键字，能够在出现异常时打印出对应的错误堆栈用于分析问题，同时 JVM 对 synchronized 提供了锁升级的优化；</p>
<p>② 锁的实现方式： ReentrantLock 是同步非阻塞，采用的是乐观并发策略，而 synchronized 是同步阻塞，使用的是悲观并发策略。</p>
<p>③ 锁的使用的安全性： ReentrantLock 需要显视加锁解锁，可能因为忘记解锁而陷入死锁，而 synchronized 为隐式加锁，不会因为忘记解锁而陷入死锁。</p>
<p>④ 功能灵活性：</p>
<ul>
<li>ReentrantLock 可尝试获取锁；</li>
<li>RentrantLock 可中断获取锁，提供了⼀种能够中断等待锁的线程的机制，<code>lock.lockInterruptibly()</code> ；</li>
<li>RentrantLock 能够支持公平锁, synchronized 只能实现非公平锁；</li>
<li>RentrantLock 可实现选择性通知： synchronizedf 使用 notify / notifyAll 进行通知时，通知的线程由 JVM 选择，ReentrantLock 更加灵活的绑定多个 Condition, 进行选择性通知。</li>
</ul>
<p>1 ReentrantLock显示的获得、释放锁，synchronized隐式获得释放锁<br>2 ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>3 ReentrantLock是API级别的，synchronized是JVM级别的<br>4 ReentrantLock可以实现公平锁<br>5 ReentrantLock通过Condition可以绑定多个条件<br>6 底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略<br>7 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。<br>8 synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。<br>9 Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。<br>10 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>11 Lock可以提高多个线程进行读操作的效率，既就是实现读写锁等。</p>
<p><strong>synchronized 与volatile 的比较</strong></p>
<p>① 实现与性能：volatile关键字是线程同步的 <u>轻量级</u>实现，所以 <font color="green">volatile性能肯定⽐synchronized关键字要好</font>。 但是 <font color="green">volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块</font>。 synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗 ⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤ synchronized 关键字的场景还是更多⼀些。</p>
<p>② 阻塞： 多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞</p>
<p>③ 三特性的： volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。synchronized关键字两者都能 保证。</p>
<p>④ 使用场景： volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是 多个线程之间访问资源的同步性。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<p>(1) 死锁的四个必要条件：</p>
<ul>
<li><p>互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。</p>
</li>
<li><p>持有和等待条件： ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不可剥夺条件：线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后 才释放资源。</p>
</li>
<li><p>循环等待条件：:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</p>
</li>
</ul>
<p>(2) 避免线程死锁</p>
<p>① 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p>② 破坏请求与保持条件 ：⼀次性申请所有的资源。</p>
<p>③ 破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p>④ 破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。</p>
<p><strong>相关问题</strong></p>
<p>(1) 如何确保N个线程可以访问N个资源同时又不导致死锁？</p>
<p>① 指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了；</p>
<p>② 使用带有超时时间的锁；</p>
<p>③ 通过死锁的检测和恢复机制进行规避；</p>
<p>(2) 写一个发生死锁的程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock1</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;flag1 one level&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;flag 1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;flag2 one level&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;flag 2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock1(<span class="number">1</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock1(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><p><strong>无锁</strong></p>
<p>CAS算法的过程是这样：<u>它包含三个参数CAS(V,E,N): V表示要更新的变量，E</u><br><u>表示预期值，N表示新值。仅当V值等于E值时</u>，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。</p>
<p><strong>可重入锁(递归锁)</strong></p>
<p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</p>
<p>偏向锁对于偏向的线程没有重入的开销。</p>
<p><strong>公平锁和非公平锁</strong></p>
<p>公平锁(Fair)</p>
<p> 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。</p>
<p>非公平锁(Nonfair) </p>
<p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</p>
<ol>
<li>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列 </li>
<li> Java中的synchronized是非公平锁，ReentrantLock 默认的lock()方法采用的是非公平锁。</li>
</ol>
<p><strong>读写锁</strong></p>
<blockquote>
<p>读读不互斥，读写互斥，写写互斥</p>
</blockquote>
<p>为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 </p>
<p>(1) 读锁 </p>
<p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p>
<p>(2) 写锁 </p>
<p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock。</p>
<p><strong>共享锁和独占锁</strong></p>
<p>java并发包提供的加锁模式分为独占锁和共享锁。 </p>
<p>(1) 独占锁</p>
<p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p>(2) 共享锁</p>
<p> 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p>
<ol>
<li>AQS的内部类Node定义了两个常量 SHARED 和 EXCLUSIVE ，他们分别标识 AQS队列中等待线程的锁获取模式。 </li>
<li> java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</li>
</ol>
<p><strong>重量级锁(Mutex Lock)</strong> </p>
<p>Synchronized是通过对象内部的一个叫做监视器锁(monitor)来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p>
<p>因此，这种  <u>依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”</u>。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<p><strong>分段锁</strong></p>
<p>是一种思想ConcurrentHashMap是学习分段锁的最好实践</p>
<p><strong>活锁</strong></p>
<p>因为活跃性而引入的问题</p>
<h1 id="并发中的设计模式"><a href="#并发中的设计模式" class="headerlink" title="并发中的设计模式"></a>并发中的设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证全局唯一，并发情况下使用安全</p>
<p>见设计模式单例</p>
<p>7 种单例模式：</p>
<p>饿汉式；</p>
<p>双重监测懒汉式；</p>
<p>线程安全懒汉式；</p>
<p>静态内部类持有懒汉式；</p>
<p>枚举式；</p>
<p>变种的饿汉式；</p>
<p>变种的懒汉式；</p>
<h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>Future模式的核心思想：异步调用</p>
<p>不仅可以在子线程完成后收集其结果，还可以设定子线程的超时时间，避免主任务一直等待。</p>
<p>() 性质<br>Future模式不会立即返回你需要的数据，但是，他会返回一个契约 ，以后在使用到数据的时候就可以通过这个契约获取到需要的数据。</p>
<p>在广义的Future模式中，虽然获取数据是一个耗时的操作，但是服务程序不等数据完成就立即返回客户端一个伪造的数据(就是上述说<br>的“契约”)，实现了Future模式的客户端并不急于对其进行处理，而是先去处理其他业<br>务，充分利用了等待的时间，这也是Future模式的核心所在，在完成了其他数据无关的任务之后，最后在使用返回比较慢的Future数据。这样在整个调用的过程中就不会出现长时间的等待，充分利用时间，从而提高系统效率。</p>
<p>() JDK 中的 Future 模式</p>
<p>FutureTask实现了 Callable，Future接口，RunnableFuture接口继承了Future和<br>Runnable接口。因为RunnableFuture实现了Runnable接口，因此FutureTask可以提<br>交给Executor进行执行，FutureTask有两个构造方法，如下：</p>
<p>Runnable 与 Callable 的区别</p>
<p>(1) Callable规定的方法是call()，Runnable规定的方法是run()；<br>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值得；<br>(3) call()方法可以抛出异常，run()方法不可以；<br>(4) 运行Callable任务可以拿到一个Future对象，Future 表示异步计算的结果</p>
<p>() 异常</p>
<p>Future 的 get() 可能会阻塞当前线程的执行，会抛出 InterruptedExcpeiton、ExecutionException，若线程已经取消，抛出 CancellationException，取消由cancel 方法来执行。isDone确定任务是正常完成还是被取消了。</p>
<p>() 可取消性</p>
<p>一旦计算完成，就不能再取消计算。如果为了可取消性而使用Future 但又不提供可<br>用的结果，则可以声明Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>使用生产者消费者模式实现的一个例子；<br>模仿分布式爬虫；</p>
<p>单生产者单消费者</p>
<p>单生产者多消费者</p>
<p>多生产者单消费者</p>
<p>多生产者多消费者</p>
<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul>
<li>《Java 并发编程的艺术》</li>
<li>《深入理解Java虚拟机(第二版)》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckm733ruo002mivvxbvwv6j4i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Docker-学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-17T14:41:19.000Z" itemprop="datePublished">2020-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Docker 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker-基础"><a href="#Docker-基础" class="headerlink" title="Docker 基础"></a>Docker 基础</h1><blockquote>
<p>类似精简的 Linux 环境，含 root 权限、进程空间、用户空间和网络空间，以及运行在其中的应用程序</p>
</blockquote>
<p><img src="http://img.janhen.com/1566961968709.png" alt="1566961968709"></p>
<p>Client： 客户端通过 CLI 命令与 Docker 交互<br>Docker daemon： 宿主机的守护进程，通过 RESTful 接口处理 Client 的命令，连接 Registry 进行镜像的拉取的推送，具体配置见 [Daemon配置](#Daemon 配置)<br>Registry： 保存 image 的地方，实现 image 的维护、复用<br>Image： 静态的镜像，可根据 Image 运行 container<br>Container： 依据 Image 生成的具体的容器，实际运行的程序</p>
<p>Docker 底层实现原理：</p>
<ul>
<li>Namespaces：做隔离pid，net，ipc，mnt，uts</li>
<li>Control groups(cgroups)：做资源限制</li>
<li>Union file systems: Container和image的分层，分层文件系统</li>
</ul>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><blockquote>
<p>一个特殊的文件系统，提供容器运行时所需的程序，同时包含一些为运行时准备的配置参数，无法更改</p>
</blockquote>
<p><strong>镜像的获取</strong></p>
<ul>
<li>根据 Dockerfile 构建镜像，配合 sh 脚本实现一些定制的初始化和参数判断逻辑，可重建</li>
<li>根据容器构建镜像，在只读镜像上操作可写容器重新打包成镜像，Docker 无状态，volume 不会打包进镜像，较少使用</li>
<li>从远程 Registry 拉取镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程 registry 拉取</span></span><br><span class="line">docker commit wonderful_mendeleev janhen/centos-vim-gcc:1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 Dockerfile 构建</span></span><br><span class="line">docker build -t janhen/myimage:1.0 .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器创建</span></span><br><span class="line">docker pull &lt;registry_host&gt;/&lt;username OR project_name&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span><br></pre></td></tr></table></figure>

<p><strong>镜像 tag</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> image 的查、交互</span></span><br><span class="line">docker images</span><br><span class="line">docker history &lt;image_id&gt;</span><br><span class="line">docker tag &lt;image_old_name&gt; &lt;image_new_name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>镜像清理</strong></p>
<p>处理同一个版本多次覆盖，默认查找顺序为 Local -&gt; Registry 的问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   删除指定的 image</span></span><br><span class="line">docker rmi &lt;image_id OR image_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">   强制删除指定|全部 image</span></span><br><span class="line">docker rmi -f $(docker images)</span><br><span class="line"><span class="meta">#</span><span class="bash">   删除 &lt;none&gt; 的镜像(<span class="comment">#)</span></span></span><br><span class="line">docker rmi $(docker images -f &quot;dangling=true&quot; -q)</span><br><span class="line">docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27; | xargs docker rmi</span><br></pre></td></tr></table></figure>



<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote>
<p> 是镜像运行时的实体，构建在镜像上，可对容器进行写操作</p>
</blockquote>
<p><strong>Container 的启动并运行</strong></p>
<p>单机上使用最多，控制部署时候的各种参数，包含网络、存储、密码、变量…</p>
<p>常用的启动指定：</p>
<ul>
<li><p>指定网络，根据需要选择端口转发、单机桥接网络、多机网络、主机网络</p>
</li>
<li><p>指定文件映射，将程序中的配置文件、数据文件隔离出来，避免应容器销毁而丢失</p>
</li>
<li><p>指定命令，内部运行的程序自带的命令，如 Redis 中的命令控制持久化方式…</p>
</li>
<li><p>指定变量，通过命令方式、环境变量方式指定，让运行容器更加定制化</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --name: 按照特定名称启动，作为容器标识</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -d: 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -i: 交互式运行容器，打开STDIN，用于控制台交互 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -t: 终端方式交互, 通过 bash、shell... 进行命令式交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -p: 映射宿主机与容器的端口号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --network=&lt;value&gt;: 指定网络连接类(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -v: 进行宿主机文件与容器文件的映射(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --&lt;param&gt;=&lt;value&gt;: 进行特定参数指定，传入中的参数，在容器中的文件处可引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -e: 指定环境变量, 对应镜像提供，与 Dockerfile 中指定的 ENV 等同，可进入容器使用 env 查看(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --privileged=<span class="literal">true</span>: 给容器扩展的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --rm: 在容器终止运行后自动删除容器文件，避免磁盘浪费，常用于测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --restart=&lt;strategy&gt;: 重启策略，与 --rm 参数冲突，提供多种策略</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --entrypoint: 覆盖默认镜像的 ENTRYPOINT</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --link: 添加链接到另一个 container, 不建议使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -w: 指定工作目录，等价于 Dockerfile 中的 WORKDIR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动过后执行一段 Shell 脚本, 用于测试环境类镜像使用</span></span><br><span class="line">docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以命令行方式进入容器，查看镜像具体情况</span></span><br><span class="line">docker run -it --entrypoint bash openjdk:7-jre </span><br><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile 中环境变量配合运行指定 JVM 运行参数、运行端口，参数名仿照 spring-boot maven 插件</span></span><br><span class="line">docker run -d -p 7070:7070 -e JVM_OPTS=&quot;-Xms1024m -Xmx2048m&quot; -e PROGRAM_ARGS=&quot;--server.port=7070&quot; com.blinkfox/web-demo:1.0.0</span><br><span class="line">docker run -e &quot;JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=5005,server=y,suspend=n&quot; -p 8080:8080 -p 5005:5005 -t springio/gs-spring-boot-docker</span><br><span class="line">docker run -d --name test1 \</span><br><span class="line">  -e MYENV=AAAA \ </span><br><span class="line">  busybox /bin/sh -c &quot;while true;do sleep 3600;done&quot;</span><br></pre></td></tr></table></figure>



<p><strong>容器的信息查看</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器整体信息查询</span></span><br><span class="line">docker info</span><br><span class="line">docker info | grep &quot;Docker Root Dir&quot;</span><br><span class="line">docker ps [(-a)|(-aq)]?</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置信息</span></span><br><span class="line">docker inspect &lt;container&gt;</span><br><span class="line">docker inspect -f &#123;&#123;xx.yy&#125;&#125; &lt;container&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 交互，调试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   日志，  -f ： follow <span class="built_in">log</span> output，持续实时显示日志，   -t:......</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   命令交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在容器中执行特定命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志查看</span></span><br><span class="line">docker logs &lt;contain_id OR container_name&gt;</span><br><span class="line">docker logs -f &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内部执行</span></span><br><span class="line">docker exec -it &lt;container_id&gt; bash</span><br><span class="line">docker exec &lt;container_id&gt; ip a</span><br><span class="line">docker exec -it &lt;container_id OR container_name&gt; env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行信息</span></span><br><span class="line">docker stat &lt;container&gt;</span><br></pre></td></tr></table></figure>



<p><strong>容器基础命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的启、停</span></span><br><span class="line">docker container start|stop|restart &lt;container_id OR contaienr_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入导出</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   导出容器成指定的 tar 包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   容器快照文件导入为*镜像*</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   URL/目录导入</span></span><br><span class="line">docker export 7691a814370e &gt; ubuntu.tar</span><br><span class="line">cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>



<p><strong>容器的清理</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除|强制删除指定的容器</span></span><br><span class="line">docker container rm &lt;container_id OR container_name&gt;</span><br><span class="line">docker contaienr rm -f &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已停止运行的容器(<span class="comment">#)</span></span></span><br><span class="line">docker rm $(docker ps -f &quot;status=exited&quot; -q)</span><br></pre></td></tr></table></figure>



<p><strong>Container 交互</strong></p>
<blockquote>
<p>容器内部可执行的命令，特定目录存储的配置内容，可以通过 CLI 的监控命令</p>
</blockquote>
<p>支持更改 /etc/hosts， /etc/hostname，/etc/resolv.conf ，只针对运行时，临时的更改</p>
<p>几种交互方式：</p>
<ul>
<li><p>运行时直接进入交互、运行时直接执行命令交互，包含对文件的操作、内部命令执行</p>
</li>
<li><p>运行后按特定终端进入交互、运行后按特定命令交互，同上</p>
</li>
<li><p>日志交互，logs，支持最后几行、最近的时间点、实时显示</p>
</li>
<li><p>基本情况，inspect，返回运行情况 JSON 字符串，可通过 Go  Templete 获取特定情况</p>
</li>
<li><p>运行的资源情况，stats，实时显示 CPU、内存、网络、磁盘情况</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器内部</span></span><br><span class="line">docker exec -it -u root jenkins sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行特定命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   创建之后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在已运行的容器中执行命令</span></span><br><span class="line">docker run -it --rm ubuntu:18.04  ip a</span><br><span class="line">docker run -it --rm ubuntu:18.04 --hostname=test.com --dns=172.16.3.3 ip a</span><br><span class="line">docker run -it --rm ubuntu:18.04  cat /etc/resolv.conf</span><br><span class="line">docker exec -it gitlab cat /etc/resolv.conf</span><br><span class="line">docker exec -it gitlab cat /etc/hostname</span><br><span class="line">docker exec -it gitlab cat /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内部执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看挂载情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看定义的环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 dns 情况, 与在宿主机上的 /etc/docker/daemon.json 上配置 dns 类似?</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看容器IP地址配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看路由情况</span></span><br><span class="line">mount</span><br><span class="line">env</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">ip addr show eth0</span><br><span class="line">ip route</span><br><span class="line"><span class="meta">#</span><span class="bash"> logs 查看</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   特定时间偏移, 特定时间段</span></span><br><span class="line">docker logs -f -t --since=40m --tail=10 jenkins</span><br><span class="line">docker logs -t --since=&quot;2019-08-01T13:23:37&quot; --until &quot;2018-08-31T12:23:37&quot; jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> inpect 查看</span></span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; 1f1f4c1f931a</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">stat</span> 查看</span></span><br><span class="line">docker stats &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝文件，作为 Dockerfile 中 COPY 的...</span></span><br><span class="line">docker cp &lt;host_machine file OR dir&gt; &lt;container_name&gt;:&lt;container_dir&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><blockquote>
<p>Docker 的私有仓库，实现容器的复用共享</p>
</blockquote>
<p>发布镜像到 Registry 的方式：</p>
<ul>
<li><p>发布镜像到仓库</p>
<p>  直接将本地已经构建好的镜像发布到仓库中</p>
</li>
<li><p>根据指定 Dockerfile 由 Docker hub 进行构建形成镜像</p>
<p>自动在 git 发生变化的时候拉取数据进行构建重新发布到仓库上，自动构建发布，CICD</p>
<p>保证镜像的可再生性</p>
</li>
</ul>
<p>私有 Registry 搭建：</p>
<p>官方提供的 registry</p>
<p>Vmware 开源的 harbor，见 <a href="./B-%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%8E%AF%E5%A2%83.md#harbor">工具与环境</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录 docker hub 账号和密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送镜像到 docker hub</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker hub 关联 github or bitbucket</span></span><br><span class="line">docker login 172.17.11.29:5111 -u admin -p Harbor12345</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名镜像的名称(tag)</span></span><br><span class="line">docker push 172.17.11.29:5111/centos-vim-gcc:1.0.0</span><br><span class="line">docker tag janhen/centos-vim-gcc:1.0.0 172.17.11.29:5111/study-docker/centos-vim-gcc:1.0.0</span><br><span class="line">docker push 172.17.11.29:5111/study-docker/centos-vim-gcc:1.0.0</span><br></pre></td></tr></table></figure>



<h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><blockquote>
<p>进行容器之间的访问，包含单机上的访问，多台机器之间的访问； 含端口映射、容器互联</p>
<p>关联文档:  <a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/network/">使用网络</a>  |  <a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/advanced_network/">高级网络配置</a></p>
</blockquote>
<p><strong>Linux 上网络访问</strong></p>
<blockquote>
<p> Linux 网络命名空间，进行网络的隔离</p>
</blockquote>
<p>Veth pair： 进行网络命名空间的连接，实现两个 net namspce 连接通信</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网络命名空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给命名空间分配 ip 地址, 默认情况下只有 mac 地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动接口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接双方使其网络互通</span></span><br><span class="line">ip netns list</span><br><span class="line">ip netns delete test1</span><br><span class="line">ip netns exec test2 ip link</span><br><span class="line">ip netns exec testl ip link set dev veth-testl up</span><br><span class="line">ip netns exec testz ip link set dev veth-test2 up</span><br></pre></td></tr></table></figure>



<h3 id="Docker-网络访问"><a href="#Docker-网络访问" class="headerlink" title="Docker 网络访问"></a>Docker 网络访问</h3><blockquote>
<p>通过link 方式实现容器之间的访问，直接通过名称而非 IP，适用于单台机器</p>
</blockquote>
<p><img src="http://img.janhen.com/1566531692115.png" alt="1566531692115"></p>
<p>一个容器对应一个网络空间</p>
<p>类似局域网连接，通过中间的交换机实现两个容器之间的通信， docker0 的内网指定默认为 172.17.0/16，自定义为 172.17.18.0/16…</p>
<p>访问外部网络，需要经过 NAT 转换</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络， bridge 网络</span></span><br><span class="line">docker network ls</span><br><span class="line">sudo docker network inspect &lt;network_id OR network_name&gt;</span><br><span class="line">ip a</span><br><span class="line">yum install bridge-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示系统当前桥接</span></span><br><span class="line">brctl show</span><br><span class="line">ip a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建指定类型的网络</span></span><br><span class="line">docker network create -d bridge net-my</span><br></pre></td></tr></table></figure>



<p><strong>Docker link 网络连接</strong></p>
<blockquote>
<p>通过命名 Docker 进行相连，类似网络命名空间中的 Veth pair，目前不推荐使用</p>
<p>命令格式： –link <container_name OR container_id>:<alias></p>
<p>替代方案： docker-compose.yml 中使用 depends_on，使用 overlay 网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 类似给 net-test2 添加 DNS 记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   link 方向性; 使用少</span></span><br><span class="line">docker run -d --name net-test2 \</span><br><span class="line">  --link net-test1 busybox \</span><br><span class="line">  /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker exec -it net-test2 /bin/sh</span><br><span class="line">  ip a </span><br><span class="line">  ping net-test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 指定网络类型， bridge|overlay</span></span><br><span class="line">docker network create -d bridge net-my</span><br><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line">docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --link &lt;name&gt; 支持通过名称访问容器 </span></span><br><span class="line">docker run -d --name flask-redis \</span><br><span class="line">  -p 5000:5000 \</span><br><span class="line">  --link redis \</span><br><span class="line">  -e REDIS_HOST=redis \</span><br><span class="line">  janhen/flask-redis </span><br><span class="line">docker run -d --name test1 \</span><br><span class="line">  -e PENG=testt1 \</span><br><span class="line">  busybox </span><br><span class="line">docker run -d --name test2 \ </span><br><span class="line">  -e PENG=testest \</span><br><span class="line">  busybox  \</span><br><span class="line">  /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br></pre></td></tr></table></figure>



<p><strong>自定义网络连接</strong></p>
<blockquote>
<p>避免使用 –link 进行容器之间网络的连接</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockernetwork create -d bridge net-demo</span><br></pre></td></tr></table></figure>



<h3 id="Docker-单机网络"><a href="#Docker-单机网络" class="headerlink" title="Docker 单机网络"></a>Docker 单机网络</h3><p><strong>Docker bridge 网络</strong></p>
<blockquote>
<p>可以创建自己的桥接网络，进行区分，docker-compose 默认管理的容器共享同一个 bridge 网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建自己的桥接网络</span></span><br><span class="line">docker network create -d bridge my-bridge</span><br><span class="line">docker network ls</span><br><span class="line">brctl show</span><br><span class="line">docker run -d \</span><br><span class="line">  -- name net-test3 \</span><br><span class="line">  --network my-bridge busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker network connect mybridge net-test2</span><br></pre></td></tr></table></figure>

<p>bridge 性能一般，对性能要求较高，可使用个 SR-IOV 网卡嵌入容器内。</p>
<p><strong>Docker host 和 none网络</strong></p>
<blockquote>
<p>none 网络： 不会有网络信息，孤立的网络，用来做私有的工具，如保存密码??，使用场景少</p>
<p>host 网络：无网络信息，与主机共享网络命名空间，存在端口冲突问题</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx </span><br></pre></td></tr></table></figure>



<h3 id="Docker-多机网络"><a href="#Docker-多机网络" class="headerlink" title="Docker 多机网络"></a>Docker 多机网络</h3><blockquote>
<p>实现多个不同机器之间的容器进行通信</p>
</blockquote>
<h4 id="Overlay-网络"><a href="#Overlay-网络" class="headerlink" title="Overlay 网络"></a>Overlay 网络</h4><blockquote>
<p>依赖一个分布式存储，保存对应的 IP，防止网络(172.18.0.0/16)、容器名称等的冲突</p>
</blockquote>
<p>实现 Docker 的多机网络，见 [Internel 访问](#Internel 访问)</p>
<p>两台机器之间可以相互通信，为了实现不同容器之间的通信需要借助第三方的分布式存储</p>
<p>使用etcd 建立的 cluster 中容器名称不允许重复、Ip 地址不允许重复</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络，实现多态主机之间的同步创建 overlay 网络</span></span><br><span class="line">docker network ls</span><br><span class="line">docker netword create -d overlay net-overlay-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络情况，子网范围，容器情况</span></span><br><span class="line">docker network inspect net-overlay-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器指定到 overlay 网络</span></span><br><span class="line">docker run -d --name node1-test1 \</span><br><span class="line">  --net net-overlay-demo \</span><br><span class="line">  busybox sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker run -d --name node2-test1 \</span><br><span class="line">  --net net-overlay-demo \</span><br><span class="line">  busybox sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点上容器的地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 cluster 中网络的情况</span></span><br><span class="line">docker exec node1-test1 ip a</span><br><span class="line">docker exec node2-test1 ip a</span><br><span class="line">docker network inspect net-overlay-demo</span><br></pre></td></tr></table></figure>



<h4 id="Etcd-分布式存储"><a href="#Etcd-分布式存储" class="headerlink" title="Etcd 分布式存储"></a><strong>Etcd 分布式存储</strong></h4><blockquote>
<p>存储分布式系统中的 key-val，开源免费，保证 overlay 网络中分配的容器与容器对应的IP地址在整个网络中唯一</p>
<p>关联： <a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd">GitHub</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在对应的两台机器上安装 etcd，容器安装/binary 安装</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过命令指定好集群启动</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证 cluster 的运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 etcd 文件夹执行健康检查，两台机器同时执行</span></span><br><span class="line">./etcdctl cluster-health</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭 Docker 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 etcd 作为分布式存储启动 docker， 手动启动 dockerd 守护进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 \</span><br><span class="line">  -H unix://var/run/docker.sock \</span><br><span class="line">  --cluster-store=etcd://192.168.xx.xx:2379 \</span><br><span class="line">  --cluster-advertise=192.168.xx.xx:2375 &amp;  </span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>



<h2 id="Docker-持久化"><a href="#Docker-持久化" class="headerlink" title="Docker 持久化"></a>Docker 持久化</h2><blockquote>
<p>将容器与数据存储隔离开，如 Mysql 运行程序与数据保存位置</p>
</blockquote>
<p><img src="http://img.janhen.com/202012172237411566571502370.png" alt="1566571502370"></p>
<p>两种持久化的方式：</p>
<ul>
<li><p>本地 FS 的 Volumn</p>
</li>
<li><p>基于 plugin 的 Volume， 如 NAS</p>
</li>
</ul>
<p>本机上三种持久化实现, -mount 选项选择数据卷：</p>
<ul>
<li><p>bind :挂载在 Linux FS 中任意位置</p>
</li>
<li><p>volume：统一挂载在 daemon 设置的 docker 目录下，默认为 <code>/var/lib/docker/volumes/&lt;unique_str_id OR volume_name&gt;</code></p>
</li>
<li><p>tmpfs： 只挂载在内存中，易丢失</p>
</li>
</ul>
<p>使用命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker volume create -d local test</span><br><span class="line">docker volume inspect &lt;contaienr&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理</span></span><br><span class="line">docker volume prune &lt;&gt;</span><br><span class="line">docker volume rm &lt;&gt;</span><br><span class="line">docker run -d --mount type=bind, source=/data, destination=/redis/data xxxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定 :ro 容器无法对挂载数据卷内的数据进行修改</span></span><br><span class="line">docker run -d -v /webapp:/opt/webapp:ro</span><br></pre></td></tr></table></figure>



<p><strong>数据卷容器</strong></p>
<p>实现多个容器操作数据，任意容器修改都可被其他容器看到</p>
<p>–volumes-from 参数所挂载的数据卷容器无需处在运行状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --volumes-from dbdata xxx</span><br></pre></td></tr></table></figure>



<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><blockquote>
<p>通过 Dockerfile 中的 Volumn 控制，在宿主机上 docker 文件下建立目录存放文件</p>
</blockquote>
<p>建议 -v 参数指定在 docker 目录下 volume 的名称，默认为 <code>/var/lib/docker/volumes/&lt;-v_name OR long_str&gt;</code></p>
<p>针对官方镜像，到 Docker Hub 上查看对应的 volume 挂载目录位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 volume，查看所有|指定|删除volume</span></span><br><span class="line">docker volume create volume1</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect volume1</span><br><span class="line">docker volume rm volume2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行-&gt;删除-&gt;验证</span></span><br><span class="line">docker run -d -v mysql1:/var/lib/mysql  \</span><br><span class="line">  --name mysql1  \</span><br><span class="line">  -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql </span><br><span class="line">docker rm -f  mysql1 mysql2</span><br><span class="line">docker run -d -v mysql1:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql </span><br><span class="line">docker exec -it mysql2 /bin/bash</span><br><span class="line">  mysql -u root</span><br><span class="line">  show databases;</span><br></pre></td></tr></table></figure>



<h3 id="Bind-Mouting"><a href="#Bind-Mouting" class="headerlink" title="Bind Mouting"></a>Bind Mouting</h3><blockquote>
<p>指定容器目录与宿主机目录绑定，宿主机文件更改影响到容器中的运行</p>
</blockquote>
<p>可以实现本台电脑  –&gt;  虚拟机  –&gt;  容器三者的目录映射</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v: &lt;宿主机目录&gt;:&lt;容器目录&gt; 进行一一映射</span></span><br><span class="line">docker run -d -v $(pwd):/usr/share/nginx/html -p 80:80 --name web janhen/my-nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 Docker 作为本地开发环境</span></span><br><span class="line">docker run -d -p 80:5000  --name flask janhen/flask-skeleton </span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><blockquote>
<p>用于生成 Docker Image 的文件，一般只用于 <code>docker build -t janhen/xx:99 .</code> 命令执行使用 </p>
<p>关联： <a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html#dockerfile-%E6%8C%87%E4%BB%A4">Dockerfile 指令</a></p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>Dockerfile 的基本语法</strong></p>
<blockquote>
<p>FROM,WORKDIR,ENV,COPY,ADD</p>
<p>RUN,CMD,ENTRYPOINT</p>
<p>VOLUME,EXPOSE</p>
</blockquote>
<ul>
<li><p><code>FROM</code>： 根据特定的镜像制作，从头制作、 根据指定环境制作、某个镜像作为构建阶段使用</p>
</li>
<li><p><code>RUN </code>： 运行命令脚本, 可以通过此安装一些环境并对环境进行配置，如安装 Node 环境，每运行一个命令增加一层 ==&gt;  建议将多个命令合并成一个命令使用</p>
</li>
<li><p><code>WORKDIR</code>： 设定当前工作目录, 类似 cd 改变目录, 没有目录自动创建(#)<br>  直接通过绝对路径定位<br>  通过绝对路径+相对路径定位目录</p>
</li>
<li><p><code>ADD and COPY</code>： 将本地文件添加到 docker image 中,常 配合 WORKDIR 使用</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> LABEL 镜像的 metadata，帮助信息</span></span><br><span class="line">LABEL maintainer=&quot;janhen &lt;ipaam414@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">RUN yum update &amp;&amp; yum install -y vim \</span><br><span class="line">  python-dev</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y perl \</span><br><span class="line">    pwgen --no-install-recommends &amp;&amp; rm -rf \  </span><br><span class="line">    /var/lib/apt/lists/*</span><br><span class="line">RUN /bin/bash -c &#x27;source $HOME/.bashrc;echo $HOME&#x27;</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">WORKDIR /test</span><br><span class="line">WORKDIR demo</span><br><span class="line">RUN pwd</span><br><span class="line"></span><br><span class="line">ADD hello /</span><br><span class="line">ADD test.tar.gz /</span><br><span class="line">WORKDIR /root</span><br><span class="line">ADD hello test/</span><br><span class="line">COPY hello test/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENV 设定环境变量, 建议使用</span></span><br><span class="line">ENV MYSQL_VERSION 5.6</span><br><span class="line">RUN apt-get install -y mysql-server = &quot;$&#123;MYSQL_VERSION&#125;&quot; \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动后默认执行的命令和参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   docker run 指定其他命令, CMD 被忽略</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   定义多个 CMD，只运行最后一个</span></span><br><span class="line">docker run [image]                # CMD 会被执行</span><br><span class="line">docker run -it [image] /bin/bash  # CMD 不会执行</span><br><span class="line">CMD [&quot;mongod&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENTRYPOINT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动时运行的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器以应用程序/服务的形式运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   不会被忽略, 一定会执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   最佳实践: 通过 shell 脚本作为 entrypoint </span></span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin/     # 添加到容器中</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]           # 指定入口脚本</span><br><span class="line">EXPOSE 27017</span><br><span class="line">ENTRYPOINT [&quot;scripts/dev.sh&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行宿主机与容器中文件的映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射容器中的 /tmp 到宿主机上，默认在 /var/lib/docker/volumes/&lt;long_id OR name&gt; 下建立对应的映射</span></span><br><span class="line">VOLUME /tmp</span><br></pre></td></tr></table></figure>



<p><strong>命令格式</strong></p>
<blockquote>
<p>不同的命令执行写法，以及对应的区别</p>
</blockquote>
<p>Shell 格式, 默认通过 shell 执行</p>
<p>Exec 格式,   ENTRYPOINT [“/bin/bash”, “-c”, “echo”, “hello $name”]</p>
<p>针对 Exec 无法映射变量问题的处理： 通过命令方式编写语句</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV name Docker</span><br><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;hello $name&quot;]</span><br></pre></td></tr></table></figure>



<p><strong>命令区别</strong></p>
<p>1、RUN、CMD和ENTRYPOINT命令区别</p>
<p>RUN 运行在 image 的构建阶段执行，执行结果会被打包进 image 文件</p>
<p>CMD 在容器启动后执行，可用于在容器内启动某个服务、进程，只可使用一次，与 run 中年执行命令冲突</p>
<p>ENTRYPOINT 在容器启动后执行，出现多行不会忽略，一定执行，通常配合 COPY 到容器中的 sh 脚本使用</p>
<p>2、COPY 与 ADD 命令区别</p>
<p>ADD 可以获取网络资源，可以直接解压缩</p>
<p><strong>注意事项</strong></p>
<p>1、CMD 的最后一次有效性</p>
<p>官方镜像中大多最后运行 CMD，方便覆盖实现定制化的参数的启动</p>
<p>2、目录</p>
<p>COPY . /app 与 COPY . /app/ 映射不同</p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><blockquote>
<p>多容器管理，通过 yml 配置管理容器之间的依赖关系，底层 python 编写，前身为开源的 Fig 项目。主要用于本地开发使用。</p>
<p>关联文档：<a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/compose/compose_file.html">Compose 模板文件</a> | <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file">Doc</a></p>
</blockquote>
<h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><blockquote>
<p>docker-compose 的启动、停止、交互</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> compose 后台启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并查看日志</span></span><br><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose -f &lt;compose_name&gt; up -d </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止并删除 容器、网络、volumes</span></span><br><span class="line">docker-compose stop &lt;service&gt;</span><br><span class="line">docker-compose down &lt;service&gt;</span><br><span class="line">docker-compose build</span><br><span class="line"><span class="meta">#</span><span class="bash"> compose 查看运行情况，状态、端口情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 compose 中定义容器使用的 images</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose images</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 compose 中的 service</span></span><br><span class="line">docker-compose exec mysql bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展</span></span><br><span class="line">docker-compose scale &lt;service_name&gt;=&lt;count&gt;</span><br></pre></td></tr></table></figure>



<p><strong>service 的扩展</strong></p>
<blockquote>
<p> 实现水平扩展，负载均衡，在不存在端口冲突的情况下通过 haproxy 进行负载均衡，在 Docker Swarm 运行时可直接通过 deploy 中的参数指定复制扩展的个数</p>
</blockquote>
<p>通过 docker-compose scale 命令进行扩展</p>
<p>处理 scale 中端口映射重复问题</p>
<p>在 docker-compose 中增加 dockercloud/haproxy 进行负载均衡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动时指定扩展</span></span><br><span class="line">docker-compose up --scale web=3 -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行后进行扩展</span></span><br><span class="line">docker-compose scale web=4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证扩展情况</span></span><br><span class="line">docker-compose ps</span><br><span class="line">for i in `seq 10`; do curl 127.0.0.1:8080; done</span><br></pre></td></tr></table></figure>




<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><blockquote>
<p>对应 docker-compose.yml 文件的语法</p>
</blockquote>
<p>三大实体：</p>
<ul>
<li><p>service: 服务</p>
</li>
<li><p>networks: 网络指定，指定网络类型，一般为 bridge、overlay，根据需要指定多个网络，进行一定的隔离</p>
</li>
<li><p>volumes: 进行数据卷的映射</p>
</li>
</ul>
<hr>
<p>image 获取方式： 通过 image 获取本地的或是拉取远程的，或者通过 build 进行构建，传入 Dockerfile 的目录以及对应的 Dockerfile 名称</p>
<p>ports: 进行宿主端口与容器端口的映射</p>
<p>depends_on: 解决容器的依赖，启动先后问题</p>
<p>links: 服务之间的依赖关系，在容器内部可以直接使用依赖服务名称对应的 IP 地址，不建议使用</p>
<p>deploy: 进行部署，控制集群中的各种情况，用于 Docker swarm，version 3 支持</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 特定片段参考</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置网络, 可多个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> frontend, backend 前后端设置</span></span><br><span class="line">networks:</span><br><span class="line">  - frontend</span><br><span class="line">  - backend</span><br><span class="line"><span class="meta">#</span><span class="bash"> 端口设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接引号设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 宿主机与容器端口映射</span></span><br><span class="line">ports:</span><br><span class="line">  - &quot;6379&quot;</span><br><span class="line">ports:</span><br><span class="line">  - 5000:80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 依赖</span></span><br><span class="line">depends_on:</span><br><span class="line">  - mysql</span><br></pre></td></tr></table></figure>





<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><blockquote>
<p>Docker 自带的服务编排框架，大多数都由其中的 Manager 做管理，较难定制，不适合太多节点的部署</p>
</blockquote>
<p>Docker Swarm 特点：</p>
<p>符合传统IT的管理模式</p>
<p>平台本身集成性好，可当成云管平台使用</p>
<p>内置太多不易进行定制化，不好 Debug，不易干预</p>
<p><strong>不提供存储选项</strong>：Docker Swarm不提供将容器连接到存储的无障碍方式，其数据量需要在主机和手动配置上进行大量即兴创作</p>
<p><strong>监控不良</strong>：Docker Swarm提供有关容器的基本信息，如果您正在寻找基本的监控解决方案，那么Stats命令就足够了。如果您正在寻找高级监控，那么Docker Swarm永远不是一个选择。虽然有像CAdvisor这样的第三方工具可以提供更多监控，但使用Docker本身实时收集有关容器的更多数据是不可行的。</p>
<h2 id="Swarm-架构"><a href="#Swarm-架构" class="headerlink" title="Swarm 架构"></a>Swarm 架构</h2><p><img src="http://img.janhen.com/202012172238091566634422450.png" alt="1566634422450"></p>
<p><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">Raft</a> consensus group： 进行控制分布式场景下的协商:  内置的分布式的存储数据库，通过 Raft 协议进行同步，包含 Leader 选举、Log 复制</p>
<p>Internel distributed state store： 分布式存储数据库，功能如保证分布式场景下 Ip 等唯一，类似 etcd</p>
<p>Manager: 可以保存 Raft 关联的文件，用于 Secret 实现</p>
<p>Worker: 主要运行容器，通过 Gossip network 进行通信，保证分布式下的一致性</p>
<p>Gossip network： 各个 Worker 之间同步实现的协议</p>
<p>扩展：</p>
<p>  Service: 通过 swam manager 进行控制，具体 service 部署到哪个 node 上</p>
<p>  Replicas： 一个 Service 对应多个 Replicas，用于扩展</p>
<h2 id="集群搭建管理"><a href="#集群搭建管理" class="headerlink" title="集群搭建管理"></a>集群搭建管理</h2><blockquote>
<p>让几台服务器搭建成一个 Swarm Cluster</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 Manager Node</span></span><br><span class="line">docker swarm init --advertise-addr=192.169.xx.xx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 Worker Node 加入到特定的 Manager Node</span></span><br><span class="line">docker swarm join --token xxxfsdfsdf &lt;ip&gt;:&lt;port&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前 Node 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点查看</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点降级</span></span><br><span class="line">docker node ls  </span><br><span class="line">docker node inspect &lt;node_name&gt;</span><br><span class="line">docker node demote &lt;node_name&gt;</span><br><span class="line">docker node ps</span><br></pre></td></tr></table></figure>



<h2 id="Swarm管理"><a href="#Swarm管理" class="headerlink" title="Swarm管理"></a>Swarm管理</h2><p><strong>Swarm Services 管理</strong></p>
<blockquote>
<p>单个 Service 的管理，一个 Service 可扩展到多个 cluster node 上的 Container 运行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建容器，运行位置有 mananger 进行控制运行在哪个节点上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似 docker run 命令，在本地创建 container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 service 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   MODE: replicated</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   REPLICAS: 1/1 支持水平扩展，类似 docker compose 中的 scale</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看具体的 service 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   运行在哪个节点上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展servie，通过复制的方式(<span class="comment">#) </span></span></span><br><span class="line">docker service create --name demo busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps demo</span><br><span class="line">docker service scale demo=5</span><br><span class="line">docker service ps demo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 本机查看 docker 容器运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除某个正在运行中的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群自动恢复，确保一定数目的 scale 扩展有效，系统稳定运行时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示节点中容器运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除服务，对应的集群节点容器删除</span></span><br><span class="line">docker ps</span><br><span class="line">docker rm -f e64432</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps demo</span><br><span class="line">docker service rm demo</span><br></pre></td></tr></table></figure>



<h2 id="RoutingMesh"><a href="#RoutingMesh" class="headerlink" title="RoutingMesh"></a>RoutingMesh</h2><blockquote>
<p>Swarm 网络通信原理，管理集群服务间的通信，访问集群中任何一个节点特定端口都会被重定向到实际运行服务的节点上</p>
</blockquote>
<p><img src="http://img.janhen.com/202012172238131566634990023.png" alt="1566634990023"></p>
<p>DNS 服务发现，单机情况下可以通过 service 的名称进行相互访问，多机情况下通过 swarm 进行相互访问</p>
<p>VIP： 非真实机器的IP地址，避免多个IP地址变化问题，造成系统运行不稳定，一个 service 对应一个</p>
<p>LVS： 根据虚拟 IP 找出容器中的具体的 IP 地址</p>
<p>两种体现：</p>
<ul>
<li>Internel：容器之间通过 overlay 网络访问</li>
<li>Ingress ：服务绑定接口的情况，此服务通过任意 Swarm 节点对应接口访问</li>
</ul>
<h3 id="Internel-访问"><a href="#Internel-访问" class="headerlink" title="Internel 访问"></a>Internel 访问</h3><blockquote>
<p>容器间实现相互访问，通过 overlay 网络实现，实现 service 与 service 之间的通信</p>
</blockquote>
<p><img src="http://img.janhen.com/202012172238171568514162156.png" alt="1568514162156"></p>
<p>whoami 镜像： 提供 web 服务，访问 8000 端口，返回 container 的 hostname</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 whoami 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   端口映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   网络指定</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有 service </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 whoami 服务运行位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 到对应机器上验证</span></span><br><span class="line">docker network create -d overlay net-demo</span><br><span class="line">docker service create -d \</span><br><span class="line">  --name whoami \</span><br><span class="line">  -p 8000:8000 \</span><br><span class="line">  --network net-demo jwilder/whoami</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps whoami</span><br><span class="line">docker ps</span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 busybox 的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   连接到同一个 overlay 网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有服务，当前 busybox service 是否启动完成</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务 client 服务具体位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入对应的机器查看对应运行的 container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   10.0.0.7 IP 地址，为虚拟 IP， 将 whoiam 通过 scale 扩展</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 scale 进行扩展 whoami </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 whoami 位置，并进入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入对应 client contaienr 中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   连接 whoami </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查询 dns，只有一个虚拟IP 10.0.0.7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 whoami 查看网络地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 whoami(另一) 查看网络地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 client</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 task.whoami，返回对应的多个节点，为真实的 IP 地址（<span class="comment">#）</span></span></span><br><span class="line">docker service create -d \</span><br><span class="line">  --name client \</span><br><span class="line">  --network net-demo busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps client</span><br><span class="line">docker ps</span><br><span class="line">docerer exec -it &lt;container_id&gt; sh</span><br><span class="line">  ping whoami    </span><br><span class="line">docker service scale whoami=2    </span><br><span class="line">docker service ps whoami</span><br><span class="line">docker service ps client</span><br><span class="line">docker exec -it &lt;container_client_id&gt; sh </span><br><span class="line">  ping whoami </span><br><span class="line">  nslookup whoami</span><br><span class="line">docker exec 5b79 ip a</span><br><span class="line">docker exec	df9 ip a</span><br><span class="line">docerk exec -it &lt;container_client_id&gt; sh</span><br><span class="line">  nslookup task.whoami</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展 whoami 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查案 client 对应的 task.whoami，显示三个对应的(whoami)IP 地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   ==&gt; 虚拟IP: 不会随 service 的扩展而变化, 包括增加、减少、机器之间的迁移不会变化(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问多次服务 whoami，相应的对应机器上的容器会因为负载均衡而不同，通过 LVS 实现</span></span><br><span class="line">docker service scale whoami=3</span><br><span class="line">docker service ps whoami</span><br><span class="line">---</span><br><span class="line">  nslookup task.whoami</span><br><span class="line">  wget whoami:8000</span><br><span class="line">  more index.html</span><br><span class="line">  rm -rf index.html</span><br><span class="line">  wget whoami:8000</span><br></pre></td></tr></table></figure>

<p>两种体现：</p>
<p>Internal: 容器键通过 overlay 网络(VIP)访问</p>
<p>Ingress: 服务绑定接口, 通过任意 swarm 节点的接口访问’</p>
<p>DNS + VIP + iptables + LVS 实现的过程图：</p>
<p>// todo 具体 Swarm 网络中数据的流动情况</p>
<p>小结： 容器之间连接到 overlay 网络进行通信，service 之间的通信通过  VIP + LVS 实现</p>
<h3 id="Ingress-负载均衡"><a href="#Ingress-负载均衡" class="headerlink" title="Ingress 负载均衡"></a>Ingress 负载均衡</h3><blockquote>
<p>绑定端口实现的容器之间的访问，通过 <node_ip>:<service_port> 直接访问服务</p>
<p>作用体现：集群中的 Node 对应的端口提供相同的服务，即使 Node 本地无服务也支持访问</p>
</blockquote>
<p>Ingress Network 的数据包走向图</p>
<p><img src="http://img.janhen.com/202012172238261568515008492.png" alt="1568515008492"></p>
<p>在  IPTables + IPVS 发往目的网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常看网络桥接情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看机器的网络命令空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 ingress_sbox 网络命名空间</span></span><br><span class="line">iptables</span><br><span class="line">brctl show</span><br><span class="line">sudo ls /var/run/docker/netns</span><br><span class="line">sudo nsenter --net=/var/run/docker/netns/ingress_sbox</span><br><span class="line">ip a</span><br><span class="line">iptables -nL -t mangle</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 LVS 管理工具</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 LVS 情况，展示可选的服务 IP 地址，展示机器的 weight, </span></span><br><span class="line">yum install ipvsadm</span><br><span class="line">sudo nsenter --net=/var/run/docker/netns/ingress_sbox</span><br><span class="line">iptables -nL -t mangle</span><br><span class="line">ipvsadm -l</span><br></pre></td></tr></table></figure>





<h2 id="Docker-Stack-部署"><a href="#Docker-Stack-部署" class="headerlink" title="Docker Stack 部署"></a>Docker Stack 部署</h2><blockquote>
<p>进行多服务部署，可以使用 docker-compose.yml ，只能用于 swarm cluster，无法用于其他的服务编排框架</p>
</blockquote>
<p>docker-compose.yml 文件更改</p>
<p>compose file version 3: 增加 <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/#deploy">deploy</a> 命令，具体参数如下</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy</span></span><br><span class="line"><span class="comment">#   endpoint_mode: vip 模式(默认), dnsrr 模式 循环访问(少用)</span></span><br><span class="line"><span class="comment">#   labels: 帮助描述信息</span></span><br><span class="line"><span class="comment">#   mode: global, replicated， global 全局唯一, 无法通过 scale 横向扩展，一般外部服务使用此种方式，如 mysql,nginx,redis等； replicated 默认，可通过复制来进行扩展</span></span><br><span class="line"><span class="comment">#   placement:   </span></span><br><span class="line"><span class="comment">#     constraint: </span></span><br><span class="line"><span class="comment">#       - node.role == manager # 限制部署到 manager 节点上</span></span><br><span class="line"><span class="comment">#     preferences: 优先喜好</span></span><br><span class="line"><span class="comment">#       -</span></span><br><span class="line"><span class="comment">#   replicas: 在 mod 是 replicated 的时候定义初始化时候需要的 replicas</span></span><br><span class="line"><span class="comment">#   resources: 进行资源的限制</span></span><br><span class="line"><span class="comment">#     limits:</span></span><br><span class="line"><span class="comment">#       cpus: &#x27;0.50&#x27;  # CPU 使用限制</span></span><br><span class="line"><span class="comment">#       memeory: 50M  # 内存使用限制</span></span><br><span class="line"><span class="comment">#     reservations:   # 优先保留，最小的情况</span></span><br><span class="line"><span class="comment">#       cpus: &#x27;0.25&#x27;</span></span><br><span class="line"><span class="comment">#       memory: 20M</span></span><br><span class="line"><span class="comment">#   restart_policy:         # 容器宕机后的处理</span></span><br><span class="line"><span class="comment">#     conditon: on-failure  # 什么情况下重启</span></span><br><span class="line"><span class="comment">#     delay: 5s             # 延迟</span></span><br><span class="line"><span class="comment">#     max_attempts: 3       # 最大重试次数</span></span><br><span class="line"><span class="comment">#     window: 120s</span></span><br><span class="line"><span class="comment">#   update_config:          # service 更新的配置</span></span><br><span class="line"><span class="comment">#     parallelism: 2</span></span><br><span class="line"><span class="comment">#     delay: 10s</span></span><br><span class="line"><span class="comment">#     order: stop-first</span></span><br></pre></td></tr></table></figure>



<p>部署的过程：</p>
<p>更改单机的 docker-compose.yml 为对应 cluster 部署(deploy)</p>
<p>按条件执行命令： 如下</p>
<p>验证： 通过访问任意一个 cluster 中的地址即可访问</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 整个 application 定义为一个 stack 为 wordpress</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   可通过 -c=docker-compose.yml 进行简化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   mysql: 限制只运行一个，只能运行在 manager 节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 stack 查看服务情况</span></span><br><span class="line">docker stack deploy wordpress --compose-file=docker-compose.yml</span><br><span class="line">docker stack ls</span><br><span class="line">docker stack ps wordpress</span><br><span class="line">docker stack services wordpress</span><br><span class="line">docker stack rm wordpress</span><br></pre></td></tr></table></figure>



<h2 id="Docker-Secret-管理"><a href="#Docker-Secret-管理" class="headerlink" title="Docker Secret 管理"></a>Docker Secret 管理</h2><blockquote>
<p>对一些密码进行管理， 处理 docker-compose.yml 中存储密码不安全问题，借助内部分布式存储数据库控制，只作用于 Docker Swarm</p>
<p>关联： <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/secret/">Doc-CLI</a></p>
</blockquote>
<p><img src="http://img.janhen.com/202012172238471566631044524.png" alt="1566631044524"></p>
<p>Secret 类型： username password， SSH key, TLS 认证，不想让人看到的数据</p>
<p>生产环境至少要两个 Manager，分布式存储的天然加密环境</p>
<p>Secret 的管理：</p>
<p>将 Secret 存储在 Manager 中的分布式存储中的 Raft Database</p>
<p>Secret 给某个 service 指派</p>
<p><strong>Service 基本使用</strong></p>
<p>Secret 的创建方式：文件方式、输入方式。</p>
<p>存放在容器中的 <code>/run/secrets/&lt;secret_file_name&gt;</code> 文件中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按文件方式进行创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件，保证安全性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 secret</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 借助管道按照输入方式创建 secret</span></span><br><span class="line">vim password</span><br><span class="line">docker secret create my-file-pw password</span><br><span class="line">rm -rf password</span><br><span class="line">docker secret ls</span><br><span class="line">echo &quot;mypassword&quot; | docker secret create my-input-pw</span><br><span class="line">docker secret rm my-input-pw</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 swarm service 创建过程中指定 secret 进行使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器查看指定目录，找到 manager 通过 Raft Database 保存的 secret</span></span><br><span class="line">docker service create -d --name client \</span><br><span class="line">  --secret my-file-pw busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls </span><br><span class="line">docker service ps client</span><br><span class="line">docker ps</span><br><span class="line">docker exec -it &lt;client_container_id&gt; sh</span><br><span class="line">  cd /run/secrets/</span><br><span class="line">  ls</span><br><span class="line">  cat my-file-pw # 原文</span><br><span class="line"><span class="meta">#</span><span class="bash"> 实际使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建 service 的时候指定好 secret，并在环境变量中指定在容器中的位置</span></span><br><span class="line">docker service create -d --name db \</span><br><span class="line">  --secret my-file-pw \ </span><br><span class="line">  -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-file-pw mysql</span><br><span class="line">docker service ps db</span><br><span class="line">--</span><br><span class="line">docker exec -it &lt;db_container_id&gt; sh</span><br><span class="line">ls /run/secrets</span><br><span class="line">cat /run/secrets/my-file-pw</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>



<p><strong>在 Stack 中的使用</strong></p>
<p>在服务配置下增加 secrets，指定对应的 Secret</p>
<p>对应的密码参数使用指定的 secrets 在容器中的位置</p>
<p>可以连通创建 secret 一起使用，不建议</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 简化 --compose-file </span></span><br><span class="line"><span class="comment"># 查看服务是否全部启动完成</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stack</span> <span class="string">deploy</span> <span class="string">wordpress</span> <span class="string">\</span></span><br><span class="line">  <span class="string">-c=docker-compose.yml</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stack</span> <span class="string">services</span> <span class="string">wordpress</span></span><br></pre></td></tr></table></figure>



<h2 id="Docker-Service-更新"><a href="#Docker-Service-更新" class="headerlink" title="Docker Service 更新"></a>Docker Service 更新</h2><blockquote>
<p>在运行过程中对 service 依赖的镜像进行升级，实现升级过程中不会中断原来的服务</p>
</blockquote>
<h3 id="单-Service-更新"><a href="#单-Service-更新" class="headerlink" title="单 Service 更新"></a>单 Service 更新</h3><p>进行 service 的更新，不会暂停运行的项目</p>
<p>@Q: 存在一段时间有 1.0和2.0并存的情况，如何处理??</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络，启动服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待服务启动完毕</span></span><br><span class="line">docker network create -d overlay net-demo</span><br><span class="line">docker network ls</span><br><span class="line">docker service create -d --name web \</span><br><span class="line">  --publish 8080:5000 \</span><br><span class="line">  --network net-demo</span><br><span class="line">  janhen/python-flask-demo:1.0.0</span><br><span class="line">docker service ps web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查服务运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写测试脚本方便验证</span></span><br><span class="line">docker service scale web=2</span><br><span class="line">docker service ps web</span><br><span class="line">curl 127.0.0.1:8080</span><br><span class="line">sh -c &quot;while true; do curl 127.0.0.1:8080&amp;&amp;sleep 1; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新镜像，一般通过 Dockerfile 进行构建，指定对应更新的版本，发布到私有 registry</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行环境拉取镜像，执行更新命令</span></span><br><span class="line">docker service update --image janehn/python-plask-demo:2.0.0 web</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新镜像并设置参数, 覆盖 docker-compose.yml</span></span><br><span class="line">docker service update --image westos.org/game2048 \</span><br><span class="line">  --update-parallelism 10 \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>



<h3 id="端口更新"><a href="#端口更新" class="headerlink" title="端口更新"></a>端口更新</h3><blockquote>
<p> 对 service 与宿主机的端口映射进行更改</p>
</blockquote>
<p>删除掉原来的端口映射，无法做到更新时业务不中断，通过 VIP + 端口实现原理导致的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service update --publish-rm 8080:500 \</span><br><span class="line">  --publish-add 8088:5000 web</span><br></pre></td></tr></table></figure>



<h3 id="Stack-更新"><a href="#Stack-更新" class="headerlink" title="Stack 更新"></a>Stack 更新</h3><blockquote>
<p>更改 Swarm Cluster 中多个容器中对于镜像、网络、部署配置的更新，关联 <service>.deploy.update_config 下的配置</p>
</blockquote>
<p>可更改 docker-compose.yml 中 deploy 下的 update_config 控制更新时的细节，允许几个 scale 进行更新，延迟信息。。。</p>
<p>第一次通过 deploy 进行启动进行了多 service 的部署</p>
<p>第二次通过 deploy 部署时，自动检测到 docker-compose.yml 的变化，进行更新    </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy wordpress --compose-file docker-compose.yml </span><br></pre></td></tr></table></figure>



<h2 id="Docker-Swarm-监控"><a href="#Docker-Swarm-监控" class="headerlink" title="Docker Swarm 监控"></a>Docker Swarm 监控</h2><blockquote>
<p>实现对 Docker Swarm Cluster 中运行节点上容器的监控</p>
</blockquote>
<h3 id="CAdvisor-InfluxDB-Grafana"><a href="#CAdvisor-InfluxDB-Grafana" class="headerlink" title="CAdvisor+InfluxDB+Grafana"></a>CAdvisor+InfluxDB+Grafana</h3><blockquote>
<p>docker swarm集群的监控方案，开源免费</p>
<p>cAdvisor：数据收集模块，需要部署在集群中的每一个节点上，当然前提条件是节点接受task。</p>
<p>InfluxDB：数据存储模块</p>
<p>Grafana：数据展示模块</p>
</blockquote>
<p><strong>Docker Universal Control Plane(UCP)</strong></p>
<blockquote>
<p>docker原厂的可视化集群管理GUI，企业级的，只支持docker EE</p>
</blockquote>
<p><strong>portainer</strong></p>
<blockquote>
<p>在集群中部署portainer的service，只能被调度给manager角色的节点</p>
<p>关联： <a target="_blank" rel="noopener" href="https://www.portainer.io/">Web</a></p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Daemon-配置"><a href="#Daemon-配置" class="headerlink" title="Daemon 配置"></a>Daemon 配置</h2><blockquote>
<p>对容器的 dockerd 守护线程进行配置</p>
<p>关联： <a target="_blank" rel="noopener" href="https://docs.docker.com/config/daemon/">Configure the daemon</a></p>
</blockquote>
<p><strong>dameon.json</strong> </p>
<p>配置文件编写：</p>
<p>源镜像地址配置</p>
<p>私有源非 Https 配置</p>
<p>Debug 模式开启</p>
<p><code>/etc/docker/daemon.json</code></p>
<p>ip: 永久绑定到某个固定的 IP 地址</p>
<p>bridge： 将 Docker 默认桥接到创建的网桥上</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://reg-mirror.qiniu.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.17.11.29:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;172.17.11.29:5111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;192.168.205.23:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;192.168.205.23:5111&quot;</span>,</span><br><span class="line">     <span class="string">&quot;172.17.10.150:80&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span>: <span class="string">&quot;bridge-my&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更改后使其生效</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service</span><br><span class="line">sudo systemctl status docker -l</span><br><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>



<p><strong>设置运行时目录，存储驱动</strong></p>
<p><strong>设置 Http/Https 代理</strong></p>
<p>加快拉取国外访问、处理国内制作镜像无法访问国外资源问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加配置</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"></span><br><span class="line">[Service]    </span><br><span class="line">Environment=&quot;HTTP_PROXY=https://172.17.10.18:5720/&quot; &quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置生效</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置</span></span><br><span class="line">rm -f /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/admin/systemd/#/http-proxy">Docker systemd http-proxy</a> </p>
<h2 id="监控与管理"><a href="#监控与管理" class="headerlink" title="监控与管理"></a>监控与管理</h2><blockquote>
<p>人工进行容器的管理、<strong>监控</strong>、资源调整、<strong>故障排除</strong>，包括日志查看、容器实时运行情况、资源重分配，在无法使用或没有监控方案情况下使用</p>
</blockquote>
<p><strong>dockerd 支持</strong></p>
<blockquote>
<p>在发生故障后，通过设置 Docker 守护线程的一些参数方便调试</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启守护线程的 debug 模式，给出更多的信息提示</span></span><br><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.169.9.2:2376</span><br></pre></td></tr></table></figure>



<p><strong>容器的运行日志查看</strong></p>
<p>使用 Go 模板尽心格式化日志输出</p>
<p>可使用日志驱动程序插件，企业版支持统一格式查看远程的日志，默认双重日志</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/config/formatting/">Format command and log output</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $&#123;CID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个镜像对应的全部容器</span></span><br><span class="line">docker container ls | grep &lt;image&gt; | awk &#x27;&#123;print $1&#125;</span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&#x27; &lt;CONTAINER&gt;</span><br><span class="line">docker logs -f &lt;container_id&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 Go 的模板语法进行格式化展示数据</span></span><br><span class="line">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<p><strong>容器日志</strong></p>
<blockquote>
<p>在 daemon 中的日志配置，根据实际需要进行优化，可选择日志插件</p>
</blockquote>
<p>指定容器日志最大大小                20M</p>
<p>最大的文件个数                            5</p>
<p>压缩，                                           开</p>
<p><strong>容器的运行情况</strong></p>
<blockquote>
<p>通过 stats 实时查看容器的资源信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实时查看容器统计信息，CPU、内存、网络、磁盘</span></span><br><span class="line">docker stats 13b9203f9f0b d42877298134 44fb90cd2f2c</span><br><span class="line">docker container stats --format &quot;table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<p><strong>容器的资源分配</strong></p>
<blockquote>
<p>容器使用多少宿主机的资源，可以通过 docker-compose.yml 中设置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过参数限定容器访问内存、CPU</span></span><br><span class="line">docker run --help | grep cpu </span><br><span class="line">docker run --help | grep memory</span><br></pre></td></tr></table></figure>



<p><strong>容器可用性</strong></p>
<p>容器支持重启，可以通过 <code>--restart</code> 指定重启策略，保证可用性</p>
<p><strong>容器网络</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有网络</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络映射</span></span><br><span class="line">docker port nostalgic_morse 5000</span><br></pre></td></tr></table></figure>



<p><strong>.dockerignore</strong> </p>
<p>针对非 SpringBoot 项目，如前端项目需要忽略一些文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>



<p><strong>默认的重要文件：</strong></p>
<p>/var/run/docker.sock</p>
<p>/var/lib/docker/volumes/<volume_name OR long_uuid></p>
<h2 id="Docker-卸载"><a href="#Docker-卸载" class="headerlink" title="Docker 卸载"></a><strong>Docker 卸载</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止并删除容器</span></span><br><span class="line">docker rm -f `docker ps -aq`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除安装</span></span><br><span class="line">yum list installed|grep docker</span><br><span class="line"> yum -y remove docker-ce.x86_64</span><br><span class="line"> yum -y remove docker-ce-cli.x86_64</span><br><span class="line"> yum -y remove containerd.io.x86_64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有镜像、Volume删除</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除 docker-compose</span></span><br><span class="line"> rm -rf /var/lib/docker</span><br><span class="line"> rm -rf /hdapp</span><br><span class="line"> rm -rf /etc/docker</span><br><span class="line"> rm -f /usr/local/bin/docker-compose</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 测试卸载情况</span></span><br><span class="line"> yum list installed|grep docker</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除 docker0 网卡</span></span><br><span class="line"> yum install bridge-utils</span><br><span class="line"> ip link set dev docker0 down</span><br><span class="line"> brctl delbr docker0</span><br></pre></td></tr></table></figure>



<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><a target="_blank" rel="noopener" href="https://jiajially.gitbooks.io/dockerguide/content/dockerIND.html">Docker-guide</a>: 中文的 GitBook</p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">官方镜像示例</a>： Docker Hub 中一些镜像的开源示例</p>
<p><a target="_blank" rel="noopener" href="https://labs.play-with-docker.com/p/blga8164315g00e59gs0">play-with-docker</a> ： 方便环境搭建， 保存 docker 4h，在网站上创建多个网络，进行互通访问</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53260098">10分钟看懂Docker和K8S</a>： 快速入门</p>
<p><a target="_blank" rel="noopener" href="https://zhuyasen.com/post/docker_note.html">docker学习笔记</a>： 他人博客笔记</p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/">Docker – 从入门到实践</a></p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/appendix/debug.html">如何调试 Docker</a>： 总结调试方法</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/21d66ca6115e">关于对docker run –link的理解</a>： Docker 桥接网络理解</p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/advanced_network/e">工具和示例</a>： Docker 相关工具</p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html#dockerfile-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">Dockerfile 最佳实践</a>： 编写 Dockerfile 的一些建议 </p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/12227558/2096290">CentOS7.4—构建LVS+Keepalived高可用群集</a>： LVS </p>
<p><a target="_blank" rel="noopener" href="https://www.centos.bz/2018/02/docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/">docker镜像操作</a>： 容器制作、本地导入、镜像导出</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckm733ru5002iivvx5usl7qdw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/" rel="tag">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hive/" rel="tag">Hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Hadoop/" style="font-size: 17.5px;">Hadoop</a> <a href="/tags/Hive/" style="font-size: 20px;">Hive</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/Scala/" style="font-size: 12.5px;">Scala</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/">Hive-基础</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-%E4%BC%98%E5%8C%96/">Hive-优化</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-%E5%87%BD%E6%95%B0/">Hive-函数</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-HQL/">Hive-HQL</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>