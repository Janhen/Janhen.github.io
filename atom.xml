<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Janhen</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-07T07:52:38.829Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Janhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spark-数据倾斜</title>
    <link href="http://example.com/2021/05/07/Spark-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/"/>
    <id>http://example.com/2021/05/07/Spark-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/</id>
    <published>2021-05-07T07:45:41.000Z</published>
    <updated>2021-05-07T07:52:38.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数据倾斜： Task 之间数据分配的非常不均匀</p><p><strong>DataSkew 的原因：</strong></p><p>数据倾斜一般发生在 shuffle 过程中。</p><ul><li>数据异常： key 有大量的空值/默认值</li><li>Map Task 数据倾斜<ul><li>数据文件大小不一致，数据压缩格式不可切分</li><li>接收的数据源，如 Kafka 对应的数据分区不均匀</li></ul></li><li>Reduce task 数据倾斜：<ul><li>数据存在很多空值或缺省值</li><li>Shuffle： 外因，Shuffle 操作涉及到大量的磁盘、网络 IO 、对作业型任务影响极大</li><li>Key 分布不均匀： 内部原因</li><li>Shuffle + Key 分布不均匀(主因)：</li></ul></li></ul><p>主要原因为 shuffle + key 分布不均</p><p><strong>DataSkew 问题定位：</strong></p><ul><li>了解数据 key 的分布情况</li><li>一般通过 Spark Web UI 或其他监控方式出现的异常来进行综合判断</li><li>查看代码中可能导致 shuffle 的算子出现</li></ul><p><strong>DataSkew 的影响:</strong></p><ul><li>OutOfMemory，某个 Task 莫名出现内存移除情况, 一般情况下，OOM 的原因都是数据倾斜</li><li>某个 Task 执行特别慢, 大量数据交由一个 Task 处理，拖累整个程序</li><li>Shuffle 过程报错</li></ul><h3 id="数据倾斜处理"><a href="#数据倾斜处理" class="headerlink" title="数据倾斜处理"></a>数据倾斜处理</h3><ul><li><p>数据的预处理：</p><ul><li>过滤空值/默认值，filter + coalesce</li><li>小区数据源带来的数据倾斜</li></ul></li><li><p><strong>避免 Shuffle:</strong> 通过程序避免使用 shuffle 的算子完成相应的任务，通过改写程序实现。</p></li><li><p>减少 Shuffle 过程中的数量</p><ul><li>使用 groupBy –&gt; reduceByKey / aggregateByKey</li><li>通过 Map 端的 Join 来减少</li></ul></li><li><p>选择新的可用于聚合/join 的 key</p><ul><li>根据业务，选择新的 key 去做聚合或 join。可尝试使用更细的维度。</li></ul></li><li><p><strong>改变 reduce 的并行度:</strong> 一般情况下不管用，数据倾斜可能是由很多 key 造成的</p></li><li><p>加盐强行打散 Key:</p><p> 处理 ****shuffle + key 不能分散。</p><ul><li>为数据量特别大的 Key 增加随机前/后缀，使得原来 Key 相同的数据变为 Key 不相同的数据，从而使倾斜的数据集分散到不同的 Task 中，彻底解决数据倾斜问题。</li></ul></li><li><p><strong>自定义 Partitioner</strong>: 使用自定义的 Partitioner，将原本被分配到同一个 Task 的不同 Key 分配到不同 Task。</p></li></ul><h3 id="加盐打散-Key"><a href="#加盐打散-Key" class="headerlink" title="加盐打散 Key"></a><strong>加盐打散 Key</strong></h3><p><strong>两阶段聚合</strong></p><p>不能改变原来的结果</p><ul><li>对于聚合类的 shuffle 操作导致的数据倾斜，效果较好。一般可以解决掉 DataSkew，将 Spark 作业的性能提升数倍以上。</li><li>仅适用于聚合类的 shuffle 操作，适用范围相对较窄。如果是 join 类的 shuffle 操作，需要选择其他的解决方案。</li></ul><p>执行步骤：</p><ul><li>加盐打散 key。给每个 key 都加一个随机数，如 10 以内的随机数。此时 key 就被打散了</li><li>局部聚合。对打上随机数的数据，执行一次聚合操作，得到结果</li><li>全局聚合。将各个 key 的前缀去掉，再进行一次聚合操作，得到最终结果</li></ul><p><strong>采样倾斜 key 并拆分 join 操作</strong></p><p>使用场景：计算两个 RDD /两张表中的 key 分布情况。如果出现数据倾斜，是其中一个 RDD/Hive 表中的<strong>少数几个 key 的数据量过大</strong>，而另一个 RDD/Hive 表中的所有 key 都分布比较均匀，那么采用这个解决方案比较合适。</p><p>处理步骤：</p><p>1、对包含少数几个数据量过大的 key 的那个 RDD，通过 sample 算子采样出一份样本来，然后统计一下每个 key 的数量，计算出数据量最大的是哪几个 key；</p><p>2、将这几个 key 对应的数据从原来的 RDD 中拆分出来，形成一个单独的 RDD，并给每个 key 都打上 n 以内的随机数作为前缀，而不会导致倾斜的大部分 key 形成另外一个 RDD；</p><p>3、将需要 join 的另一个 RDD，也过滤出来那几个倾斜 key 对应的数据并形成一个单独的 RDD，将每条数据膨胀成 n 条数据，这 n 条数据都按顺序附加一个 0~n 的前缀，不会导致倾斜的大部分 key 也形成另外一个 RDD；</p><p>4、再将附加了随机前缀的独立 RDD 与另一个膨胀 n 倍的独立 RDD 进行 join，此时就可以将原先相同的 key 打散成 n 份，分散到多个 task 中去进行 join 了；</p><p>5、另外两个普通的 RDD 就照常 join 即可；</p><p>6、最后将两次 join 的结果使用 union 算子合并起来即可，就是最终的 join 结果。</p><p><strong>使用随机前缀和扩容再进行 join</strong></p><p>业务场景：如果在进行 join 操作时，RDD 中有大量的 key 导致数据倾斜，进行分拆 key 没什么意义，此时就只能使用最后一种方案来解决问题了。 处理步骤：</p><p>1、选一个 RDD，将每条数据都打上一个 n 以内的随机前缀(打散)</p><p>2、对另外一个 RDD 进行扩容，将每条数据都扩容成 n 条数据，扩容出来的每条数据都依次打上一个 0~n 的前缀</p><p>3、将两个处理后的 RDD 进行 join 即可</p><p>扩容保证能正常 join 的执行</p><p>使用注意事项：</p><ul><li>如果两个 RDD 都很大，那么将 RDD 进行 N 倍的扩容显然行不通</li><li>使用扩容的方式通常能缓解数据倾斜，不能彻底解决数据倾斜问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据倾斜&quot;&gt;&lt;a href=&quot;#数据倾斜&quot; class=&quot;headerlink&quot; title=&quot;数据倾斜&quot;&gt;&lt;/a&gt;数据倾斜&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark-Shuffle 过程和原理</title>
    <link href="http://example.com/2021/05/05/Spark-Shuffle%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/05/05/Spark-Shuffle%E8%BF%87%E7%A8%8B/</id>
    <published>2021-05-05T08:55:56.000Z</published>
    <updated>2021-05-05T09:18:41.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><p><strong>按照一定的规则对数据重新分区的过程就是 Shuffle。</strong>需要 Shuffle 是因为某种具有共同特征的数据汇聚到一个计算节点上进行计算。</p><p>Shuffle 过程中包含了许多低效的操作，包括磁盘 IO、序列化、网络数据传输等。</p><p><strong>Shuffle 分类</strong></p><ul><li>Hash Shuffle V1<ul><li>两个严重问题：生成大量文件，占用文件描述符，同时引入 DiskObjectWriter 带来的 Writer Handler 的缓存也非常消耗内存。如果在 Reduce Task 时需要合并操作的话，会把数据放在一个 HashMap 中进行合并，如果数据量较大，很容易引发 OOM</li></ul></li><li>Hash Shuffle V2<ul><li>在 v1 基础上引入 File Consolidation</li><li>一个 Executor 上所有的 Map Task 生成的分区文件只有一份，即将所有的 Map Task 相同的分区文件合并，这样每个 Executor 上最多只生成 N 个分区文件。</li></ul></li><li>Sort Shuffle V1<ul><li>每个 Task 不会为后续的每个 Task 创建单独的文件，而是将所有对结果写入同一个文件。该文件中的记录首先是按照 Partition Id 排序，每个 Partition 内部再按照 Key 进行排序，Map Task 运行期间会顺序写每个 Partition 的数据，同时生成一个索引文件记录每个 Partition 的大小和偏移量。</li><li>在 Reduce 阶段，Reduce Task 拉取数据做 Combine 时不再采用 HashMap，而是采用 <strong>ExternalAppendOnlyMap</strong>，该数据结构在做 Combine 时，如果内存不足，会刷写磁盘，避免(AppendOnlyMap)大数据情况下的 OOM。</li><li>Sort Shuffle 解决了 Hash Shuffle 的所有弊端，但是因为需要其 Shuffle 过程需要对记录进行排序，所以在性能上有所损失。</li></ul></li><li>Tungsten-Sort Based Shuffle(Unsafe Shuffle)<ul><li>1.5+ 后开始钨丝计划，优化内存和 CPU 的使用，使用了堆外内存进一步提升 Spark 的性能。</li><li>将数据记录用二进制的方式存储，直接在序列化的二进制数据上 Sort 而不是在 Java 对象上。减少内存的使用和 GC 的开销，避免 Shuffle 过程中频繁的序列化以及反序列化。</li><li>排序过程中，提供 cache-efficient sorter，使用一个 8 bytes 的指针，把排序转化成了一个指针数组的排序，极大的优化了排序性能。</li><li>使用要求：<ul><li>Shuffle 阶段不能有 aggregate 操作，对于 aggretateByKey 之类的算子无法使用。</li><li>分区数不能超过 2^24</li><li>序列化支持 relocation，如 kyro 序列化</li></ul></li></ul></li><li>Sort Shuffle V2<ul><li>Spark1.6+，把 Sort Shuffle 和 Tungsten-Sort Based Shuffle 全部统一到 Sort Shuffle 中，如果检测到满足 Tungsten-Sort Based Shuffle 条件会自动采用 Tungsten-Sort Based Shuffle，否则采用 Sort Shuffle。</li><li>sort-based shuffle 的缺陷<ul><li>mapper 的 Task 数量过大，依旧会产生大量小文件，此时在 shuffle 传递数据的过程中 reducer 端，reduce 会需要同时大量的记录进行反序列化，导致大量的内存消耗和 GC 的巨大负担，造成系统缓慢甚至崩溃。</li><li>如果需要在分片内也进行排序，此时需要进行 mapper 端和 reducer 端的两次排序。</li></ul></li></ul></li></ul><h3 id="ShuffleWriter-执行流程"><a href="#ShuffleWriter-执行流程" class="headerlink" title="ShuffleWriter 执行流程"></a>ShuffleWriter 执行流程</h3><ol><li><strong>数据先写入一个内存数据结构中。</strong>不同的 shuffle 算子，可能选用不同的数据结构<ul><li>如果是 reduceByKey 聚合类的算子，选用 Map(ExternalAppendOnlyMap) 数据结构，一边通过 Map 进行聚合，一边写入内存</li><li>如果是 join 类的 shuffle 算子，那么选用 Array(CompactBuffer) 数据结构，直接写入内存</li></ul></li><li><strong>检查是否达到内存阈值。</strong>每写一条数据进入内存数据结构之后，就会判断一下，是否达到了某个临界阈值。如果达到临界阈值的话，那么就会将内存数据结构中的数据溢写到磁盘，并清空内存数据结构</li><li><strong>数据排序。</strong>在溢写到磁盘文件之前，会先根据 key 对内存数据结构中已有的数据进行排序。排序过后，会分批将数据写入磁盘文件。默认的 batch 数量是 10000 条，也就是说，排序好的数据，会以每批 1 万条数据的形式分批写入磁盘文件</li><li><strong>数据写入缓冲区</strong>。写入磁盘文件是通过 Java 的 BufferedOutputStream 实现的。BufferedOutputStream 是 Java 的缓冲输出流，首先会将数据缓冲在内存中，当内存缓冲满溢之后再一次写入磁盘文件中，这样可以减少磁盘 IO 次数，提升性能</li><li><strong>重复写多个临时文件</strong>。一个 Task 将所有数据写入内存数据结构的过程中，会发生多次磁盘溢写操作，会产生多个临时文件</li><li><strong>临时文件合并</strong>。最后将所有的临时磁盘文件进行合并，这就是 merge 过程。此时会将之前所有临时磁盘文件中的数据读取出来，然后依次写入最终的磁盘文件之中写索引文件。由于一个 Task 就只对应一个磁盘文件，也就意味着该 task 为下游 stage 的 task 准备的数据都在这一个文件中，因此还会单独写一份索引文件，其中标识了下游各个 Task 的数据在文件中的 start offset 与 end offset。</li></ol><h3 id="SortShuffleManager"><a href="#SortShuffleManager" class="headerlink" title="SortShuffleManager"></a>SortShuffleManager</h3><p>当前 ShuffleManager 唯一实现类。在基于排序的 shuffle 中，传入记录根据其目标分区 id 进行排序，然后写入单个映射输出文件。Reducers 获取这个文件的连续区域，以便读取映射输出中属于它们的部分。在 map 输出数据太大而无法装入内存的情况下，可以将输出的排序子集溢出到磁盘，并合并那些磁盘上的文件以生成最终的输出文件。</p><ul><li>getReader(): 返回读取 shuffle 过程的数据的 reader，当前使用的位置<ul><li>当前获取的位置： CoGroupedRDD、ShuffledRDD、SubtractedRDD、ShuffledRowRDD</li></ul></li><li>getWriter(): 根据条件判断选择哪种 ShuffleWriter，可选择 BypassMergeSortShuffleWriter, UnsafeShuffleWriter, SortShuffleWriter</li><li>registerShuffle(): 注册 shuffle</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">SortShuffleManager</span>(<span class="params">conf: <span class="type">SparkConf</span></span>) <span class="keyword">extends</span> <span class="title">ShuffleManager</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A mapping from shuffle ids to the number of mappers producing output for those shuffles.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> numMapsForShuffle = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> shuffleBlockResolver = <span class="keyword">new</span> <span class="type">IndexShuffleBlockResolver</span>(conf)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Obtains a [[ShuffleHandle]] to pass to tasks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">registerShuffle</span></span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>](</span><br><span class="line">      shuffleId: <span class="type">Int</span>,</span><br><span class="line">      numMaps: <span class="type">Int</span>,</span><br><span class="line">      dependency: <span class="type">ShuffleDependency</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>]): <span class="type">ShuffleHandle</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">SortShuffleWriter</span>.shouldBypassMergeSort(conf, dependency)) &#123;</span><br><span class="line">      <span class="comment">// 小于 bypassMerge(spark.shuffle.sort.bypassMergeThreshold) 的阈值分区数，不需要 map 端的聚合，</span></span><br><span class="line">      <span class="comment">// 然后直接写入MnumPartitions 文件，并在最后将它们连接起来。这避免了两次序列化和反序列化来合并溢出的文件，缺点是一次打开多个文件，从而分配给缓冲区更多的内存</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">BypassMergeSortShuffleHandle</span>[<span class="type">K</span>, <span class="type">V</span>](</span><br><span class="line">        shuffleId, numMaps, dependency.asInstanceOf[<span class="type">ShuffleDependency</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">V</span>]])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">SortShuffleManager</span>.canUseSerializedShuffle(dependency)) &#123;</span><br><span class="line">      <span class="comment">// 尝试以序列化的形式缓冲映射输出，因为这样更有效率</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">SerializedShuffleHandle</span>[<span class="type">K</span>, <span class="type">V</span>](</span><br><span class="line">        shuffleId, numMaps, dependency.asInstanceOf[<span class="type">ShuffleDependency</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">V</span>]])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 缓冲区映射以反序列化形式输出</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">BaseShuffleHandle</span>(shuffleId, numMaps, dependency)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取一系列 reduce 分区的读取器(startPartition 到 endPartition-1，包括在内)。通过 reduce 任务调用 executor。</span></span><br><span class="line"><span class="comment">   * 当前使用到的位置：</span></span><br><span class="line"><span class="comment">   * - CoGroupedRDD</span></span><br><span class="line"><span class="comment">   * - ShuffledRDD</span></span><br><span class="line"><span class="comment">   * - SubtractedRDD</span></span><br><span class="line"><span class="comment">   * - ShuffledRowRDD</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getReader</span></span>[<span class="type">K</span>, <span class="type">C</span>](</span><br><span class="line">      handle: <span class="type">ShuffleHandle</span>,</span><br><span class="line">      startPartition: <span class="type">Int</span>,</span><br><span class="line">      endPartition: <span class="type">Int</span>,</span><br><span class="line">      context: <span class="type">TaskContext</span>): <span class="type">ShuffleReader</span>[<span class="type">K</span>, <span class="type">C</span>] = &#123;</span><br><span class="line">    <span class="comment">// shuffle 过程的 reader, 当前 ShuffleReader 的唯一实现类</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">BlockStoreShuffleReader</span>(</span><br><span class="line">      handle.asInstanceOf[<span class="type">BaseShuffleHandle</span>[<span class="type">K</span>, _, <span class="type">C</span>]], startPartition, endPartition, context)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取给定分区的写入器。通过 map 任务调用 executor</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getWriter</span></span>[<span class="type">K</span>, <span class="type">V</span>](</span><br><span class="line">      handle: <span class="type">ShuffleHandle</span>, <span class="comment">// 根据传入的 ShuffleHandle 获取到</span></span><br><span class="line">      mapId: <span class="type">Int</span>,</span><br><span class="line">      context: <span class="type">TaskContext</span>): <span class="type">ShuffleWriter</span>[<span class="type">K</span>, <span class="type">V</span>] = &#123;</span><br><span class="line">    numMapsForShuffle.putIfAbsent(</span><br><span class="line">      handle.shuffleId, handle.asInstanceOf[<span class="type">BaseShuffleHandle</span>[_, _, _]].numMaps)</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">SparkEnv</span>.get</span><br><span class="line">    handle <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// 序列化的 Shuffle 处理，使用 UnsafeShuffleWriter</span></span><br><span class="line">      <span class="keyword">case</span> unsafeShuffleHandle: <span class="type">SerializedShuffleHandle</span>[<span class="type">K</span> <span class="meta">@unchecked</span>, <span class="type">V</span> <span class="meta">@unchecked</span>] =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">UnsafeShuffleWriter</span>(</span><br><span class="line">          env.blockManager,</span><br><span class="line">          shuffleBlockResolver.asInstanceOf[<span class="type">IndexShuffleBlockResolver</span>],</span><br><span class="line">          context.taskMemoryManager(),</span><br><span class="line">          unsafeShuffleHandle,</span><br><span class="line">          mapId,</span><br><span class="line">          context,</span><br><span class="line">          env.conf)</span><br><span class="line">      <span class="comment">// 跳过 mergeSort 的 shuffle 处理</span></span><br><span class="line">      <span class="keyword">case</span> bypassMergeSortHandle: <span class="type">BypassMergeSortShuffleHandle</span>[<span class="type">K</span> <span class="meta">@unchecked</span>, <span class="type">V</span> <span class="meta">@unchecked</span>] =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">BypassMergeSortShuffleWriter</span>(</span><br><span class="line">          env.blockManager,</span><br><span class="line">          shuffleBlockResolver.asInstanceOf[<span class="type">IndexShuffleBlockResolver</span>],</span><br><span class="line">          bypassMergeSortHandle,</span><br><span class="line">          mapId,</span><br><span class="line">          context,</span><br><span class="line">          env.conf)</span><br><span class="line">      <span class="comment">// 通用的 ShuffleWriter 处理</span></span><br><span class="line">      <span class="keyword">case</span> other: <span class="type">BaseShuffleHandle</span>[<span class="type">K</span> <span class="meta">@unchecked</span>, <span class="type">V</span> <span class="meta">@unchecked</span>, _] =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">SortShuffleWriter</span>(shuffleBlockResolver, other, mapId, context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">object</span> <span class="title">SortShuffleManager</span> <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在以序列化形式缓冲映射输出时 SortShuffleManager 支持的最大 shuffle 输出分区数。</span></span><br><span class="line"><span class="comment">   * 这是一种极端的防御性编程措施，因为一次 shuffle 极不可能产生超过 1600 万个输出分区。</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MAX_SHUFFLE_OUTPUT_PARTITIONS_FOR_SERIALIZED_MODE</span> =</span><br><span class="line">    <span class="type">PackedRecordPointer</span>.<span class="type">MAXIMUM_PARTITION_ID</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于确定 shuffle 是否可使用优化的序列化 shuffle path 是否应该退回到对反序列化对象进行操作的 original path</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canUseSerializedShuffle</span></span>(dependency: <span class="type">ShuffleDependency</span>[_, _, _]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> shufId = dependency.shuffleId</span><br><span class="line">    <span class="keyword">val</span> numPartitions = dependency.partitioner.numPartitions</span><br><span class="line">    <span class="comment">// 需要依赖对应的序列化器支持 relocation</span></span><br><span class="line">    <span class="keyword">if</span> (!dependency.serializer.supportsRelocationOfSerializedObjects) &#123;</span><br><span class="line">      log.debug(<span class="string">s&quot;Can&#x27;t use serialized shuffle for shuffle <span class="subst">$shufId</span> because the serializer, &quot;</span> +</span><br><span class="line">        <span class="string">s&quot;<span class="subst">$&#123;dependency.serializer.getClass.getName&#125;</span>, does not support object relocation&quot;</span>)</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dependency.mapSideCombine) &#123;</span><br><span class="line">      <span class="comment">// 不可为 MapSideCombine</span></span><br><span class="line">      log.debug(<span class="string">s&quot;Can&#x27;t use serialized shuffle for shuffle <span class="subst">$shufId</span> because we need to do &quot;</span> +</span><br><span class="line">        <span class="string">s&quot;map-side aggregation&quot;</span>)</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numPartitions &gt; <span class="type">MAX_SHUFFLE_OUTPUT_PARTITIONS_FOR_SERIALIZED_MODE</span>) &#123;    <span class="comment">// 2^24</span></span><br><span class="line">      <span class="comment">// 分区数小于 2^24</span></span><br><span class="line">      log.debug(<span class="string">s&quot;Can&#x27;t use serialized shuffle for shuffle <span class="subst">$shufId</span> because it has more than &quot;</span> +</span><br><span class="line">        <span class="string">s&quot;<span class="subst">$MAX_SHUFFLE_OUTPUT_PARTITIONS_FOR_SERIALIZED_MODE</span> partitions&quot;</span>)</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.debug(<span class="string">s&quot;Can use serialized shuffle for shuffle <span class="subst">$shufId</span>&quot;</span>)</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-Hadoop-Shuffle-的比较"><a href="#与-Hadoop-Shuffle-的比较" class="headerlink" title="与 Hadoop Shuffle 的比较"></a>与 Hadoop Shuffle 的比较</h3><p>二者从功能上看是相似的；从 High Level来看，没有本质区别。</p><ul><li><strong>何时进行 fetch Map 端的数据</strong>： Hadoop 中有一个 Map 完成，Reduce 便可以去 fetch 数据了，MR Shuffle 不必等到所有 Map 任务完成；而 Spark shuffle 必须等到父 stage 完成，也就是父 stage 的 map 操作全部完成才能去 fetch 数据。这是因为 spark 必须等到父 stage 执行完，才能执行子 stage，主要是为了迎合 stage 规则</li><li><strong>何时执行 Reduce 端的聚合：</strong> Hadoop 的 Reduce 要等到 fetch 完全部数据，才将数据传入 reduce 函数进行聚合，Spark 是一边 fetch 一边聚合。</li><li><strong>分区有序的要求：</strong> Hadoop 的 Shuffle 是 sort-base 的，那么不管是 Map 的输出，还是 Reduce 的输出，都是 partition 内有序的，而 spark 不要求 partition 内有限</li></ul><h3 id="Shuffle-Writer"><a href="#Shuffle-Writer" class="headerlink" title="Shuffle Writer"></a>Shuffle Writer</h3><p><strong>BypassMergeSortShuffleWriter</strong></p><blockquote><p>与 Hash Shuffle 的实现基本相同，区别在于 map task 输出汇总一个文件，同时还会产生一个 index file</p></blockquote><p>特点：</p><ul><li>类似于Hash Shuffle，多了文件的合并</li><li>对于大量 reduce 分区的 shuffle，是低效的，因为同时为所有分区打开单独的序列化器和文件流</li></ul><p>Writer 流程：</p><ul><li>每个 Map Task 为每个下游 reduce task 创建一个临时磁盘文件，并将数据按 key 进行 hash 然后根据 hash 值写入内存缓冲，缓冲写满之后再溢写到磁盘文件；</li><li>最后将所有临时磁盘文件都合并成一个磁盘文件，并创建索引文件；</li><li>在 shuffle 过程中会创建很多磁盘文件，最后多了一个磁盘文件合并的过程。Shuffle Read 的性能会更好；</li></ul><p>Bypass 方式与普通的 Sort Shuffle 方式的不同点：</p><ul><li>磁盘写机制不同</li><li>根据 key 求 hash，减少了数据排序操作，提高了性能</li></ul><p>选择条件：</p><ul><li>分区数 &lt;=200(spark.shuffle.sort.bypassMergeThreshold)</li><li>非聚合操作</li><li>没有指定排序</li><li>不是 mapSideCombine</li></ul><p><strong>UnsafeShuffleWriter</strong></p><p>序列化的排序方式： 在序列化排序模式中，传入的记录一旦传递给 shuffle 写入器就会被序列化，并在排序期间以序列化的形式进行缓冲。</p><p>序列化排序方式的优化：</p><ul><li>它的排序操作是序列化的二进制数据，而不是 Java 对象，这减少了内存消耗和 GC 开销。此优化要求记录序列化器具有某些属性，以允许在不反序列化的情况下重新排序序列化的记录。</li><li>它使用专用的高效缓存排序器([[ShuffleExternalSorter]])对压缩记录指针和分区id数组进行排序。通过在排序数组中每条记录只使用 8 个字节的空间，这可以将更多的数组放入缓存中</li><li>spill 合并过程对属于同一分区的序列化记录块进行操作，合并过程中不需要反序列化记录。</li><li>当 spill 压缩编解码器支持连接压缩数据时，spill merge 只是将序列化的 spill 分区和压缩的 spill 分区连接起来，以产生最终的输出分区。这允许使用高效的数据复制方法，如 NIO 的 transferTo，并避免了在合并期间分配解压缩缓冲区或复制缓冲区的需要。</li></ul><p>选择条件：</p><ul><li>shuffle 序列化器支持 object relocation, 目前 KryoSerializer 或 SparkSQL 自定义的一些序列化方式支持</li><li>分区数 &lt; 2^24(16777216)</li><li>shuffle 依赖项不指定聚合或输出顺序，即 mapSideCombine 为 false。</li><li>设置堆外内存大小</li></ul><p><strong>SortShuffleWriter</strong></p><p>对于没有选择 BypassMergeSortShuffleWriter、UnsafeShuffleWriter 的，默认选择 SortShuffleWriter。</p><p>执行流程：</p><ul><li>数据先写入内存数据结构。聚合类操作写入 Map，非聚合类算子写入 Array</li><li>检查是否达到内存阈值。非实时检查，不定时采样，不准确</li><li>数据排序</li><li>数据写入缓冲区(32k)</li><li>重复写多个临时文件</li><li>最后临时文件合并为数据文件</li><li>写索引文件</li><li>将文件位置、计算状态等封装到 MapStatus 中，汇报给 Driver</li></ul><h3 id="MapOutputTracker"><a href="#MapOutputTracker" class="headerlink" title="MapOutputTracker"></a>MapOutputTracker</h3><blockquote><p>Shuffle 过程中的中间数据的元信息，由 MapOutputTracker 负责管理。</p></blockquote><p>Shuffle Writer 会将中间数据保存到 Block 里面，然后将数据的位置发送给 MapOutputTracker。Shuffle Reader 通过向 MapOutputTracker 获取中间数据的位置之后，才能读取到数据。</p><ul><li>MapOutputTracker： 跟踪 map 阶段输出的位置，在 executor 和 driver 端都存在。<ul><li>trackerEndpoint： 一个 RpcEndpointRef</li></ul></li><li>MapOutputTrackerMaster： 存在于 driver 端，DAGScheduler 使用该类注册 map 输出状态和查找统计信息执行位置感知减少任务调度。<ul><li>负责管理所有 shuffleMapTask 的输出数据，每个 shuffleMapTask 执行完后会把执行结果（MapStatus）注册到  MapOutputTrackerMaster</li><li>MapOutputTrackerMaster 会处理 executor 发送的 GetMapOutputStatuses 请求，并返回 serializedMapStatus 给 executor 端</li></ul></li><li>MapOutputTrackerMasterEndpoint：存在于 driver 端</li><li>MapOutputTrackerWorker： 存在于 executor 端<ul><li>负责为 reduce 任务提供 shuffleMapTask 的输出数据信息（MapStatus）</li><li>如果 MapOutputTrackerWorker 在本地没有找到请求的 shuffle 的 mapStatus，则会向 MapOutputTrackerMasterEndpoint 发送 GetMapOutputStatuses 请求获取对应的 mapStatus</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MapOutputTrackerMasterEndpoint</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    override val rpcEnv: <span class="type">RpcEnv</span>, tracker: <span class="type">MapOutputTrackerMaster</span>, conf: <span class="type">SparkConf</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">RpcEndpoint</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 GetMapOutputStatuses、StopMapOutputTracker 的偏函数</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context: <span class="type">RpcCallContext</span>): <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GetMapOutputStatuses</span>(shuffleId: <span class="type">Int</span>) =&gt;</span><br><span class="line">      <span class="keyword">val</span> hostPort = context.senderAddress.hostPort</span><br><span class="line">      logInfo(<span class="string">&quot;Asked to send map output locations for shuffle &quot;</span> + shuffleId + <span class="string">&quot; to &quot;</span> + hostPort)</span><br><span class="line">      <span class="comment">// MapOutputTrackerMaster 发送 GetMapOutputMessage</span></span><br><span class="line">      <span class="keyword">val</span> mapOutputStatuses = tracker.post(<span class="keyword">new</span> <span class="type">GetMapOutputMessage</span>(shuffleId, context))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">StopMapOutputTracker</span> =&gt;</span><br><span class="line">      logInfo(<span class="string">&quot;MapOutputTrackerMasterEndpoint stopped!&quot;</span>)</span><br><span class="line">      context.reply(<span class="literal">true</span>)</span><br><span class="line">      stop()</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MapOutputTrackerMaster</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    broadcastManager: <span class="type">BroadcastManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    isLocal: <span class="type">Boolean</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">MapOutputTracker</span>(<span class="params">conf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> minSizeForBroadcast =</span><br><span class="line">    conf.getSizeAsBytes(<span class="string">&quot;spark.shuffle.mapOutput.minSizeForBroadcast&quot;</span>, <span class="string">&quot;512k&quot;</span>).toInt</span><br><span class="line">  <span class="comment">// spark.rpc.message.maxSize 默认为 128M</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxRpcMessageSize = <span class="type">RpcUtils</span>.maxMessageSizeBytes(conf)</span><br><span class="line">  <span class="comment">// requests for map output statuses</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mapOutputRequests = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>[<span class="type">GetMapOutputMessage</span>]</span><br><span class="line">  <span class="comment">// 用于处理映射输出状态请求的线程池。</span></span><br><span class="line">  <span class="comment">// 这是一个单独的线程池，以确保我们不会阻塞普通的调度程序线程。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> threadpool: <span class="type">ThreadPoolExecutor</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> numThreads = conf.getInt(<span class="string">&quot;spark.shuffle.mapOutput.dispatcher.numThreads&quot;</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">val</span> pool = <span class="type">ThreadUtils</span>.newDaemonFixedThreadPool(numThreads, <span class="string">&quot;map-output-dispatcher&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">      pool.execute(<span class="keyword">new</span> <span class="type">MessageLoop</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pool</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post</span></span>(message: <span class="type">GetMapOutputMessage</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 放到 LinkedBlockingQueue 阻塞队列中</span></span><br><span class="line">    mapOutputRequests.offer(message)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于发送消息的 message loop， threadpool 中执行的任务</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageLoop</span> <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 消费阻塞队列中的 GetMapOutputMessage 消息</span></span><br><span class="line">            <span class="keyword">val</span> data = mapOutputRequests.take()</span><br><span class="line">             <span class="keyword">if</span> (data == <span class="type">PoisonPill</span>) &#123;</span><br><span class="line">              <span class="comment">// Put PoisonPill back so that other MessageLoops can see it.</span></span><br><span class="line">              mapOutputRequests.offer(<span class="type">PoisonPill</span>)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> context = data.context</span><br><span class="line">            <span class="keyword">val</span> shuffleId = data.shuffleId</span><br><span class="line">            <span class="keyword">val</span> hostPort = context.senderAddress.hostPort</span><br><span class="line">            logDebug(<span class="string">&quot;Handling request to send map output locations for shuffle &quot;</span> + shuffleId +</span><br><span class="line">              <span class="string">&quot; to &quot;</span> + hostPort)</span><br><span class="line">            <span class="keyword">val</span> shuffleStatus = shuffleStatuses.get(shuffleId).head</span><br><span class="line">            context.reply(</span><br><span class="line">              shuffleStatus.serializedMapStatus(broadcastManager, isLocal, minSizeForBroadcast))</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logError(e.getMessage, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ie: <span class="type">InterruptedException</span> =&gt; <span class="comment">// exit</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shuffle-Reader"><a href="#Shuffle-Reader" class="headerlink" title="Shuffle Reader"></a>Shuffle Reader</h3><ul><li>Map Task 执行完毕后会将文件位置、计算状态等信息封装到 MapStatus 中，通过  MapOutPutTrackerWorker 对象将其发送给 Driver 进程的 MapOutPutTrackerMaster</li><li>Reduce Task 开始执行之前会先让本进程中的 MapOutputTrackerWorker 向 Driver 进程中的 MapOutputTrackerMaster 发动请求，获取磁盘文件位置等信息</li><li>当所有的 Map Task 执行完毕后，Driver 进程中的 MapOutputTrackerMaster 获得了所有的 Shuffle 文件的信息。此时 MapOutPutTrackerMaster 会告诉 MapOutPutTrackerWorker 磁盘小文件的位置信息</li><li>完成之前的操作之后，由 BlockTransforService 去 Executor 所在的节点拉数据，默认会启动五个子线程。每次拉取的数据量不能超过 48M</li><li>spark.reducer.maxSizeInFlight: shuffle reader 时候，一次 fetch 不能过多，不能超过的数据量，默认为 48M, 空间是由这 5 个 fetch 线程共享的</li><li>BlockStoreShuffleReader: 当前 ShuffleReader 的唯一实现类<ul><li>read(): 读取 reduce 任务的组合键值</li></ul></li><li>ShuffleBlockFetcherIterator: 获取多个块的迭代器。对于本地块，它从本地块管理器获取。对于远程块，它使用提供的 BlockTransferService 获取。<ul><li>创建 (BlockID, InputStream) 元组，对远程获取进行了限制，不会超过 maxBytesInFlight，避免使用太多的内存</li></ul></li></ul><h3 id="Shuffle-的优化"><a href="#Shuffle-的优化" class="headerlink" title="Shuffle 的优化"></a>Shuffle 的优化</h3><p><strong>开发过程中的优化：</strong></p><ul><li>减少 Shuffle 过程中的数据量： 使用高性能算子，如使用 filter + coalesce 过滤不需要的值并减少分区数，使用 reduceByKey 替代 groupByKey 有 mapSideCombine 减少聚合的数据量，</li><li>避免 Shuffle： 更改代码避免 shuffle，使用 map 端的 join 避免， 如使用 colasce 替代 repartititon, repartitionAndSortxxx 将会产生两个 shuffle 的合并为一个</li></ul><p><strong>参数优化：</strong></p><ul><li>调节 map 端缓冲区大小<ul><li>spark.shuffle.file.buffer 默认值为32K，shuffle write 阶段 buffer 缓冲大小。将数据写到磁盘文件之前，会先写入 buffer 缓冲区，缓冲写满后才溢写到磁盘</li></ul></li><li>调节 reduce 端拉取数据缓冲区大小<ul><li>spark.reducer.maxSizeInFlight 默认值为48M。设置shuffle read阶段buffer缓冲区大小，这个buffer缓冲决定了每次能够拉取多少数据</li><li>在内存资源充足的情况下，可适当增加参数的大小（如96m），减少拉取数据的次数及网络传输次数，进而提升性能</li><li>合理设置参数，性能会有 1%~5% 的提升</li></ul></li><li>调节 reduce 端拉取数据重试次数及等待间隔，Shuffle read 阶段拉取数据时，如果因为网络异常导致拉取失败，会自动进行重试。<ul><li>Shuffle read阶段拉取数据时，如果因为网络异常导致拉取失败，会自动进行重试</li><li>spark.shuffle.io.maxRetries，默认值3。最大重试次数</li><li>spark.shuffle.io.retryWait，默认值5s。每次重试拉取数据的等待间隔</li><li>一般调高最大重试次数，不调整时间间隔</li></ul></li><li>调节 Sort Shuffle 排序操作阈值<ul><li>如果shuffle reduce task的数量小于阈值，则shuffle write过程中不会进行排序操作，而是直接按未经优化的Hash Shuffle方式写数据，最后将每个task产生的</li><li>所有临时磁盘文件都合并成一个文件，并创建单独的索引文</li><li>spark.shuffle.sort.bypassMergeThreshold，默认值为200 当使用SortShuffleManager时，如果的确不需要排序操作，建议将这个参数调大</li></ul></li><li>调节 Shuffle 内存大小，分配多一些的比例给执行内存用于 Shuffle</li></ul><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>Shuffle 中的重要参数：</p><ul><li><p><code>spark.local.dir</code>: Shuffle 缓存目录</p></li><li><p><code>spark.shuffle.file.buffer</code>： shuffle write 阶段 buffer 缓冲大小，将数据写到磁盘文件之前，会先写入 buffer 缓冲中，待缓冲写满之后，才会溢写到磁盘。默认值为 32K。 </p></li><li><p><code>spark.reducer.maxSizeInFlight</code>： shuffle read 阶段 buffer 缓冲区大小。默认值为 48M。</p></li><li><p><code>spark.shuffle.io.maxRetries</code>： Shuffle read 阶段拉取数据失败时的最大重试次数。默认值 3。</p></li><li><p><code>spark.shuffle.io.retryWait</code>： Shuffle read 阶段拉取数据失败重试时的等待时间。默认值 5s。</p></li><li><p><code>spark.shuffle.sort.bypassMergeThreshold</code>： 使用 bypassMergeSortShuffleWriter 机制，RDD 分区数的限制阈值。默认值为 200。</p></li><li><p><code>spark.memory.fraction &amp; spark.memory.storageFraction</code>： 调整 Shuffle 相关内存所占的比例</p></li><li><p><code>spark.memory.fraction</code>： 缺省值 0.6。存储内存和执行内存占（heap 内存 - 300M）的百分比</p></li><li><p><code>spark.memory.storageFraction</code>： 缺省值 0.5 存储内存与 （存储内存与执行内存之和）的百分比</p></li><li><p><code>spark.shuffle.manager</code>： 通过反射方式生成的 SortShuffleManager 的实例。默认为 SortShuffleManager。</p></li><li><p>Spark 1.5 以后，有三个可选项：hash、sort 和 tungsten-sort。</p></li><li><p><code>spark.shuffle.consolidateFiles</code>：</p></li><li><p><code>spark.shuffle.mapOutput.minSizeForBroadcast</code>：默认值 512K</p></li><li><p><code>spark.shuffle.mapOutput.dispatcher.numThreads</code>: 默认值为 8，map 端输出派发线程池中的线程数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shuffle&quot;&gt;&lt;a href=&quot;#Shuffle&quot; class=&quot;headerlink&quot; title=&quot;Shuffle&quot;&gt;&lt;/a&gt;Shuffle&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;按照一定的规则对数据重新分区的过程就是 Shuffle。&lt;/strong&gt;需要 Sh</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark-Join的原理</title>
    <link href="http://example.com/2021/05/05/Spark-SQL%E4%B8%ADJoin%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/05/05/Spark-SQL%E4%B8%ADJoin%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-05T08:29:59.000Z</published>
    <updated>2021-05-05T08:32:30.358Z</updated>
    
    <content type="html"><![CDATA[<p>Spark 物理计划阶段，join Selection 类会根据 join hints 策略，Join 表的大小、join 是否是等值 join、参与 join 的 key 是否可排序等条件选择最终的 join 策略。</p><p><strong>Spark 支持的 join 类型：</strong></p><ul><li><p>inner join: 内连接</p></li><li><p>left outer join: 左外连接</p></li><li><p>right outer join: 右外连接</p></li><li><p>full outer join: 全连接</p><p>full outer join 仅采用 sort merge join 实现，左边和右表既要作为 streamIter，又要作为 buildIter</p></li><li><p>left semi join: 以左表为准，在右表中查找匹配的记录，如果查找成功，则仅返回左边的记录，否则返回 null</p></li><li><p>left anti join: 以左表为准，在右表中查找匹配的记录，如果查找成功，则返回 null，否则仅返回左边的记录</p></li><li><p>cross join:</p></li></ul><p><strong>五种 Join 策略</strong></p><ul><li>Broadcast hash join (BHJ): 将小表的数据广播到 Spark 所有的 Executor，作业中较常见</li><li>Shuffle hash join（SHJ）: 是大表和小表进行 join 时选择的一种策略</li><li>Shuffle sort merge join (SMJ)： join 表都很大的时候选择，作业中较常见</li><li>Shuffle-and-replicate nested loop join: 又称笛卡尔积 join，非等值连接的时候可能使用</li><li>Broadcast nested loop join (BNLJ):</li></ul><h2 id="JoinSelection"><a href="#JoinSelection" class="headerlink" title="JoinSelection"></a>JoinSelection</h2><p><strong>选择策略：</strong></p><ul><li>Join 的 Key 为等值 Join 来选择 BHJ、SHJ、SMJ 中的一个；</li><li>Join 的 Key 为不等值 Join 或者没有指定 Join 条件，则会选择 BNLJ 或 Shuffe-and-replicate nested loop join</li></ul><p>SparkStrategies.JoinSelection 的 apply 对各种 join 策略的选择：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JoinSelection</span> <span class="keyword">extends</span> <span class="title">Strategy</span> <span class="keyword">with</span> <span class="title">PredicateHelper</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 匹配输出应该足够小以用于广播连接的计划，小表的大小小于配置 spark.sql.autoBroadcastJoinThreshold(10M)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">canBroadcast</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    plan.stats.sizeInBytes &gt;= <span class="number">0</span> &amp;&amp; plan.stats.sizeInBytes &lt;= conf.autoBroadcastJoinThreshold</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该 plan 的单个分区应该足够小，可以构建哈希表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">canBuildLocalHashMap</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    plan.stats.sizeInBytes &lt; conf.autoBroadcastJoinThreshold * conf.numShufflePartitions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回计划a是否比计划b小很多(3X)。</span></span><br><span class="line"><span class="comment"> * 构建哈希映射的成本比排序高，我们应该只在一个比其他表小得多的表上构建哈希映射。因为我们没有行数的统计信息，所以这里使用字节大小作为估计。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">muchSmaller</span></span>(a: <span class="type">LogicalPlan</span>, b: <span class="type">LogicalPlan</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    a.stats.sizeInBytes * <span class="number">3</span> &lt;= b.stats.sizeInBytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Seq</span>[<span class="type">SparkPlan</span>] = plan <span class="keyword">match</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// --- BroadcastHashJoin --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// broadcast hints were specified</span></span><br><span class="line">      <span class="comment">// 广播提示被指定</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(joinType, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="keyword">if</span> canBroadcastByHints(joinType, left, right) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide = broadcastSideByHints(joinType, left, right)</span><br><span class="line">        <span class="type">Seq</span>(joins.<span class="type">BroadcastHashJoinExec</span>(</span><br><span class="line">          leftKeys, rightKeys, joinType, buildSide, condition, planLater(left), planLater(right)))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// broadcast hints were not specified, so need to infer it from size and configuration.</span></span><br><span class="line">      <span class="comment">// 没有指定广播提示，所以需要从大小和配置推断它。</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(joinType, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="comment">// 选择 BroadcastHashJoin 策略，需要为等值连接，广播的小小符合</span></span><br><span class="line">        <span class="keyword">if</span> canBroadcastBySizes(joinType, left, right) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide = broadcastSideBySizes(joinType, left, right)</span><br><span class="line">        <span class="type">Seq</span>(joins.<span class="type">BroadcastHashJoinExec</span>(</span><br><span class="line">          leftKeys, rightKeys, joinType, buildSide, condition, planLater(left), planLater(right)))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// --- ShuffledHashJoin ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 选择 ShuffledHashJoin</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(joinType, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="comment">// 配置中不是优先 SortMergeJoin</span></span><br><span class="line">        <span class="comment">// 且 Join 类型符合要求</span></span><br><span class="line">        <span class="comment">// 且 可以构建本地的 HashMap</span></span><br><span class="line">        <span class="comment">// 且足够小(返回计划a是否比计划b小很多(3X)) 或 leftKeys 不可排序</span></span><br><span class="line">        <span class="keyword">if</span> !conf.preferSortMergeJoin &amp;&amp; canBuildRight(joinType) &amp;&amp; canBuildLocalHashMap(right)</span><br><span class="line">           &amp;&amp; muchSmaller(right, left) ||</span><br><span class="line">           !<span class="type">RowOrdering</span>.isOrderable(leftKeys) =&gt;</span><br><span class="line">        <span class="type">Seq</span>(joins.<span class="type">ShuffledHashJoinExec</span>(</span><br><span class="line">          leftKeys, rightKeys, joinType, <span class="type">BuildRight</span>, condition, planLater(left), planLater(right)))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 和上面相同逻辑，转换下 left,right 进行比较</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(joinType, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">         <span class="keyword">if</span> !conf.preferSortMergeJoin &amp;&amp; canBuildLeft(joinType) &amp;&amp; canBuildLocalHashMap(left)</span><br><span class="line">           &amp;&amp; muchSmaller(left, right) ||</span><br><span class="line">           !<span class="type">RowOrdering</span>.isOrderable(leftKeys) =&gt;</span><br><span class="line">        <span class="comment">// 选择 ShuffledHashJoin 策略</span></span><br><span class="line">        <span class="type">Seq</span>(joins.<span class="type">ShuffledHashJoinExec</span>(</span><br><span class="line">          leftKeys, rightKeys, joinType, <span class="type">BuildLeft</span>, condition, planLater(left), planLater(right)))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// --- SortMergeJoin ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 等值连接，leftKeys 是可排序的情况下选择</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(joinType, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="keyword">if</span> <span class="type">RowOrdering</span>.isOrderable(leftKeys) =&gt;</span><br><span class="line">        <span class="comment">// 选择 SortMergeJoin 策略</span></span><br><span class="line">        joins.<span class="type">SortMergeJoinExec</span>(</span><br><span class="line">          leftKeys, rightKeys, joinType, condition, planLater(left), planLater(right)) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// --- Without joining keys ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Pick BroadcastNestedLoopJoin if one side could be broadcast</span></span><br><span class="line">      <span class="keyword">case</span> j @ logical.<span class="type">Join</span>(left, right, joinType, condition)</span><br><span class="line">          <span class="keyword">if</span> canBroadcastByHints(joinType, left, right) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide = broadcastSideByHints(joinType, left, right)</span><br><span class="line">        <span class="comment">// 选择 BroadcastNestedLoopJoin(BNLJ)</span></span><br><span class="line">        joins.<span class="type">BroadcastNestedLoopJoinExec</span>(</span><br><span class="line">          planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> j @ logical.<span class="type">Join</span>(left, right, joinType, condition)</span><br><span class="line">          <span class="keyword">if</span> canBroadcastBySizes(joinType, left, right) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide = broadcastSideBySizes(joinType, left, right)</span><br><span class="line">        joins.<span class="type">BroadcastNestedLoopJoinExec</span>(</span><br><span class="line">          planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Pick CartesianProduct for InnerJoin</span></span><br><span class="line">      <span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, _: <span class="type">InnerLike</span>, condition) =&gt;</span><br><span class="line">        joins.<span class="type">CartesianProductExec</span>(planLater(left), planLater(right), condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, joinType, condition) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide = broadcastSide(</span><br><span class="line">          left.stats.hints.broadcast, right.stats.hints.broadcast, left, right)</span><br><span class="line">        <span class="comment">// This join could be very slow or OOM</span></span><br><span class="line">        joins.<span class="type">BroadcastNestedLoopJoinExec</span>(</span><br><span class="line">          planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// --- Cases where this strategy does not apply ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Join-策略"><a href="#Join-策略" class="headerlink" title="Join 策略"></a>Join 策略</h2><h3 id="BroadcastHashJoin"><a href="#BroadcastHashJoin" class="headerlink" title="BroadcastHashJoin"></a><strong>BroadcastHashJoin</strong></h3><p>将小表的数据广播到 Spark 所有的 Executor 端，只能用于等值连接。避免了 Shuﬄe 操作。一般而言，Broadcast Hash Join 会比其他 Join 策略执行的要快。</p><p><strong>Join 步骤：</strong></p><ul><li>利用 collect 算子将小表的数据从 Executor 端拉到 Driver 端</li><li>在 Driver 端调用 sparkContext.broadcast 广播到所有 Executor 端</li><li>在 Executor 端使用广播的数据与大表进行 Join 操作</li></ul><p><strong>使用条件：</strong></p><ul><li>必须为等值连接，不要求 Join 的 keys 可排序</li><li>小表大小小于 <code>spark.sql.autoBroadcastJoinThreshold</code>(default 10M)设定的值</li></ul><h3 id="ShuffleHashJoin"><a href="#ShuffleHashJoin" class="headerlink" title="ShuffleHashJoin"></a>ShuffleHashJoin</h3><p>与 BHJ 都是在大表和小表进行 Join 的时候选择的一种策略。</p><p><strong>Join 步骤</strong>：把大表和小表按照相同的分区算法和分区数进行分区(Join 的 keys 进行分区)，保证了 hash 值一样的数据都分发到同一个分区中，然后在同一个 Executor 中两张表 hash 值一样的分区就可以在本地进行 hash Join 。在进行 Join 之前，还会对小表的分区构建 Hash Map。</p><p><strong>使用条件：</strong></p><ul><li>必须为等值连接</li><li>不是优先 SortMergeJoin，即配置 <code>spark.sql.join.preferSortMergeJoin</code> 为 false</li><li>小表的大小（plan.stats.sizeInBytes）必须小于 <code>spark.sql.autoBroadcastJoinThreshold</code>(10M) * <code>spark.sql.shuffle.partitions</code>（200）</li><li>小表大小（stats.sizeInBytes）的三倍必须小于等于大表的大小（stats.sizeInBytes）</li></ul><h3 id="SortMergeJoin"><a href="#SortMergeJoin" class="headerlink" title="SortMergeJoin"></a>SortMergeJoin</h3><p>对表的大小没有条件，不管分区多大，SortMergeJoin 都不用把一侧的数据全部加载到内存中，而是即用即丢；两个序列都有序。从头遍历，碰到 key 相同的就输出，如果不同，左边小就继续取左边，反之取右边，提高了大数据量下sql join 的稳定性。</p><p><strong>Join 步骤：</strong></p><ul><li>将两张表按照 join key 进行shuﬄe，保证join key值相同的记录会被分在相应的分区</li><li>对每个分区内的数据进行排序</li><li>排序后再对相应的分区内的记录进行连接</li></ul><p><strong>使用条件：</strong></p><ul><li>等值连接</li><li>参与 join 的 key 可排序</li></ul><h3 id="BroadcastNestedLoopJoin"><a href="#BroadcastNestedLoopJoin" class="headerlink" title="BroadcastNestedLoopJoin"></a>BroadcastNestedLoopJoin</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> record_1 in relation_1:</span><br><span class="line">  <span class="keyword">for</span> record_2 in relation_2:</span><br><span class="line">  # join condition is executed</span><br></pre></td></tr></table></figure><p>在某些情况会对某张表重复扫描多次，效率非常低下，会根据相关条件对小表进行广播，以减少表的扫描次数。</p><p>支持等值和不等值 Join，支持所有的 Join 类型。</p><h3 id="CartesianProductJoin"><a href="#CartesianProductJoin" class="headerlink" title="CartesianProductJoin"></a>CartesianProductJoin</h3><p>join 表未指定连接条件时使用</p><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a><strong>相关配置</strong></h2><p>影响 join 策略选择的配置</p><ul><li><code>spark.sql.autoBroadcastJoinThreshold</code>： 使用 broadcast hash join 的阈值，默认为 10M，为 -1 表示关闭这种连接方式</li><li><code>spark.sql.join.preferSortMergeJoin</code>： 是否尝试使用 Shuffle Hash Join，默认为 true</li><li><code>spark.sql.shuffle.partitions</code>： 默认 200</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spark 物理计划阶段，join Selection 类会根据 join hints 策略，Join 表的大小、join 是否是等值 join、参与 join 的 key 是否可排序等条件选择最终的 join 策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spark 支持的 jo</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
    <category term="SparkSQL" scheme="http://example.com/tags/SparkSQL/"/>
    
  </entry>
  
  <entry>
    <title>数据结构设计</title>
    <link href="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-04-19T14:53:47.000Z</published>
    <updated>2021-04-19T14:56:28.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><h3 id="Array-实现-Queue"><a href="#Array-实现-Queue" class="headerlink" title="Array 实现 Queue"></a>Array 实现 Queue</h3><p>和 Java 中的 ArrayDequeue 实现类似，记录队列头部和尾部的索引实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> E[] data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> frontIdx;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tailIdx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    frontIdx = <span class="number">0</span>;</span><br><span class="line">    tailIdx = <span class="number">0</span>;</span><br><span class="line">    N = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == data.length)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;LinkedQueue is full.&quot;</span>);</span><br><span class="line">    data[tailIdx] = e;</span><br><span class="line">    tailIdx = (tailIdx + <span class="number">1</span>) % data.length;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;LinkedQueue is empty.&quot;</span>);</span><br><span class="line">    E oldFront = data[frontIdx];</span><br><span class="line">    data[frontIdx] = <span class="keyword">null</span>;</span><br><span class="line">    frontIdx = (frontIdx + <span class="number">1</span>) % data.length;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;LinkedQueue is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data[frontIdx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array-实现-Stack"><a href="#Array-实现-Stack" class="headerlink" title="Array 实现 Stack"></a>Array 实现 Stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> E[] data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    N = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == data.length)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">    data[N] = e;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">    E oldTop = data[N - <span class="number">1</span>];</span><br><span class="line">    data[N - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">return</span> oldTop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data[N - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stack-实现-Queue"><a href="#Stack-实现-Queue" class="headerlink" title="Stack 实现 Queue"></a>Stack 实现 Queue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="comment">// peek element always is first put element when pop or peek operation</span></span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    in.push(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in2out();</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in2out();</span><br><span class="line">    <span class="keyword">return</span> out.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// maintain out first pop is first input</span></span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">        out.push(in.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-实现-Stack"><a href="#Queue-实现-Stack" class="headerlink" title="Queue 实现 Stack"></a>Queue 实现 Stack</h3><p>两个队列实现, 在弹出时进行结构调整 peek, poll   O(N) push         O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    data.offer(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">while</span> (data.size() &gt; <span class="number">1</span>)</span><br><span class="line">      help.offer(data.poll());</span><br><span class="line">    <span class="keyword">int</span> oldTop = data.poll();</span><br><span class="line">    swap();</span><br><span class="line">    <span class="keyword">return</span> oldTop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">while</span> (data.size() &gt; <span class="number">1</span>)</span><br><span class="line">      help.offer(data.poll());</span><br><span class="line">    <span class="keyword">int</span> top = data.poll();</span><br><span class="line">    help.offer(top);</span><br><span class="line">    swap();</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; t = data;</span><br><span class="line">    data = help;</span><br><span class="line">    help = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二： 一个队列实现</p><p>同一个队列实现, 将队尾元素重新插入到队首元素实现逆序 push  O(N) pop   O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue.offer(x);</span><br><span class="line">    <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">    <span class="comment">// reverse queue element, offer(poll())</span></span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      queue.offer(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> queue.poll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h3><p>实现一种狗猫队列的结构，要求如下： 用户可以调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add        方法，将cat类或dog类的实例放入队列中； 用户可以调用</span><br><span class="line">pollAll    方法，将队列中所有的实例按照进队列的先后顺序依次弹出； 用户可以调用</span><br><span class="line">pollDog    方法，将队列中dog类的实例按照进队列的先后顺序依次弹出； 用户可以调用</span><br><span class="line">pollCat    方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； 用户可以调用</span><br><span class="line">isEmpty    方法，检查队列中是否还有dog或cat的实例； 用户可以调用</span><br><span class="line">isDogEmpty 方法，检查队列中是否有dog类的实例； 用户可以调用</span><br><span class="line">isCatEmpty 方法，检查队列中是否有cat类的实例。</span><br></pre></td></tr></table></figure><p>每个 Pet 加入时通过 index 标识次序, 用于弹出时比较. 分开存储, Cat、Dog 分别存放到一个队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatDogQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;WrappedPet&gt; dogs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;WrappedPet&gt; cats = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequence; <span class="comment">// as index to keep order</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dogs.isEmpty() &amp;&amp; cats.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cats.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dogs.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Pet pet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add pet to different queue by pet type</span></span><br><span class="line">    <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">      dogs.add(<span class="keyword">new</span> WrappedPet(pet, sequence++));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">      cats.add(<span class="keyword">new</span> WrappedPet(pet, sequence++));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;not a dog or cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pet <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// one queue is empty</span></span><br><span class="line">    <span class="keyword">if</span> (dogs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> cats.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cats.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> dogs.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare sequence number</span></span><br><span class="line">    <span class="keyword">return</span> dogs.peek().getCount() &lt; cats.peek().getCount() ?</span><br><span class="line">      dogs.poll().getPet() :</span><br><span class="line">      cats.poll().getPet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cat <span class="title">pollCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cats.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;have no cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Cat) cats.poll().getPet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Dog <span class="title">pollDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dogs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;have no dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Dog) dogs.poll().getPet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedPet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedPet</span><span class="params">(Pet pet, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.pet = pet;</span><br><span class="line">      <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有最小值的栈"><a href="#带有最小值的栈" class="headerlink" title="带有最小值的栈"></a>带有最小值的栈</h3><p>min 栈与 data 栈存放元素个数不一致</p><p>min 栈只存放小元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty() || x &lt;= min.peek()) &#123;</span><br><span class="line">      min.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    data.push(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (data.peek().equals(min.peek()))</span><br><span class="line">      min.pop();</span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> data.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> min.peek();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="LRU-实现"><a href="#LRU-实现" class="headerlink" title="LRU 实现"></a>LRU 实现</h3><p><a href="https://leetcode.com/problems/lru-cache/">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> );</span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br></pre></td></tr></table></figure><p>使用构建一个双向链表来维护 LRU 的关系，一个 Map 对应 element value → Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="keyword">private</span> Node head;</span><br><span class="line">  <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    Integer key;</span><br><span class="line">    Integer val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer k, Integer v)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = k;</span><br><span class="line">      <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity * <span class="number">4</span> / <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = cache.get(key);</span><br><span class="line">    remove(node);</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">      Node oldNode = cache.get(key);</span><br><span class="line">      oldNode.val = value;</span><br><span class="line">      remove(oldNode);</span><br><span class="line">      setHead(oldNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">      <span class="keyword">if</span> (cache.size() &gt;= capacity) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cache is FULL! Removing &quot;</span> + tail.val + <span class="string">&quot; from cache...&quot;</span>);</span><br><span class="line">        cache.remove(tail.key);</span><br><span class="line">        remove(tail);</span><br><span class="line">      &#125;</span><br><span class="line">      setHead(newNode);</span><br><span class="line">      cache.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove from list node, note head tail edge</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.prev.next = node.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      head = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.next.prev = node.prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tail = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// make node(newNode or accessed node) to head</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    node.next = head;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init or remove no element</span></span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      head.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    head = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init or remove no element</span></span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">      tail = head;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LFU-实现"><a href="#LFU-实现" class="headerlink" title="LFU 实现"></a>LFU 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">headList</span><br><span class="line">   <span class="number">1</span>  &lt;-&gt;  <span class="number">3</span>  &lt;-&gt;  <span class="number">4</span>  &lt;-&gt;  <span class="number">7</span></span><br><span class="line">   F       G       H       I</span><br><span class="line">   ^       ^       ^       ^</span><br><span class="line">   |       |       |       |</span><br><span class="line">   v       v       v       v</span><br><span class="line">   A       D</span><br><span class="line">   ^</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">   C</span><br><span class="line">   ^</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">   E</span><br></pre></td></tr></table></figure><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h3><p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">nowcoder</a></p><p>思路: 原始拆分存储在不同的容器中 通过维护左右两个堆实现, 左边的为最大堆, 右边的为最小堆 插入元素时, 若当前容器大小为偶数, 通过先放入右边的最大堆, 之后弹出左边最大堆的堆顶元素放入右边的最小堆实现有序性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// max heap</span></span><br><span class="line">  <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; leftSmall = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">  <span class="comment">// min heap</span></span><br><span class="line">  <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; rightBig = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;   <span class="comment">// even, put rightBig AND ordered</span></span><br><span class="line">      leftSmall.offer(num);</span><br><span class="line">      rightBig.offer(leftSmall.poll());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">// odd, right N/2+1</span></span><br><span class="line">      rightBig.offer(num);</span><br><span class="line">      leftSmall.offer(rightBig.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> (leftSmall.peek() + rightBig.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">double</span>) rightBig.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leftSmall.isEmpty() &amp;&amp; rightBig.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h3><p>一对一的映射</p><p>一个 Map 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;K, V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!map.get(key).equals(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// O(n)</span></span><br><span class="line">      <span class="keyword">if</span> (map.containsValue(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      map.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 Map 实现</p><p>分别保存 key 和 val，使用一个 sequence 来唯一确定是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneMap2</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;K, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;V, Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequence;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// O(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">    Integer keyReplace = map1.put(key, sequence);</span><br><span class="line">    Integer valReplace = map2.put(val, sequence);</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(keyReplace, valReplace) == <span class="keyword">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sequence++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有最大值的滑动窗口"><a href="#带有最大值的滑动窗口" class="headerlink" title="带有最大值的滑动窗口"></a>带有最大值的滑动窗口</h3><p><a href="https://leetcode.com/problems/sliding-window-maximum/">leetcode-sliding-window-maximum</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], and k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>方式一： 单调的双向队列实现</p><p>offer, poll O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// keep original enqueue order</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Tuple&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// Monotone decreasing, last element is max</span></span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Tuple&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// increasing sequence</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequencer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// poll not meet to main monotonicity</span></span><br><span class="line">    <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; val &gt;= qmax.peekLast().val) &#123;</span><br><span class="line">      qmax.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tuple tuple = <span class="keyword">new</span> Tuple(val, sequencer++);</span><br><span class="line">    queue.offer(tuple);</span><br><span class="line">    qmax.offerLast(tuple);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple oldFront = queue.poll();</span><br><span class="line">    <span class="comment">// remove relate max value</span></span><br><span class="line">    <span class="keyword">if</span> (qmax.peekFirst().idx == oldFront.idx) &#123;</span><br><span class="line">      qmax.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldFront.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qmax.peekFirst().val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wrapped value with idx to record original put order</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    Tuple(<span class="keyword">int</span> val, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val = val;</span><br><span class="line">      <span class="keyword">this</span>.idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二： 使用堆实现</p><p>offer, poll O(nlogn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue2</span> </span>&#123;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    queue.offer(e);</span><br><span class="line">    heap.offer(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">int</span> oldFront = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (oldFront == heap.peek())</span><br><span class="line">      heap.poll();  <span class="comment">// time: O(nlogn)</span></span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// O(1) 获取队列中的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> heap.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三： 使用 MaxStack 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (max.isEmpty()) &#123;</span><br><span class="line">        max.push(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt;= max.peek()) &#123;</span><br><span class="line">        max.push(e);</span><br><span class="line">      &#125;</span><br><span class="line">      data.push(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Integer oldTop = data.pop();</span><br><span class="line">      <span class="keyword">if</span> (max.peek() == oldTop)</span><br><span class="line">        max.pop();</span><br><span class="line">      <span class="keyword">return</span> oldTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (max.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="keyword">return</span> max.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MaxStack in = <span class="keyword">new</span> MaxStack();</span><br><span class="line">  <span class="keyword">private</span> MaxStack out = <span class="keyword">new</span> MaxStack();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    in.push(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty())</span><br><span class="line">        out.push(in.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty())</span><br><span class="line">        out.push(in.pop());</span><br><span class="line">    <span class="keyword">return</span> out.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// O(1) 获取队列中的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> Math.max(in.isEmpty() ? Integer.MIN_VALUE : in.max(),</span><br><span class="line">      out.isEmpty() ? Integer.MIN_VALUE : out.max());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.size() + out.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流中第一个重复元素"><a href="#数据流中第一个重复元素" class="headerlink" title="数据流中第一个重复元素"></a>数据流中第一个重复元素</h3><p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">nowcoder</a></p><p>通过 Map 记录当前所有字节流中的词频, loopArrQueue 保留原始的字节流插入顺序,同时保证 loopArrQueue 的队首元素词频为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Character, Integer&gt; freqs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// record original sequence</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    freqs.put(ch, freqs.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    queue.offer(ch);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; freqs.get(queue.peek()) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      queue.poll(); <span class="comment">// pop head of queue and keep head freq is 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列与栈&quot;&gt;&lt;a href=&quot;#队列与栈&quot; class=&quot;headerlink&quot; title=&quot;队列与栈&quot;&gt;&lt;/a&gt;队列与栈&lt;/h2&gt;&lt;h3 id=&quot;Array-实现-Queue&quot;&gt;&lt;a href=&quot;#Array-实现-Queue&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spark实现KNN近邻算法</title>
    <link href="http://example.com/2021/04/16/Spark%E5%AE%9E%E7%8E%B0KNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/04/16/Spark%E5%AE%9E%E7%8E%B0KNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-16T02:32:24.000Z</published>
    <updated>2021-04-16T02:33:10.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KNN-近邻算法"><a href="#KNN-近邻算法" class="headerlink" title="KNN 近邻算法"></a>KNN 近邻算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p><img src="http://img.janhen.com/202104160847096mLEpK.jpg" alt="http://img.janhen.com/202104160847096mLEpK.jpg"></p><p><strong>KNN 算法描述</strong></p><p>KNN（k-NearestNeighbor）又被称为最近邻算法。</p><p>思路是：若一个样本在特征空间中的 k 个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>KNN 算法是机器学习中最简单的方法之一。KNN 是一种分类算法，KNN 没有显式的学习过程，即没有训练阶段，待收到新样本后直接进行处理。</p><p><strong>距离计算</strong></p><p>计算待测案例与训练样本之间的距离，常用的距离有欧式距离、曼哈顿距离、余弦距离等。</p><p>在欧几里得空间中，点x =(x1,…,xn)和 y =(y1,…,yn)之间的欧氏距离为</p><p><img src="http://img.janhen.com/20210416090249gfm1go.png" alt="http://img.janhen.com/20210416090249gfm1go.png"></p><p>欧几里得距离</p><p><strong>算法实现流程：</strong></p><ol><li>读文件中的测试数据、训练数据集，形成数据集 X,Y</li><li>求数据集 Y 中的每个点到数据集 X 中每个点的位置，得到数据集 D</li><li>找到数据集 D 中最小的 K 个点</li><li>求 K 个点的分布情况</li><li>返回前 K 个点中出现频率最高的类别作为测试数据的预测分类</li></ol><h3 id="鸢尾花数据集"><a href="#鸢尾花数据集" class="headerlink" title="鸢尾花数据集"></a>鸢尾花数据集</h3><p>数据集内包含 3 类共 150 条 记录，每类各 50 个数据，</p><p>记录都有 4 项特征：花萼长度、花萼宽度、花瓣长度、花瓣宽度，可以通过这 4个 特征预测鸢尾花卉属于哪一品种(iris-setosa, iris-versicolour, iris-virginica)。</p><p>原始的数据集：Iris.csv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Id,SepalLengthCm,SepalWidthCm,PetalLengthCm,PetalWidthCm,Species</span><br><span class="line">1,5.1,3.5,1.4,0.2,Iris-setosa</span><br><span class="line">2,4.9,3.0,1.4,0.2,Iris-setosa</span><br><span class="line">3,4.7,3.2,1.3,0.2,Iris-setosa</span><br><span class="line">..</span><br><span class="line">52,6.4,3.2,4.5,1.5,Iris-versicolor</span><br><span class="line">53,6.9,3.1,4.9,1.5,Iris-versicolor</span><br><span class="line">..</span><br><span class="line">102,5.8,2.7,5.1,1.9,Iris-virginica</span><br><span class="line">103,7.1,3.0,5.9,2.1,Iris-virginica</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>未知的数据集：unknown_iris.csv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8888,5.7,4.4,1.5,0.4,Iris-setosa22</span><br><span class="line">7777,5.5,2.4,4.0,1.4,Iris-versicolor22</span><br><span class="line">6666,6.8,3.2,5.1,2.3,Iris-virginica22</span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KNNDriver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="type">K</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;knn-test&quot;</span>).setMaster(<span class="string">&quot;local[4]&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">        sc.setLogLevel(<span class="string">&quot;WARN&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取实际的数据   id, (x1,y1,z1,e1)</span></span><br><span class="line">        <span class="keyword">val</span> realRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])] = sc.textFile(<span class="string">&quot;data/Iris.csv&quot;</span>).map(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (fields(<span class="number">0</span>).equals(<span class="string">&quot;Id&quot;</span>)) &#123;</span><br><span class="line">                (<span class="string">&quot;unknown&quot;</span>, <span class="type">Array</span>(<span class="number">-1.0</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (fields.last, fields.init.tail.map(_.toDouble))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">val</span> realBc: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])]] = sc.broadcast(realRdd.collect)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取待验证的数据</span></span><br><span class="line">        <span class="keyword">val</span> toValidRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])] = sc.textFile(<span class="string">&quot;data/unknown_iris.csv&quot;</span>).map(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (fields(<span class="number">0</span>).equals(<span class="string">&quot;Id&quot;</span>)) &#123;</span><br><span class="line">                (<span class="string">&quot;unknown&quot;</span>, <span class="type">Array</span>(<span class="number">-1.0</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (fields.last, fields.init.tail.map(_.toDouble))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> varData: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])] = toValidRdd.collect()</span><br><span class="line">        varData.foreach(elem =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> res: <span class="type">Array</span>[(<span class="type">Double</span>, <span class="type">String</span>)] = realBc.value.map(point =&gt; (distance(point._2, elem._2), point._1))</span><br><span class="line">            <span class="keyword">val</span> kNeastNeighbor: <span class="type">Array</span>[(<span class="type">Double</span>, <span class="type">String</span>)] = res.sortBy(_._1).take(<span class="type">K</span>)</span><br><span class="line">            <span class="keyword">val</span> labels: <span class="type">Array</span>[<span class="type">String</span>] = kNeastNeighbor.map(_._2)</span><br><span class="line">            print(<span class="string">s&quot;TestData: <span class="subst">$&#123;elem._2.toBuffer&#125;</span>, NearestNeighbor: &quot;</span>)</span><br><span class="line">            labels.groupBy(x =&gt; x).mapValues(_.length).foreach(print)</span><br><span class="line">            println()</span><br><span class="line">        &#125;)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个点之间的欧式距离</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span></span>(x: <span class="type">Array</span>[<span class="type">Double</span>], y: <span class="type">Array</span>[<span class="type">Double</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">        math.sqrt(x.zip(y).map(z =&gt; math.pow(z._1 - z._2, <span class="number">2</span>)).sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestData: ArrayBuffer(5.7, 4.4, 1.5, 0.4), NearestNeighbor: (Iris-setosa,15)</span><br><span class="line">TestData: ArrayBuffer(5.5, 2.4, 4.0, 1.4), NearestNeighbor: (Iris-versicolor,15)</span><br><span class="line">TestData: ArrayBuffer(6.8, 3.2, 5.1, 2.3), NearestNeighbor: (Iris-virginica,14)(Iris-versicolor,1)</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><p>训练时间复杂度低，为O(n)；</p><p>简单，易于理解；</p><p>可用于非线性分类；</p><p>缺点：</p><p>使用懒散学习方法，基本上不学习，导致预测时速度比起逻辑回归之类的算法慢；</p><p>KNN 模型可解释性不强。</p><p>分类的时候，未考虑权重等因素，仅根据投票数量来决定分类结果。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm#Algorithm">k-nearest neighbors algorithm - Wikipedia</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB">欧几里得距离 - 维基百科，自由的百科全书</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KNN-近邻算法&quot;&gt;&lt;a href=&quot;#KNN-近邻算法&quot; class=&quot;headerlink&quot; title=&quot;KNN 近邻算法&quot;&gt;&lt;/a&gt;KNN 近邻算法&lt;/h2&gt;&lt;h3 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spark-内存管理与持久化</title>
    <link href="http://example.com/2021/04/09/Spark-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2021/04/09/Spark-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-04-09T07:10:07.000Z</published>
    <updated>2021-05-07T07:52:48.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>静态内存管理</strong></p><p>Spark 2.0 以前版本采用静态内存管理机制。存储内存、执行内存和其他内存的大小在 Spark 应用程序运行期间均为固定的。 容易造成存储内存和执行内存中的一方剩余大量的空间，而另一方却早早被占满，不得不淘汰或移出旧的内容以存储新的内容。目前已经被淘汰。</p><p><strong>统一内存管理</strong></p><p>Spark 2.0 之后引入统一内存管理机制，存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域，统一内存管理的堆内内存结构。</p><p>可以借用内存</p><p>最重要的优化在于动态占用机制</p><p>在执行过程中：执行内存的优先级 &gt; 存储内存的优先级</p><p>凭借统一内存管理机制，Spark 在一定程度上<strong>提高了堆内和堆外内存资源的利用率</strong>， 降低了开发者维护 Spark 内存的难度</p><h3 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h3><p><strong>RDD 持久化机制</strong></p><p>Task 在启动之初读取一个分区时：</p><ul><li>先判断这个分区是否已经被持久化</li><li>如果没有则需要检查 Checkpoint 或按照血统重新计算。</li></ul><p>RDD 的持久化由 Spark 的 Storage(BlockManager) 模块负责，实现了 RDD 与物理存储的解耦合。</p><p>Storage 模块在逻辑上以 Block 为基本存储单位，RDD 的每个 Partition 经过处理后 唯一对应一个Block。</p><p><strong>RDD 缓存过程</strong> RDD 缓存的源头：Other (Iterator / 内存空间不连续)</p><p>Record 的对象实例在逻辑上占用了 JVM 堆内内存的 other 部分的空间，同一 Partition 的不同 Record 的存储空间并不连续。</p><p>RDD 在缓存到存储内存之后，Partition 被转换成 Block，Record 在堆内或堆外存储内存中占用一块连续的空间 将 Partition 由不连续的存储空间转换为连续存储空间的过程，Spark 称之为展开（Unroll）。</p><p><strong>淘汰与落盘</strong> 存储内存的淘汰规则为：</p><ul><li>被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存</li><li>新旧 Block 不能属于同一个 RDD，避免循环淘汰</li><li>旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题</li><li>遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MemoryStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    blockInfoManager: <span class="type">BlockInfoManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    serializerManager: <span class="type">SerializerManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    memoryManager: <span class="type">MemoryManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    blockEvictionHandler: <span class="type">BlockEvictionHandler</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> entries = <span class="keyword">new</span> <span class="type">LinkedHashMap</span>[<span class="type">BlockId</span>, <span class="type">MemoryEntry</span>[_]](<span class="number">32</span>, <span class="number">0.75</span>f, <span class="literal">true</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行内存管理"><a href="#执行内存管理" class="headerlink" title="执行内存管理"></a>执行内存管理</h3><p>主要用来存储任务在执行 Shuffle 时占用的内存</p><p>Spark 会使用一种叫 <code>AppendOnlyMap</code> 的哈希表在堆内执行内存中存储数据</p><p>Spark 的存储内存和执行内存使用不同的管理方式：</p><ul><li>对存储内存来说，Spark 用一个 <code>LinkedHashMap</code> 来集中管理所有的 Block， Block 由需要缓存的 RDD 的 Partition 转化而成；</li><li>对执行内存来说，Spark 用 <code>AppendOnlyMap</code> 来存储 Shuffle 过程中的数据， 在 Tungsten 排序中甚至抽象成为页式内存管理，开辟了全新的 JVM 内存管理机制。</li></ul><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>数据持久化/缓存的目的：</p><p>Spark 默认数据存放在内存中，适合高速迭代，多个步骤只有第一个输入数据，中间不产生临时数据，风险很高，容易出错，需要进行容错。 RDD 出错/分片可以根据血统重新计算出来，如果没有父 RDD 进行 persist 或者 cache，就需要重新做，耗时较大。将数据缓存起来，方便进行迭代计算。</p><h3 id="RDD-持久化"><a href="#RDD-持久化" class="headerlink" title="RDD 持久化"></a>RDD 持久化</h3><p>RDD 中的数据持久化：</p><p>对于 Spark 中 RDD 不支持的持久化方式，可使用 foreachPartition 进行自定义。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">saveAsObjectFile()</span><br><span class="line">saveAsTextFile()</span><br><span class="line">saveAsHadoopFile()</span><br><span class="line">saveAsHadoopDataset()</span><br><span class="line">saveAsSequenceFile()</span><br></pre></td></tr></table></figure><h3 id="cache-和-persist-比较"><a href="#cache-和-persist-比较" class="headerlink" title="cache 和 persist 比较"></a>cache 和 persist 比较</h3><p>都是用于将一个 RDD 缓存，之后使用的时候就不用重新计算了，节省程序运行时间</p><ul><li>cache 只有一个默认的缓存级别 MEMORY_ONLY, cache 调用了persist，而 persist 可以根据情况设置其它的缓存级别；</li><li>executor 执行的时候，默认 60% 做 cache，40% 做 task 操作，persist 是最根本的函数，最底层的函数。</li></ul><h3 id="persist-适用场景"><a href="#persist-适用场景" class="headerlink" title="persist 适用场景"></a>persist 适用场景</h3><ul><li>特定步骤耗时高</li><li>计算的链条长，重新计算步骤多</li><li>checkpoint 所在的 rdd 要持久化 persist</li><li>shuffle 之后进行 percist, shuffle 需要进行网络传输，风险大</li><li>shuffle 之前进行 precast，框架默认将数据持久化到磁盘，自动执行的</li></ul><h3 id="cache-和-checkpoint-比较"><a href="#cache-和-checkpoint-比较" class="headerlink" title="cache 和 checkpoint 比较"></a>cache 和 checkpoint 比较</h3><p>cache 和 checkpoint 是有显著区别的，缓存把 RDD 计算出来然后放在内存中，但是 RDD 的依赖链还在， 当某个点某个 executor 挂掉了，上面 cache 的 RDD 就会丢掉，需要通过依赖链重放计算。checkpoint 是把 RDD 保存在 HDFS 中，是多副本可靠存储，依赖链可以丢掉，斩断了依赖链，在 executor 发生故障的时候，从 HDFS 中取出，无需重放计算。</p><h3 id="Partition-与-Block-的关联关系"><a href="#Partition-与-Block-的关联关系" class="headerlink" title="Partition 与 Block 的关联关系"></a>Partition 与 Block 的关联关系</h3><ul><li>HDFS 中的 Block 是分布式存储的最小单位，等分，可设置冗余，可能有一部分磁盘空间的浪费</li><li>Spark 中的 Partition 是 RDD 的最小单元，RDD 是由分布在各个节点上的 Partition 组成。Partition 指的是 Spark 计算过程中，生成的数据在计算空间内的最小单元，同一份数据(RDD) 的 partition 大小不一、数量不定，根据 Application 里的算子和最初读入的数据分块决定</li><li>Block 位于存储空间、Partition 位于计算空间，Block 的大小是固定的，Partition 的大小是不固定的。</li></ul><h2 id="BlockManager"><a href="#BlockManager" class="headerlink" title="BlockManager"></a>BlockManager</h2><blockquote><p>管理数据块。是一个嵌入在 Spark 中的 key-value 型分布式存储系统，也是 Master-Slave 结构的，RDD-cache、 shuffle-output、broadcast 等的实现都是基于 BlockManager 来实现的。</p></blockquote><p><img src="http://img.janhen.com/20210414144422ZnWph0.jpg" alt="http://img.janhen.com/20210414144422ZnWph0.jpg"></p><p><strong>BlockManager 中的组件：</strong></p><ul><li>DiskStore：负责对磁盘数据进行读写</li><li>MemoryStore：负责对内存数据进行读写</li><li>BlockTransferService：负责建立到远程其他节点 BlockManager 的连接，对远程其他节点的 BlockManager 的数据进行读写</li></ul><p><strong>存储和管理机制：</strong></p><p>每个节点上存储的 block 信息都会汇报给 Driver 端的 BlockManager Master 作统一管理，BlockManager 对外提供 get 和 set 数据接口，可将数据存储在 Memory、Disk、Off-heap。</p><p><strong>BlockManger 在 Spark 中的使用</strong></p><ul><li>shuffle 的过程中使用 BlockManager 作为数据的中转站</li><li>将广播变量发送到 Executor 时， broadcast 底层使用的数据存储层</li><li>spark streaming 一个 ReceiverInputDStream 接收到的数据，先放在 BlockManager 中， 然后封装为一个 BlockRdd 进行下一步运算</li><li>如果对一个 RDD 进行了 cache，CacheManager 也是把数据放在了 BlockManager 中， 后续 Task 运行的时候可以直接从 CacheManager 中获取到缓存的数据，不用再从头计算</li></ul><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><ul><li><code>spark.storage.memoryFraction</code><ul><li>用于设置 RDD 持久化数据在 Executor 内存中能占的比例，默认是 0.6， 默认 Executor 60% 的内存，可以用来保存持久化的 RDD 数据。根据的持久化策略，如果内存不够时，可能数据就不会持久化，或者数据会写入磁盘；</li><li>如果持久化操作比较多，可以提高 <code>spark.storage.memoryFraction</code> 参数，使得更多的持久化数据保存在内存中，提高数据的读取性能，如果 shuffle 的操作比较多，有很多的数据读写操作到 JVM 中，那么应该调小一点，节约出更多的内存给 JVM，避免过多的 JVM gc 发生。</li></ul></li><li><code>spark.shuffle.memoryFraction</code><ul><li>为 Spark 调优中的重要参数，shuffle 从上一个 task 拉去数据过来，要在Executor进行聚合操作， 聚合操作时使用Executor内存的比例由该参数决定，默认是20%如果聚合时数据超过了该大小，那么就会spill到磁盘，极大降低性能；</li><li>如果Spark作业中的RDD持久化操作较少，shuffle操作较多时，建议降低持久化操作的内存占比，提高shuffle操作的内存占比比例， 避免shuffle过程中数据过多时内存不够用，必须溢写到磁盘上，降低了性能。此外，如果发现作业由于频繁的gc导致运行缓慢，意味着task执行用户代码的内存不够用， 那么同样建议调低这个参数的值。</li></ul></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://books.japila.pl/apache-spark-internals/storage/BlockManager/">BlockManager - The Internals of Apache Spark</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;静态内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark 2.0 以前版本采用静态内存管理机制。存储内存、执</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-管理</title>
    <link href="http://example.com/2021/04/09/MySQL-%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/04/09/MySQL-%E7%AE%A1%E7%90%86/</id>
    <published>2021-04-08T17:10:05.000Z</published>
    <updated>2021-04-08T17:15:27.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本管理"><a href="#基本管理" class="headerlink" title="基本管理"></a>基本管理</h2><p>查看数据库中行数大于 0 的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找表行大于0的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(table_schema, <span class="string">&#x27;.&#x27;</span>, table_name)                    <span class="keyword">AS</span>  TABLE_NAME</span><br><span class="line">      ,<span class="keyword">engine</span>                                                   <span class="keyword">AS</span>  TABLE_ENGINE </span><br><span class="line">      ,table_type                                               <span class="keyword">AS</span>  TABLE_TYPE</span><br><span class="line">      ,table_rows                                               <span class="keyword">AS</span>  TABLE_ROWS</span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(data_length  / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_DATA_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(index_length / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_IDX_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>((data_length + index_length ) </span><br><span class="line">            / ( <span class="number">1024</span> * <span class="number">1024</span> ), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)                         <span class="keyword">AS</span>  TOTAL_SIZE</span><br><span class="line">      ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span>  data_length =<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">ELSE</span>  <span class="keyword">ROUND</span>(index_length / data_length, <span class="number">2</span>) <span class="keyword">END</span>      <span class="keyword">AS</span>  TB_INDX_RATE</span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>( data_free / <span class="number">1024</span> / <span class="number">1024</span>,<span class="number">2</span>), <span class="string">&#x27;MB&#x27;</span>)          <span class="keyword">AS</span>  TB_DATA_FREE </span><br><span class="line">      ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span> (data_length + index_length) = <span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="keyword">ROUND</span>(data_free/(data_length + index_length),<span class="number">2</span>) </span><br><span class="line">       <span class="keyword">END</span>                                                        <span class="keyword">AS</span>  TB_FRAG_RATE</span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES  </span><br><span class="line"><span class="keyword">WHERE</span> TABLE_ROWS &gt; <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> table_name <span class="keyword">in</span> (<span class="string">&#x27;entitylog&#x27;</span>,<span class="string">&#x27;iterfacelog&#x27;</span>,<span class="string">&#x27;stockshiftflow&#x27;</span>,<span class="string">&#x27;stockoperlog&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_length </span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><ul><li><code>-e</code>: 执行 SQL 语句</li><li><code>-D</code>: 连接的数据库</li><li><code>-s</code>, <code>--silent</code>: 使用 tab 作为分隔符，row ⇒ line，用于制作报表</li><li><code>-C</code>, <code>--compress</code>: 使用压缩在 client/server 之间</li><li>输出： 配合 Excel 制表<ul><li><code>-B</code>: 使用 Tab 替换分隔符</li><li><code>-N</code>: 不输出列信息</li><li><code>-E</code>: 垂直输出，展示格式</li><li><code>-H</code>: 以 HTML 输出</li><li><code>-X</code>: 以 XML 输出</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 DB 执行 SQL，让结果按照特定格式显示，方便 awk, sed 处理</span></span><br><span class="line">mysql -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> -h&lt;ip&gt; -D school -e <span class="string">&quot;SELECT * FROM student;&quot;</span></span><br><span class="line">mysql -udbuser -p123456 -h&lt;ip&gt; -D school -N -B -e <span class="string">&quot;SELECT * FROM student;&quot;</span></span><br><span class="line">mysql -udbuser -p123456 -h&lt;ip&gt; -D school -N -H -B -e <span class="string">&quot;SELECT * FROM student;&quot;</span> &gt; result.html</span><br></pre></td></tr></table></figure><h3 id="服务信息查看"><a href="#服务信息查看" class="headerlink" title="服务信息查看"></a>服务信息查看</h3><p>查看最近的 InnoDB 信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> <span class="keyword">INNODB</span> <span class="keyword">STATUS</span> \\G</span><br></pre></td></tr></table></figure><p>查看存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUE <span class="keyword">LIKE</span> <span class="string">&#x27;.*&#x27;</span> \\G</span><br></pre></td></tr></table></figure><p>查看函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUE <span class="keyword">LIKE</span> <span class="string">&#x27;.*&#x27;</span> \\G</span><br></pre></td></tr></table></figure><p>查找出所有 function,routines</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SPECIFIC_NAME <span class="keyword">FROM</span> information_schema.Routines \\G</span><br></pre></td></tr></table></figure><p>查看服务器状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;%lock%&#x27;</span>\\G</span><br></pre></td></tr></table></figure><p>查询是否锁表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录当前锁表状态 </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">where</span> In_use &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>查询 MySQL 进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Top 100</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure><p>查看正在锁的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS; </span><br></pre></td></tr></table></figure><p>查看等待锁的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS; </span><br></pre></td></tr></table></figure><p>慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看慢查询时间</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;long_query_time&quot;</span>;</span><br><span class="line"><span class="comment">-- 查看慢查询配置情况</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&quot;%slow_queries%&quot;</span>;</span><br><span class="line"><span class="comment">-- 查看慢查询日志路径</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;%slow%&quot;</span>;</span><br></pre></td></tr></table></figure><p>查看当前有那些表是打开的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span> <span class="keyword">from</span> <span class="keyword">database</span>;</span><br></pre></td></tr></table></figure><p>查看服务器超时参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> ‘%<span class="keyword">timeout</span>%’;</span><br><span class="line"><span class="comment">-- 隔离级别SHOW VARIBALES LIKE &#x27;ios%&#x27;</span></span><br><span class="line"><span class="comment">-- innodb</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span></span><br><span class="line"><span class="comment">-- 日志缓冲区</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">lIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span></span><br><span class="line"><span class="comment">-- 表的索引信息查看</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> &lt;mytab&gt;</span><br><span class="line"><span class="comment">-- 表信息查看</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;mytab&gt; \\G</span><br><span class="line"><span class="comment">-- warning 出现后的查看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span>;</span><br><span class="line"><span class="comment">-- 时区设置</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">time_zone</span>=<span class="string">&#x27;+10:00&#x27;</span>;</span><br><span class="line"><span class="comment">-- 隔离级别设置</span></span><br><span class="line"><span class="keyword">SET</span> SESSSION <span class="keyword">TRANSACTION</span> <span class="keyword">LEVEL</span></span><br></pre></td></tr></table></figure><h3 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h3><p>对于连接程序的账户，不给予 <code>ALERT</code> 权限，但是给定 DML 语句的 <code>EXEC</code>，让用户通过 <code>EXEC</code> 执行函数或是存储过程来变更表结构，防止权限造成的表结构更改混乱问题</p><p><a href="https://www.notion.so/1d0ad58b7c5b441e84544c888ba6b395">权限</a></p><p>创建检查账号:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,process,super,<span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> . </span><br><span class="line"><span class="keyword">to</span> <span class="string">&#x27;mysql_check&#x27;</span>@<span class="string">&#x27;x.x.x.x&#x27;</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;mysql_check&#x27;</span>; </span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p><strong>如何在给定场景下为某用户授权？</strong></p><p>对于对接的数据库授权，主要为 DML 权限</p><p><strong>如何为用户授权</strong></p><ul><li>遵循最小权限原则</li><li>使用 Grant 命令对用户授权(非改 db)</li></ul><p><strong>用户管理流程规范</strong> 数据库用户管理流程规范 (1) 最小权限原则 (2) 密码强度策略 (3) 密码过期原则。5.7 中引入 (4) 限制历史密码重用原则</p><p><strong>定义账号</strong> 如何定义MySQL数据库账号？ (1) 用户名@可访问控制列表 1.%：代表可以从所有外部主机访问 2.192.168.1.%：表示可以从192.168.1网段访问 3.localhost: DB服务器本地访问 (2) 使用CREATE USER命令建立用户</p><p>8.0 信息更多</p><p><strong>如何从一个实例迁移数据库账号到另一个实例？</strong> 根据 mysql 的数据库版本是否一致判断</p><ul><li>一致，备份 mysql 数据库，目的实例进行恢复 - 不一致，到处授权 sql</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pt-show-grants u=root，p=123456，h=localhost</span><br><span class="line">show priviledges;  </span><br><span class="line">CREATE USER userinfo IDENTIFIED BY <span class="string">&#x27;3UuQuskw2k%k&#x27;</span>;</span><br><span class="line">RENAME USER userinfo TO janhen;</span><br><span class="line">DROP USER janhen;</span><br><span class="line">SHOW GRANTS FOR janhen;</span><br><span class="line"></span><br><span class="line">-- 授权给新增的用户</span><br><span class="line">GRANT SELECT,UPDATE,INSERT,DELETE ON openapi.* TO openapi;</span><br><span class="line"></span><br><span class="line">-- 取消授权</span><br><span class="line">REVOKE DELETE ON openapi.* FROM openapi;、</span><br><span class="line"></span><br><span class="line">-- 更改密码</span><br><span class="line">SET PASSWORD FOR openapi = PASSWORD(<span class="string">&#x27;!BrJ%4MROWvN&#x27;</span>);</span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR <span class="string">&#x27;dbadmin&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> = bigshark;</span><br><span class="line"></span><br><span class="line">-- 设置登陆用户的密码</span><br><span class="line">SET PASSWORD = PASSWORD(<span class="string">&#x27;xxxxx&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>权限查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>权限收回</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span> <span class="keyword">on</span> test.* <span class="keyword">from</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>常见权限</strong></p><p>(1) 管理权限</p><p>不提供 MySQL 的 root 权限，给管理员权限，防止误操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="keyword">ON</span> *.* </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;janhenadmin&#x27;</span>@<span class="string">&#x27;sjfksjfaksdjfad&#x27;</span> </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></span><br><span class="line"><span class="keyword">grant</span> super,process,<span class="keyword">file</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;janhen&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p>(2) 数据库的读写权限</p><p>主要用于系统对接使用， SELECT, INSERT, UPDATE, DELETE, EXECUTE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">EXECUTE</span> </span><br><span class="line"><span class="keyword">ON</span> openapi.* </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;openapi&#x27;</span>@<span class="string">&#x27;%&#x27;</span> </span><br><span class="line"><span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>(3) 监控权限</p><p>用于命令行监控，或是 Prometheus 进行监控信息的获取 基本的主从命令 对于统计数据库的权限</p><p>基本的要求： SHOW MASTER LOGS SHOW ENGINE INNODB STATUS SHOW VIEW, PROCESS, REPLICATION CLIENT, SELECT and SHOW DATABASES</p><p>对 mysql 表的查看</p><p>(4) 备份权限</p><p>通过 mysqldump 或是 xtracback 执行备份，需要对 VIEW、Function、event 等进行备份 SELECT, RELOAD, LOCK TABLES, REPLICATION CLIENT, SHOW VIEW, EVENT, PROCESS</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">select</span>,reload,<span class="keyword">lock</span> <span class="keyword">tables</span>,<span class="keyword">replication</span> <span class="keyword">client</span>,<span class="keyword">show</span> <span class="keyword">view</span>,<span class="keyword">event</span>,process </span><br><span class="line"><span class="keyword">ON</span> *.* </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;backup&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5) 登陆权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">usage</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="MySQL-监控"><a href="#MySQL-监控" class="headerlink" title="MySQL 监控"></a>MySQL 监控</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>监控什么</strong></p><p>1、可用性: 端口检测，执行 select 1 或 show status 作为测试 SQL</p><p>2、性能监控: 并发线程监控</p><p>3、对主从复制进行监控</p><p>4、服务器资源的监控</p><p><strong>可用性监控</strong></p><p>本地 | 网络, 自带命令 ping 进行检测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -umonitor -p -h pingtelnet ip db_port</span><br></pre></td></tr></table></figure><p>2、Telent 连接</p><p>3、程序通过网络建立数据库</p><p>@Q: 确定 DB 是否读写 read_only 参数，主从中注意，定期检查</p><p>简单查询 SELECT @@version</p><p>连接数量监控：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 运行最大</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"><span class="comment">-- 当前连接</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;Threads_connected&#x27;</span>;</span><br><span class="line"><span class="comment">-- 比例监控</span></span><br><span class="line">Threads_connected/max_connections&gt;0.8;</span><br></pre></td></tr></table></figure><p><strong>性能监控</strong></p><p>@Q: QPS 和 TPS TPS 每秒的事务数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRU QPS=(Queries2-Queries1)/(Uptime_since_flush_status2- Uptime_since_flush_status1)</span><br><span class="line"></span><br><span class="line">TPS=((Com_insert2+Com_update2+Com_delete2)- (Com_insert1+Com_update1+Com_delete1))/ (Uptime_ since_flush_status2-Uptime_since_flush_ status1)</span><br></pre></td></tr></table></figure><p><strong>主从复制监控</strong></p><p>@Q: 监控主从复制链路的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Master_Log_File:mysql-bin.001083</span><br><span class="line">Read_Master_Log_Pos:228613650</span><br><span class="line">Relay_Log_File:mysqld-relay-bin.003606</span><br><span class="line">Relay_Log_Pos:228613813</span><br><span class="line">Relay_Master_Log_File:mysql-bin.001083</span><br><span class="line">Slave_Io_Running:Yes Slave_SQL_Running:Yes Replicate_Do__DB: Replicate_Iqnore_DB:</span><br></pre></td></tr></table></figure><p>@Q: 主从延迟 #{。。。}</p><p>@Q: 验证主从复制的数据一致性</p><p><strong>MySQL 信息查看</strong></p><blockquote><p>不使用其他的工具，借助 MySQL 自带的命令或表进行查看</p></blockquote><p><strong>MySQL 状态信息查看</strong></p><p>收集这些信息可以用于检测数据库的运行情况 分为全局状态、会话状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> ‘%下面变量%’;  </span><br></pre></td></tr></table></figure><ul><li>Aborted_clients 由于客户没有正确关闭连接已经死掉,已经放弃的连接数量.</li><li>Flush_commands 执行FLUSH命令的次数.</li><li>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数.</li><li><code>Max_used_connections</code> 同时使用的连接的最大数目.</li><li><code>Slow_queries</code>：要花超过long_query_time时间的查询数量.</li><li>Open_tables 打开表的数量.</li><li>Open_files 打开文件的数量.</li><li>Open_streams 打开流的数量(主要用于日志记载）</li><li>Opened_tables 已经打开的表的数量.</li><li>Threads_connected 当前打开的连接的数量.</li></ul><p><strong>INFORMATION_SCHEMA</strong></p><blockquote><p>辅助表信息</p></blockquote><p>transaction</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_TRX;  </span><br></pre></td></tr></table></figure><p>PERFORMANCE_SCHEMA</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">&#x27;perf%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可不与 mysql 在同一个机器上，作为额外的监控组件进行操作 支持服务器分组，支持多个 mysql 连接，较少的配置易于执行</p><h3 id="Innotop"><a href="#Innotop" class="headerlink" title="Innotop"></a>Innotop</h3><p>Innotop 为 MySQL和 InnoDB 事务/状态的监视器，类似 MySQL 的 top 命令，显示查询、InnoDB 事务、锁等待、死锁、打开的表、复制的状态、缓冲信息等。</p><p><strong>运行的参数</strong></p><ul><li>d：多久时间更新一次</li><li>h：连接的主机名</li><li>p：连接的端口</li><li>S：socket的位置</li><li>u：连接的用户</li><li>c: 指定配置文件运行</li></ul><p><code>#</code> 进行服务器分组<code>@</code> 进行选择连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innotop -h 127.0.0.1 \\</span><br><span class="line">  -u root -p<span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br></pre></td></tr></table></figure><p><strong>服务器分组</strong></p><p>保存配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[server_groups]</span><br><span class="line"></span><br><span class="line">inner&#x3D;master233 slave158</span><br><span class="line"></span><br><span class="line">[&#x2F;server_groups] </span><br><span class="line"></span><br><span class="line">[connections]</span><br><span class="line">master233&#x3D;user&#x3D;slave have_user&#x3D;1 pass&#x3D;slave have_pass&#x3D;1 dsn&#x3D;DBI:mysql:;host&#x3D;172.17.10.233;port&#x3D;3306 savepass&#x3D;1</span><br><span class="line">slave158&#x3D;user&#x3D;slave have_user&#x3D;1 pass&#x3D;slave have_pass&#x3D;1 dsn&#x3D;DBI:mysql:;host&#x3D;172.17.10.158;port&#x3D;3306 savepass&#x3D;1</span><br><span class="line"></span><br><span class="line">[&#x2F;connections]</span><br></pre></td></tr></table></figure><p><strong>面板</strong></p><p>M: 主从情况 T: 事务情况</p><p>O: 打开的表 是否在使用，是否被锁住</p><h2 id="数据存储碎片化"><a href="#数据存储碎片化" class="headerlink" title="数据存储碎片化"></a>数据存储碎片化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>碎片分类</strong></p><p>三种类型的数据碎片化</p><ul><li>行碎片（Row fragmentation）</li><li>行间碎片（Intra-row fragmentaion）</li><li>剩余空间碎片（Free space fragmentation）</li></ul><p><strong>碎片的影响</strong></p><p>磁盘上索引页的物理排序不接近页面上记录的索引排序，或者64页块中有许多未使用的页面被分配给索引</p><ul><li>占用的空间比“应该”占用的空间多，所有 InnoDB 数据和索引都存储在 B-trees 中，它们的 fill factor 可能在50％到100％之间变化。</li><li>表扫描需要比“应该”花费更多的时间。</li></ul><p><strong>碎片查看</strong></p><p>(1)碎片大小=数据总大小-实际表空间文件大小</p><p>(2)数据总大小=data_length+index_length=15220736</p><p>(3)实际表空间文件大小=rows<em>avg_rog_length=299335</em>50=14966750</p><p>(4)碎片大小=（15220736-14966750)/1024/1024=0.2M</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span>  mall <span class="keyword">like</span> <span class="string">&#x27;stockshiftflow&#x27;</span> \\G;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> mall <span class="keyword">like</span> <span class="string">&#x27;stockoperlog&#x27;</span> \\G;</span><br><span class="line"><span class="comment">-- 查询空闲空间超过 50M 大小的表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(table_schema, <span class="string">&#x27;.&#x27;</span>, table_name)                    <span class="keyword">AS</span>  TABLE_NAME</span><br><span class="line">      ,<span class="keyword">engine</span>                                                   <span class="keyword">AS</span>  TABLE_ENGINE </span><br><span class="line">      ,table_type                                               <span class="keyword">AS</span>  TABLE_TYPE</span><br><span class="line">      ,table_rows                                               <span class="keyword">AS</span>  TABLE_ROWS</span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(data_length  / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_DATA_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(index_length / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_IDX_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>((data_length + index_length ) </span><br><span class="line">            / ( <span class="number">1024</span> * <span class="number">1024</span> ), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)                         <span class="keyword">AS</span>  TOTAL_SIZE</span><br><span class="line">      ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span>  data_length =<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">ELSE</span>  <span class="keyword">ROUND</span>(index_length / data_length, <span class="number">2</span>) <span class="keyword">END</span>      <span class="keyword">AS</span>  TB_INDX_RATE</span><br><span class="line">    ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>( data_free / <span class="number">1024</span> / <span class="number">1024</span>,<span class="number">2</span>), <span class="string">&#x27;MB&#x27;</span>)            <span class="keyword">AS</span>  TB_DATA_FREE </span><br><span class="line">    ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span> (data_length + index_length) = <span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="keyword">ROUND</span>(data_free/(data_length + index_length),<span class="number">2</span>) </span><br><span class="line">     <span class="keyword">END</span>                                                        <span class="keyword">AS</span>  TB_FRAG_RATE</span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">ROUND</span>(DATA_FREE/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>) &gt;=<span class="number">50</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_free <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>, <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><p><strong>optimize table table_name</strong></p><p>OPTIMIZE 操作会暂时锁住表,而且数据量越大,耗费的时间也越长。</p><p>OPTIMIZE TABLE 后，表的变化跟存储引擎有关。</p><p>对于 INNODB 表,OPTIMIZE TABLE 映射到 ALTER TABLE … FORCE（或者这样翻译：在 InnoDB 表中等价 ALTER TABLE … FORCE），它重建表以更新索引统计信息并释放聚簇索引中未使用的空间。当您在InnoDB表上运行时，它会显示在 OPTIMIZE TABLE 的输出中</p><p>对于 <code>innodb_file_per_table=1</code> 的 InnoDB 表，OPTIMIZE TABLE 会重组表和索引的物理存储，将空闲空间释放给操作系统。也就是说 <code>OPTIMIZE TABLE [tablename]</code> 这种方式只适用于独立表空间</p><p><strong>ALTER TABLE table_name ENGINE = Innodb</strong></p><p>实际上重新整理碎片了.当执行优化操作时,实际执行的是一个空的 ALTER 命令,但是这个命令也会起到优化的作用,它会重建整个表,删掉未使用的空白空间。</p><p>ALTER TABLE ENGINE= INNODB,会重新整理在聚簇索引上的数据和索引。</p><p>在有些情况下，ALTER TABLE xxxx ENGINE= INNODB 更好。例如old_alter_table 系统变量没有启用等等。另外对于 MyISAM 类型表，使用 ALTER TABLE xxxx ENGINE= INNODB 是明显要优于 OPTIMIZE TABLE 这种方法的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stockshiftflow <span class="keyword">ENGINE</span> = <span class="keyword">Innodb</span>;</span><br></pre></td></tr></table></figure><p><strong>pt-online-schema-change</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change  \\</span><br><span class="line"> --user=<span class="variable">$&#123;user&#125;</span> \\</span><br><span class="line"> --password=<span class="variable">$&#123;passwd&#125;</span> \\</span><br><span class="line"> --host=<span class="variable">$&#123;host&#125;</span>  \\</span><br><span class="line"> P=3306,D=<span class="variable">$&#123;database&#125;</span>,t=<span class="variable">$table</span> \\</span><br><span class="line"> --charset=utf8 \\</span><br><span class="line"> --alter=<span class="string">&quot;ENGINE=InnoDB&quot;</span>  \\</span><br><span class="line"> --nocheck-replication-filters \\</span><br><span class="line"> --alter-foreign-keys-method=auto  \\</span><br><span class="line"> --execute</span><br></pre></td></tr></table></figure><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>文件名 clean_pieces.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#********************************************************************</span></span><br><span class="line"><span class="comment">#$1         :         清理碎片的数据库名称</span></span><br><span class="line"><span class="comment">#$2         :         清理碎片的表名称</span></span><br><span class="line"><span class="comment">#Description:         清理 MySQL 表的碎片</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">args=($*)</span><br><span class="line">database=<span class="variable">$&#123;args[0]&#125;</span></span><br><span class="line">tables=( <span class="variable">$&#123;args[@]:1&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;database: <span class="variable">$database</span>&quot;</span></span><br><span class="line"><span class="keyword">for</span> table <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;tables[@]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;table: <span class="variable">$table</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">host=<span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">user=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">passwd=<span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> table <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;tables[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">sql=<span class="string">&quot;</span></span><br><span class="line"><span class="string">select</span></span><br><span class="line"><span class="string">  CONCAT(table_schema, &#x27;.&#x27;, table_name)                           AS  TABLE_NAME,</span></span><br><span class="line"><span class="string">  concat(round(sum((DATA_LENGTH+Index_length)/1024/1024),2),&#x27;MB&#x27;) AS TABLE_SIZE,</span></span><br><span class="line"><span class="string">  concat(round(sum(DATA_LENGTH/1024/1024),2),&#x27;MB&#x27;)                AS DATA_SIZE,</span></span><br><span class="line"><span class="string">  concat(round(sum(Index_length/1024/1024),2),&#x27;MB&#x27;)               AS INDEX_SIZE,</span></span><br><span class="line"><span class="string">  table_rows                                                      AS  TABLE_ROWS,</span></span><br><span class="line"><span class="string">  CASE WHEN  data_length =0 THEN 0</span></span><br><span class="line"><span class="string">            ELSE  ROUND(index_length / data_length, 2) END        AS  TB_INDX_RATE</span></span><br><span class="line"><span class="string">from TABLES where table_schema=&#x27;<span class="variable">$database</span>&#x27; and table_name=&#x27;<span class="variable">$table</span>&#x27;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------- <span class="subst">$(date +%s)</span> Database: <span class="variable">$database</span>, Table: <span class="variable">$table</span>, Begin clean ... --------------- &quot;</span></span><br><span class="line">mysql -u<span class="variable">$user</span> -p<span class="variable">$passwd</span> -P3306 -h<span class="variable">$host</span> information_schema -e <span class="string">&quot;<span class="variable">$sql</span>&quot;</span></span><br><span class="line"></span><br><span class="line">time pt-online-schema-change  \\</span><br><span class="line">  --user=<span class="variable">$&#123;user&#125;</span> \\</span><br><span class="line">  --password=<span class="variable">$&#123;passwd&#125;</span> \\</span><br><span class="line">  --host=<span class="variable">$&#123;host&#125;</span>  \\</span><br><span class="line">  P=3306,D=<span class="variable">$&#123;database&#125;</span>,t=<span class="variable">$table</span> \\</span><br><span class="line">  --charset=utf8 \\</span><br><span class="line">  --alter=<span class="string">&quot;ENGINE=InnoDB&quot;</span>  \\</span><br><span class="line">  --nocheck-replication-filters \\</span><br><span class="line">  --alter-foreign-keys-method=auto  \\</span><br><span class="line">  --execute</span><br><span class="line"></span><br><span class="line">mysql -u<span class="variable">$user</span> -p<span class="variable">$passwd</span> -P3306 -h<span class="variable">$host</span> information_schema -e <span class="string">&quot;<span class="variable">$sql</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行 CASE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理 mall 数据库中表 interfacelog stockoperatelog stockshiftflow 的碎片</span></span><br><span class="line">bash clean_pieces.sh mall interfacelog stockoperatelog stockshiftflow</span><br></pre></td></tr></table></figure><h2 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h2><h3 id="服务器参数"><a href="#服务器参数" class="headerlink" title="服务器参数"></a>服务器参数</h3><p><strong>基本参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto-increment-increment &#x3D; 2      </span><br><span class="line">auto-increment-offset &#x3D; 2    </span><br><span class="line">slave-skip-errors &#x3D; all </span><br></pre></td></tr></table></figure><p><strong>InnoDb基本参数</strong></p><p>状态变量</p><p>基本配置</p><p><strong>innodb_buffer_pool_size</strong></p><p>缓冲池并不仅仅缓存素引：它还会缓存行的数据、自适应哈希索引、插入缓冲（Insert Buffer）、锁，以及其他内部数据结构。 来帮助延迟写入，可合并多个写入操作</p><p><strong>innodb_log_file_size</strong></p><p><strong>max_connections</strong></p><p>最大连接数，阿里云的 MySQL5.8, 8C16G 默认为 4000</p><p><strong>Innodb 参数</strong></p><p><strong>innodb_file_per_table</strong></p><p>每张表都是一个独立表空间，对应每张表都是一个 <code>idb</code> 文件。</p><p>配置成独立表空间后可以对表进行数据、索引碎片整理。</p><p><strong>Innodb_flush_log_at_trx_commit</strong></p><p>事务刷写磁盘日志的策略</p><ul><li>0: 数据不安全，适合配置 slave 机器</li><li>1: 默认值，最安全的设置，每次事务后日志都会刷新到磁盘。</li><li>2: 每秒刷新一次事务，有丢失的风险，对于 master 有时可以接受; MySQL 进挂掉，不会丢任何事务，整个服务器挂了或断点，可能会丢失一些事务</li></ul><p>缓冲区大小</p><p>Innodb read io threads innodb write io threads</p><p>以上两个参数決定了 Innodb 读写的 I0 进程数，默认为 4</p><p>Innodb stats on metadata</p><p>决定了 MYSQL 在什么情況下会刷新 innodb 表的统计信息。</p><p>配置的内容：</p><ul><li>个数 - 字节 - 开启与关闭 - 百分比</li></ul><p>table_cache: 表可被缓存的数量</p><p>key_buffer_size:  以字节为单位</p><p>max_heap_table_size: 指定隐式内存临时表最大允许的大小</p><p>table_cache_size: 结果值比缓存中的表数小，MYSQL 将从缓存中删除不常使用的表</p><p>thread_cache_size:</p><p>query_cache_size:</p><p>sort_buffer_size:</p><p>innodb_buffer_pool_pages_dirty: 状态变量，缓冲池中的脏页数量</p><p>innodb_buffer_pool_instances:  5.5+ 新增</p><p>open_files_limit:  设置的较少，可能出现 too many open files</p><p><strong>参数动态配置</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> sort_buffer_size = &lt;<span class="keyword">value</span>&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> sort_buffer_size = &lt;<span class="keyword">value</span>&gt;</span><br><span class="line"><span class="keyword">SET</span> @@sort_buffer_size := &lt;<span class="keyword">value</span>&gt;</span><br><span class="line"><span class="keyword">SET</span> @@session.sort_buffer_size := &lt;<span class="keyword">value</span>&gt;</span><br><span class="line">@@global.sort_buffer_size := &lt;<span class="keyword">value</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>控制 Innodb 并发</strong></p><p>innodb_thread_concurrency: 并发设置，默认为 0，表示不限制 建议并发值 = CPU 数量 * 磁盘数量 * 2</p><p>innodb_thread_sleep_delay: 微秒为单位, 在进入内核线程超过运行的数量后，第一次休眠的时间，之后重试，若不能进入，则放入到等待队列，由 OS 处理</p><p>innodb_concurrency_tickets: 较少小改</p><p>innodb commit concurrency: 変量控制有多少个线程可以在同时间提交</p><p><strong>排序</strong></p><p>max_length_for_sort_data： 影响使用哪种排序算法</p><p>max_connect_errors:  网络、配置、权限等问题导致大连个链接重试，记录黑名单设置的大，有效地禁用主机黑名单</p><p>read_only： 建议备库设置成只读模式</p><p>slave_net_timeout： 默 1h，可缩短到 1min</p><p><strong>I/O 配置</strong></p><p>innodb_log_file_in_group</p><p><strong>主从配置</strong></p><p>跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断 1062: 一些主键重复 1032: 主从数据库数据不一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave_skip_errors&#x3D;1062  </span><br></pre></td></tr></table></figure><p>忽略指定的数据库同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog-ignore-db&#x3D;mysql</span><br></pre></td></tr></table></figure><p><strong>sync_binlog</strong></p><p>控制何时 binlog 刷新到磁盘上</p><p>0: 由 OS 进行控制 1: 每次事务提交的时候写入，最为安全，但影响性能</p><h3 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h3><p><strong>Connection</strong></p><ul><li>createDatabaseIfNotExist： 默认为 false</li><li>rollbackOnPooledClose: 默认为 true, 在 Driver 因为问题回滚..</li><li>useAffectedRows: 默认为 false</li></ul><p><strong>Session</strong></p><ul><li><code>characterEncoding=utf8</code>: 设置 session 对应的编码格式，告知 server 返回的结果编码格式，默认为 “autodetect”。</li><li>useUnicode=true： 使用 Unicode</li><li><code>serverTimezone=Asia/Shanghai</code>： 设置时区</li></ul><p><strong>Networking</strong></p><ul><li>connectTimeout： 默认为 0，连接超时, 单位 ms</li><li>socketTimeout: 默认为 0，单位 ms. 网络 socket 操作的超时时间</li><li>maxAllowedPacket： 默认为 65535，最大允许发送的网络包 Packet 大小</li><li>useCompression： 默认为 false，使用 zlib 压缩，当与服务器通信的时候</li></ul><p><strong>Statements</strong></p><ul><li>cacheDefaultTimezone： 默认为 true，缓存客户端默认时区，MySQL8.0.20 后添加的</li><li>queryTimeoutKillsConnection: 默认 false</li></ul><p><strong>Performance Extensions</strong></p><p>If ‘cacheCallableStmts’ is enabled, how many callable statements should be cached?</p><p>Default: 100</p><ul><li>metadataCacheSize: 结果元数据缓存的大小，在 cacheResultSetMetaData 设置为 true 时有效，默认 50</li><li>prepStmtCacheSize： 多少 prepared statements 被缓存，默认 25</li><li><code>rewriteBatchedStatements=true</code>：默认 false，重写批量的语句，提高批量的操作效率</li><li><code>allowMultiQueries=true</code>： 允许多查询</li></ul><h3 id="归档数据库配置"><a href="#归档数据库配置" class="headerlink" title="归档数据库配置"></a>归档数据库配置</h3><p>可定期对 MySQL 进行数据归档，可考虑使用 Archive 存储引擎，对于归档的数据库可适当减少配置，关闭一些耗时的配置。</p><p>配置如下：</p><ul><li>使用 4G 的 innodb 缓冲区</li><li>更改事务隔离级别为 READ-UNCOMMITTED，一般只是导入导出无事务操作</li><li>适当调整 mysqldump 的 max_allowed_packet，方便进行必要数据的恢复</li><li>关闭慢查询、binlog</li><li>减小相应的 buffer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port                            &#x3D; 3306</span><br><span class="line">socket                          &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">pid-file                        &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">datadir                         &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">log-error                       &#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;mysql-error.log</span><br><span class="line">tmpdir                          &#x3D; &#x2F;tmp</span><br><span class="line"></span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line"></span><br><span class="line"># binlog setting</span><br><span class="line">#log-bin                         &#x3D; mysql-bin</span><br><span class="line">#binlog_format                   &#x3D; MIXED      # can be mixed, decrease ..</span><br><span class="line">#binlog_format                   &#x3D; ROW      # can be mixed, decrease ..</span><br><span class="line">#binlog_row_image                &#x3D; minimal</span><br><span class="line">sync_binlog                     &#x3D; 1  # default 0    affect performance，</span><br><span class="line">                                      # safe to guarantee replication</span><br><span class="line">slave_net_timeout               &#x3D; 60 # defacult 3600</span><br><span class="line"></span><br><span class="line">#expire_logs_days                &#x3D; 7</span><br><span class="line">#relay_log                       &#x3D; mysql-relay</span><br><span class="line">#server_id                       &#x3D; &#123;&#123;server_id | default(&#39;555&#39;)&#125;&#125;</span><br><span class="line">#log_bin_trust_function_creators &#x3D; 1</span><br><span class="line">wait_timeout                    &#x3D; 57600</span><br><span class="line">interactive_timeout             &#x3D; 57600</span><br><span class="line"></span><br><span class="line">max_allowed_packet              &#x3D; 512M # or 100M</span><br><span class="line">event_scheduler                 &#x3D; 1</span><br><span class="line">max_connections                 &#x3D; 2000</span><br><span class="line"></span><br><span class="line"># log setting &#123;slow query, not using indexs&#125;</span><br><span class="line">#slow_query_log                  &#x3D; &#123;&#123;slow_query_log | default(&#39;0&#39;)&#125;&#125;</span><br><span class="line">#slow_query_log_file             &#x3D; mysql-slow.log</span><br><span class="line">#long_query_time                 &#x3D; &#123;&#123;long_query_time | default(&#39;0.20&#39;)&#125;&#125;</span><br><span class="line">#log_queries_not_using_indexes   &#x3D; &#123;&#123;log_queries_not_using_indexes | default(&#39;0&#39;)&#125;&#125;</span><br><span class="line"></span><br><span class="line"># character</span><br><span class="line">character-set-server            &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line"># tx</span><br><span class="line">transaction-isolation                   &#x3D; READ-UNCOMMITTED #REPEATABLE-READ req for ACID, SERIALIZABLE req XA</span><br><span class="line"></span><br><span class="line"># innodb</span><br><span class="line">#innodb_buffer_pool_size         &#x3D; 768M</span><br><span class="line">innodb_buffer_pool_size         &#x3D; 4G</span><br><span class="line">                                  # old 128M, 70%-80% mache mem</span><br><span class="line">innodb_log_file_size            &#x3D; 32M # old 500M, total 1G,  can bigger to 1024M</span><br><span class="line">                                       # Note: modify need to move old file to other position,may start fail</span><br><span class="line">                                       # 64G_RAM+ &#x3D; 768, 24G_RAM+ &#x3D; 512, 8G_RAM+ &#x3D; 256, 2G_RAM+ &#x3D; 128</span><br><span class="line">#innodb_log_files_in_group       &#x3D; 2 # defacult 2</span><br><span class="line">innodb_log_buffer_size          &#x3D; 64M  # defalut 8M</span><br><span class="line">innodb_buffer_pool_instances    &#x3D; 8    # default</span><br><span class="line">innodb_flush_log_at_trx_commit  &#x3D; 2 # defalut 1, per second trx flush  2&#x2F;0 &#x3D; perf, 1 &#x3D; ACID</span><br><span class="line">innodb_file_per_table           &#x3D; 1</span><br><span class="line">innodb_lock_wait_timeout        &#x3D; 60  # timeout 500</span><br><span class="line">innodb_status_output            &#x3D; ON</span><br><span class="line">innodb_status_output_locks      &#x3D; ON</span><br><span class="line">innodb_print_all_deadlocks      &#x3D; ON</span><br><span class="line">innodb_read_io_threads          &#x3D; 6  # default 4</span><br><span class="line">innodb_write_io_threads         &#x3D; 6  # default 4</span><br><span class="line">#innodb_thread_concurrency       &#x3D; 16 # default 0  recommend 2x core quantity</span><br><span class="line">#innodb_additional_mem_pool_size &#x3D; 8M #default 8M</span><br><span class="line">#innodb_open_files               &#x3D; 2000  # default 2000, can open *.idb file count</span><br><span class="line"># buffer setting</span><br><span class="line">sort_buffer_size                &#x3D; 256K # default 0.25M</span><br><span class="line">join_buffer_size                &#x3D; 256K # default 0.25M,     can bigger to 128M</span><br><span class="line">read_buffer_size                &#x3D; 512K # default 0.125M</span><br><span class="line">read_rnd_buffer_size            &#x3D; 512K # default 0.25M</span><br><span class="line">#max_length_for_sort_data        &#x3D; 1024 # default 1024</span><br><span class="line">#max_connect_errors              &#x3D; 100 # defacult 100</span><br><span class="line">#innodb_doublewrite              &#x3D; 1 # default on</span><br><span class="line">#thread_concurrency              &#x3D; 12  # default 10    recommend 2x CPU cores</span><br><span class="line">#thread_cache_size               &#x3D; 28 # defacult 28    recommend 5% of max_connections</span><br><span class="line">#open_files_limit                &#x3D; 1048576 # default 1048576</span><br><span class="line"></span><br><span class="line"># MyISAM</span><br><span class="line">#key_buffer_size                 &#x3D; 32M   # default 8M</span><br><span class="line">#query_cache_size                &#x3D; 1M # default 1M</span><br><span class="line"></span><br><span class="line"># table size</span><br><span class="line">tmp_table_size                  &#x3D; 128M  # default 16M</span><br><span class="line">max_heap_table_size             &#x3D; 128M  # default 16M recommend same size as tmp_table_size</span><br><span class="line"></span><br><span class="line"># concat</span><br><span class="line">group_concat_max_len            &#x3D; 100000000</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set           &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set           &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">quote-names</span><br><span class="line">max_allowed_packet              &#x3D; 256M</span><br></pre></td></tr></table></figure><h3 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port                            = 3306</span><br><span class="line">socket                          = /var/run/mysqld/mysqld.sock</span><br><span class="line">pid-file                        = /var/run/mysqld/mysqld.pid</span><br><span class="line">datadir                         = /var/lib/mysql</span><br><span class="line">log-error                       = /var/log/mysql/mysql-error.log</span><br><span class="line">tmpdir                          = /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># binlog setting</span></span><br><span class="line">log-bin                         = mysql-bin</span><br><span class="line"><span class="comment">#binlog_format                   = MIXED      # can be mixed, decrease ..</span></span><br><span class="line">binlog_format                   = ROW      <span class="comment"># can be mixed, decrease ..</span></span><br><span class="line">binlog_row_image                = minimal</span><br><span class="line"><span class="comment">#sync_binlog                     = 1  # default 0    affect performance，</span></span><br><span class="line">                                      <span class="comment"># safe to guarantee replication</span></span><br><span class="line">slave_net_timeout               = 60 <span class="comment"># defacult 3600</span></span><br><span class="line"></span><br><span class="line">expire_logs_days                = 7</span><br><span class="line">relay_log                       = mysql-relay</span><br><span class="line">server_id                       = 199192</span><br><span class="line">log_bin_trust_function_creators = 1</span><br><span class="line">wait_timeout                    = 57600</span><br><span class="line">interactive_timeout             = 57600</span><br><span class="line"></span><br><span class="line">max_allowed_packet              = 256M <span class="comment"># or 100M</span></span><br><span class="line">event_scheduler                 = 1</span><br><span class="line">max_connections                 = 2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># log setting &#123;slow query, not using indexs&#125;</span></span><br><span class="line">slow_query_log                  = 1</span><br><span class="line">slow_query_log_file             = mysql-slow.log</span><br><span class="line">long_query_time                 = 0.20</span><br><span class="line">log_queries_not_using_indexes   = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># character</span></span><br><span class="line">character-<span class="keyword">set</span>-<span class="keyword">server</span>            = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># tx</span></span><br><span class="line"><span class="keyword">transaction</span>-<span class="keyword">isolation</span>                   = REPEATABLE-<span class="keyword">READ</span> <span class="comment">#REPEATABLE-READ req for ACID, SERIALIZABLE req XA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># innodb</span></span><br><span class="line">innodb_buffer_pool_size         = <span class="number">18</span>G</span><br><span class="line">                                  <span class="comment"># old 128M, 70%-80% mache mem</span></span><br><span class="line">innodb_log_file_size            = <span class="number">500</span>M <span class="comment"># old 500M, total 1G,  can bigger to 1024M</span></span><br><span class="line">                                       <span class="comment"># <span class="doctag">Note:</span> modify need to move old file to other position,may start fail</span></span><br><span class="line">                                       <span class="comment"># 64G_RAM+ = 768, 24G_RAM+ = 512, 8G_RAM+ = 256, 2G_RAM+ = 128</span></span><br><span class="line"><span class="comment">#innodb_log_files_in_group       = 2 # defacult 2</span></span><br><span class="line">innodb_log_buffer_size          = <span class="number">8</span>M  <span class="comment"># defalut 8M</span></span><br><span class="line">innodb_buffer_pool_instances    = <span class="number">8</span>    <span class="comment"># default</span></span><br><span class="line">innodb_flush_log_at_trx_commit  = <span class="number">2</span> <span class="comment"># defalut 1, per second trx flush  2/0 = perf, 1 = ACID</span></span><br><span class="line">innodb_file_per_table           = <span class="number">1</span></span><br><span class="line">innodb_lock_wait_timeout        = <span class="number">60</span>  <span class="comment"># timeout 500</span></span><br><span class="line">innodb_status_output            = <span class="keyword">ON</span></span><br><span class="line">innodb_status_output_locks      = <span class="keyword">ON</span></span><br><span class="line">innodb_print_all_deadlocks      = <span class="keyword">ON</span></span><br><span class="line">innodb_read_io_threads          = <span class="number">6</span>  <span class="comment"># default 4</span></span><br><span class="line">innodb_write_io_threads         = <span class="number">6</span>  <span class="comment"># default 4</span></span><br><span class="line"><span class="comment">#innodb_thread_concurrency       = 16 # default 0  recommend 2x core quantity</span></span><br><span class="line"><span class="comment">#innodb_additional_mem_pool_size = 8M #default 8M</span></span><br><span class="line"><span class="comment">#innodb_open_files               = 2000  # default 2000, can open *.idb file count</span></span><br><span class="line"><span class="comment"># buffer setting</span></span><br><span class="line">sort_buffer_size                = <span class="number">1</span>M <span class="comment"># default 0.25M</span></span><br><span class="line">join_buffer_size                = <span class="number">1</span>M <span class="comment"># default 0.25M,     can bigger to 128M</span></span><br><span class="line">read_buffer_size                = <span class="number">1</span>M <span class="comment"># default 0.125M</span></span><br><span class="line">read_rnd_buffer_size            = <span class="number">1</span>M <span class="comment"># default 0.25M</span></span><br><span class="line"><span class="comment">#max_length_for_sort_data        = 1024 # default 1024</span></span><br><span class="line"><span class="comment">#max_connect_errors              = 100 # defacult 100</span></span><br><span class="line"><span class="comment">#innodb_doublewrite              = 1 # default on</span></span><br><span class="line"><span class="comment">#thread_concurrency              = 12  # default 10    recommend 2x CPU cores</span></span><br><span class="line"><span class="comment">#thread_cache_size               = 28 # defacult 28    recommend 5% of max_connections</span></span><br><span class="line"><span class="comment">#open_files_limit                = 1048576 # default 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyISAM</span></span><br><span class="line"><span class="comment">#key_buffer_size                 = 32M   # default 8M</span></span><br><span class="line"><span class="comment">#query_cache_size                = 1M # default 1M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># table size</span></span><br><span class="line">tmp_table_size                  = <span class="number">128</span>M  <span class="comment"># default 16M</span></span><br><span class="line">max_heap_table_size             = <span class="number">128</span>M  <span class="comment"># default 16M recommend same size as tmp_table_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># concat</span></span><br><span class="line">group_concat_max_len            = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>           = utf8mb4</span><br><span class="line"></span><br><span class="line">[<span class="keyword">client</span>]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>           = utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line"><span class="keyword">quick</span></span><br><span class="line">quote-<span class="keyword">names</span></span><br><span class="line">max_allowed_packet              = <span class="number">128</span>Mr</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="MySql-大表数据删除"><a href="#MySql-大表数据删除" class="headerlink" title="MySql 大表数据删除"></a>MySql 大表数据删除</h3><p>Mysql 官网对于大表数据的删除说明</p><blockquote><p>If you are deleting many rows from a large table, you may exceed the lock table size for an InnoDB table. To avoid this problem, or simply to minimize the time that the table remains locked, the following strategy (which does not use DELETE at all) might be helpful: Select the rows not to be deleted into an empty table that has the same structure as the original table: INSERT INTO t_copy SELECT * FROM t WHERE … ; Use RENAME TABLE to atomically move the original table out of the way and rename the copy to the original name: RENAME TABLE t TO t_old, t_copy TO t; Drop the original table:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> copy_interfacelog </span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> mall.servicelog </span><br><span class="line"><span class="keyword">WHERE</span> logtime <span class="keyword">between</span> <span class="string">&#x27;2020-04-07 02:00:00&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-04-14 10:23:24&#x27;</span>;</span><br><span class="line"><span class="comment">-- 使用 mysqldump, file...备份恢复</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> mall.servicelog  <span class="keyword">TO</span> mall.old_servicelog copy_interfacelog <span class="keyword">TO</span> interfacelog;  </span><br></pre></td></tr></table></figure><p>通过 <code>INSERT INTO &lt;table-name&gt; SELECT ..</code> 筛选出不需要删除的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`table`</span> <span class="keyword">WHERE</span> (whatever criteria) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line">MYSQL=<span class="string">&quot;mysql -uroot -p$MYSQL_ROOT_PASSWORD &quot;</span></span><br><span class="line"><span class="keyword">sql</span>=<span class="string">&quot;select uuid from mail.interfacelog where (condition) order by uuid desc limit 1000 &quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 1000`</span>; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">$MYSQL -e <span class="string">&quot;$sql&quot;</span> | sed <span class="string">&#x27;s;/|;;g&#x27;</span> | awk <span class="string">&#x27;&#123;if(NR&gt;1)print &quot;delete from table_name where uuid = &quot;,$1,&quot;;&quot; &#125;&#x27;</span> | $MYSQL; </span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://stackoverflow.com/questions/1318972/deleting-millions-of-rows-in-mysql">Deleting millions of rows in MySQL</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">MySQL :: MySQL 8.0 Reference Manual :: 13.7.3.4 OPTIMIZE TABLE Statement</a></p><p>官网对于 OPTIMIZE TABLE 说明</p><p><a href="https://www.cnblogs.com/kerrycode/p/10943122.html">潇湘隐者</a></p><p>MySQL 数据存储碎片化</p><p><a href="https://gist.github.com/fevangelou/fb72f36bbe333e059b66">Optimized my.cnf configuration for MySQL/MariaSQL (on Ubuntu, CentOS etc. servers)</a></p><p>优化的 mysql 配置</p><p><a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/">Ten MySQL performance tuning settings after installation</a></p><p>percona 网站对于 MySQL 性能调整配置说明</p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html</a></p><p>官网对于属性的配置</p><p><a href="https://stackoverflow.com/questions/32286518/whats-the-difference-between-cacheprepstmts-and-useserverprepstmts-in-mysql-jdb">What’s the difference between cachePrepStmts and useServerPrepStmts in MySQL JDBC Driver</a></p><p><a href="https://stackoverflow.com/questions/2993251/jdbc-batch-insert-performance">https://stackoverflow.com/questions/2993251/jdbc-batch-insert-performance</a></p><p>批量操作参数的更改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本管理&quot;&gt;&lt;a href=&quot;#基本管理&quot; class=&quot;headerlink&quot; title=&quot;基本管理&quot;&gt;&lt;/a&gt;基本管理&lt;/h2&gt;&lt;p&gt;查看数据库中行数大于 0 的表&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-备份与恢复</title>
    <link href="http://example.com/2021/04/09/MySQL-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://example.com/2021/04/09/MySQL-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2021-04-08T17:06:57.000Z</published>
    <updated>2021-04-08T17:16:05.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份概述"><a href="#备份概述" class="headerlink" title="备份概述"></a>备份概述</h2><blockquote><p>备份决定了数据库的安全，在主从不一致的情况下删除从库的所有数据，进行数据重新整理。</p></blockquote><p>对于 MyISAM 备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br></pre></td></tr></table></figure><h3 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h3><p><strong>逻辑备份：</strong> 结果为 sql 文件，方法适用于所有 Engine</p><p><strong>物理备份：</strong> 数据库目录的拷贝，对于内存表只备份结构</p><p><strong>备份的内容：</strong></p><ul><li>事务的 innodb 表，不带有事务的(无法保证一致性)</li><li>函数(routines)、触发器、视图</li><li>包含的表，有时无需对整个数据库所有的表进行备份，只需要备份重要的业务表，用于以后的恢复</li><li>排除的表，在做全量备份的时候，排除掉日志表、记录表、备份表等与业务非强相关的表，提高备份的效率</li></ul><p><strong>备份的类型：</strong></p><ul><li>热备份： 在线备份，不需要任何的服务停机时间，ibbackup 商业工具可实现</li><li>冷备份： 备份 .frm, .idb 文件，需要离线备份</li><li>温备份： 非离线备份，在线执行，会影响线上的数据库运行</li></ul><p><strong>备份的方案:</strong></p><ul><li>全量备份</li><li>增量备份</li><li>压缩备份</li><li>加密备份</li></ul><p>备份的数据存放到另一块物理磁盘上或是传输到另一台机器上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">data</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> xxx.txt</span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">data</span> <span class="keyword">INFILE</span> xxx.txt <span class="keyword">INTO</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dc_mp_fans <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/data/fans.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line">zip fans.zip /data/fans.txt</span><br><span class="line">scp fans.zip root@ip:/data/ </span><br><span class="line">unzip /data/fans.zip</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">&#x27;/data/fans.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> wxa_fans(</span><br><span class="line">  <span class="keyword">id</span>,appid,openid,unionid,created_at);</span><br></pre></td></tr></table></figure><p><strong>备份场景</strong></p><p>备份业务中重要的业务表</p><p>日志表的归档，归档到另一个表中</p><p>备份/导出/ETL 到大数据平台</p><h3 id="强制恢复"><a href="#强制恢复" class="headerlink" title="强制恢复"></a>强制恢复</h3><p>处理恢复过程中启动不起来的情况</p><p>MySQL 配置参数 innodb_force_recovery 控制</p><ul><li>1: (SRV_FORCE_IGNORE_CORRUPT): 忽略检查到的 corrupt 页。</li><li>2: (SRV_FORCE_NO_BACKGROUND): 阻止主线程的运行，如主线程需要执行 full purge 操作，会导致 crash。</li><li>3: (SRV_FORCE_NO_TRX_UNDO): 不执行事务回滚操作。</li><li>4: (SRV_FORCE_NO_IBUF_MERGE): 不执行插入缓冲的合并操作。</li><li>5: (SRV_FORCE_NO_UNDO_LOG_SCAN): 不查看重做日志，InnoDB 存储引擎会将未提交的事务视为已提交。</li><li>6: (SRV_FORCE_NO_LOG_REDO): 不执行前滚的操作。</li></ul><p>当 innodb_purge_threads 和 innodb_force_recovery 一起设置会出现一种loop 现象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_force_recovery&#x3D;6</span><br><span class="line">innodb_purge_thread&#x3D;0</span><br></pre></td></tr></table></figure><p>当设置参数值大于0后，可以对表进行 select,create,drop 操作,但 insert,update 或者 delete 这类操作是不允许的</p><p>MySQL crash 或者 MySQL 数据库服务器 crash 会导致各种各样的问题 ，比如主备之间的 error 1594 (5.6 版本开启crash-safe ，会最大程度上避免 error 1594的问题)，error 1236， 日志损坏，数据文件损坏等。</p><h3 id="物理文件离线备份"><a href="#物理文件离线备份" class="headerlink" title="物理文件离线备份"></a>物理文件离线备份</h3><p>离线方式的备份，需要停止整个服务 存在复制过程中的文件损坏，对应表空间没法使用，数据库服务一直尝试重启</p><p>注意数据库的 <code>.frm</code>, <code>.idb</code> 的权限 660；目录为 700；目录的属主为 <code>mysql:mysql</code></p><h3 id="基于日志点的恢复"><a href="#基于日志点的恢复" class="headerlink" title="基于日志点的恢复"></a>基于日志点的恢复</h3><p>增量恢复</p><p>备份二进制日志，使用 <code>FLUSH LOGS</code> 开始一个新的二进制日志</p><p><a href="https://dba.stackexchange.com/questions/60722/how-to-recover-truncate-table-in-mysql">https://dba.stackexchange.com/questions/60722/how-to-recover-truncate-table-in-mysql</a></p><p>mysqlbinlog：</p><ul><li><code>--start-position</code>: 开始位置</li><li><code>--stop-position</code>: 停止位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -v mysqlbin.000002 | grep -B5 TRUNCATE --color</span><br><span class="line"></span><br><span class="line">mysqlbinlog \\</span><br><span class="line">  --start-position=1603 \\</span><br><span class="line">  --stop-position=919664 \\</span><br><span class="line">  mysqlbin.000002 &gt; /mysqlbackup/binlog_`date +%y%m%d%H`.sql</span><br><span class="line">show binary logs;</span><br><span class="line">show master logs;</span><br><span class="line">SHOW BINLOG EVENTS;</span><br><span class="line">show binlog events <span class="keyword">in</span> <span class="string">&quot;mysql-bin.000005&quot;</span>;</span><br><span class="line">mysqlbinlog binlog.[0-9]* | mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p>可直接使用 DBver, Navicate, DataGrip 等图形化连接客户端进行各种格式的导出，包含 INSERT 语句、UPDATE 语句、HTML 表格、CSV(TSV)、JSON、格式化的text文本、Markdown 的表格等。</p><p><img src="http://img.janhen.com/20210324225548Pk0vYq.png" alt="http://img.janhen.com/20210324225548Pk0vYq.png"></p><p>SELECT … INTO OUTFILE</p><p>需要登录的 mysql 账号具有 FILE 权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> entitylog <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/var/lib/mysql/backup/entitylog.txt&#x27;</span>;</span><br><span class="line"><span class="comment">-- 指定分割符合换行符， 导出为 CSV 格式</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> entitylog <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/var/lib/mysql/backup/entitylog.txt&#x27;</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">&#x27;&quot;&#x27;</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;\\r\\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>mysql 命令导出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出为 CSV 格式</span></span><br><span class="line">mysql -uroot -p -e &quot;<span class="keyword">select</span> * <span class="keyword">from</span> entitylog<span class="string">&quot; --skip-column-names test|sed -e &quot;</span>s/[\\t]/,/<span class="string">&quot; -e &quot;</span>s/$/\\r/<span class="string">&quot; &gt; entity.txt</span></span><br></pre></td></tr></table></figure><h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><blockquote><p>MySQL 自带的备份工具，可以对数据库进行全备份和部分备份,不支持增量备份。</p></blockquote><p>使用场景： 10G 以下的数据库操作简单</p><p>缺点： 数据量范围：30G –&gt; TB级别 的时候备份、恢复操作很慢，效率低</p><p><strong>基本配置：</strong></p><ul><li><code>-h</code> / -P / -u / -p: 基本连接参数</li><li><code>--single-transaction</code>: 保证导出的数据一致性，保证备份 InnoDB 的一致性逻辑备份，和 –lock-tables 选项是互斥的</li><li><code>-l</code> / <code>--lock-tables</code>:一般用于 MyIsam 备份，与上面的互斥</li><li><code>x, --lock-all-tables</code>: 数据库</li><li><code>-master-data</code>: [1/2]</li></ul><p><strong>备份内容配置:</strong></p><ul><li><code>--all-databases</code>: 备份全部的 DB</li><li><code>--databases &lt;db1&gt; &lt;db2&gt;</code>: 备份指定的多个数据库</li><li><code>--tables a1 a2</code>: 备份指定的多个 Table</li><li><code>-w, --where=&quot;&quot;</code>: 备份表中筛选后的数据</li><li><code>-R, --routines</code>: 备份 procedures, functions</li><li><code>--triggers</code>: 备份触发器</li><li><code>-e, --events</code>:</li><li><code>--no-data</code>: 只导出表结构，不导出数据</li></ul><p><strong>控制输出内容配置：</strong></p><ul><li><code>--skip-add-drop-table</code>: <strong>取消每个数据表创建之前添加 drop 数据表语句</strong>(默认每个表之前存在drop语句)，对于部分恢复的情况下需要注意。</li><li><code>--skip-add-locks</code>: 跳过锁表语句</li><li><code>--no-create-info</code>： 导出的 SQL 中不包含 create table 语句</li><li><code>--set-gtid-purged</code>： 跳过导 GTID</li><li><code>--add-drop-database</code>: 增加删除数据库 sql（默认不会）</li><li>-opt： 等同于 <code>--add-drop-table</code>, <code>--add-locks</code>, <code>--create-options</code>, <code>--quick</code>, <code>--extended-insert</code>, <code>--lock-tables</code>, <code>--set-charset</code>, <code>--disable-keys</code>，默认开启</li><li><code>-c</code>, <code>--complete-insert</code>: 生成的 Insert 语句中带有字段名称, insert into T(col1,col2..) values(…)</li></ul><p>其他配置</p><ul><li><code>–-lock-all-tables</code>: 锁住所有的表，表变为只读的</li><li>–master-data=: 将当前服务器的binlog的位置和文件名追加到输出文件，不会停止当前服务器的主从服务</li><li>-F: 生成新的 binlog 文件</li><li>-C： 启用压缩传递</li><li><code>--dump-slave</code></li></ul><h3 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--all-databases \\</span></span><br><span class="line">  <span class="comment">--master-data \\</span></span><br><span class="line">  <span class="comment">--single-transaction \\</span></span><br><span class="line">  &gt; backup_$(date +%y%m%d).sql</span><br></pre></td></tr></table></figure><h3 id="多服务器数据传输"><a href="#多服务器数据传输" class="headerlink" title="多服务器数据传输"></a>多服务器数据传输</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --host=h1 -uroot -proot --databases db1 | mysql --host=h2 -uroot -proot db2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩传输</span></span><br><span class="line">mysqldump --host=192.168.80.137 -uroot -proot -C --databases <span class="built_in">test</span> | mysql --host=192.168.80.133 -uroot -proot <span class="built_in">test</span> </span><br></pre></td></tr></table></figure><h3 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h3><p>线上环境导入导出使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩备份</span></span><br><span class="line">mysqldump -P3306 \\</span><br><span class="line">  -uroot -p  \\</span><br><span class="line">  -q -Q --set-gtid-purged=OFF \\</span><br><span class="line">  --default-character-set=utf8 \\</span><br><span class="line">  --hex-blob --skip-lock-tables \\</span><br><span class="line">  --databases abc 2&gt;/abc.err |gzip &gt;/abc.sql.gz</span><br><span class="line"><span class="comment"># 还原</span></span><br><span class="line">gunzip -c abc.sql.gz | mysql -uroot -p -vvv -P3306 --default-character-set=utf8 abc 1&gt; abc.log 2&gt;abc.err</span><br></pre></td></tr></table></figure><h3 id="按条件备份"><a href="#按条件备份" class="headerlink" title="按条件备份"></a>按条件备份</h3><p><strong>备份指定数据库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqldump  \\</span><br><span class="line">  -hlocalhost -P3306 \\</span><br><span class="line">  -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --add-drop-table \\</span><br><span class="line">  --master-data=2 \\</span><br><span class="line">  --single-transaction \\</span><br><span class="line">  --routines --triggers --events \\</span><br><span class="line">  --databases account basic report \\</span><br><span class="line">  &gt; backup_$(date +%y%m%d).sql</span><br></pre></td></tr></table></figure><p><strong>备份满足特定条件的表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份指定时间的日志数据</span></span><br><span class="line">mysqldump -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --databases basic \\</span><br><span class="line">  --tables interfacelog \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;logtime &lt; &#x27;2020-05-01 00:00:00&#x27; and logtime &gt; &#x27;2020-04-08 00:00:00&#x27;&quot;</span> \\</span><br><span class="line">   &gt; backup-interfacelog-`date +%y%m%d`</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从重命名的表中备份数据</span></span><br><span class="line">mysqldump -uroot -proot \\</span><br><span class="line">  --databases basic \\</span><br><span class="line">  --tables old_interfacelog \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;logtime between &#x27;2020-04-13 00:00:00&#x27; and &#x27;2020-04-14 00:00:00&#x27;&quot;</span> \\</span><br><span class="line">   &gt; backup-interfacelog-`date +%y%m%d`</span><br></pre></td></tr></table></figure><p>备份表并在 insert 语句中插入字段</p><p>使用场景： 备份数据，并恢复到变更表结构的该表</p><ul><li>归档表重命名原始表名，对应 INSERT INTO <table-name> 与生产库的表名一致</li><li>对于表结构变更的，需要 Insert 增加字段名</li><li>用于从归档到生产库的，需要去除逻辑备份前面的 Drop 语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试输出的结果</span></span><br><span class="line">db=account</span><br><span class="line">table=entitylog</span><br><span class="line">time mysqldump -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --databases <span class="variable">$db</span> \\</span><br><span class="line">  --tables <span class="variable">$table</span> \\</span><br><span class="line">  --complete-insert \\</span><br><span class="line">  --skip-add-locks \\</span><br><span class="line">  --no-create-info \\</span><br><span class="line">  --skip-add-drop-table \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;1=1 limit 0,1&quot;</span> \\</span><br><span class="line">   &gt; test.sql</span><br><span class="line">db=facility</span><br><span class="line">table=<span class="string">&quot;stockoperlog &quot;</span></span><br><span class="line">time mysqldump -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --databases <span class="variable">$db</span> \\</span><br><span class="line">  --complete-insert \\</span><br><span class="line">  --tables <span class="variable">$table</span> \\</span><br><span class="line">  --no-create-info \\</span><br><span class="line">  --skip-add-locks \\</span><br><span class="line">  --skip-add-drop-table \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;logtime &gt; &#x27;2021-01-01 00:00:00&#x27;&quot;</span> \\</span><br><span class="line">   &gt; stockoperlog_210101_`date +%y%m%d`.sql</span><br></pre></td></tr></table></figure><h3 id="备份表结构"><a href="#备份表结构" class="headerlink" title="备份表结构"></a>备份表结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot \\</span><br><span class="line">  --no-data \\</span><br><span class="line">  --databases account \\</span><br><span class="line">  &gt; /tmp/account_schema.sql</span><br></pre></td></tr></table></figure><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>专门创建一个备份数据库，查询出必要的数据，之后插入到实际使用的表</p><p>使用 table 进行恢复，只对需要的进行恢复</p><p>进行时间点的恢复 前提：</p><ul><li>一个时间点的全备</li><li>对应的 binlog</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 SQL 恢复到指定的数据库</span></span><br><span class="line">mysql -uroot -proot \\</span><br><span class="line">  basic &lt; backup_200604_basic.sql</span><br><span class="line"></span><br><span class="line">mysql -uroot -proot \\</span><br><span class="line">  account &lt; backup_200604_account.sql</span><br></pre></td></tr></table></figure><h2 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h2><blockquote><p>可对数据库进行全备和增量备份，使用 binlog 对数据库进行时间点的… 支持在线的物理备份</p></blockquote><p><strong>配置</strong> 在 my.cnf 中指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xtrabackup]</span><br><span class="line">target_dir &#x3D; &#x2F;data&#x2F;backups&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure><p><strong>基础参数</strong></p><ul><li><code>--print-defaults</code>: 打印程序参数和列表并退出</li><li><code>--target-dir=&lt;path&gt;</code>: 备份到的目标文件夹</li><li><code>--backup</code>: take backup to target-dir</li><li><code>--prepare</code>: 准备备份以在备份上启动 mysql 服务器。</li><li><code>--export</code>:</li><li><code>--print-param</code>:</li><li><code>--rate-limit</code>: 限制备份脚本的吞吐量</li></ul><p><strong>备份过滤的参数：</strong></p><ul><li><code>--tables=name</code> / : 根据正则表达式过滤表名，过滤列表根据</li><li><code>--tables-file=name</code>: 根据文件中的 <code>database.table</code> 进行过滤</li><li><code>--databases=name</code>: 根据数据库列表过滤</li><li><code>--tables-exclude=name</code>: 排除指定的表, 与 <code>--tables</code> 相反，优先级比 <code>--tables</code> 高</li><li><code>--databases-exclude=name</code>: 排除指定的数据库</li></ul><p><strong>压缩备份参数</strong></p><ul><li><code>--compress[=name]</code>: 是否进行压缩备份</li><li><code>--compres</code>s： 进行压缩备份</li><li><code>--compress-threads=N</code>: 指定压缩的线程数</li><li><code>--decompress</code>: 解压缩恢复备份数据</li></ul><p><strong>增量备份参数</strong></p><ul><li><code>--incremental-basedir=&lt;path&gt;</code>： 增量备份基于的全量备份文件夹</li></ul><p><strong>数据库恢复参数</strong></p><ul><li><code>--copy-back</code>: 复制之前所有的文件</li></ul><p><strong>其他参数</strong></p><ul><li><code>--slave-info</code>: 主从复制备份有效</li><li><code>--safe-slave-backup</code>:</li><li><code>–-binlog-info[=name]</code></li></ul><h3 id="全量备份-1"><a href="#全量备份-1" class="headerlink" title="全量备份"></a>全量备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_BACKUP_DIR=/var/<span class="built_in">log</span>/mysql/backups/<span class="variable">$dir_name</span>/Full_$(date +%Y.%m.%d_%H.%M.%S)</span><br><span class="line">mkdir -p <span class="variable">$MYSQL_BACKUP_DIR</span></span><br><span class="line">xtrabackup --backup \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span> \\</span><br><span class="line">  -uroot -proot </span><br><span class="line"></span><br><span class="line">xtrabackup --prepare \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span> \\</span><br><span class="line">  -uroot -proot</span><br></pre></td></tr></table></figure><h3 id="有条件的全量备份"><a href="#有条件的全量备份" class="headerlink" title="有条件的全量备份"></a>有条件的全量备份</h3><p>xtrabackup 当前只能指定到表级别，没法对表的数据进行筛选 若需要对表的内容进行筛选，可考虑使用 <code>mysqldump</code> 进行逻辑备份，配合 <code>xtrbackup</code> 的物理备份实现</p><p><strong>排除指定表进行备份</strong></p><p>可根据实际需要列出需要排除的大表，拼接成正则或是到文件中进行过滤；</p><p>可通过 <code>(.*log.*|.*record.*|.*bak.*|.*\\d+.*)</code> 正则表达式进行排除不相关的表；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. define back info</span></span><br><span class="line">MYSQL_BACKUP_DIR=/var/lib/mysql/<span class="keyword">backup</span></span><br><span class="line">back_up_dir=$MYSQL_BACKUP_DIR/Full_$(<span class="built_in">date</span> +%Y.%m.%d_%H.%M.%S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2 compare back info</span></span><br><span class="line"><span class="comment"># Filter pattern: (.*log.*|.*record.*|.*bak.*|.*\\d+.*)</span></span><br><span class="line">mkdir -p $back_up_dir</span><br><span class="line">table_exclude_names=(</span><br><span class="line">  <span class="string">&quot;account.entitylog&quot;</span></span><br><span class="line">  <span class="string">&quot;account.mqlog&quot;</span></span><br><span class="line">  <span class="string">&quot;basic.interfacelog&quot;</span></span><br><span class="line">  <span class="string">&quot;basic.article_bak&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">join</span>() &#123;</span><br><span class="line">  <span class="keyword">local</span> IFS=<span class="string">&quot;$1&quot;</span></span><br><span class="line">  shift</span><br><span class="line">  echo <span class="string">&quot;$*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">join_str=$(<span class="keyword">join</span> \\| <span class="string">&quot;$&#123;table_exclude_names[@]&#125;&quot;</span>)</span><br><span class="line">exclude_table=<span class="string">&quot;($join_str)&quot;</span></span><br><span class="line">echo <span class="string">&quot;exclude_table: $exclude_table&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 非压缩备份</span></span><br><span class="line"><span class="built_in">time</span> xtrabackup <span class="comment">--backup \\</span></span><br><span class="line">  <span class="comment">--host=127.0.0.1 \\</span></span><br><span class="line">  -uroot -proot \\</span><br><span class="line">  <span class="comment">--tables-exclude=&quot;$exclude_table&quot; \\</span></span><br><span class="line">  <span class="comment">--datadir=/var/lib/mysql/ \\</span></span><br><span class="line">  <span class="comment">--target-dir=$back_up_dir</span></span><br></pre></td></tr></table></figure><p><strong>备份指定的表</strong></p><p>单独备份表的话需要表在独立的表空间，对应 innodb_file_per_table=1</p><h3 id="压缩备份-1"><a href="#压缩备份-1" class="headerlink" title="压缩备份"></a>压缩备份</h3><p>需要使用 <code>qpress</code> 工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 qpress</span></span><br><span class="line">percona-release <span class="built_in">enable</span> tools</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install qpress</span><br><span class="line">MYSQL_BACKUP_DIR=/var/<span class="built_in">log</span>/mysql/backups/<span class="variable">$dir_name</span>/Full_$(date +%Y.%m.%d_%H.%M.%S)</span><br><span class="line">mkdir -p <span class="variable">$MYSQL_BACKUP_DIR</span>  </span><br><span class="line">xtrabackup --backup \\</span><br><span class="line">  --compress  \\</span><br><span class="line">  --compress-threads=4 \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">xtrabackup --decompress \\</span><br><span class="line">  --target-dir=/data/compressed/</span><br><span class="line"></span><br><span class="line">xtrabackup --copy-back \\</span><br><span class="line">  --target-dir=/data/backups/</span><br></pre></td></tr></table></figure><p><strong>数据恢复</strong></p><p>数据目录在恢复前必须为空</p><p>在执行恢复前，MySQL 服务需要关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --copy-back \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span> </span><br></pre></td></tr></table></figure><h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><p>增量并压缩备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">datadir=/var/lib/mysql/backup</span><br><span class="line">xtrabackup --user=root \\</span><br><span class="line">  --password=root \\</span><br><span class="line">  --backup \\</span><br><span class="line">  --compress \\</span><br><span class="line">  --compress-threads=4 \\</span><br><span class="line">  --target-dir=<span class="variable">$&#123;datadir&#125;</span>/inc<span class="variable">$&#123;today&#125;</span> \\</span><br><span class="line">  --incremental-basedir=/var/lib/mysql/backup/Full_2020.08.23</span><br></pre></td></tr></table></figure><p>比较偏移的点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat xtrabackup_checkpoints</span><br><span class="line">backup_type = full-backuped</span><br><span class="line">from_lsn = 0</span><br><span class="line">to_lsn = 10820498082</span><br><span class="line">last_lsn = 10820498082</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br><span class="line">flushed_lsn = 10820475795</span><br><span class="line">backup_type = incremental</span><br><span class="line">from_lsn = 10820498082</span><br><span class="line">to_lsn = 10820575291</span><br><span class="line">last_lsn = 10820575291</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br><span class="line">flushed_lsn = 10820572909</span><br></pre></td></tr></table></figure><h3 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h3><p>准备</p><ul><li>可以在任何机器上运行 <code>prepare</code> 命令，无需在原始服务器上, 可复制备份到指定机器上进行恢复</li><li>准备步骤使用此嵌入式 InnoDB 对复制的数据文件执行崩溃恢复</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/</span><br></pre></td></tr></table></figure><h3 id="复制与授权"><a href="#复制与授权" class="headerlink" title="复制与授权"></a>复制与授权</h3><p>复制备份文件</p><p>方式一: 使用 xtraback 提供的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/data/backups/</span><br></pre></td></tr></table></figure><p>方式二: 使用 <code>rsync</code> 或 <code>cp</code> 复制备份文件到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -avrP /data/backup/ /var/lib/mysql/</span><br><span class="line"><span class="comment"># 2 cp </span></span><br></pre></td></tr></table></figure><p>授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于数据量大的情况，可以考虑将大表的数据通过 ETL 工具导出到大数据平台进行存储，业务系统中只保留最近 1年的数据。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://www.cnblogs.com/chenmh/p/5300370.html">MySQL mysqldump数据导出详解</a></p><p><a href="https://blog.csdn.net/helloxiaozhe/article/details/77680255">MySql数据库备份与恢复–使用mysqldump 导入与导出方法总结_helloxiaozhe的博客-CSDN博客_mysqldump备份数据库</a></p><p>MySql数据库备份与恢复——使用mysqldump 导入与导出方法总结</p><p><a href="https://www.percona.com/doc/percona-xtrabackup/2.4/index.html">Percona XtraBackup - Documentation</a></p><p>Percona XtraBackup 2.4 官方文档</p><p><a href="https://www.percona.com/doc/percona-xtrabackup/2.4/xtrabackup_bin/partial_backups.html">Partial Backups</a></p><p>Percona 官网部分备份说明文档</p><p><a href="https://cloud.tencent.com/developer/article/1682656">使用innobackupex对数据库进行部分备份(指定表或数据库)</a></p><p>使用innobackupex对数据库进行部分备份(指定表或数据库)</p><p><a href="https://www.runoob.com/mysql/mysql-database-export.html">MySQL 导出数据</a></p><p>MySQL 导出数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;备份概述&quot;&gt;&lt;a href=&quot;#备份概述&quot; class=&quot;headerlink&quot; title=&quot;备份概述&quot;&gt;&lt;/a&gt;备份概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;备份决定了数据库的安全，在主从不一致的情况下删除从库的所有数据，进行数据重新整理。&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-日志</title>
    <link href="http://example.com/2021/04/09/Mysql-%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2021/04/09/Mysql-%E6%97%A5%E5%BF%97/</id>
    <published>2021-04-08T17:06:49.000Z</published>
    <updated>2021-04-08T17:07:47.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><blockquote><p>MySQL 的动态参数，可以随关随停</p></blockquote><h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p>优化策略：</p><ul><li>调优 TOP10, 之后迭代…</li><li>业务扩展，用户流量增加，进一步调优</li></ul><p>慢查询日志的性能剖析工具：汇总一些信息，自动排序</p><p>查看慢日志：</p><p>正常的格式</p><p>explain</p><p>EXPLAIN 关键字模拟优化器执行 SQL 查询语句</p><p><img src="http://img.janhen.com/202103072224361551841270019.png" alt="http://img.janhen.com/202103072224361551841270019.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> </span><br><span class="line">   star, </span><br><span class="line">  evaluator_no </span><br><span class="line"><span class="keyword">from</span> indicator_evaluate </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> evaluator_no <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>id: 代表执行的顺序</li><li>type: 找到数据行的方式, 数据的访问类型，取值为如下<ul><li>all: 全表扫描</li><li>index: ALL 和 INDEX 都读全表，INDEX 从索引读， ALL 从硬盘读</li><li>range： between, in, &gt;, &lt; 等的查询，无需扫全表</li><li>ref：非唯一性索引扫描，返回匹配..</li><li>eq_ref: 唯一性索引扫描，对于每一个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。</li><li>const: 表示通过索引一次就找到了，const 用于比较为 primary key(主键索引)或者是 unique 索引，因为只匹配一行，所以很快，若将主键作为 where 条件，MySQL 就会把该查询作为一个常量</li><li>system ：表中只有一条记录(等同于系统表) 这是 const 特例，平时不会出现。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 最好达到 ref OR range 级别</span><br><span class="line">system&gt;const&gt;eq_ref&gt;</span><br><span class="line">ref&gt;range&gt;</span><br><span class="line">index&gt;all</span><br></pre></td></tr></table></figure><ul><li><p><strong>extra：</strong> Using where, Using index， Using filesort</p><p>最重要的 extra 的取值是前三个 filesort、 using temporary(性能差的sql语句) 、use index(性能好的 sql语句)；</p><p>是查询优化器进行选择索引的一个参数，及排序的规则；extra 中出现下面两项意味着 MySQL 不能使用索引，效率会有很大的影响，需尽早优化</p><ul><li>Using filesort: 外部索引排序，不是从表中按索引次序读取相关内容，可能在内存或磁盘上排序，MySQL 无法利用索引完成的排序。</li><li>Using temporary: 使用临时表，在 order by 和 group by 中常见</li></ul></li><li><p><strong>select_type:</strong> 查询的类型 有以下六种取值</p><ul><li>simplye: 表示简单查询 ，不包含子查询以及 union</li><li>primary: 若查询中包含了任何的子查询，最外层的主查询标识为 primary</li><li>subquery: 标识为子查询</li><li>derived: 派生的，在 from 子查询的结果会被放入为衍生虚表(临时表)</li><li>union: 若第二个 select 出现在 union 之后，则会标记为 union(若 union 包含在 from 子句的子查询中，外层的的 select 标识为 derived)</li><li>union result：从 union 表中获取数据的 select 标识</li></ul></li><li><p><code>key</code>:实际上使用的索引,为 null 表示为索引失效</p></li><li><p>possiable_keys: 理论上可能使用到的索引，若在查询的时候使用了覆盖索引，那么该索引就不会出现在 possible_keys 中，而只会出现在 key 列中。</p></li><li><p>key_len：表示索引在使用的字节数，可以通过该列计算查询中使用的索引的长度，长度越小越好 key_len 显示的值为索引字段的最大可能长度，而非使用长度，及key_len 是根据表定义计算而得，不是通过表内检索出来的。</p></li><li><p>ref: 表示索引的哪一列被使用，如果可能的话是一个常数，哪些列或者常量被用于索引列上的查找。</p></li><li><p>rows: 根据表信息统计，估算出大约要扫描的行数。</p></li></ul><p><strong>优化：</strong></p><p><strong>&amp;手动优化</strong></p><p><strong>① 修改SQL:</strong> 在业务允许的情况下使得语句走对应的索引；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> evaluator_no, course_id <span class="keyword">from</span> evaluator;</span><br></pre></td></tr></table></figure><p><strong>② 添加索引：</strong>对于无法通过修改 SQL 满足业务的情况下，而此 SQL 又进行多次的查询，对其进行添加索引处理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">index</span> idx_name(&lt;<span class="keyword">col</span>&gt;);</span><br></pre></td></tr></table></figure><p><strong>&amp;查询优化器优化</strong></p><p>不使用密集索引，稀疏索引为二级索引不存放对应的全行信息；</p><p>查询的不需要整体信息；</p><p>记住抽样统计，同时查询是否排序、是否使用临时表进行索引的选择；</p><p><img src="http://img.janhen.com/202103072224511551841656997.png" alt="http://img.janhen.com/202103072224511551841656997.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>( <span class="keyword">id</span> ) <span class="keyword">FROM</span> person_info_large;</span><br><span class="line"><span class="comment">-- 测试使用什么索引所以更好</span></span><br><span class="line">&lt;sql&gt; FORCE INDEX(&lt;index&gt;);</span><br></pre></td></tr></table></figure><h3 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h3><blockquote><p>mysql 自带的工具，较为简单</p></blockquote><p>按序显示执行的 SQL 情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --verbose slow-query.log</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 总次数</li><li><code>-t</code>: 时间</li><li><code>l</code>: 锁的时间</li><li><code>r</code>: 总数据行</li><li><code>at</code>,<code>al</code>,<code>ar</code>: 平均数 按照时间排序的前10个查询</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 10 slow-query.log</span><br><span class="line">mysqldumpslow -s c -t 10 slow-query.log</span><br><span class="line">mysqldumpslow -s l -t 10 slow-query.log</span><br><span class="line">mysqldumpslow -s r -t 10 slow-query.log</span><br></pre></td></tr></table></figure><h3 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="pt-query-digest"></a>pt-query-digest</h3><blockquote><p>percona toolkit 中提供</p></blockquote><p>功能增强的慢查询分析工具，具体使用见 <a href="https://www.notion.so/Percona-Toolkit-e9ea157626d24777babdaacf2babd301">这里</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest \\</span><br><span class="line">  --<span class="built_in">type</span> slowlog \\</span><br><span class="line">  slow-query.log</span><br></pre></td></tr></table></figure><p>根据 STDIN 进行分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --query <span class="string">&quot;select * from mysql.user&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置项：</p><ul><li><code>slow_query_log=1</code>： 开启慢查询；</li><li><code>long_query_time=0.2</code>： 设置慢查询的时间阈值，设置为 200 毫秒；</li><li><code>slow_query_log_file</code>：设置慢查询日志文件目录；</li><li><code>log_queries_not_using_indexes=1</code>： 显示没有使用索引的 SQL 语句；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%quer%&#x27;</span>;        <span class="comment">--慢查询日志开启、位置、时长，查询缓冲、</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_queries%&#x27;</span>;   <span class="comment">-- 当前慢查询数-- </span></span><br><span class="line"><span class="keyword">Set</span> slow querySET <span class="keyword">GLOBAL</span> slow_query_log=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time=<span class="number">1</span>;        <span class="comment">-- 当前会话有效, 修改 my.ini 永久</span></span><br></pre></td></tr></table></figure><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>逻辑日志。为归档日志；记录了完整的逻辑记录；属于 Server 层的日志，可作用于任何存储引擎；</p></blockquote><p>包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，主要用于备份恢复、回滚操作等。</p><p>binlog 有三种格式：Statement, Row 和 Mixed.</p><ul><li>Statement: 基于 SQL 语句的复制（statement-based replication, SBR） ： 对一些函数如 now() 在不同主机上执行结果不同会出现不一致的问题</li><li>Row: 基于行的复制（row-based replication, RBR): 不会出现某些特定情况下的存储过程，或 function，以及 trigger 的调用和触发无法被正确复制的问题。<ul><li>基于 Row 的，数据恢复更快</li></ul></li><li>Mixed: 混合模式复制（mixed-based replication, MBR），混合 statement 和物理文件，减少 binlog 的大小</li></ul><p>生成新的 binlog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">logs</span></span><br></pre></td></tr></table></figure><p><strong>生成新的 binlog 的时机</strong></p><ul><li>MySQL 服务器停止或重启时执行；</li><li>使用 <code>flush logs</code> 命令；</li><li>当 binlog 文件大小超过 <code>max_binlog_size</code> 系统变量配置的上限时；</li></ul><p><strong>查看相关</strong> 查看 binblog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">logs</span>;;</span><br></pre></td></tr></table></figure><p>查看 binlog 文件的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">&quot;mysql-bin.000005&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h3><p>为了保证 binlog 和 redo log 的一致性使用，如果不使⽤“两阶段提交”，那么数据库的状态就有可能和⽤它的⽇志恢复出来的库的状态不⼀致；</p><p>分为 prepare 和 commit 两个阶段；</p><p>对于 prepare 状态的事务，参考 binlog，若该事务在 binlog 中存在，则将其提交，不存在，则将其回滚，这样保证主从之间的一致性。</p><p>不只是误操作后需要⽤这个过程来恢复数据。当需要扩容的时候，也就是多搭建⼀些备库来增加系统的读能⼒的时候，常⻅的做法是⽤全量备份加上应⽤ binlog 来实现的，这个“不⼀致”就会导致你的线上出现主从数据库不⼀致的情况。 简单说，redo log 和 binlog 都可以⽤于表示事务的提交状态，⽽两阶段提交就是让这两个状态保持逻辑上的⼀致。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>数据库恢复</strong></p><p>借助 binlog 配合一次全量备份实现指定时间点数据的恢复</p><p>一些参数</p><ul><li><code>--start-position</code>: 开始位置</li><li><code>--stop-porition</code>: 结束位置</li><li><code>--start-datetime</code>: 开始时间</li><li><code>--stop-datetime</code>: 结束时间</li><li><code>--database</code>: 指定数据库</li><li><code>-no-defaults</code>: 处理默认字符集问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysql-bin.000001 | mysql -uroot -proot</span><br><span class="line">mysqlbinlog mysql-bin.000002 | mysql -uroot -proot</span><br><span class="line">.....</span><br><span class="line">mysqlbinlog \\</span><br><span class="line">  --start-datetime=<span class="string">&quot;2005-12-25 11:25:56&quot;</span>\\</span><br><span class="line">  binlog.000003</span><br></pre></td></tr></table></figure><p>多个 binlog 的恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.[0-9]* | mysql -u root -p</span><br></pre></td></tr></table></figure><p>更改一内容再恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.000001 &gt; tmpfile</span><br><span class="line">... edit tmpfile ...</span><br><span class="line">mysql -u root -p &lt; tmpfile</span><br><span class="line">mysqlbinlog --no-defaults \\</span><br><span class="line">  -v --base64-output=DECODE-ROWS \\</span><br><span class="line">  mysql-bin.000009</span><br></pre></td></tr></table></figure><p>指定位置进行重新执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --start-position=27284 \\</span><br><span class="line">   binlog.001002 binlog.001003 binlog.001004</span><br><span class="line">  | mysql --host=host_name -u root -p</span><br></pre></td></tr></table></figure><h3 id="与-redo-log-比较"><a href="#与-redo-log-比较" class="headerlink" title="与 redo log 比较"></a>与 redo log 比较</h3><p>binlog 与 redo log 日志的区别：</p><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使⽤。</li><li>redo log 是物理⽇志，记录的是“在某个数据⻚上做了什么修改”；binlog是逻辑⽇志，记录的是这个语句的原始逻辑，⽐如“给ID=2这⼀⾏的c字段加1”。</li><li>redo log 空间固定会⽤完；binlog是可以追加写⼊的。“追加写”是指binlog ⽂件写到⼀定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。</li></ul><p><a href="https://www.notion.so/63e588ddc94a453397dcb0e8d736c689">日志比较</a></p><h3 id="实时监控-binlog"><a href="#实时监控-binlog" class="headerlink" title="实时监控 binlog"></a><strong>实时监控 binlog</strong></h3><p>适用场景：</p><ul><li>通过实时对 binlog 进行监控分析，将 binlog 中的数据按照业务进行分开，控制拆分的逻辑</li><li>通过实时监控 binlog，根据事件的类型，删除或更改基于数据库的倒排索引，以此来保证索引的有效性</li><li>通过实时对 binlog 进行读取，将数据写入到 Kafka 中，交由流式处理工具(如Flink) 做实时的分析</li></ul><p>实现方案： 通过第三方库操作(阿里的 canal)，因为 mysql 支持通过远程方式下载指定 mysql-server 上的 binlog，从而能够实现借助端口对 MySQL 进行运行情况监控和更改信息的获取。</p><h3 id="binlog-清理"><a href="#binlog-清理" class="headerlink" title="binlog 清理"></a>binlog 清理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除指定日期以前的日志索引中 binlog 日志文件</span></span><br><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">before</span> <span class="string">&#x27;2016-09-01 17:20:00&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除指定日志文件的日志索引中binlog日志文件</span></span><br><span class="line"><span class="comment">-- 将 bin.000022 之前的binlog清掉</span></span><br><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">to</span> <span class="string">&#x27;mysql-bin.000022&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清除master.info文件、relay-log.info文件，以及所有的relay log文件,并重新启用一个新的relaylog文件</span></span><br><span class="line"><span class="comment">-- 使用reset slave之前必须使用stop slave 命令将复制进程停止</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将删除日志索引文件中记录的所有binlog文件，创建一个新的日志文件，起始值从000001开始。不要轻易使用该命令，这个命令通常仅仅用于第一次用于搭建主从关系的时的主库</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>:</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p><strong>配置项</strong></p><ul><li>log-bin：指定 binlog 的文件名</li><li>innodb_flush_log_at_trx_commit：</li><li>expire_logs_days：保留 binlog 的天数</li><li>max_binlog_size： binlog 单个文件的大小，默认 1G，一个事务所产生的所有事件必须记录在同一个 binlog 文件中，所以即使 binlog 文件的大小达到 max_binlog_size 参数指定的大小，也会写入到 binlog 后才能切换。</li></ul><p><strong>配置更改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">log-bin                         &#x3D; mysql-bin</span><br><span class="line">binlog_format                   &#x3D; ROW         # can be mixed, decrease</span><br><span class="line">binlog_row_image                &#x3D; minimal</span><br><span class="line">expire_logs_days                &#x3D; 30</span><br><span class="line">sync_binlog                     &#x3D; 1           # default 0    affect performance， safe to guarantee replication</span><br><span class="line">innodb_flush_log_at_trx_commit  &#x3D; 2           # defalut 1, per second trx flush  2&#x2F;0 &#x3D; perf, 1 &#x3D; ACID</span><br></pre></td></tr></table></figure><p><strong>会话级别更改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># modify</span><br><span class="line">SET SQL_LOG_BIN&#x3D;0  </span><br><span class="line">SET GLOBAL expire_log_days&#x3D;3;</span><br></pre></td></tr></table></figure><h2 id="redolog-物理"><a href="#redolog-物理" class="headerlink" title="redolog (物理)"></a>redolog (物理)</h2><blockquote><p>为物理日志。重做日志。InnoDB 在处理更新语句的时候，只做了写⽇志这⼀个磁盘操作。这个⽇志叫作 redo log，在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</p></blockquote><p>作用：</p><ul><li>确保事务的持久性</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性</li></ul><p>只有 InnoDB 有，其他引擎没有；</p><p>redolog 确保事务的持久性。</p><p>由来： 如果每⼀次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很⾼。</p><p>包含两部分，一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p><h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>**WAL(Write-Ahead Logging)**： 预写日志。先写⽇志，再写磁盘。利⽤ WAL 技术，数据库将随机写转换成了顺序写，⼤⼤提升了数据库的性能。 但是，由此也带来了内存脏⻚的问题。脏⻚会被后台线程⾃动 flush，也会由于数据⻚淘汰⽽触发 flush，⽽刷脏⻚的过程由于会占⽤资源，可能会让更新和查询语句的响应时间⻓⼀些。</p><h3 id="刷新脏页"><a href="#刷新脏页" class="headerlink" title="刷新脏页"></a>刷新脏页</h3><p><strong>Q： MySQL “抖” 了一下的原因</strong></p><p>A：当内存数据⻚跟磁盘数据⻚内容不⼀致的时候，我们称这个内存⻚为“脏⻚”。</p><p>内存数据写⼊到磁盘后，内存和磁盘上的数据⻚的内容就⼀致了，称为“⼲净⻚”。</p><p>平时执⾏很快的更新操作，其实就是在写内存和⽇志，⽽ MySQL 偶尔“抖”⼀下的那个瞬间，可能就是在刷脏⻚(flush)。</p><p>几种可能的原因：</p><p>① InnoDB 的 redo log 写满了。这时候系统会停⽌所有更新操作，把 checkpoint 往前推进，redo log留出 空间可以继续写。</p><p>② 系统内存不⾜。当需要新的内存⻚，⽽内存不够⽤的时候，就要淘汰⼀些数据⻚，空出内存给别的数据⻚使⽤。如果淘汰的是“脏⻚”，就要先将脏⻚写到磁盘。</p><p>③ MySQL 认为系统“空闲”的时候，即使是“⽣意好”的时候，也要⻅缝插针地找时间，只要有机会就刷⼀点“脏⻚”</p><p>④ MySQL正常关闭的情况，这时候，MySQL 会把内存的脏⻚都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p><p>对性能的影响：</p><p>对于 ① 出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。</p><p>对于 ② 这种情况其实是常态。<strong>InnoDB ⽤缓冲池(buffer pool)管理内存，缓冲池中的内存⻚有三种状态</strong>：第⼀种是，还没有使⽤的； 第⼆种是，使⽤了并且是⼲净⻚； 第三种是，使⽤了并且是脏⻚。</p><p>InnoDB 刷脏页的控制策略</p><p>要正确地告诉 InnoDB 所在主机的 IO 能⼒，这样 InnoDB 才能知道需要全⼒刷脏⻚的时候，可以刷多快。</p><p>可能的问题： MySQL 的写⼊速度很慢，TPS 很低，但是数据库主机的 IO 压⼒并不⼤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_io_capacity           # 会告诉 InnoDB 磁盘能⼒,建议设置成磁盘的 IOPS</span><br></pre></td></tr></table></figure><p>如果你来设计策略控制刷脏⻚的速度，会参考哪些因素呢？</p><p>InnoDB 的刷盘速度就是要参考这两个因素：⼀个是脏⻚⽐例，⼀个是 redo log 写盘速度。</p><p>参数 innodb_max_dirty_pages_pct 是脏⻚⽐例上限，默认值是 75%。InnoDB 会根据当前的脏⻚⽐例(假设为M)，算出⼀个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样：  <strong>根据上述算得的F1(M)和F2(N)两个值，取其中较⼤的值记为R，之后引擎就可以按照innodb_io_capacity定义的能⼒乘以R%来控制刷脏⻚的速度。</strong></p><p><img src="http://img.janhen.com/202103072225031553991442351.png" alt="http://img.janhen.com/202103072225031553991442351.png"></p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><ul><li><pre><code>innodb_flush_log_at_trx_commit<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：指定何时将事务日志刷到磁盘，默认为1。</span><br><span class="line"></span><br><span class="line">  - 0： 事务提交时不会将 log buffer 中日志写入到 os buffer，而是每秒写入 os buffer 并调用fsync()</span><br><span class="line">    - 系统崩溃，会丢失 1 秒钟的数据。</span><br><span class="line">  - 1：每次 commit 都会把 redo log 从 redo log buffer 写入到 system，并 fsync 刷新到磁盘文件中。</span><br><span class="line">    - 即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能较差。</span><br><span class="line">  - 2： 每次事务提交时 MySQL 会把日志从 redo log buffer 写入到 system，但只写入到 file system buffer，由系统内部来 fsync 到磁盘文件。</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_buffer_size&#96;: redo 日志的缓冲区，默认为 8M，延迟事务日志写入磁盘</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_files_in_group&#96;： redo 日志的个数，默认为2，命名为 ib_logfile&lt;N&gt;</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_file_size&#96;： 事务日志的大小</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_group_home_dir&#96;： 事务日志组路径，当前目录表示数据目录</span><br><span class="line"></span><br><span class="line">## undo 日志</span><br><span class="line"></span><br><span class="line">&gt; 属于 InnoDB 存储引擎特有的日志，做事务的处理。</span><br><span class="line"></span><br><span class="line">**提供回滚和多个行版本控制(MVCC)**。</span><br><span class="line"></span><br><span class="line">为逻辑日志，默认存放在共享表空间中，如果配置了 innodb_file_per_table，将会存放在 &lt;table-name&gt;.ibd 中。</span><br><span class="line"></span><br><span class="line">相关的一些问题</span><br><span class="line"></span><br><span class="line">### 配置</span><br><span class="line"></span><br><span class="line">- innodb_max_undo_log_size:</span><br><span class="line">- innodb_undo_tablespaces:</span><br><span class="line">- innodb_undo_log_truncate:</span><br><span class="line">- innodb_purge_rseg_truncate_frequency:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sql</span><br><span class="line">show global variables like &#39;%undo%&#39;;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h3><blockquote><p>中继日志，是复制过程中产生的日志。</p></blockquote><p>relay log 是从库服务器 I/O 线程将主库服务器的二进制日志读取过来记录到从库服务器本地文件，然后从库的 SQL 线程会读取 relay-log 日志的内容并应用到从库服务器上。</p><p><strong>配置</strong></p><ul><li>relay_log：</li><li>max_relay_log_size：</li><li>relay_log_recovery</li></ul><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a><strong>错误日志</strong></h3><p>查找 MySQL 错误日志，查看 MySQL 普通的日志</p><p>通过在 mysql.cnf 中配置错误日志的地址</p><ul><li>log_error：on|文件路径 是否启用错误日志,on表示开启,文件路径表示指定自定义日志路径</li><li>log_warnings： 1|0 是否记录warnings信息到错误日志中</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;log_error&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><ul><li>general_log： on / off</li><li>general_log_file：文件保存地址</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;%genera%&quot;</span>;</span><br><span class="line"><span class="comment">-- 开启</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html">MySQL :: MySQL 8.0 Reference Manual :: 4.6.8 mysqlbinlog - Utility for Processing Binary Log Files</a></p><p>工具 mysqlbinlog 官方文档</p><p>[<a href="https://zhuanlan.zhihu.com/p/58011817">玩转MySQL之八]MySQL日志分类及简介</a></p><p><a href="https://cloud.tencent.com/developer/article/1497297">【MySQL （六） | 详细分析MySQL事务日志redo log】</a></p><p>【MySQL （六） | 详细分析MySQL事务日志redo log】</p><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲_MySQL_数据库-极客时间</a></p><p>极客时间-MySQL实战45讲</p><p><a href="https://www.cnblogs.com/wy123/p/8365234.html">MySQL中的重做日志（redo log），回滚日志（undo log），以及二进制日志（binlog）的简单总结 - MSSQL123 - 博客园</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;慢查询日志&quot;&gt;&lt;a href=&quot;#慢查询日志&quot; class=&quot;headerlink&quot; title=&quot;慢查询日志&quot;&gt;&lt;/a&gt;慢查询日志&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 的动态参数，可以随关随停&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-结构索引与SQL优化</title>
    <link href="http://example.com/2021/04/09/MySQL-%E7%BB%93%E6%9E%84%E7%B4%A2%E5%BC%95%E4%B8%8ESQL%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/04/09/MySQL-%E7%BB%93%E6%9E%84%E7%B4%A2%E5%BC%95%E4%B8%8ESQL%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-08T17:06:14.000Z</published>
    <updated>2021-04-09T09:04:19.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-结构优化"><a href="#MySQL-结构优化" class="headerlink" title="MySQL 结构优化"></a>MySQL 结构优化</h2><p><strong>结构设计</strong></p><ul><li>过分的反范式化为表建立太多的列</li><li>过分的范式化造成太多的表关联</li><li>在 OLTP 环境中使用不恰当的分区表</li><li>使用外键保证数据的完整性</li></ul><p><strong>性能优化顺序</strong></p><ul><li>数据库结构设计和SQL语句</li><li>数据库存储引擎的选择和参数配置</li><li>系统选择及优化</li><li>硬件升级</li></ul><p>知道常用的数据类型，数据库的范式和反范式，各种字段类型占据的大小，更改字段类型是否锁表，如何处理分布式系统下字段的更改。</p><p>1、数据库优化的目的</p><ul><li>减少<strong>数据冗余</strong>，节约数据存储空间</li><li>提高查询效率</li><li>避免数据维护中的异常：<ul><li>插入异常： 必须有什么才能有什么</li><li>更新异常： 如果更改表中的某个实体的单独属性时，需要<strong>对多行进行更新</strong></li><li>删除异常： 如果删除表中的某一实体则会导致其他实体的消失</li></ul></li></ul><p>2、数据库结构设计步骤 (1) 需求分析： (2) 逻辑设计: 确定数据实体之间的逻辑关系，逻辑存储结构 (3) 物理设计： 跟据所使用的数据库特点进行表结构设计 (4) 维护优化： 维护好索引</p><h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><p>1、数据库设计范式 (1) 1NF (2) 2NF： 要求一个表中只具有一个业务主键，符合第二范式的表中<strong>不存在非主键列，只对部分主键的依赖关系</strong> 复合主键 进行表的拆分实现 (3) 3NF： 指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上<strong>消除了非主属性对主键的传递依赖</strong></p><p><strong>范式化优点：</strong> <strong>可以尽量的减少数据冗余；</strong> 范式化的更新操作比反范式化更快； 范式化的表通常比反范式化更小 <strong>范式化缺点：</strong> 对于查询需要对多个表进行关联；更难进行索引优化</p><p>2、反范式化设计 是为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，而<strong>允许存在少量的数据冗余</strong>，反范式化就是<strong>使用空间来换取时间</strong></p><p><strong>反范式化优点：</strong> 可以减少表的关联，可以更好的进行索引优化</p><p><strong>反范式化缺点：</strong> 存在数据冗余及数据维护异常，对数据的修改需要更多的成本</p><h3 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a>字段选择</h3><p>当一个列可以选择多种数据类型时， 考虑顺序： 数字类型 ⇒ 日期 / 二进制类型 ⇒ 字符类型</p><p>对于相同级别的数据类型，应该优先选择占用空间小的数据类型 == 加载的页(16k)</p><p><strong>整数类型</strong></p><p>共五种类型</p><p>int(2) 不影响占用的字节，使用 tinyint 进行存储</p><p>@Q: int(x) x 是什么?</p><p>@A: 11 代表的并不是长度，而是字符的显示宽度,navicat 进行格式化显示了</p><p><strong>实数类型</strong> 共三种类型 FLOAT 4B DOUBLE 8B DECIMAL: 每 4 个字节存 9 个数字，小数点占一个字节</p><p>@Q: DECIMAL（18，9）占用几个字节</p><p>@A: 需要 9 个字节来存储, 表示 9 位整数，9 位小数, 小数点占一个字节， 2*4+1=9</p><p><strong>字符串类型</strong> 常用的两种，还支持 blog, text 类型</p><p>1、varchar 类型 varchar 特点</p><ul><li>varchar 用于存储变长字符串，只占用必要的存储空间列的</li><li>最大长度小于 <strong>255</strong> 则只占用一个额外字节用于记录字符串长度</li><li>列的最大长度大于 255 则要占用两个额外字节用于记录字符串长度</li><li>更改 varchar 小于 255 不会锁表，大于 255 会<strong>锁表</strong></li><li>使用时需要确定 varchar 的长度</li></ul><p>varchar 使用场景：</p><ul><li>字符串列的<strong>最大长度比平均长度</strong>大很多</li><li>字符串列很少被更新</li><li>使用了多字节字符集存储字符串</li></ul><p>2、char 类型</p><p>char 类型的特点：</p><ul><li>CHAR 类型是定长的</li><li>字符串存储在 CHAR 类型的列中会删除末尾的空格</li><li>CHAR 类型的 <strong>最大宽度为255</strong></li></ul><p>char 的适用场景：</p><ul><li>CHAR 类型适合存储所长度近似的值，如 MD5 加密的密码</li><li>CHAR 类型适合存储短字符串，限制 255</li><li>CHAR 类型适合存储经常更新的字符串列，不会锁表，内存占用固定</li></ul><p><strong>日期类型</strong></p><p><a href="https://www.notion.so/ddc0213d5fd7443fb373a18f9a18f7f1">Untitled</a></p><p>共支持四种类型,分别占8B,4B,3B,xB (1) DATATIME 类型 以格式存储日期时间 DATATIME 类型<strong>与时区无关</strong>，占用<strong>8个字节</strong>的存储空间时间范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YYYY-MM-DD HH:MM:SS[.fraction]</span><br><span class="line">datetime=YYYY-MM-DD HH:MM:SS</span><br><span class="line">datetime(6)=YYYY-MM-DD HH:MM:SS.fraction</span><br><span class="line"><span class="comment">-- 支持的范围</span></span><br><span class="line">1000-1-1 0:0:0~9999-12-31 23:59:59</span><br></pre></td></tr></table></figure><p>(2) TIMESTAMP 类型 由格林尼治时间 1970 年 1 月 1 日到当前时间的秒数以]的格式显示 占用 <strong>4个字节</strong> 默认使用 <strong>第一个 timestamp 进行自动更新</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YYYY-MM-DD HH:MM:SS.[L.fraction</span><br></pre></td></tr></table></figure><p>比较 timestamp 类型<strong>显示依赖于所指定的时区</strong> 在行的数据修改时可以<strong>自动修改 timestamp 列的值</strong></p><p>时区比较 存储微秒值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">time_zone</span>=<span class="string">&#x27;+10:00&#x27;</span>;</span><br><span class="line"><span class="comment"># timestamp 与时区相关</span></span><br><span class="line">ALERT TABLE t MODIFY d1 DATETIME(6), MODIFY d2 TIMESTAMP(6);</span><br></pre></td></tr></table></figure><p>(3) Date 类型 为实现 Date，原来使用 int, datetime 存储 占用的字节数比使用字符串、datetime、int 存储要少，使用 date 类型只需要<strong>3个字节</strong> Date 类型还可以利用日期时间函数进行日期之间的计算</p><p>(4) time 类型 time 类型用于存储时间数据</p><p>日期类型使用注意事项</p><ul><li>不要使用字符串类型来存储日期时间数据日期时间类型</li><li>通常比字符串占用的存储空间小日期时间类型在进行查找过滤时可以利用日期来进行对比</li><li>日期时间类型还有着丰富的<strong>处理函数</strong>，可以方便的对时期类型进行日期计算</li><li>使用 Int 存储日期时间不如使用 Timestamp 类型</li></ul><p>使用 int 时间戳保存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">&#x27;2020-01-11 09:53:32&#x27;</span>);  </span><br><span class="line"><span class="keyword">select</span> FROM_UNIXTIME(<span class="number">1578707612</span>);</span><br></pre></td></tr></table></figure><h3 id="Recommand"><a href="#Recommand" class="headerlink" title="Recommand"></a>Recommand</h3><p>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p><p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p><p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p><p><strong>尽量做到冷热数据分离,减小表的宽度</strong> MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）； 更有效的利用缓存，避免读入无用的冷数据； 经常一起使用的列放到一个表中（避免更多的关联操作）。</p><p><strong>尽量控制单表数据量的大小, 建议控制在 500 万以内。</strong></p><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。</p><p>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀。</p><p><strong>日期相关</strong> timestamp 与时区相关，占用 4个字节 datetime, 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前会话时区</span></span><br><span class="line"><span class="keyword">SELECT</span> @@session.time_zone;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前会话时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;Europe/Helsinki&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span> = <span class="string">&quot;+00:00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库全局时区设置</span></span><br><span class="line"><span class="keyword">SELECT</span> @@global.time_zone;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;+8:00&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;Europe/Helsinki&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>索引是在存储引擎层实现的, 部分存储引擎不支持索引</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h2><p>B+树索引：</p><p>1、特点： B-tree 索引能够加快数据的查询速度 <strong>B-tree 索引更适合进行范围查找，叶子节点指向的是主键</strong></p><p>2、适合使用 B+ 树的索引</p><p>全值匹配 <strong>最左前缀</strong> 匹配<strong>列前缀</strong> 范围匹配 精确匹配 只访问索引，覆盖索引</p><p>3、B+ 树使用限制</p><p>查询优化器判定。。。</p><p>非最左列开始查找，。。。</p><p>不能跳过左边的 Not in 和 &lt;&gt; 无法使用 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引</p><h2 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h2><p>Memory 支持，且为默认的 InnoDB 存储引擎支持<strong>自适应 Hash 索引</strong></p><p>1、特点</p><p>精确匹配使用，只用在等值查询</p><p>所有列，<strong>每一行计算一个Hash码</strong></p><p>2、限制</p><p>需要<strong>两次查找</strong>，先找到行，之后读取值</p><p>无法进行排序 只支持等值查找，不支持索引查找、范围查找</p><p>Hash 冲突可能导致性能问题，不适合选择性差的列</p><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p>1、使用索引的好处：</p><ul><li>减少存储引擎需要扫描的数量，16K 每页，内存中存放更多的索引</li><li>帮助排序，避免使用临时表，索引存储结构为 B 树，按序存储</li><li>将随机 I/O 转化成顺序的 I/O，扫描的行变少</li></ul><p>2、索引带来的损耗：</p><ul><li>写操作成本，需要对应的索引控制</li><li>多个索引会增加查询优化器的选择时间</li></ul><p>3、建立索引的策略：</p><p>安装演示数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://downloads.mysql.com/docs/sakila-db.tar.gztar-zxf&gt; sakila-db.tar.gz</span><br><span class="line">mysql -uroot -p &lt; sakila-schema.sql</span><br><span class="line">mysql-uroot -p &lt; sakila-data.sql</span><br></pre></td></tr></table></figure><h2 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h2><p>1、索引列上不能使用函数或表达式</p><p>2、索引长度有限，针对字符串</p><p>3、通过索引的<strong>选择性</strong>确定前缀索引的长度(字符串)</p><p>4、选取索引列的顺序：</p><ul><li>经常使用的放到列的左边(选择性差的例外)</li><li>选择性高的优先</li><li>宽度小的列优先，I/O 小</li></ul><p>5、覆盖索引直接获取：</p><p>优点： 可以优化缓存，减少磁盘I/O 减少随机I/O，将磁盘I/O改为内存的顺序 I/O 可避免对 Innodb 主键索引的二次查询， 可以避免 MyISAM 表进行系统调用</p><p>缺点： memory 不支持覆盖索引 查询中太多的列。。。 使用双 % 号的 LIKE 查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- using index，覆盖索引使用</span></span><br><span class="line">expalin <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> &lt;mytab&gt; <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>\\G</span><br><span class="line"><span class="comment">-- using where, 非覆盖所以不</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> &lt;mytab&gt; <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>\\G</span><br><span class="line"><span class="comment">-- idx_name name 建立索引查询， using where,using index, 自动增加上主键索引的信息</span></span><br><span class="line"><span class="comment">-- 高版本优化 using indexexplain </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> &lt;mytab&gt; <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;joe&#x27;</span></span><br><span class="line"><span class="comment">-- 1. 表达式剔除:  out_date 为索引列, 查找近一个月内添加的商品</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> productwhere <span class="keyword">to_days</span>(out_date)-<span class="keyword">to_days</span>(<span class="keyword">current_date</span>)&lt;=<span class="number">30</span></span><br><span class="line"><span class="comment">-- 优化后的</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> productwhere out_date &lt;= <span class="keyword">date_add</span>(<span class="keyword">current_date</span>，<span class="built_in">interval</span> <span class="number">30</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="comment">-- 2. 前缀索引长度确定</span></span><br></pre></td></tr></table></figure><h2 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h3><p><strong>优化排序：</strong> 通过排序操作 按照索引顺序扫描数据</p><p>优化的限制：</p><ul><li>索引的列顺序和 Order By 子句的顺序完全一致</li><li>索引中所有列的方向（升序，降序）和 Order by 子句完全一致</li><li>Order by 中的字段全部在关联表中的第一张表中</li></ul><h3 id="仿-Hash-索引优化"><a href="#仿-Hash-索引优化" class="headerlink" title="仿 Hash 索引优化"></a>仿 Hash 索引优化</h3><p><strong>模拟 Hash 索引优化</strong></p><p>(1) 使用流程 新增 title_hash 列 设置值 创建索引</p><p>使用限制</p><p>只能处理键值的全值匹配查找 所使用的Hash函数决定着索引键的大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;mytab&gt; <span class="keyword">add</span> title_hash <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line"><span class="keyword">update</span> &lt;mytab&gt; <span class="keyword">set</span> title_name=<span class="keyword">md5</span>(title);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_title_hash <span class="keyword">on</span> &lt;mhytab&gt;(title_hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- using condition index,...</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> &lt;mytab&gt;</span><br><span class="line"><span class="keyword">where</span> title_hash=<span class="keyword">md5</span>(<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    <span class="keyword">and</span> title=<span class="string">&#x27;sdfsfds&#x27;</span>\\G</span><br></pre></td></tr></table></figure><h3 id="优化锁"><a href="#优化锁" class="headerlink" title="优化锁"></a>优化锁</h3><p><strong>索引优化锁</strong></p><p>避免对表的全部锁定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;ddd&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- session 2, 未使用锁住，使用索引不会锁住</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;eee&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="索引自身问题"><a href="#索引自身问题" class="headerlink" title="索引自身问题"></a>索引自身问题</h3><p><strong>4、删除重复和冗余的索引</strong></p><p>单列的索引类型不同的重复 联合索引的最左匹配原则，形成冗余</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- todo 工具下载</span></span><br><span class="line">pt-duplicate-key-checker h=127.9.0.1</span><br></pre></td></tr></table></figure><p><strong>5、查找未使用的索引</strong></p><p>定期清理 通过 performance_schema,information 数据库查询出信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有数据中对应的表，对应的索引名称，索引使用的次数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(object_schema, <span class="string">&quot;.&quot;</span>, object_name) <span class="keyword">AS</span> TABLE_NAME, </span><br><span class="line">index_name                              <span class="keyword">AS</span> INDEX_NAME,</span><br><span class="line">b.<span class="string">`TABLE_ROWS`</span>                          <span class="keyword">AS</span> TABLE_ROWS</span><br><span class="line"><span class="keyword">FROM</span> performance_schema.table_io_waits_summary_by_index_usage a </span><br><span class="line"><span class="keyword">JOIN</span> information_schema.tables b </span><br><span class="line"><span class="keyword">ON</span> a.<span class="string">`OBJECT_SCHEMA`</span>=b.<span class="string">`TABLE_SCHEMA`</span> <span class="keyword">AND</span> a.<span class="string">`OBJECT_NAME`</span>=b.<span class="string">`TABLE_NAME`</span></span><br><span class="line"><span class="keyword">WHERE</span> index_name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> count_star = <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> object_schema, object_name;</span><br></pre></td></tr></table></figure><p><strong>6、更新索引统计信息及减少索引碎片</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> &lt;mytab&gt;</span><br><span class="line"><span class="comment">-- 可能锁表</span></span><br><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> &lt;mytab&gt;</span><br></pre></td></tr></table></figure><h1 id="SQL-查询优化"><a href="#SQL-查询优化" class="headerlink" title="SQL 查询优化"></a>SQL 查询优化</h1><p>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</p><p>获取慢查询的方式：</p><ul><li>最终用户、测试人员获取存在性能问题的 SQL, 被动，常用</li><li>慢查询日志获取，服务层的日志</li><li>实时获取存在性能问题的 SQL</li></ul><h3 id="SQL-语句执行流程"><a href="#SQL-语句执行流程" class="headerlink" title="SQL 语句执行流程"></a>SQL 语句执行流程</h3><p><strong>查询语句的执行流程</strong></p><p><img src="http://img.janhen.com/202102261610131553910277229.png" alt="http://img.janhen.com/202102261610131553910277229.png"></p><p>优化器的作用：选择索引是优化器的⼯作。⽽优化器选择索引的⽬的，是找到⼀个最优的执⾏⽅案，并⽤最⼩的代价去执⾏语句。在数据库⾥⾯，扫描⾏数是影响执⾏代价的因素之⼀。扫描的⾏数 越少，意味着 访问磁盘数据的次数 越少，消耗的CPU资源越少。 当然，扫描⾏数并不是唯⼀的判断标准，优化器还会结合 是否使⽤临时表、是否排序 等因素进⾏综合判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限校验---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</span><br></pre></td></tr></table></figure><p>Q: MySQL是怎样得到索引的基数的呢？</p><p>MySQL采样统计的⽅法，采样统计的时候，InnoDB 默认会选择 N 个数据⻚，统计这些⻚⾯上的不同值，得到⼀个平均值，然后乘以这个索引的⻚⾯数，就得到了这个索引的基数。 ⽽数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据⾏数超过 1/M 的时候，会⾃动触发重新做⼀次索引统计。</p><p><strong>执行更新语句的流程</strong></p><p><img src="http://img.janhen.com/202103072200261553911424532.png" alt="http://img.janhen.com/202103072200261553911424532.png"></p><p>MySQL可以恢复到半个⽉内任意⼀秒的状态；</p><p>涉及到两个日志文件 redo log 和 binlog；</p><p>两阶段提交，以及 Insert Buffer 插入缓冲</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> T <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="number">2</span>;</span><br><span class="line">分析器<span class="comment">----&gt;权限校验----&gt;执行器---&gt;引擎---redo log prepare---&gt;binlog---&gt;redo log commit</span></span><br></pre></td></tr></table></figure><p><strong>SQL 解析及执行计划</strong></p><p>1、SQL 执行过程</p><p>(1) 客户端发送 SQL 请求给服务器</p><p>(2) 服务器检查是否可以在查询缓存中命中该 SQL</p><p>(3) 服务器端进行 SQL 解析，预处理，再由优化器生成对应的执行计划</p><p>(4) 跟据执行计划，调用存储引擎 API 来查询数据将结果返回给客户端</p><p><strong>查询缓存</strong></p><p>查询缓存：</p><p>缓存加锁 对于一个<strong>读写频繁的系统</strong>使用查询缓存很可能会降低查询处理的效率 所以在这种情况下建议大家不要使用查询缓存</p><p>查询缓存的配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type</span><br><span class="line"># 所使用的的大小</span><br><span class="line">query_</span><br><span class="line"># 缓存结果的最大值</span><br><span class="line"># 锁住，是否返回缓存中的数据</span><br><span class="line"># 查询缓存内存块的最小</span><br></pre></td></tr></table></figure><p><strong>查询优化器</strong></p><p><strong>1、可能导致失败的情况：</strong></p><p>(1) 统计信息不准确，如 Innodb 中的总条数为抽样的数据</p><p>(2) 执行计划中的成本估算不等同于实际的执行计划的成本，无法知道顺序读取与随机读取，是否在内存中</p><p>(3) MySQL 基于其成本模型进行。。。</p><p>(4) 从不考虑其他<strong>并发</strong>的查询</p><p>(5) 不会考虑<strong>不受控制的成本</strong>，如存储过程、用户自定义的函数</p><p><strong>2、查询优化器的作用</strong></p><p>(1) 优化 count(), min() 和 max(), B+树的。。。</p><p>(2) 将表达式转换成一个常数，MyISAM中的 Selelct Count(*)</p><ol><li>子查询优化： 转化成关联查询</li><li>提前终止查询：</li><li>对 in() 条件进行优化，对 in 中的数据进行排序，之后通过二分查找方式确定是否满足条件 ### 查询耗时 <strong>1、通过 profile</strong> 高版本已经不建议使用，建议使用方式二</li><li>开启与执行</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> &lt;mytab&gt;</span><br><span class="line"><span class="comment">-- 查看整体信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="comment">-- 查看执行的每个阶段信息</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> &lt;query_id&gt;;</span><br><span class="line"><span class="comment">-- 查看 CPU 的信息</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> &lt;query_id&gt;;</span><br></pre></td></tr></table></figure><ol><li>结果数据</li></ol><p><strong>2、通过 performance_schema(建议)</strong></p><p>在 MySQL5.6 之后建议使用 对数据全局有效 (1) 开启与使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 处理的先决条件，开启 performance_schema</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`setup_instruments`</span></span><br><span class="line"><span class="keyword">SET</span> enabled=<span class="string">&#x27;YES&#x27;</span>,TIMED=<span class="string">&#x27;YES&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">&#x27;stage%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> setup_consumers</span><br><span class="line"><span class="keyword">SET</span> enabled=<span class="string">&#x27;YES&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">&#x27;events%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询使用</span></span><br><span class="line"><span class="keyword">SELECT</span> a.THREAD_ID, SQL_TEXT,c.EVENT_NAME,(c.TIMER_END-c.TIMER_START)/<span class="number">1000000000</span> <span class="keyword">AS</span> <span class="string">&#x27;DURATION(ms)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> events_statements_history_long a </span><br><span class="line"><span class="keyword">JOIN</span> threads b </span><br><span class="line"><span class="keyword">ON</span> a.THREAD_ID=b.THREAD_IDJOIN events_stages_history_long c </span><br><span class="line"><span class="keyword">ON</span> c.THREAD_ID=b.THREAD_ID </span><br><span class="line">  <span class="keyword">AND</span> c.EVENT_ID <span class="keyword">BETWEEN</span> a.EVENT_ID <span class="keyword">AND</span> a.END_EVENT_ID </span><br><span class="line"><span class="keyword">WHERE</span> b.PROCESSLIST_ID=CONNECTION_ID() </span><br><span class="line">  <span class="keyword">AND</span> a.EVENT_NAME=<span class="string">&#x27;statement/sql/select&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.THREAD_ID,c.EVENT_ID</span><br></pre></td></tr></table></figure><ol><li>信息返回 返回各个阶段的耗时 执行的线程ID</li></ol><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>写日志为顺序存储</p><p><strong>慢查询配置</strong></p><ul><li>动态参数,可配合脚本定时开关 slow_query_log</li><li>存放位置。将日志存储与数据存储分开 slow_query_log_file</li><li>查询阈值，秒为单位，建议 0.001 秒 long_query_time</li><li>记录未使用索引的 SQL log_queries_not_using_indexes</li></ul><ol><li>实际使用的SQL</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%quer%&#x27;</span><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file=<span class="string">&#x27;/var/log/mysql/mysql-slow.log&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time=<span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_queries_not_using_indexes=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure><p><strong>2、慢查询记录的内容</strong></p><p>用户</p><p>查询的时间，精确到毫秒</p><p>查询占用的锁时间</p><p>返回的数据行数</p><p>扫描的行数 执行SQL的时间，</p><p>UNIX时间戳</p><p>对应的SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2019-05-30T10:10:02.771744Z</span><br><span class="line"># User@Host: root[root] @ localhost [127.0.0.1]  Id:    44</span><br><span class="line"># Query_time: 0.001503  Lock_time: 0.001002 Rows_sent: 12  Rows_examined: 12</span><br><span class="line">SET timestamp&#x3D;1559211002;</span><br><span class="line">SELECT * FROM exam;</span><br></pre></td></tr></table></figure><p><strong>mysqldumpslow 获取</strong></p><p>通过自带的工具进行筛选输出 (1) <code>-s order（c，t，l，r，at，al，ar）</code>: 指定按哪种排序方式输出结果</p><ul><li>c：总次数</li><li>t：总时间</li><li>1：锁的时间</li><li>r：总数据行</li><li>at，al，ar:t，l，r平均数</li><li><code>t top</code>: 指定取前几条作为结束输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s &lt;r&gt; -t &lt;10&gt; &lt;slow-mysql.log&gt;</span><br></pre></td></tr></table></figure><p><strong>pt-query-digest 获取</strong></p><p>建议使用 还支持对 bin log等日志的进行查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --explain h=127.0.0.1,u=root,p=password mysql-slow.log</span><br></pre></td></tr></table></figure><p>返回结果： 整体的统计信息，total,max,min</p><p>执行计划</p><p><strong>实时获取</strong></p><p>通过 information_schema.proceeslist 表进行查看获取实时数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询出服务器中执行超过 60s 的SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, </span><br><span class="line">    <span class="keyword">user</span>,</span><br><span class="line">    DB, </span><br><span class="line">    command, </span><br><span class="line">     <span class="built_in">time</span>, </span><br><span class="line">    state, </span><br><span class="line">    info</span><br><span class="line"><span class="keyword">FROM</span> information_schema.PROCESSLIST</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">TIME</span> &gt;= <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h2 id="特定-SQL-的优化"><a href="#特定-SQL-的优化" class="headerlink" title="特定 SQL 的优化"></a>特定 SQL 的优化</h2><p><strong>大表的数据修改分批处理：</strong></p><p>1000 万行记录的表中删除/更新 100 万行记录 一次只删除/更新 5000 行记录，暂停几秒</p><p>方式一： 通过存储过程实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$USE `&lt;myDB&gt;`$$DROP PROCEDURE IF EXISTS `p_delete rows`$$CREATE DEFINER=`root`@`127.0.0.1` PROCEDURE `p_delete_rows`()BEGIN   DECLARE v_rows INT；  SET v_rows=1;  WHILE v_roWs &gt;0  DO     -- 根据业务修改下面的语句    DELETE FROM sbtest1 WHERE id&gt;=90000 AND id &lt;=19000 LIMIT 5000;    SELECT ROW_COUNT() INTO v_rows;    -- sleep    SELECT SLEEP(5);  END WHILE;END$$DELIMITER；</span><br></pre></td></tr></table></figure><p>方式二： 程序中执行类似存储过程的逻辑每次获取少量数据，之后执行处理逻辑</p><p><strong>修改大表的表结构</strong></p><p>对表的列的字段类型进行修改，改变字段的宽度会锁表，无法解决主从数据库延迟问题</p><p>方式一： 主从切换</p><p>方式二： 手动创建新表进行迁移，减少主从延迟，操作复杂</p><p>可使用 pt-online-schema-change 工具 完成方式二的复杂逻辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change</span><br><span class="line">--alter=<span class="string">&quot;MODIFY C VARCHAR(150) NOT NULL DEFAULT &#x27;&#x27;&quot;</span></span><br><span class="line">--user=root \\</span><br><span class="line">--password=PassWord D=&lt;mydb&gt;,t=&lt;mytab&gt;</span><br><span class="line">--charset=utf8 \\</span><br><span class="line">--execute</span><br></pre></td></tr></table></figure><p><strong>优化 not in 和 &lt;&gt; 查询(#)</strong></p><p>通过外连接 + NULL 进行处理，即为<strong>将子查询转化成表的连接查询</strong>； 常用的调整手段；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, first_name, last_name, email</span><br><span class="line"><span class="keyword">FROM</span> customerWHERE customer_id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">  (<span class="keyword">SELECT</span> customer_id <span class="keyword">FROM</span> payment)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 Left join 配合 null 的优化</span></span><br><span class="line"><span class="keyword">SELECT</span> a.customer_id,a.first_name,a.last_name,a.email</span><br><span class="line"><span class="keyword">FROM</span> customer a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> payment b </span><br><span class="line"><span class="keyword">ON</span> a.customer_id =b.customer_idWHERE b.customer_id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p><strong>使用汇总表优化查询(#)</strong></p><p>汇总表概述<strong>：</strong> 汇总表就是提前以要统计的数据进行汇总并记录到表中以备后续的查询使用。 汇总表的数据可以使非实时的。</p><p>实际使用汇总表的策略</p><ul><li>使用汇总表记录从该天开始之前的所有统计信息，之后每天进行更新维护；</li><li>查询时借助统计信息表的数据和当天的数据汇总返回；</li><li>汇总表被当做一种缓存，当天数据类似增量信息；</li><li>从原来的表中提取出汇总信息，不会变更原来的表结构，侵入性低，是一种常用的扩展手段。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始的统计SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> product_ <span class="keyword">comment</span> <span class="keyword">WHERE</span> productid=<span class="number">999</span></span><br><span class="line"><span class="comment">-- 创建汇总表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_ comment_cnt(product <span class="keyword">id</span> <span class="built_in">INT</span>,cnt <span class="built_in">INT</span>);</span><br><span class="line"><span class="comment">-- 修改后的 SQL, UNION ALL 确定</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(cnt) <span class="keyword">FROM</span>(</span><br><span class="line"><span class="keyword">SELECT</span> cnt </span><br><span class="line"><span class="keyword">FROM</span> product_comment_cnt </span><br><span class="line"><span class="keyword">WHERE</span> product_id=<span class="number">999</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> product_comment </span><br><span class="line"><span class="keyword">WHERE</span> product_id=<span class="number">999</span><span class="keyword">AND</span> timestr&gt;<span class="built_in">DATE</span>(<span class="keyword">NOW</span>())) a</span><br></pre></td></tr></table></figure><p><strong>只要一行数据时使用 LIMIT 1</strong></p><p>已经知道结果只会有一条结果，加上 LIMIT 1 可以增加性能。MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><p><strong>用 Not Exists 代替 Not In</strong></p><p>Not Exists 允许用户使用相关子查询已排除一个表中能够与另一个表成功连接的所有记录。Not Exists 用到了连接，能够发挥已经建好的索引的作用，而 Not In 不能使用索引。Not In 是最慢的方式，要同每条记录比较，在数据量比较大的查询中不建议使用这种方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> a.mobileid</span><br><span class="line"><span class="keyword">from</span> Log_user a</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> b.mobileid                  </span><br><span class="line"><span class="keyword">from</span> magazineitem b                  </span><br><span class="line"><span class="keyword">where</span> b.mobileid=a.mobileid);</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲_MySQL_数据库-极客时间</a></p><p>MySQL实战45讲</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-结构优化&quot;&gt;&lt;a href=&quot;#MySQL-结构优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL 结构优化&quot;&gt;&lt;/a&gt;MySQL 结构优化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;结构设计&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过分的</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql-索引</title>
    <link href="http://example.com/2021/04/09/MySql-%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/04/09/MySql-%E7%B4%A2%E5%BC%95/</id>
    <published>2021-04-08T17:06:02.000Z</published>
    <updated>2021-04-08T17:09:24.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>删除长期未使用的索引</strong> 不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</p><p><strong>避免定义重复的索引</strong></p><p>借助 pt-duplicate-key-checker 查找，并生成删除重复索引的 SQL 语句</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-duplicate-key-checker -h &lt;host&gt; -u&lt;user&gt; -p&lt;passwd&gt;</span><br></pre></td></tr></table></figure><p><strong>索引好处：</strong></p><ul><li>提高访问速度；</li><li>优化查询；</li><li>将随机 IO 改为顺序 IO</li></ul><p><strong>索引缺点：</strong></p><ul><li>占用空间，索引建立的越多越占用空间；</li><li>更改频繁时，每次修改都需要重建索引；</li></ul><p><strong>索引的适用场景</strong></p><ul><li>选择性较高的场景；</li></ul><p><strong>不适合索引的场景：</strong></p><ul><li>数据规模小的情况；</li><li>选择性较低的列；</li></ul><p><strong>索引的底层实现</strong></p><ol><li>Hash 索引</li></ol><p>适⽤于只有等值查询的场景，⽐如 Memcached 及其他⼀些 NoSQL 引擎。</p><p>(2)) 有序数组</p><p>有序数组在等值查询和范围查询场景中的性能就都⾮常优秀, 有序数组索引只适⽤于静态存储引擎。</p><ol><li>二叉树</li><li>B+ 树</li></ol><h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a><strong>索引的创建</strong></h3><ul><li>index_type： 可选择 BTREE，HASH</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line">    [index_type]</span><br><span class="line">    <span class="keyword">ON</span> tbl_name (key_part,...)</span><br><span class="line">    [index_option]</span><br><span class="line">    [algorithm_option | lock_option] ...</span><br></pre></td></tr></table></figure><p>Functional Key Parts: MySQL8.0+ 支持，不只是列/列特定的前缀，支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  col1 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> (col1, col2(<span class="number">10</span>))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (col1 <span class="built_in">INT</span>, col2 <span class="built_in">INT</span>, <span class="keyword">INDEX</span> func_index ((<span class="keyword">ABS</span>(col1))));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx1 <span class="keyword">ON</span> t1 ((col1 + col2));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx2 <span class="keyword">ON</span> t1 ((col1 + col2), (col1 - col2), col1);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> ((col1 * <span class="number">40</span>) <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p>JSON 格式的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">JSON</span>,</span><br><span class="line">  <span class="keyword">INDEX</span> idx ((<span class="keyword">CAST</span>(<span class="keyword">data</span>-&gt;&gt;<span class="string">&quot;$.name&quot;</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>(<span class="number">30</span>)) <span class="keyword">COLLATE</span> utf8mb4_bin))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;james&quot;, &quot;salary&quot;: 9000 &#125;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;James&quot;, &quot;salary&quot;: 10000 &#125;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;Mary&quot;, &quot;salary&quot;: 12000 &#125;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;Peter&quot;, &quot;salary&quot;: 8000 &#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">data</span>-&gt;&gt;<span class="string">&#x27;$.name&#x27;</span> = <span class="string">&#x27;James&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="索引查看"><a href="#索引查看" class="headerlink" title="索引查看"></a><strong>索引查看</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看指定表的索引</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> &lt;<span class="keyword">table</span>-<span class="keyword">name</span>&gt; <span class="keyword">FROM</span> &lt;<span class="keyword">database</span>-<span class="keyword">name</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定数据库的索引统计</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    TABLE_NAME</span><br><span class="line">    ,INDEX_NAME</span><br><span class="line">    ,SEQ_IN_INDEX</span><br><span class="line">    ,COLUMN_NAME</span><br><span class="line">    ,CARDINALITY</span><br><span class="line">    ,INDEX_TYPE    </span><br><span class="line"><span class="keyword">FROM</span> INFORMATION_SCHEMA.STATISTICS </span><br><span class="line"><span class="keyword">WHERE</span> table_schema = <span class="string">&#x27;DatabaseName&#x27;</span></span><br></pre></td></tr></table></figure><p>重复索引的查看，见 <a href="https://www.notion.so/Percona-Toolkit-e9ea157626d24777babdaacf2babd301">pt-duplicate-key-checker</a></p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>索引分类</p><ul><li>B-Tree: b 树索引</li><li>R-tree: 空间索引</li><li>hash: 散列索引</li><li>full-text: 全文索引</li></ul><h3 id="主键索引-聚集"><a href="#主键索引-聚集" class="headerlink" title="主键索引(聚集)"></a><strong>主键索引(聚集)</strong></h3><p>作为表的主键，可以有包含多个列，该索引是唯一索引，在 InnoDB 存储引擎中为聚集索引。</p><p>主键⻓度越⼩，普通索引的叶⼦节点就越⼩，普通索引占⽤的空间也就越⼩。 所以，从性能和存储空间⽅⾯考量，⾃增主键往往是更合理的选择。</p><p>聚集索引和非聚集索引的区别</p><ul><li>聚集索引在叶子节点存储的是表中的数据</li><li>非聚集索引在叶子节点存储的是主键和索引列</li></ul><p>Q：基于主键索引和普通索引的查询有什么区别？</p><p>A：如果语句是 select * from table where id=8888，只需要搜索 ID 这棵 B+ 树； 如果语句是 select * from table where key=5，需要先搜索 key 索引树，得到 id 的值为 500，再到 ID 索引树搜索⼀次。这个过程称为 回表。 也就是说，基于⾮主键索引的查询需要多扫描⼀棵索引树。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a><strong>普通索引</strong></h3><p>相较于唯一索引，使用了 change buffer</p><p>与唯一索引的相比，这两类索引在查询能⼒上是没差别，主要考虑的是对更新性能的影响。</p><p>Change buffer 使用场景：</p><p>如果所有的更新后⾯，都⻢上伴随着对这个记录的查询，那么应该关闭 change buffer。⽽在其他情况下，change buffer 都能提升更新性能。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a><strong>唯一索引</strong></h3><p>唯⼀索引⽤不上 change buffer 的优化机制，因此如果业务可以接受，从性能⻆度出发建议优先考虑⾮唯⼀索引。</p><p>对于唯⼀索引来说，由于索引定义了唯⼀性，查找到第⼀个满⾜条件的记录后，就会停⽌继续检索。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h3><p>包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引。</p><p>对于频繁的查询优先考虑使用覆盖索引。</p><p>无需二次扫表，直接扫描索引中的 B+ 树即可获取全部数据；</p><p>覆盖索引的好处：</p><ul><li>避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li><li>可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><p>创建的注意事项：</p><ul><li>选取字符串的前多少位作为索引项()；<ul><li>阿里巴巴开发手册规定 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</li></ul></li><li>注意 最左前缀 的使用，以及基于此衍生出来的联合索引组合；</li><li>能够形成覆盖索引，从而避免二次扫表问题。</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><strong>联合索引定义的顺序</strong>： 建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><p><strong>索引列的选取：</strong> 常见索引列建议</p><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a><strong>字符串索引</strong></h2><p>直接创建完整索引，这样可能⽐较占⽤空间；</p><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使⽤覆盖索引</p><p>倒序存储，再创建前缀索引，⽤于绕过字符串本身前缀的区分度不够的问题；</p><p>创建 引，查询性能稳定，有额外的存储和计算消耗，跟第三种⽅式⼀样，都不⽀持 。hash字段索范围扫描</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><strong>前缀索引限定索引的长度</strong></p><p>不指定前缀长度，默认包含整个字符串；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SUser <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx1(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- only prefix</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SUser <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节，所以占⽤的空间会更⼩，这就是使⽤前缀索引的优势。 但可能会增加额外的记录扫描次数。</p><p>如果使⽤的是 index1(即 email 整个字符串的索引结构)，执⾏顺序是这样的：</p><ol><li>从 index1 索引树找到满⾜索引值是 <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的这条记录，取得ID2的值；</li><li>到主键上查到主键值是ID2的⾏，判断email的值是正确的，将这⾏记录加⼊结果集；</li><li>取index1索引树上刚刚查到的位置的下⼀条记录，发现已经不满⾜email=’<a href="mailto:&#x7a;&#x68;&#97;&#110;&#103;&#115;&#115;&#120;&#121;&#x7a;&#64;&#x78;&#x78;&#x78;&#46;&#x63;&#111;&#109;">&#x7a;&#x68;&#97;&#110;&#103;&#115;&#115;&#120;&#121;&#x7a;&#64;&#x78;&#x78;&#x78;&#46;&#x63;&#111;&#109;</a>’的条件了，循环结束。 这个过程中，只需要回主键索引取⼀次数据，所以系统认为只扫描了⼀⾏。</li></ol><p>如果使⽤的是index2(即email(6)索引结构)，执⾏顺序是这样的：</p><p>1 . 从index2索引树找到满⾜索引值是’zhangs’的记录，找到的第⼀个是ID1；</p><p>2 . 到主键上查到主键值是ID1的⾏，判断出email的值不是’<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#115;&#x78;&#121;&#122;&#64;&#x78;&#120;&#x78;&#46;&#x63;&#x6f;&#109;">&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#115;&#x78;&#121;&#122;&#64;&#x78;&#120;&#x78;&#46;&#x63;&#x6f;&#109;</a>’，这⾏记录丢弃；</p><p>3 . 取index2上刚刚查到的位置的下⼀条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整⾏然后判断，这次值对了，将这⾏记录加⼊结果集；</p><p>4 . 重复上⼀步，直到在idxe2上取到的值不是’zhangs’时，循环结束。 在这个过程中，要回主键索引取4次数据，也就是扫描了4⾏。 通过这个对⽐，你很容易就可以发现，使⽤前缀索引后，可能会导致查询语句读数据的次数变多。</p><p><strong>使⽤前缀索引，定义好⻓度，就可以做到既节省空间，⼜不⽤额外增加太多的查询成本。</strong></p><p>根据区分度来选择前缀的长度；</p><p>建立索引列的区分度越⾼越好。区分度越⾼，意味着重复的键值越少。可以通过统计索引上有多少个不同的值来判断要使⽤多⻓的前缀。 可以使⽤下⾯这个语句，算出这个列上有多少个不同的值，95% 作为参考；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">4</span>)) <span class="keyword">AS</span> L4,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">5</span>)) <span class="keyword">AS</span> L5,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">6</span>)) <span class="keyword">AS</span> L6,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">7</span>)) <span class="keyword">AS</span> L7,</span><br><span class="line"><span class="keyword">FROM</span> SUser;</span><br></pre></td></tr></table></figure><p><strong>前缀索引对覆盖索引的影响</strong></p><p>如果使⽤ index1(即email整个字符串的索引结构)的话，可以利⽤覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查⼀次。⽽如果使⽤index2(即email(6)索引结构)的话，就不得不回到ID索引再去判断email字段的值。 即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查⼀下，因为系统并不确定前缀索引的定义是否截断了完整信息。 也就是说，使⽤前缀索引就⽤不上覆盖索引对查询性能的优化了，这也是你在选择是否使⽤前缀索引时需要考虑的⼀个因素。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SUser <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_email(eamil(<span class="number">20</span>));</span><br><span class="line"><span class="comment">--SELECT id, name, email FROM SUserWHERE email=&#x27;zhangssxyz@xxx.com&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="区分度不足的处理"><a href="#区分度不足的处理" class="headerlink" title="区分度不足的处理"></a>区分度不足的处理</h3><p><strong>前缀的区分度不够时如何处理</strong></p><p>比如国家的身份证号、电话号码</p><p>方式一： 倒序存储</p><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了⾜够的区分度，先使⽤ count(distinct) ⽅法做验证</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 函数 revere 操作，插入处理</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T(col.., id_card) <span class="keyword">VALUES</span> (xxx, revere(<span class="string">&#x27;input_id_card_string&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询的处理</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;field_list&gt; <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id_card=<span class="keyword">reverse</span>(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p>方式二： 使用 Hash 字段</p><p>在表上再创建⼀个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><p>之后每次插⼊新记录的时候，都同时⽤ crc32() 函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。</p><p>这样，索引的⻓度变成了 4 个字节，⽐原来⼩了很多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 新增加一列，4byte 存放索引 hash 后的值</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ADD</span> id_card_crc <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>, <span class="keyword">ADD</span> <span class="keyword">index</span>(id_card_crc);</span><br><span class="line"><span class="comment">-- 插入逻辑， crc32 hash 值以及原始的值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T(co1..., id_card_crc, id_card) <span class="keyword">VALUES</span> (xxx, <span class="keyword">crc32</span>(<span class="string">&#x27;input_card_string&#x27;</span>), <span class="string">&#x27;input_id_card_string&#x27;</span>);                        </span><br><span class="line"></span><br><span class="line"><span class="comment">-- INDEX can duplication</span></span><br><span class="line"><span class="comment">-- 对应的查询语句，先对 hash 进行查询后对原始字符串查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *  <span class="keyword">FROM</span> t  <span class="keyword">WHERE</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">&#x27;input_id_card_string&#x27;</span>) <span class="keyword">AND</span> id_card=<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>倒序存储和 hash 存储两种方式的比较：</strong></p><p>相同点是，都不⽀持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的⽅式排序的，已经没有办法利⽤索引⽅式查出身份证号码在[ID_X, ID_Y]的所有市⺠了。同样地，hash 字段的⽅式也只能⽀持等值查询。</p><p>它们的区别，主要体现在以下三个⽅⾯：</p><p>① 从占⽤的额外空间来看，倒序存储⽅式在主键索引上，不会消耗额外的存储空间，⽽ hash 字段⽅法需要增加⼀个字段。当然，倒序存储⽅式使⽤ 4 个字节的前缀⻓度应该是不够的，如果再⻓⼀点，这个消耗跟额外这个 hash 字段也差不多抵消了。</p><p>② 在CPU消耗⽅⾯，倒序⽅式每次写和读的时候，都需要额外调⽤⼀次 reverse 函数，⽽ hash 字段的⽅式需要额外调⽤⼀次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更⼩些。</p><p>③ 从查询效率上看，使⽤ has h字段⽅式的查询性能相对更稳定⼀些。因为 crc32 算出来的值虽然有冲突的概率，但是概率⾮常⼩，可以认为每次查询的平均扫描⾏数接近 1。⽽倒序存储⽅式毕竟还是⽤的前缀索引的⽅式，也就是说还是会增加扫描⾏数。</p><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>修改 SQL 语句尽量使其走索引；</p><p>对于查询优化器选择索引错误，通过修改 SQL 引导其进行选择正确的索引，如通过 <code>FORCE INDEX()</code> 来指定使用特定的索引进行查询；</p><p>为查询较多的字段添加索引，可考虑使用覆盖索引；</p><p>要避免编写使索引失效的 SQL 语句；</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><blockquote><p>全值匹配我最爱，最左前缀要遵守； 带头大哥不能死，中间兄弟不能断； 原因： B+ 树的索引结构导致</p></blockquote><p>原因： 复合索引(组合)，先对最左边的字段进行排序，在第一个字段排序的基础上再对后面的字段排序。</p><p>类似 orderby ，只保证第一个字段有序，通常对于第二个字段用不到索引；</p><p>B+ 树这种索引结构，可以利⽤索引的“最左前缀”，来定位记录</p><p>只要满⾜最左前缀，就可以利⽤索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>如何控制索引的顺序：</p><p>如果通过调整顺序，可以少维护⼀个索引，那么这个顺序往往就是需要优先考虑采⽤的。 考虑的原则就是空间了。⽐如上⾯这个市⺠表的情况，name 字段是⽐ age 字段⼤的，那我就建议你创建⼀个(name,age)的联合索引和⼀个(age)的单字段索引</p><p><img src="http://img.janhen.com/202103072220221551846748988.png" alt="http://img.janhen.com/202103072220221551846748988.png"></p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><blockquote><p>索引列上少计算，范围之后全失效； LIKE 百分写最右，覆盖索引不写星； 不等空值还有 OR, 索引失效要少用； VAR 引号不可丢，SQL 高级也不难！</p></blockquote><p><strong>条件字段函数及计算操作</strong></p><p>如果对字段做了函数计算，就⽤不上索引了。</p><p>SQL语句条件⽤的是 where t_modified=‘2018-7-1’ 的话，B+ 树提供的这个快速定位能⼒，来源于同⼀层兄弟节点的有序性。</p><p>显示调用函数，在 t_modified 字段加了 month() 函数操作，导致了全索引扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Query，对索引列使用了函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tradelog <span class="keyword">WHERE</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>按照业务进行修改，使其走索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改索引列中使用的函数成为索引列的范围比较查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tragelog</span><br><span class="line"><span class="keyword">WHERE</span> (t_modified &gt;= <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">AND</span> t_modified&lt;<span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">OR</span> </span><br><span class="line">  (t_modified &gt;= <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">AND</span> t_modified&lt;<span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">OR</span>  </span><br><span class="line">  (t_modified &gt;= <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">AND</span> t_modified&lt;<span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>隐式类型转换</strong></p><p>字符串隐式的转换成数字进行操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid=<span class="number">110717</span>;</span><br><span class="line"><span class="keyword">select</span> “<span class="number">10</span>” &gt; <span class="number">9</span>;     </span><br><span class="line"><span class="comment">-- 1, String ⇒ number</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tradelog <span class="keyword">WHERE</span> <span class="keyword">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="built_in">int</span>)=<span class="number">110717</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改后的 SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tradelog <span class="keyword">WHERE</span> tradeid=<span class="string">&#x27;110717&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>隐式字符编码转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`trade_detail`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`trade_step`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&quot;操作步骤&quot;</span>,</span><br><span class="line"><span class="string">`step_info`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&quot;步骤信息&quot;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- log 和 业务的详情表字符集不同</span></span><br><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l, trade_detail d </span><br><span class="line"><span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>; <span class="comment">/* 语句 Q1 */</span></span><br></pre></td></tr></table></figure><p>两个字符集不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid=$L2.tradeid.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等同于，对列粒度的字符进行编码转换比较</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></table></figure><p>字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做⽐较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做⽐较。</p><p>方案一： 把 trade_detail 表上的 tradeid字 段的字符集也改成 utf8mb4，这样就没有字符集转换的问题了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> trade_detail <span class="keyword">MODIFY</span> tradeid <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">character</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>方案二： 在无法修改字符集的情况下，或者表中的数据很多的情况下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l , trade_detail d </span><br><span class="line"><span class="keyword">where</span> d.tradeid=<span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8) <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>简单的计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> trade_detail <span class="keyword">WHERE</span> trade_step=trade_step + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="索引下堆-5-6"><a href="#索引下堆-5-6" class="headerlink" title="索引下堆(5.6)"></a>索引下堆(5.6)</h3><p>// TODO</p><h2 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h2><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><p><strong>@Q: 为什么要重建索引?</strong></p><p>索引可能因为删除，或者⻚分裂等原因，导致数据⻚有空洞，重建索引的过程会创建⼀个新的索引，把数据按顺序插⼊，这样⻚⾯的利⽤率最⾼，让索引更紧凑、更省空间。</p><p>通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理。</p><p>重建索引 k 的做法是合理的，可以达到省空间的⽬的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执⾏这两个语句的话，第⼀个语句就⽩做了。这两个语句，可以⽤这个语句代替 ： <code>alter table Tengine=InnoDB</code>。</p><p>记录⽇志⽤的表, 会定期删除过早之前的数据。 最后这个表实际内容的⼤⼩ 10G, 索引却有 30G.. 是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放. 只能是重新建表才能重建索引.</p><h3 id="索引选择异常"><a href="#索引选择异常" class="headerlink" title="索引选择异常"></a>索引选择异常</h3><p>@Q: 索引选择异常和处理？ 处理查询优化器选择错误索引？</p><p>查询优化器选择的不是最优的索引情况的处理。</p><p>⼤多数时候优化器都能找到正确的索引，但偶尔还是会碰到我们上⾯举例的这两种情况：原本可以执⾏得很快的SQL语句，执⾏速度却⽐你预期的慢很多</p><p><strong>方式一：采⽤ <code>force index()</code> 强⾏选择⼀个索引</strong></p><p>MySQL 会根据词法解析的结果分析出可能可以使⽤的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少⾏。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执⾏代价。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- FORCE INDEX 的使用</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(a) </span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span> </span><br><span class="line">  <span class="keyword">AND</span> b <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> bLIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但其实使⽤ force index 最主要的问题还是变更的及时性。因为选错索引的情况还是⽐较少出现的，所以开发的时候通常不会先写上 force index。⽽是等到线上出现问题的时候，你才会再去修改 SQL 语句、加上 force index。但是修改之后还要测试和发布，对于⽣产系统来说，这个过程不够敏捷。</p><p><strong>方法二：可以考虑修改语句，引导 MySQL 使⽤期望的索引</strong></p><p>⽐如，在这个例⼦⾥，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p>现在 order by b,a 这种写法，要求按照b,a排序，就意味着使⽤这两个索引都需要排序。因此，扫描⾏数成了影响决策的主要条件，于是此时优化器选了只需要扫描 1000 ⾏的索引 a。 当然，这种修改并不是通⽤的优化⼿段，只是刚好在这个语句⾥⾯有 limit 1，因此如果有满⾜条件的记录， order by b limit 1 和 order by b,a limit 1 都会返回 b 是最⼩的那⼀⾏，逻辑上⼀致，才可以这么做。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(a)</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span></span><br><span class="line">  <span class="keyword">AND</span> b <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> b,a     </span><br><span class="line"><span class="comment">-- modifyLIMIT 1;</span></span><br><span class="line"><span class="comment">-- 另一种引导我们⽤limit 100让优化器意识到，使⽤b索引代价是很⾼的。其实是我们根据数据特征诱导了⼀下优化器，也不具备通⽤性。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> (a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span>) </span><br><span class="line">     <span class="keyword">AND</span> (B <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span>) </span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> b </span><br><span class="line">   <span class="keyword">LIMIT</span> <span class="number">100</span>) <span class="keyword">alias</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>方法三：在有些场景下，可以新建⼀个更合适的索引，来提供给优化器做选择，或删掉误⽤的索引</strong></p><p>这种情况其实⽐较少，尤其是经过 DBA 索引优化过的库，再碰到这个 bug，找到⼀个更合适的索引⼀般⽐较难。 如果我说还有⼀个⽅法是删掉索引 b，你可能会觉得好笑。但实际上我碰到过两次这样的例⼦，最终是 DBA 跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p><h2 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B 树与索引"></a>B 树与索引</h2><p>B+ 树特点：</p><ul><li>关键字分布在整棵树的所有节点。</li><li>任何一个关键字，<strong>出现且只出现在一个节点中</strong>。</li><li>搜索有可能在<strong>非叶子节点</strong>结束。</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ul><p>B+树基本特点</p><ul><li>非叶子节点的子树指针与关键字个数相同。</li><li>非叶子节点的子树指针 P[i]，指向关键字属于 <strong>[k[i],K[i+1])</strong> 的子树（<strong>注意：区间是前闭后开</strong>)。</li><li><strong>为所有叶子节点增加一个链指针</strong>。</li><li><strong>所有关键字都在叶子节点出现</strong>。</li></ul><p><strong>B 树与 B+ 树的区别</strong></p><p>关键字与孩子节点的个数不同；</p><p>B+树的磁盘读写代价更低：B+ 树的内部没有指向关键字具体信息的指针，其内部节点相对 B 树更小，把所有关键字存放在同一块盘中，B+ 树比 B 树所能容纳的关键字数量也越多；</p><p>查询的稳定性： B+ 树所欲数据都存放在叶子节点，B+ 树无论如何都要扫表到叶子节点才能返回数据， 所有关键字查询的路径长度相同；B 树可以中途跳出，查询效率不够稳定；</p><p>B+ 树适合用于遍历和范围的选择，底层叶子节点是双向链表，只需要去遍历叶子节点就可以实现整棵树的遍历；</p><p><strong>MongoDB 的索引为什么选择 B 树，而 MySQL 的索引是 B+树</strong></p><p>MongoDB 非传统的 RDBMS，是以 Json 格式作为存储的 NoSQL，目的就是高性能、高可用、易扩展。摆脱了关系模型，所以范围查询和遍历查询的需求就没那么强烈。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/indexes.html">MySQL :: MySQL 8.0 Reference Manual :: C Indexes</a></p><p>MySQL 的索引官方文档</p><p><a href="https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c">深入理解MySQL索引-InfoQ</a></p><p>深入理解 MySQL 索引</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;删除长期未使用的索引&lt;/strong&gt; 不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务</title>
    <link href="http://example.com/2021/04/09/MySQL-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/04/09/MySQL-%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-04-08T17:04:36.000Z</published>
    <updated>2021-04-08T17:08:37.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>事务是数据库区别于文件系统的一个关键特性。</p></blockquote><p><strong>事务的分类</strong></p><p>① 扁平事务，使用最频繁；</p><p>② 带有保存点的扁平事务；</p><p>③ 链事务，下一个事务将能够看到上一个事务的结果，只能恢复到最近一个的保存点；</p><p>④ 嵌套事务； 任何子事务都在顶层事务提交后才真正的提交；是一棵树状的结构；</p><p>只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源；</p><p>⑤ 分布式事务；需要根据数据所在位置访问网络中的不同节点；保存点在事务内部是递增的；可以借助消息队列实现分布式事务。</p><p>相关的 SQL</p><p>// TODO 关联 Spring 提供的几个事务级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;ios%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ul><li>原子性(Atomic)： 所有操作要么全部成功，要么全部失败</li><li>一致性(Consistency)： 数据从一个一致性状态转移到另一个一致性状态，一致指的是 数据的完整性约束 没有被破坏</li><li>**隔离性(Isolation)**： 并发执行事务时，一个事务应该不影响其他事务的执行</li><li>持久性(Duration)： 对 DB 的修改永久，恢复性能</li></ul><h3 id="事务的实现方式"><a href="#事务的实现方式" class="headerlink" title="事务的实现方式"></a><strong>事务的实现方式</strong></h3><p>实现的原理： InnoDB 中的 undo.log, redo.log 日志文件。</p><p>隔离性： 通过锁实现</p><p>原子性和持久性： 通过 redo 物理日志实现；</p><p>事务的一致性： 通过 undo log 实现；</p><p><strong>redo log</strong></p><p>blog</p><p>可通过参数调节控制 redo log 刷新到磁盘的策略；</p><p>log block： redo log 的块大小与磁盘扇区大小一样都是 512 字节，保证了原子性，不需要 doublewrite 技术；</p><p>为物理日志，恢复速度比逻辑日志快，是幂等的。</p><p>重做日志记录了事务的行为，可以很好地通过其对也进行 “重做” 操作</p><p><strong>undo log</strong></p><ul><li>帮助事务回滚；</li><li>帮助实现 MVCC；</li><li>是实现快照读的一种必要机制；</li><li>存放在数据库内部的一个特殊字段上；</li></ul><p>功能一： 是逻辑日志，将数据库逻辑地恢复到原来的样子；</p><p>功能二： 当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p><p>分类：</p><p>insert undo log</p><p>update undo log</p><p>delete 操作不直接删除记录，而只是将记录标记为已删除。</p><p>undo 信息的数据字典：</p><p>真正删除这行记录的操作其实被 “延时” 了，最终在 purage 操作中完成。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h3><p>第一阶段： 所有参与全局事务的节点都开始准备(PREPARE) ，告诉事务管理器准备好了；</p><p>第二阶段： 事务管理器告诉资源管理器质性 ROLLBACK 还是 COMMIT，分布式事务需要多一次的 PREPARE 操作，待收到所有节点的统一信息后，再进行 COMMIT 或是 ROLLBACK 操作。</p><p>事务相关的 SQL 语句</p><p>一条语句失败并抛出异常，不会导致先前已经执行的语句自动会馆，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- salfpoint </span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一个保存点</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到某个保存点, 此时事务没有结束</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置级别</span></span><br><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> | <span class="keyword">SESSION</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>分布式事务</strong></p><p>XA</p><p>XA 事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。</p><p>Serializable 级别</p><p><strong>长事务</strong></p><p>执行时间较长的事务；</p><p>进行的优化：在 1 亿用户表中，这个操作被封装在一个事务中完成，通过为其转化成小批量的事务进行处理；</p><p>好处一： 便于回滚每完成一个小事务，将完成的结果存放在 batchcontext 表中，表示已完成批量事务的最大账号 ID。 在发生错误时，可以从这个已完成的最大事务 ID 继续进行批量的小事务，重新开启事务的代价就显得比较低。</p><p>好处二： 用户可以知道现在大概已经执行到了哪个阶段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> account_total=account_total+<span class="number">1</span> + (<span class="number">1</span>+interest_rate);</span><br></pre></td></tr></table></figure><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p><strong>更新丢失：</strong></p><p><img src="http://img.janhen.com/202103072221061551851135178.png" alt="http://img.janhen.com/202103072221061551851135178.png"></p><p><strong>Dirty Read</strong></p><p>读取到未提交的数据，之后回滚 ，修改成 <code>READ UNCOMMITTED</code> 隔离级别可以处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><a href="https://www.notion.so/3b7ce6854e864bed8418e6d73783f404">.</a></p><p><strong>不可重复读</strong></p><p>session1 执行事务期间，另一个 session2 事务对session1 读取的数据修改并提交</p><p>将事务隔离级别升级为 REPEATABLE READ 即可处理该问题</p><p><strong>幻读</strong></p><p>侧重于删除和增加</p><p>Transaction A 读取与搜索条件相匹配的若干行， Transaction B 插入或删除行修改 Transaction A 的结果集。</p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插⼊的数据的。因此，幻读在“当前读”下才会出现。</li><li>上⾯session B的修改结果，被session A之后的select语句⽤“当前读”看到，不能称为幻读。幻读仅专指“新插⼊的⾏”。</li></ol><p>幻读有什么问题？ ⾸先是语义上的。session A在T1时刻就声明了，“我要把所有d=5的⾏锁住，不准别的事务进⾏读写操作”。⽽实际上，这个语义被破坏了。 其次，是数据⼀致性的问题。 我们知道，锁的设计是为了保证数据的⼀致性。⽽这个⼀致性，不⽌是数据库内部数据状态在此刻的⼀致性，还包含了数据和⽇志在逻辑上的⼀致性。 原因很简单。在T3时刻，我们给所有⾏加锁的时候，id=1这⼀⾏还不存在，不存在也就加不上锁。 也就是说，即使把所有的记录都加上锁，还是阻⽌不了新插⼊的记录，这也是为什么“幻读”会被单独拿出来解决的原因。 到这⾥，其实我们刚说明完⽂章的标题 ：幻读的定义和幻读有什么问题。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离得越严实，效率就会越低。</p><ol><li>READ UNCOMMITTED: ⼀个事务还没提交时，它做的变更就能被别的事务看到。</li><li>READ COMMIT: ⼀个事务提交之后，它做的变更才会被其他事务看到。</li><li>REPEATABLE READ: ⼀个事务执⾏过程中看到的数据，总是跟这个事务在启动时看到的数据是⼀致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可⻅的。</li><li>SERIALIZABLE: 对于同⼀⾏记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前⼀个事务执⾏完成，才能继续执⾏。主要用于实现 InnoDB 的分布式事务。</li></ol><p><strong>InnoDB 在 REPEATABLE READ 级别下，使用 Next-Key Lock 锁算法，避免幻读的产生。</strong></p><p><a href="https://www.notion.so/5600ccbf25144edaaf0f7827ad50127f">隔离级别与事务问题</a></p><p><strong>事务隔离的实现</strong></p><p>read view 算法</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录⼀条回滚操作。记录上的最新值，通过回滚操作，都可以得到前⼀ 个状态的值。 回滚⽇志什么时候删除呢？</p><p>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要⽤到这些回滚⽇志时，回滚⽇志会被删除。</p><p>什么时候才不需要了呢？</p><p>当系统⾥没有⽐这个回滚⽇志更早的 read-view 的时候。</p><p>为何尽量不使用长事务？</p><p>⻓事务意味着系统⾥⾯会存在很⽼的事务视图。由于这些事务随时可能访问数据库⾥⾯的任何数据，所以这个事务提交之前，数据库⾥⾯它可能⽤到的回滚记录都必须保留，这就会导致⼤量占⽤存储空间。</p><p>除此之外，⻓事务还占⽤锁资源，可能会拖垮库。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>开启事务的方式</strong></p><ul><li>显式启动事务语句： begin 或者 start transaction, 提交 commit，回滚 rollback；</li><li>set autocommit=0： 该命令会把这个线程的⾃动提交关掉。这样只要执⾏⼀个 select 语句，事务就启动，并不会⾃动提交，直到主动执⾏ commit 或 rollback 或断开连接。</li></ul><p>建议使⽤⽅法⼀，如果考虑多⼀次交互问题，可以使⽤ commit work and chain 语法。在 autocommit=1 的情况下⽤ begin 显式启动事务，如果执⾏ commit 则提交事务。如果执⾏ commit work and chain 则提交事务并⾃动启动下⼀个事务。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>InnoDB⾥⾯每个事务有⼀个 唯⼀的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。 ⽽每⾏数据也都是有多个版本的。每次事务更新数据的时候，都会⽣成⼀个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。 也就是说，数据表中的⼀⾏记录，其实可能有多个版本(row)，每个版本有⾃⼰的row trx_id。</p><p><strong>InnoDB利⽤了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能⼒。</strong></p><p>更新数据都是先读后写的，⽽这个读，只能读当前的值，称为“当前读”(currentread)。</p><p>InnoDB的⾏数据有多个版本，每个数据版本有⾃⼰的row trx_id，每个事务或者语句有⾃⼰的⼀致性视图。普通查询语句是⼀致性读，⼀致性读会根据row trx_id和⼀致性视图确定数据版本的可⻅性。</p><ul><li><p>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</p></li><li><p>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</p><p>⽽当前读，总是读取已经提交完成的最新版本。你也可以想⼀下，为什么表结构不⽀持“可重复读”？这是因为表结构没有对应的⾏数据，也没有row trx_id，因此只能遵循当前读的逻辑。</p></li></ul><h2 id="RR-下解决幻读"><a href="#RR-下解决幻读" class="headerlink" title="RR 下解决幻读"></a>RR 下解决幻读</h2><p>表象：快照读(非阻塞读)–伪MVCC 内在：是因为事务对数据加了next-key锁(行锁+gap锁) -gap锁会用在非唯一索引或者不走索引的当前读中</p><p><strong>RC、RR 下的 InnoDB 的非阻塞读实现</strong></p><p>RR 下可能读取到老的版本</p><p>RR 创建快照的时机决定了事务的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session1:</span><br><span class="line">UPDATE ...     -- 1</span><br><span class="line"></span><br><span class="line">session2:</span><br><span class="line">SELECT          --  3</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;    -- 2</span><br></pre></td></tr></table></figure><ol><li>数据行中三个行隐藏参数：</li></ol><p>DB_TRX_ID: 最近一次对本行数据进行修改的数据 ID</p><p>DB_ROW_PTR: 回滚指针， 指向 undo 日志</p><p>DB_ROW_ID: 无主件时隐式的 ID</p><p><strong>(2) undo 日志</strong>： 老版本</p><p>针对 Insert undo log,</p><p>针对 update undo log</p><p><strong>(3) read view</strong>: 可见性算法</p><p><img src="http://img.janhen.com/202103072224031551854704429.png" alt="http://img.janhen.com/202103072224031551854704429.png"></p><p><img src="http://img.janhen.com/202103072224191551854739908.png" alt="http://img.janhen.com/202103072224191551854739908.png"></p><p>MVCC: 读不加锁，读写不冲突，读多写少</p><p>伪 MVCC： 无法多版本共存</p><p><strong>RR 避免 幻读</strong></p><p>产⽣幻读的原因是，⾏锁只能锁住⾏，但是新插⼊记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引⼊新的锁，也就是间隙锁(Gap Lock)。</p><p>但是间隙锁不⼀样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插⼊⼀个记录”这个操作</strong>。间隙锁之间都不存在冲突关系。</p><p><strong>间隙锁和 next-key lock 的引⼊，帮我们解决了幻读的问题，但同时也带来了⼀些“困扰”。</strong></p><p><strong>间隙锁的引⼊，可能会导致同样的语句锁住更⼤的范围，这其实是影响了并发度的。</strong></p><p>⾏锁确实⽐较直观，判断规则也相对简单，间隙锁的引⼊会影响系统的并发度，也增加了锁分析的复杂度，但也有章可循</p><p>next-key 锁</p><p>行锁：</p><p><strong>Gap 锁</strong>： 锁定一个范围，不包含当前</p><p>() GAP 锁出现的时机</p><p>出现的场景： WHERE + INDEX</p><p>where 条件全部命中，不会加 Gap Lock, 只会加 Record Lock</p><p>where 条件部分命中，或全部不命中，加 Gap Lock;</p><p>Gap 锁会用在非唯一索引或者不走 index 的当前读中：</p><ul><li>非唯一索引</li><li>不走索引的当前读，尽量避免</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><blockquote><p>Multiversion concurrency control 多版本并发控制。</p></blockquote><p>并发访问（读或者写）数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li>《MySQL技术内幕：InnoDB存储引擎(第二版)》姜承尧</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;事务是数据库区别于文件系统的一个关键特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;事务的分类&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java-Map类源码</title>
    <link href="http://example.com/2021/04/09/Java-Map%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/04/09/Java-Map%E7%B1%BB%E6%BA%90%E7%A0%81/</id>
    <published>2021-04-08T16:59:34.000Z</published>
    <updated>2021-04-08T17:00:39.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap-JDK7"><a href="#HashMap-JDK7" class="headerlink" title="HashMap(JDK7)"></a>HashMap(JDK7)</h2><p>Hash 表结构几个重要的通用操作， hash 函数、hash 冲突、rehash 及扩容；</p><h3 id="存储结构与初始化"><a href="#存储结构与初始化" class="headerlink" title="存储结构与初始化"></a><strong>存储结构与初始化</strong></h3><p>（1） 结构</p><p>底层结构中为每一个 Node 添加指向 prev, next 的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对，为链表结构，数组每个位置相当于一个桶，桶中存放链表。借助其来处理 Hash 冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>① 无参初始化；</p><p>② Map 传入初始化；</p><p>③ 指定初始化容量；</p><p>④ 执行初始化容量和负载因子；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Obejct, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(x * <span class="number">4</span>/<span class="number">3</span>);    <span class="comment">// loadFactor to prevent grow</span></span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash 函数 | 元素定位</strong></p><p>① 整体的定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>② 具体的 hash 确定</p><p>通过多次移位和异或进行 hash 扰动，使其尽量不依赖于传入的 hashCode 的不均匀性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 根据 hash 确定桶下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度和链表的长度成正比；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、put</strong></p><p>(1) 总体实现流程</p><p>①判断初始化，未初始化则做对应的初始化</p><p>②Null 值特殊处理，Null 无法调用 hashCode()，防止 NullPointerException</p><p>③确定桶下标</p><p>④遍历链表，若重复直接覆盖并返回</p><p>⑤为新加入元素，插入 &lt;K,V&gt;</p><p>⑥根据情况看是否需要扩容处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 对于 NULL 的插入处理</p><p>无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">/*0 bucket*/</span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 处理 Hash 碰撞</p><p>头插法处理；</p><p>在容量阈值达到时，进行 2 倍扩容操作；</p><p>是一种添加之后，再进行扩容的行为，依赖的是上次添加完毕的情况；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、扩容 | rehash</strong></p><p>（1） 影响的变量</p><p>① loadFactor： 负载因子时间上和空间上的一种平衡:</p><ul><li>↑ 查找性能差, 空间利用率高；</li><li>↓ 查找性能高, 空间利用率低；</li></ul><p>② size | threshold： size/capacity 达到负载因子时进行对应的扩容</p><p>③ modCount：用来处理扩容时出现并发访问造成数据不一致，从而 fail-fast</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>（2） 扩容实现</p><p>在负载因子达到给定值的情况下进行扩容；</p><p>扩容为原来数组的两倍；</p><p>需要将原来的 Entry 重新插入到新建的表中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） rehash | 计算桶下标</p><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>根据 hash 值在当前的高位上是否为 0，进行不同的处理。</p><ul><li>为 0： 不需要移动</li><li>为 1： 移动偏移 原来容量对应的桶上；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） JDK7 与 JDK8 中 HashMap 的比较</p><p>① 底层结构上：</p><ul><li>JDK8 采用 数组 + 链表 + 红黑树实现，长度过长转换成红黑树有效防范了 Hash 碰撞攻击；</li><li>将原来的 Entry 改为 Node，表示红黑树节点、链表节点；</li></ul><p>② hash 函数： JDK8 只需要一次移位和异或即可，既能有效处理冲突上还保证了执行效率；</p><p>③ 处理 hash 冲突上： 在为链表时，通过尾插法进行处理，避免出现逆序且链表死循环问题；</p><p>（2） 不安全体现</p><p>扩容时因为头插法而形成环形引用，造成无限循环，CPU 100%；</p><p>put 操作可能造成丢失修改；</p><h2 id="HashMap-JDK8"><a href="#HashMap-JDK8" class="headerlink" title="HashMap(JDK8)"></a>HashMap(JDK8)</h2><h3 id="底层结构与初始化"><a href="#底层结构与初始化" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 整体结构</p><p>① table： 存储节点类型，用于多态扩展</p><p>② loadFactor： 负载因子，控制扩容的时机</p><p>③ modCount： 控制迭代访问， fail-fast</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>（2） 节点与树化</p><p>① 控制树化的时机：</p><ul><li>TREEIFY_THRESHOLD(8)： 链表元素大于该值的时候进行树化</li><li>UNTREEIFY_THRESHOLD(6)： TreeNode 中元素删除到该值时，将结构退化为链表，一般比 TREEIFY_THRESHOLD(8) 小，避免复杂度震荡</li><li>MIN_TREEIFY_CAPACITY(64): 在整个 HashMap 的容量小于该值的时候，即使单个桶中的元素达到 TREEIFY_THRESHOLD(8)，不会进行树化，会直接进行 rehash。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    <span class="comment">/* prevent complexity oscillation */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  <span class="comment">/* prevent resize and treeify conflict */</span></span><br></pre></td></tr></table></figure><p>② 链表节点结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;                  </span><br><span class="line">    <span class="keyword">final</span> K key;                      </span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 红黑树节点结构： 继承 LinkedHashMap.Entry，便于从 tree 回退到 listNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash 函数 | 元素定位</strong></p><p>一次异或一次移位进行 hash 扰动，避免依赖于原来 hashCode 处理键冲突，提高 hash 值的扩散性；</p><p>对于 null 的 KEY，直接使其 hash 值为 0，从而避免 NullPointerException；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><p>执行过程：</p><ul><li>定位到对应的桶看是否有该 KEY</li><li>首个节点为该 KEY，则直接返回</li><li>若为 TreeNode，进行红黑树的查找逻辑</li><li>若为 ListNode 进行链表的迭代遍历查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、put</strong></p><p>（1） 执行流程：</p><p>① 如果 HashMap 未被初始化过，则初始化；</p><p>② 对 Key 求 Hash 值，然后再计算下标；</p><p>③ 如果没有碰撞直接放入桶中；</p><p>④ 如果碰撞了，以链表的方式链接到后面；</p><p>⑤ 如果链表长度超过阀值，就把链表转成红黑树；</p><p>⑥ 如果链表长度低于 6，就把红黑树转回链表；</p><p>⑦ 如果节点已经存在就替换旧值；</p><p>⑧ 如果桶满了（容量 16 *加载因子 0.75 ），就需要 resize（扩容 2 倍后重排）</p><p>（2） 额外功能：</p><ul><li>null 值处理： 直接通过 hash(key) 给 NULL KEY 为 0 的值；</li><li>onlyIfAbsent： 实现 <code>putIfAbsent()</code> 方法逻辑，保留旧的值；</li><li>afterNodeAccess，afterNodeInsertion： hook 钩子函数进行特殊处理，可用于 LinkedHashMap 实现 LRU；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)   <span class="comment">/*  初始情况 */</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)        <span class="comment">/* 插入的桶无元素 */</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                        </span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;                        <span class="comment">/* 第一个位置与插入的重复 */</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)              <span class="comment">/* 是否树化 */</span>       </span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                                   </span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                                         </span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);     <span class="comment">/* 树化 */</span>                            </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))             </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)  <span class="comment">/* 总体的容量扩容 */</span></span><br><span class="line">        resize();                                                                       </span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） Hash 冲突处理</p><p>对于链表的 hash 冲突</p><p>部分 putVal() 方法：</p><p>为了实现树化，需要统计链表中的个数，直接遍历到链表尾部，进行插入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                <span class="comment">// binCount 记录链表中的个数</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                            <span class="comment">/* 迭代到链表尾部 */</span></span><br><span class="line">        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);                      <span class="comment">/* 树化 */</span>                       </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))         </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 扩容 | rehash</strong></p><p>两种可能情况：</p><ul><li>仍然在原来的位置</li><li>在原来的位置上偏移原来的容量</li></ul><p>（1） 链表拆分</p><p>将原来的链表拆成两条链表，低位链表的数据将会到新数组的当前下标位置，高位链表的数据将会到新数组的当前下标+当前数组长度的位置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;   </span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、 树化</strong></p><p>（1） 链表转为红黑树</p><p>在挂接的链表大于 TREEIFY_THRESHOLD 时进行树化逻辑；</p><p>容器整体大于 MIN_TREEIFY_CAPACITY 时才允许树化，否则进行 resize；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;                 </span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) </span><br><span class="line">        resize();   <span class="comment">/* 当前容量太小，直接扩容，防 resize 和 treeify 频繁性能损耗 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 红黑树转变成链表</p><p>在红黑树节点数少于 UNTREEIFY_THRESHOLD(6) 时，进行结构转变；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeNode.split</span></span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index + bit] = hiHead;</span><br><span class="line">        <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">            hiHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-JDK7"><a href="#ConcurrentHashMap-JDK7" class="headerlink" title="ConcurrentHashMap(JDK7)"></a>ConcurrentHashMap(JDK7)</h2><p><img src="http://img.janhen.com/20210130172336image-20201031105854190.png" alt="http://img.janhen.com/20210130172336image-20201031105854190.png"></p><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><h3 id="底层结构与初始化-1"><a href="#底层结构与初始化-1" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 全局结构</p><p>segmentShift | segmentMask： 用于快速定位到 Segment 的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;     <span class="comment">// keep object</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>（2） Segment 结构</p><p>相当于一个带有锁的 HashMap(7)</p><p>① 继承自 <code>ReentrantLock</code> 从而实现并发加分段锁访问；</p><p>② 保存了 count 用于整个容器的统计，以及作为扩容的参考值；</p><p>默认情况下并发级别为 16；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;     <span class="comment">// use for size()</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） HashEntry 结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash &amp; 定位</strong></p><p>先整体进行了多次异或操作，进行 hash 扰动，将每位都用上。</p><p>通过 hash 借助 sementShift 和 segmentMask 来定位到对应的段上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到 Entry，定位 Segment 使用的是元素的 hashcode 通过再散列后得到的值的高位，而定位 HashEntry 直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在 Segment 里散列开了，但是却没有 HashEntry 里散列开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　　 <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);　　 <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><p>无锁获取值实现：</p><p>基于 volatile 来替代锁实现，由 JMM 提供的 happen before 原则保证可见性；</p><p>通过 hash 得出对应的散列值，之后通过 hash 定位到对应的段；</p><p>在桶中再进行 hash 得到对应的桶，只有在读取到 NULL 值时才进行加锁；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Segment 中的总数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashEntry 中的值</span></span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure><p><strong>3、put()</strong></p><p>判断是否需要扩容，不是添加之后进行判断的，在插入前进行判断，避免无效的扩容。</p><p>扩容仅仅是对当前的 Segment 进行扩容，无需对整个容器扩容。</p><p><strong>4、size()</strong></p><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>可能的两步操作：</p><p>① 先尝试通过 <code>RETRIES_BEFORE_LOCK</code>(2) 次借助 segment 中 volatile 保存的 count 相加，基于 <code>modCount</code> 来实现的；</p><p>② 若无法则对整个容器进行加锁统计所有 Segment 的大小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 过多 CAS 转换成对所有 Segment 加锁获取</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） JDK7 与 JDK8 中 ConcurrentHashMap 的比较</p><p>① 底层结构： 链表过长转换成红黑树</p><p>② 同步机制： JDK7 采用分段锁实现，而 JDK8 可以有两种方案</p><ul><li>尝试通过 CAS 来支持更高的并发度；</li><li>在 CAS 失败时通过内置锁 <code>synchronized</code> 锁住链表 | 红黑树的头结点；</li></ul><h2 id="ConcurrentHashMap-JDK8"><a href="#ConcurrentHashMap-JDK8" class="headerlink" title="ConcurrentHashMap(JDK8)"></a>ConcurrentHashMap(JDK8)</h2><p><img src="http://img.janhen.com/20210130172332image-20201031105915401.png" alt="http://img.janhen.com/20210130172332image-20201031105915401.png"></p><p>五十几个内部类，Guava 中的 Cache 基于此实现。</p><p>无法存放 NULL。</p><h3 id="底层结构与初始化-2"><a href="#底层结构与初始化-2" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 底层结构</p><p>① nextTable： 用于并发下的扩容操作</p><p>② transferIndex： 在 rehash 情况下的标记索引</p><p>③ counterCells： 用于并发下获取容量，不精确，与 LongAdder 类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>五种初始化方式：</p><p>前四种同 HashMap 初始化方式；</p><p>⑤ 初始容量、负载因子、并发级别： 含有并发级别控制；</p><p>并发级别基本不用，初始化用于与 initialCapacity 进行比较取最大值；</p><p>与 JDK7 进行兼容的处理逻辑；</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash 函数|定位</strong></p><p>通过传入对象的 hashCode 来进行对应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、put()</strong></p><p>① 判断 Node[] 数组是否初始化，没有则进行初始化操作</p><p>② 通过 hash 定位数组的索引坐标，是否有 Node 节点，如果没有则使用 CAS 进行添加（链表的头节点），添加失败则进入下次循环。</p><p>③ 检查到内部正在扩容，就帮助它一块扩容。</p><p>④ 如果 f != null 则使用 synchronized 锁住 f 元素（链表/红黑二叉树的头元素）</p><p>4.1如果是Node（链表结构）则执行链表的添加操作。</p><p>4.2如果是TreeNode（树型结构）则执行树添加操作。</p><p>⑤ 判断链表长度已经达到临界值 8 (default)节点数超过这个值就需要将链表转换为树结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;          <span class="comment">// may enter this loop many times</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)         <span class="comment">/* P1. not init */</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;      <span class="comment">/* P2. 第一个桶位置为空, CAS添加 */</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)                      <span class="comment">/* P3. 其他线程正在扩容 */</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;                         <span class="comment">/* 发生 hash 碰撞, 处理 listnode OR treenode, 只有此时才加锁, 其他情况都 CAS 循环尝试  */</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;       <span class="comment">/* 使用第一个元素作为锁, 粒度比 Segment 分段锁更加细 */</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;   <span class="comment">/* 链表的计数器 */</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;                    <span class="comment">/* 遍历到链表的结尾，在链表尾部添加节点 */</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;                       <span class="comment">/* 为树形结构的处理 */</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)           <span class="comment">/* 判断是否需要树化, 在方法中还需处理当前是否到达树化的最小容量，否则进行扩容操作 */</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、扩容</strong></p><p>// todo</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><img src="http://img.janhen.com/20210130172343image-20201031105952779.png" alt="http://img.janhen.com/20210130172343image-20201031105952779.png"></p><p>与 JDK7 的 HashMap 基本一致；</p><p>线程安全的同步容器；</p><h3 id="底层结构与初始化-3"><a href="#底层结构与初始化-3" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 底层结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 初始化容量为 11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash | 定位</strong></p><p>直接通过取模实现；</p><p>效率较 HashMap 低；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure><p><strong>2、 扩容 | rehash</strong></p><p>容量为 <code>2*oldCapacity+1</code>；</p><p>初始容量和扩容机制都与 HashMap 不同；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>3、 迭代方式</strong></p><p>通过 <code>Enumerator</code> 实现，而非 Iterator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） 与 HashMap的区别</p><p>① HashTable 设计上基于 Dictionary 实现，线程安全，执行效率低下，而 HashMap 基于 AbstractMap 实现，线程不安全，执行效率比 HashTable 高；</p><p>② NULL 值： HashMap 允许 NULL 值， HashTable 不允许；</p><p>③ 初始化与 hash 定位： HashTable 初始容量为 11，HashMap 初始容量为 16，HashTable 通过 % 的方式进行定位，HashMap 通过移位异或进行定位；</p><p>④ 迭代访问上： 两者实现的迭代不同，一个基于 Iterator，一个基于 Enumerator；</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>默认保持元素插入属性的 Map；</p><p>可先通过 HashMap 来进行统计一些必要的数据，之后通过对 HashMap 的 KEY, VALUE 进行一些排序，将其变为有序的，使用 LinkedHashMap 来将这些顺序串联起来，之后进行对应的逻辑处理；</p><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a><strong>底层结构</strong></h3><p>（1） 全局属性</p><p>① accessOrder： 控制开启访问作为次序，可借助 LinkedHashMap 实现 LRU Cache;</p><p>② head|tail： 控制按照插入 | 访问顺序迭代；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>（2） 节点</p><p>before | after 用于将节点连接起来方便遍历；</p><p>HashMap.TreeNode 扩展此节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;       </span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h3><p>（1） LRU Cache</p><p>通过 HashMap 的 putVal() 中提供的两个 hook 钩子函数实现特有的功能；</p><p>根据 assessOrder 值不同，迭代出不同的结果。为 true，执行 LRU 顺序，访问过后移到链表尾部，头部为最近最久未使用节点； 为 false，执行插入顺序，与 List 语义相同；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;     <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1-2） LinkedHashMap 实现的线程安全的 LRUCache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    cache = <span class="keyword">new</span> LinkedHashMap((<span class="keyword">int</span>) Math.ceil(capacity/DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">223232L</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.size() &gt;= capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.put(key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 借助多态将 HashMap 中的数据按照一定的规则进行排序</p><p>如 HashMap 存放的是词频，可以根据词频进行排序，之后迭代访问时就是词频从高到低的序列；</p><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） 与 HashMap 的区别</p><p>① 设计层面上： LinkedHashMap 是 HashMap 的子类；</p><p>② 底层结构及功能扩展上： LinkedHashMap 节点中添加了 before, after 用于保证顺序；</p><p>③ put 操作： LinkedHashMap 在继承的基础上重写 HashMap 中的 hook(钩子) 方法，在 LinkedHashMap 中向哈希表中插入新 Entry 的同时，还会通过 Entry 的 addBefore 方法将其链入到双向链表中。</p><p>④ get 操作： LinkedHashMap 中重写了 HashMap 中的 get 方法，通过 HashMap 中的 getEntry 方法获取 Entry 对象。 在此基础上，进一步获取指定键对应的值。</p><p>⑤ 在扩容操作上： 虽然 LinkedHashMap 完全继承了 HashMap 的 resize 操作，但是鉴于性能和 LinkedHashMap 自身特点的考量， LinkedHashMap 对其中的重哈希过程(transfer 方法)进行了重写。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>红黑树的实现</p><p>// todo</p><p><strong>X、其他 与 HashMap 的区别</strong></p><p>① 顺序性： TreeMap 可对按照 Key 的自然顺序或是传入的比较器进行排序；</p><p>② 存取效率上： O(1) VS O(logN)；</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>对于 ThreadLocal：</p><ul><li>当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本；</li><li>是一种无锁同步方案；</li><li>是一种用空间换取时间来保证线程安全的方案；</li><li>多线程情况下，对应的子线程的 ThreadLocal 无法获取到父线程的 ThreadLocal，需要第三方工具包支持，可选择 alibaba 的 transmittable-thread-local 包；</li></ul><p><strong>1、底层结构</strong></p><p>（1） 全局结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">Entry[] table;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>（2） Entry</p><p>继承自 WeakReference ，在无活跃线程或栈中持有时，在 GC 时就会被回收；</p><p>节点只保存值，ThreadLocalMap 不是使用链地址法来解决 Hash 冲突；</p><p>多个线程，只设置一个 ThreadLocal 变量，在这个线程中的 ThreadLocal 变量的值始终是只有一个的，即以前的值被覆盖了的。这里是因为 Entry 对象是以该 ThreadLocal 变量的引用为 key 的，所以多次赋值以前的值会被覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;     <span class="comment">/* ThreadLocal as key */</span></span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 定位</p><p>通过此来进行 hash 桶的定位；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure><p>（4） 负载因子</p><blockquote><p>0.66</p></blockquote><p>空间利用率相较于 HashMap 的 0.75 较低，但加快查询；</p><p>同时配合开放地址法来快速定位到空闲的桶；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash()</strong></p><p>没有扰动函数，通过 ThreadLocal 中保存的 threadLocalHashCode 来实现；</p><p>threadLocalHashCode 根据维护的 <code>AtomicInteger nextHashCode</code> 获取；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThreadLocalMap.getEntry</span></span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、set()</strong></p><p>① 先获取到 ThreadLocal 键的 thresholdLocalHashCode ，以此来确定对应的桶下标；</p><p>② 如果在该位置正好与当前进行重合，直接覆盖；</p><p>③ 如果该位置无元素，则将其放入该位置；</p><p>④ 上面两个都不满足的情况下，使用线性探测法不断寻找到对应的满足上述两个条件的位置；</p><p>⑤ 上述都不满足，创建一个节点，并清理一些桶位，之后进行重新 hash ；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail  more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];          <span class="comment">// bucket position</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)   <span class="comment">// add node need to clean some object</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、扩容 | rehash</strong></p><p>（1） rehash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） resize</p><p>扩容为原来的两倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1）与 HashMap 的比较</p><p>① 底层结构：</p><ul><li>ThreadLocalMap 只有数组，HashMap 通过数组 + 链表(Tree) 方式</li><li>节点引用类型： ThreadLocalMap 节点为弱引用，会下一次 GC 被回收</li></ul><p>② hash： 并发下通过 AtomicInteger 实现</p><p>③ hash 冲突处理： ThreadLocalMap 通过线性探测法实现的，HashMap 通过链地址法实现；</p><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a><strong>底层结构</strong></h3><p>（1）节点</p><p>与 Entry 继承 WeakReference，当前 Entry 需要引用队列来进行处理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="comment">// 单独的 Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;    <span class="comment">/* must use reference queue */</span></span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash | 定位</strong></p><p>通过四次异或来进行 hash 扰动，使其少依赖于原始的 hashCode()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、put</strong></p><p>NULL 值： 对 NULL 的 KEY 处理机制，将 NULL 作为指向一个对象进行存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li>《Java并发编程的艺术》方腾飞 / 魏鹏 / 程晓明</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashMap-JDK7&quot;&gt;&lt;a href=&quot;#HashMap-JDK7&quot; class=&quot;headerlink&quot; title=&quot;HashMap(JDK7)&quot;&gt;&lt;/a&gt;HashMap(JDK7)&lt;/h2&gt;&lt;p&gt;Hash 表结构几个重要的通用操作， hash 函数、h</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java-集合类源码</title>
    <link href="http://example.com/2021/04/08/Java-%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/04/08/Java-%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/</id>
    <published>2021-04-08T15:18:17.000Z</published>
    <updated>2021-04-08T16:54:15.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>基本性质：</p><ul><li>底层基于数组保存；</li><li>增删慢、随机查询快；</li><li>线程不安全；</li></ul><h3 id="底层结构与初始化"><a href="#底层结构与初始化" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>（2） 加载和初始化</p><p>懒加载形式，在 add() 时进行对应的初始化；</p><p>共支持三种初始化方式：</p><p>① 无参构造： 默认不进行数据的初始化；</p><p>② 给定容量： 程序中通过给定容量来优化；</p><p>③ 通过放入 Collection 接口进行初始化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="comment">// 使用 Guava 创建指定容量的 List</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayListWithCapacity(oldList.size());</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>1、add</strong></p><p>① 默认插入尾部，O(1) 实现；</p><p>② 任意位置插入</p><ul><li>将插入位置后的所有元素右移一位，之后在插入位置赋值；</li><li>插入的开销与插入的位置有关；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);             <span class="comment">/* 右移一位 */</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、remove</strong></p><p>需要调用 System.arraycopy() 将 index + 1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，开销大；</p><p>同 add() 操作，删除与位置紧密相关；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 扩容</strong></p><p>扩容后的大小为 <code>oldN * 1.5 + 1</code>；</p><p>通过 <code>Arrays.copyOf()</code> 复制到新数组中；</p><p>可通过指定初始容量的方式，来减少扩容的次数，减少不必要的开销；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">/* init capacity */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">/* copy to impl. */</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、 迭代访问</strong></p><p>采用快速失败模式实现；</p><p>通过成员变量 <code>modCount</code> 与 expectedModCount 比较实现；</p><p>主要用在序列化获得迭代操作时进行判断，对应抛出 <code>ConcurrentModificationException</code>；</p><p><strong>5、序列化</strong></p><p>只序列化数组中存放值的这些部分。</p><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;     <span class="comment">// not serialize</span></span><br></pre></td></tr></table></figure><p>通过 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;   <span class="comment">/* keep to compare */</span></span><br><span class="line">    s.defaultWriteObject();             <span class="comment">/* only have space */</span></span><br><span class="line"></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;        <span class="comment">/* only write have element */</span></span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;    <span class="comment">/* use for fail-fast */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 list 序列化到指定文件</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p><strong>（1） ArrayList 与 Array 的比较</strong></p><p>① 存储类型： Array 可以存放基本和对象类型， ArrayList 只能存放对象类型；</p><p>② 存放元素的大小： ArrayList 动态可变，Array 不可变;</p><p>③ 其他方法和特性：</p><ul><li>ArrayList 提供 addAll()，removeAll()，iterator() 等方法;</li><li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ul><p><strong>（2）ArrayList 与 LinkedList 的比较</strong></p><p>都是线程不安全的容器，都实现了 List 接口具备 List 的特性。</p><p>① 底层结构： ArrayList 基于索引的数据接口，底层是动态数组实现，LinkedList 以元素列表的形式存储数据，是双向链表实现；</p><p>② 操作性质：</p><ul><li>随机访问： ArrayList 支持随机访问，LinkedList 不支持；</li><li>元素删除： LinkedList 在任意位置添加删除元素更快；</li><li>操作是否与元素位置的影响： 比较插入和删除是否受元素位置影响，ArrayList 插入和删除受元素位置影响，add(e) 默认追加到末尾，在指定位置 i 插入和删除时复杂度为 O(n-i)，而 LinkedList 链表存储，插入和删除不受位置影响；</li></ul><p>③ 内存占用上： LinkedList 存放两个指针，相同数据量下占用更多的空间；</p><p><strong>（3） ArrayList 与 Vector 的比较</strong></p><ul><li>同步性： Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。</li><li>扩容： Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。且 Vector 可以设置增长空间的大小。</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基本性质：</p><ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。</li><li>线程不安全；</li><li>LinkedList 可以用作栈、队列和双向队列。</li></ul><h3 id="底层结构与初始化-1"><a href="#底层结构与初始化-1" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><p>通过记录 first, last, size 便于边界操作（注：用于队列、栈、双端队列）</p><p>队列中每个节点都存放元素，存在初始化情况；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>不支持初始情况下给定对应的容量，即基于链表都为无界队列；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、add</strong></p><p>添加元素, 最后元素与中间元素, 可处理头结点位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)         </span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;               </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);    </span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)             <span class="comment">/* init 处理 */</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、remove</strong></p><p>操作不受指定位置的影响；</p><p>为双向链表中指定节点的删除；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>基本性质：</p><ul><li>底层基于数组保存元素；</li><li>随机查询快，增删慢；</li><li>线程安全；</li><li>Java 中的 Stack 通过继承 Vector 实现的；</li></ul><h3 id="底层结构与初始化-2"><a href="#底层结构与初始化-2" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><p>① elementCount：初始容量为 10，非懒加载实现；</p><p>② capacityIncrement；可以设置每次容量的增长数量；</p><p>③ 无 modCount： 同步容器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] elementData;</span><br><span class="line"><span class="keyword">int</span> elementCount;</span><br><span class="line"><span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>支持 ArrayList 的各种初始化；</p><p>支持设置每次的扩容时的容量增长；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、add / get</strong></p><p>对修改底层结构的函数进行加锁同步访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、扩容机制</strong></p><p>默认扩容为 <code>oldN * 2</code>；</p><p>可以通过用户设置的正常数量进行控制扩容大小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?                 <span class="comment">/* 默认扩容 1 倍 */</span></span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p><strong>替代方案</strong></p><p>因为 Vector 通过加锁实现，粒度大效率低。</p><p>（1） 获得对应线程不安全容器的同步容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>（2） 使用并发容器，如 CopyOnWriteArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>基本性质：</p><ul><li>易引起 YongGC, FullGC</li><li>不可用于实时的数据， 写操作复制防止并发修改不一致</li><li>适合读多写少的情景</li><li>读操作无需加锁，写操作加锁</li></ul><p>三个设计思想：</p><ul><li>读写分离</li><li>最终一致性</li><li>新开辟空间，解决并发冲突</li></ul><h3 id="底层结构与初始化-3"><a href="#底层结构与初始化-3" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><p>① ReentrantLock： 通过此来实现并发访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>三种初始化方式：</p><p>LinkedList 的初始化方式</p><p>支持泛型数组初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>(1) add</strong></p><p>并发下安全的容器，需要处理并发访问问题、处理复制问题。</p><p>包含 lock 加锁获取与释放：</p><p>① 获取原数组</p><p>② 复制出 len+1 的数组</p><p>③ 为新数组末尾复制</p><p>④ 修改内部数组指向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;           </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();      <span class="comment">/* 获取原数组, volatile 保证可见性 */</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);   <span class="comment">/* 复制数组 */</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) get</strong></p><p>无需加锁直接访问, 在 add 操作的同时可访问旧有的数据 ⇒ 实时性得不到保证 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、迭代方式</strong></p><p>通过安全失败实现，将当前数组放入到 Iterator 实现类中作为快照访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器中保存某个时间点下底层数组的快照，通过 cursor 来进行向前迭代访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="keyword">int</span> cursor;</span><br><span class="line">COWIterator(Object[] elements, <span class="keyword">int</span> initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） 读写分离</p><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响；</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失；</p><p>写操作结束之后需要把原始数组指向新的复制数组；</p><p>（2）适用场景</p><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>（3） 缺陷</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="底层结构与初始化-4"><a href="#底层结构与初始化-4" class="headerlink" title="底层结构与初始化"></a>底层结构与初始化</h3><p>通过一个 HashMap 实现，对应的 Value 为指定的一个 Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><p>1、add</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>基于 LinkedHashMap 实现, HashSet 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>与 HashSet 的区别</strong></p><p>① 底层结构：HashSet 基于 hash 表实现，元素无序， 一些方法 add(), remove(), contains() 复杂度为 O(1)；</p><p>② 有序性： TreeSet 基于红黑树实现，元素有序， add(), remove(), contains() 复杂度为 O(logN)；</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>基本性质：</p><ul><li>有序的优先队列；</li><li>不可以存放 NULL，NULL 无自然顺序；</li><li>非线程安全，入队和出队的时间复杂度为 O(logN)；</li><li>基于堆结构实现，默认情况下为最小堆；</li></ul><h3 id="底层结构与初始化-5"><a href="#底层结构与初始化-5" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 底层结构</p><p>数组保存的完全二叉树，首元素存放元素值。</p><p>堆顶元素有序，默认情况下为最小堆。</p><p>comparator： 默认自定义比较器优先于存入对象的自然排序进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue; </span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>可指定初始容量与比较器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">PriorityQueue(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator) &#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator);</span><br></pre></td></tr></table></figure><h3 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>（1） offer</strong></p><p>实现：</p><ul><li>先将元素放到完全二叉树的尾节点</li><li>之后不断上浮调整结构使其符合堆特性</li></ul><p>辅助-shiftUp</p><p>上浮函数，用于维护最小堆的结构。</p><p>赋值替换交换优化；</p><p>找出正确位置并放入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2） poll</strong></p><p>弹出当前堆顶元素。</p><p>实现：</p><ul><li>保存堆顶元素；</li><li>将堆顶与最末叶子节点交换，之后通过堆顶下沉实现结构的维护；</li><li>siftDown，下沉函数，最小堆的结构；</li><li>通过赋值来替换掉交换操作；</li><li>找到元素应该放入的正确位置放入；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3） remove</strong></p><p>remove(o) 删除一个对象，为 Collection 中的方法，需要先进行向下调整后进行向上调整；</p><p>实现：</p><ul><li>最末叶子节点赋值到当前删除的位置；</li><li>让原来的最末叶子节点向下调整；</li><li>若结构不合法则向上调整；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];       <span class="comment">/* 最末叶子节点赋值到当前删除的位置 */</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);             <span class="comment">/* 让原来的最末叶子节点向下调整 */</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;      <span class="comment">/* 结构不合法向上调整 */</span></span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4） heapify</strong></p><p>初始传入为 Collection 进行堆化处理，借助原始结构，从中间处向上不断下沉处理，相比较每次插入到最末叶子节点进行向上调整效率更高；</p><p>完全二叉树中间节点位置 size / 2 - 1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="comment">/* 完全二叉树从上层节点不断向下调整实习 */</span></span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、扩容</strong></p><p>小数据量快速 <code>2 * oldCapacity + 2</code> 扩容，容量大于 64 后进行 <code>1.5 * oldCapacity</code> 扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、迭代访问</strong></p><p>通过双向队列 ArrayDeque 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    ArrayDeque&lt;E&gt; forgetMeNot = <span class="keyword">null</span>;</span><br><span class="line">    E lastRetElt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>使用场景</p><ul><li>贪心算法选择局部最优；</li><li>图论中使用进行优化；</li><li>实现哈夫曼树等结构；</li></ul><h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p>基于数组实现的双向队列；</p><p>可使用 Stack 的 API;</p><h3 id="底层结构与初始化-6"><a href="#底层结构与初始化-6" class="headerlink" title="底层结构与初始化"></a>底层结构与初始化</h3><p>(1) 底层结构</p><p>一个数组，两个索引指向队列的头节点和尾部节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>(2) 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>1、sort</strong></p><p><strong>JDK 中的排序都为稳定排序</strong></p><p>算法的执行逻辑：</p><ul><li>小数据量使用 INSERT 排序</li><li>一定规模数据量使用 QUICK 排序</li><li>大数据量使用 MERGE 排序</li><li>并非所有大数据量都是 Merge Sort，在不具备结构性时转换成 Quick Sort；</li></ul><p>（1） 归并排序</p><p>① 小数据量转快速排序</p><p>② 通过分配当前大小进行 merge</p><p>③ 判断排序数组的结构，不具有时使用快速排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];   <span class="comment">/* aux space to merge */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"><span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The array is not highly structured,</span></span><br><span class="line"><span class="comment">        * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 快速排序</p><p>① 小数据量插入排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">boolean</span> leftmost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use insertion sort on tiny arrays</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>② 逻辑实现</p><p>通过双枢纽元分割实现；</p><p>类似 BFPRT 算法中对于枢纽元的选取，将原来期望的复杂度转换成确定的复杂度；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">left part           center part                   right part</span><br><span class="line"> +--------------------------------------------------------------+</span><br><span class="line"> |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line"> +--------------------------------------------------------------+</span><br><span class="line">               ^                          ^       ^</span><br><span class="line">               |                          |       |</span><br><span class="line">              less                        k     great</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">   left part         center part                  right part</span><br><span class="line"> +----------------------------------------------------------+</span><br><span class="line"> | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line"> +----------------------------------------------------------+</span><br><span class="line">              ^                        ^       ^</span><br><span class="line">              |                        |       |</span><br><span class="line">             less                      k     great</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line"> Partitioning degenerates to the traditional <span class="number">3</span>-way</span><br><span class="line"> (or <span class="string">&quot;Dutch National Flag&quot;</span>) schema:</span><br><span class="line"></span><br><span class="line">   left part    center part              right part</span><br><span class="line"> +-------------------------------------------------+</span><br><span class="line"> |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line"> +-------------------------------------------------+</span><br><span class="line">              ^              ^        ^</span><br><span class="line">              |              |        |</span><br><span class="line">             less            k      great</span><br></pre></td></tr></table></figure><p>（3） 插入排序</p><p>为快速排序中的子过程实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Traditional (without sentinel) insertion sort,</span></span><br><span class="line"><span class="comment">        * optimized for server VM, is used in case of</span></span><br><span class="line"><span class="comment">        * the leftmost part.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + <span class="number">1</span>] = ai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Skip the longest ascending sequence.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Every element from adjoining part plays the role</span></span><br><span class="line"><span class="comment">        * of sentinel, therefore this allows us to avoid the</span></span><br><span class="line"><span class="comment">        * left range check on each iteration. Moreover, we use</span></span><br><span class="line"><span class="comment">        * the more optimized algorithm, so called pair insertion</span></span><br><span class="line"><span class="comment">        * sort, which is faster (in the context of Quicksort)</span></span><br><span class="line"><span class="comment">        * than traditional implementation of insertion sort.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">            <span class="keyword">int</span> a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a1 &lt; a2) &#123;</span><br><span class="line">                a2 = a1; a1 = a[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class="line">                a[k + <span class="number">2</span>] = a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            a[++k + <span class="number">1</span>] = a1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class="line">                a[k + <span class="number">1</span>] = a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            a[k + <span class="number">1</span>] = a2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = a[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (last &lt; a[--right]) &#123;</span><br><span class="line">            a[right + <span class="number">1</span>] = a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        a[right + <span class="number">1</span>] = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、binarySearch</strong></p><p>计算 mid <code>mid = (low + high) &gt;&gt;&gt; 1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like public version, but without range checks.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">  <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;       <span class="comment">// </span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Comparable midVal = (Comparable)a[mid];</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、asList / subList</p><p>不推荐使用，返回的 List 修改会有问题。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>1、提供一些容器的空实现：作为容器为空的情况下的返回值，规避空指针问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List EMPTY_LIST = <span class="keyword">new</span> EmptyList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、提供单个元素的集合：</p><p>方便传递方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">singletonList</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SingletonList&lt;&gt;(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3<strong>、sort</strong></p><p>JDK8 中借助 List 中自带的 sort() 函数调用实现；</p><p>4<strong>、binarySearch</strong></p><p>对 List 进行二分搜索</p><p>根据底层是数组还是链表采用不同的处理：</p><p>① 数组： 数组随机访问定位实现</p><p>② 链表： 接着 ListIterator 实现二分查找</p><p>在 binarySearch（）⽅法中，它要判断传⼊的list 是否 RamdomAccess 的实例，如果是，调⽤ indexedBinarySearch() ⽅法，如果不是，那么调⽤ iteratorBinarySearch() ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">    <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、提供将不安全的容器转换为同步容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JDK 中 ArrayList,LinkedList,Vector,CopyOnWriteArrayList,PriorityQueue,ArrayDeque,Collections,Arrays 源码分析比较，关注于集合类型的底层结构、扩容机制、线程安全、复杂度震荡、迭代方式等方面。</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="http://example.com/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/</id>
    <published>2021-03-09T15:23:13.000Z</published>
    <updated>2021-04-09T09:34:16.928Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Notion 做笔记，博客为 Notion 的部分导出。</p><p><a href="https://github.com/Janhen/notes">https://github.com/Janhen/notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 Notion 做笔记，博客为 Notion 的部分导出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Janhen/notes&quot;&gt;https://github.com/Janhen/notes&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hive-优化</title>
    <link href="http://example.com/2021/03/09/Hive-%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/03/09/Hive-%E4%BC%98%E5%8C%96/</id>
    <published>2021-03-09T13:33:13.000Z</published>
    <updated>2021-04-09T09:06:21.334Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>影响 Hive 效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、Job / IO过多、MapReduce 分配不合理等。</p><h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><h3 id="执行引擎选择"><a href="#执行引擎选择" class="headerlink" title="执行引擎选择"></a>执行引擎选择</h3><p>通过参数 hive.execution.engine 控制，可选 MapReduce, Tez, Spark, Flink 作为执行引擎，在离线数仓中，批处理方面主要使用 Spark</p><h3 id="优化器的使用"><a href="#优化器的使用" class="headerlink" title="优化器的使用"></a>优化器的使用</h3><p>在真正执行计算之前，生成和优化逻辑执行计划与物理执行计划。</p><ul><li>Vectorize 矢量化查询执行</li><li>Cost-Based Optimization: CBO 成本优化器</li></ul><p><strong>矢量化查询执行</strong> 要求执行引擎为Tez, 执行通过一次批量执行1024行而不是每行一行来提高扫描，聚合，过滤器和连接等操作的性能, 可一显着缩短查询执行时间。 需要使用 orc 格式存储数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启 </span></span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.enabled = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.reduce.enabled = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>成本优化器</strong> 基于apache Calcite的，Hive的CBO通过查询成本(有analyze收集的统计信息)会生成有效率的执行计划，最终会减少执行的时间和资源的利用</p><p>可定期执行表的分析，分析后数据存放在元数据库中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从 v0.14.0默认</span></span><br><span class="line"><span class="keyword">SET</span> hive.cbo.enable=<span class="literal">true</span>; </span><br><span class="line">true</span><br><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.compute.query.using.stats=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.stats.fetch.column.stats=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认true</span></span><br><span class="line"><span class="keyword">SET</span> hive.stats.fetch.partition.stats=<span class="literal">true</span>; </span><br></pre></td></tr></table></figure><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>Parquet 和 ORC 都是 Apache 旗下的开源列式存储格式。列式存储比起传统的行式存 储更适合批量 OLAP 查询，并且也支持更好的压缩和编码。 选择 Parquet 的原因主要是它支持 Impala 查询引擎，并且对 update、delete 和事务性操作需求很低。</p><p>选择 ORCFile 支持事务操作。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>压缩的配置可以在hive的命令行中或者hive-site.xml文件中进行配置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.compress.intermediate=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>DEFLATE</li><li>GZIP: 扩展名 .gz</li><li>Bzip2: 支持分割, 扩展名 .gz</li><li>LZO：</li><li>LZ4：</li><li>Snappy: 不支持分割</li></ul><p>可在mapred-site.xml, hive-site.xml 配置，命令行配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.intermediate.compression.codec=org.apache.hadoop.io.compress</span><br><span class="line">.SnappyCodec;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.compress.output=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">SET</span> mapreduce.output.fileoutputformat.compress.codec =</span><br><span class="line">org.apache.hadoop.io.compress.SnappyCodc</span><br></pre></td></tr></table></figure><h3 id="分区、分桶表"><a href="#分区、分桶表" class="headerlink" title="分区、分桶表"></a>分区、分桶表</h3><p>设计成分区表可以提升查询的性能，对于一个特定分区的查询，只会加载对应分区路  径的文件数据</p><p>尽量避免层级较深的分区</p><ul><li>日期或时间。如year、month、day或者hour，</li><li>地理位置。如国家、省份、城市</li><li>业务逻辑。如部门、销售区域、客户</li></ul><p>分桶表 分桶表的组织方式是将HDFS上的文件分割成多个文件。 分桶可以加快数据采样，也可以提升join的性能(join的字段是分桶字段)，因为分桶可 以确保某个key对应的数据在一个特定的桶内(文件)，巧妙地选择分桶字段可以大幅 度提升join的性能。</p><p>分桶字段可以选择经常用在过滤操作或者join操作的字段。</p><h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>支持将作业动态地转为本地模式, 当Hive处理的数据量较小时，启动分布式去处理数据会有点浪费。</p><p>一个作业只要满足下面的条件，会启用本地模式</p><ul><li>输入文件的大小小于 <code>hive.exec.mode.local.auto.inputbytes.max</code> 配置的大小</li><li>map 任务的数量小于 <code>hive.exec.mode.local.auto.input.files.max</code> 配置的大小</li><li>reduce 任务的数量是1或者0</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto=<span class="literal">true</span>; <span class="comment">-- 默认 false</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto.inputbytes.max=<span class="number">50000000</span>;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto.input.files.max=<span class="number">5</span>; <span class="comment">-- 默认 4</span></span><br></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>强制不允许用户执行3种有风险的HiveQL语句，一旦执行会直接失败。</p><ul><li>查询分区表时不限定分区列的语句；</li><li>两表 join 产生了笛卡尔积的语句；</li><li>用 order by 来排序，但没有指定 limit 的语句。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DEFAULT strict</span></span><br><span class="line"><span class="keyword">set</span> hive.mapred.mode=nostrict</span><br></pre></td></tr></table></figure><h3 id="JVM-重用"><a href="#JVM-重用" class="headerlink" title="JVM 重用"></a>JVM 重用</h3><p>Hadoop可以重用 JVM，通过共享 JVM 以串行而非并行的方式运行 map 或者 reduce。 避免 JVM 启动进程所耗费的时间会比作业执行的时间还要长。</p><p>JVM的重用<font color="green">适用于同一个作业的 map 和 reduce，对于不同作业的 task 不能够共享 JVM。</font></p><p>开启JVM重用将一直占用使用到的 task 插槽，以便进行重用，直到任务完成后才能释放。</p><p>如果某个“不平衡的”job中有某几个reduce task执行的时间要比其他Reduce task消耗的时间多的多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 代表同一个MR job中顺序执行的5个task重复使用一个JVM，减少启动和关闭的开销</span></span><br><span class="line"><span class="keyword">SET</span> mapreduce.job.jvm.numtasks=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>Hive 将查询转换成一个或多个阶段，MapReduce 阶段、抽样阶段、合并阶段、Limit 阶段..</p><p>默认情况下一次只执行一个阶段，对于特定 Job 有多个阶段，阶段间非完全相互依赖，并行执行，可以缩短 job 的执行时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.parallel=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认8</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.parallel.thread.number=<span class="number">16</span>; </span><br></pre></td></tr></table></figure><h3 id="推测执行"><a href="#推测执行" class="headerlink" title="推测执行"></a>推测执行</h3><p>在分布式集群环境下，因为程序Bug、负载不均衡、资源分布不均、网络情况等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务, 这些任务会拖慢作业的整体执行进度。</p><p>Hadoop采用了推测执行机制，它根据一定的规则推测出 “拖后腿” 的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.map.speculative=<span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.reduce.speculative=<span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> hive.mapred.reduce.tasks.speculative.execution=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="合并小文件"><a href="#合并小文件" class="headerlink" title="合并小文件"></a>合并小文件</h3><p>在map执行前合并小文件，减少map数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 缺省参数</span></span><br><span class="line"><span class="keyword">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</span><br></pre></td></tr></table></figure><p>在Map-Reduce的任务结束时合并小文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 map-only 任务结束时合并小文件，默认true</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.mapfiles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 map-reduce 任务结束时合并小文件，默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.mapredfiles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 合并文件的大小，默认256M</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.size.per.task = <span class="number">268435456</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当输出文件的平均大小小于该值时，启动一个独立的 map-reduce 任务进行文件merge</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.smallfiles.avgsize = <span class="number">16777216</span>;</span><br></pre></td></tr></table></figure><h3 id="Fetch-模式"><a href="#Fetch-模式" class="headerlink" title="Fetch 模式"></a>Fetch 模式</h3><p>Fetch 模式是指 Hive 中对某些情况的查询可以不必使用 MapReduce 计算 在开启 fetch 模式之后，在全局查找、字段查找、limit 查找等都不启动 MapReduce</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Default Value: minimal in Hive 0.10.0 through 0.13.1, </span></span><br><span class="line"><span class="comment">-- more in Hive 0.14.0 and later</span></span><br><span class="line">hive.fetch.task.conversion=more</span><br></pre></td></tr></table></figure><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="列裁剪和分区裁剪"><a href="#列裁剪和分区裁剪" class="headerlink" title="列裁剪和分区裁剪"></a>列裁剪和分区裁剪</h3><p>列裁剪： SELECT 只查需要的列。少用 SELECT * 分区裁剪:  只读取需要的列。在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where 后面，那么就会先全表关联，之后再过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列裁剪优化相关的配置项, default true</span></span><br><span class="line">hive.optimize.cp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 分区裁剪优化, default true</span></span><br><span class="line">hive.optimize.pruner=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h3><p>在 RDBMS 中，如 MySQL 也有 Predicate Pushdown(PPD) 的概念，将 SQL 语句中的 where 谓词逻辑尽可能提前执行，减少下游处理的数据量。</p><p>如下的 SQQ， forum_topic 表过滤的 where 语句卸载子查询内部，而不是外部，Hive 谓词下推逻辑优化器是 PredicatePushDown，该优化器将 OperatorTree 中的 FilterOperator 向上提。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.uid,a.event_type,b.topic_id,b.title</span><br><span class="line"><span class="keyword">from</span> calendar_record_log a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> uid,topic_id,title <span class="keyword">from</span> forum_topic</span><br><span class="line"><span class="keyword">where</span> pt_date = <span class="number">20190224</span> <span class="keyword">and</span> <span class="keyword">length</span>(<span class="keyword">content</span>) &gt;= <span class="number">100</span></span><br><span class="line">) b <span class="keyword">on</span> a.uid = b.uid</span><br><span class="line"><span class="keyword">where</span> a.pt_date = <span class="number">20190224</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment"># 谓词下推优化的配置项, default true</span></span><br><span class="line">hive.optimize.ppd = true</span><br></pre></td></tr></table></figure><h3 id="sort-by-代替-order-by"><a href="#sort-by-代替-order-by" class="headerlink" title="sort by 代替 order by"></a>sort by 代替 order by</h3><p>为了控制 map 端数据分配到 reducer 的 key, 需要配置 distribute by 一起使用，如果不加 distribute by 的话，map 端数据就会随机分配到 reducer。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以UID为key，以上传时间倒序、记录类型倒序输出记录数据</span></span><br><span class="line"><span class="keyword">select</span> uid,upload_time,event_type,record_data</span><br><span class="line"><span class="keyword">from</span> calendar_record_log</span><br><span class="line"><span class="keyword">where</span> pt_date &gt;= <span class="number">20190201</span> <span class="keyword">and</span> pt_date &lt;= <span class="number">20190224</span></span><br><span class="line"><span class="keyword">distribute</span> <span class="keyword">by</span> uid</span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> upload_time <span class="keyword">desc</span>,event_type <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="group-by-代替-count-distinct"><a href="#group-by-代替-count-distinct" class="headerlink" title="group by 代替 count(distinct)"></a>group by 代替 count(distinct)</h3><p>去重计算数据量大时不好处理，数据量大的时候用一个 ReduceTask 来完成，导致整个 Job 很难完成  。 一般 COUNT DISTINCT 使用先 GROUP BY 再 COUNT 的方式替换。使用 group by 替换后， SQL 如下，会启动两个 MR Job，确保启动 Job 开销远小于计算耗时的时候使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> calendar_record_log</span><br><span class="line"><span class="keyword">where</span> pt_date &gt;= <span class="number">20190101</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><h3 id="group-by-配置调整"><a href="#group-by-配置调整" class="headerlink" title="group by 配置调整"></a>group by 配置调整</h3><p>并不是所有的聚合操作都需要在 Reduce 端完成，可现在 Map 端进行部分聚合，最后在 Reduce 端得出最终结果</p><ul><li><code>hive.map.aggr=true</code>: 是否在 Map 端进行聚合</li><li><code>hive.groupby.napaggr.checkinterva=10000</code>: 在 Map 端进行聚合操作的条目数目</li><li><code>hive.groupby.skewindata=true</code>: 有数据倾斜的时候进行负载均衡，默认 false</li></ul><p>当选项设定为 true，生成的查询计划会有两个 MR Job。第一个MR Job中，Map的输出结果会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的Group By Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；第二个MR Job再根据预处理的数据结果按照Group By Key分布到Reduce中（这个过程可以保证相同的Group By Key被分布到同一个Reduce中），最后完成最终的聚合操作。</p><h3 id="join-基础优化"><a href="#join-基础优化" class="headerlink" title="join 基础优化"></a>join 基础优化</h3><p>map join</p><p>分桶 join</p><h3 id="大表-join-大表处理空值或无意义值"><a href="#大表-join-大表处理空值或无意义值" class="headerlink" title="大表 join 大表处理空值或无意义值"></a>大表 join 大表处理空值或无意义值</h3><p>(1) 空 key 过滤 大表 Join 大表时，key 有大量的异常数据，相同的 key 发送到相同的 reducer 上，从而导致内存不够，结果 Join 的时候耗时长，可先通过 SQL 对其进行过滤。</p><p>(2) 空 key 转化 空 Key 转化，key 非异常数据，必须包含在 join 的结果中，可对为空的 key 设置随机值，使数据随机均匀分到不同的 reducer 上，防止数据的倾斜问题 …</p><h3 id="单独处理倾斜-key"><a href="#单独处理倾斜-key" class="headerlink" title="单独处理倾斜 key"></a>单独处理倾斜 key</h3><h3 id="调整-Map-数"><a href="#调整-Map-数" class="headerlink" title="调整 Map 数"></a>调整 Map 数</h3><p>通常情况下，作业通过 Input 目录产生一个/多个 map 任务 input 文件总个数、文件大小，集群设置的文件快大小。</p><p>Q:  是不是map数越多越好？ 答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</p><p>Q:  是不是保证每个map处理接近128m的文件块，就高枕无忧了？ 答案也是不一定。比如有一个127m的文件，正常会用一个 map 去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果 map 处理的逻辑比较复杂，用一个 map 任务去做，肯定也比较耗时。</p><p>增加 Map 的方法：</p><p>调整 maxSize 最大值，使 maxSize 小于 blockSize 增加 map 个数</p><p>// TODO maxSize 对应的配置参数…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))&#x3D;blocksize&#x3D;128M</span><br></pre></td></tr></table></figure><h3 id="调整-Reduce-数"><a href="#调整-Reduce-数" class="headerlink" title="调整 Reduce 数"></a>调整 Reduce 数</h3><p>过多的 reduce 问题</p><ul><li>过多的 reduce， 会过多启动、初始化 reduce 消耗时间和资源</li><li>有多少个 reduce 就会有多少个输出文件，生成很多小文件，如果这些小文件作为下一个任务的输入，会出现小文件过多的问题</li><li><code>hive.exec.reducers.bytes.per.reducer=256000000</code>: 每个 reduce 处理的数据量默认为 256MB</li><li><code>hive.exec.reducers.max=1009</code>: 每个任务最大的 reduce 数，默认 1009</li><li><code>mapreduce.job.reduces</code>： 设置每个 job 的 reduce 个数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置每个 job 的 reduce 个数</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">15</span></span><br></pre></td></tr></table></figure><p>优化小结 Hadoop/Hive 处理数据过程，有几个显著特征：</p><ul><li>不怕数据多，就怕数据倾斜</li><li>对 job 数比较多的作业运行效率相对比较低</li><li>对 sum、count 等聚合操作而言，不存在数据倾斜问题</li><li>count(distinct) 效率较低，数据量大容易出问题</li></ul><p>优化可以从几个方面着手：</p><ul><li>好的模型设计，事半功倍</li><li>解决数据倾斜问题。根据配置和业务进行处理</li><li>减少 job 数</li><li>设置合理的map、reduce task 数</li><li>对小文件进行合并，是行之有效的提高 Hive 效率的方法</li><li>优化把握整体，单一作业的优化不如整体最优</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Hive 自带的序列化与反序列化</p><p><a href="https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe">https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe</a></p><p>Hive 参数说明的官方文档：<a href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties">https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties</a></p><p><a href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html">Hive SQL的编译过程</a></p><p><a href="https://mp.weixin.qq.com/s/DfvN7S_00oYw1hqAQDr48g">Hive/HiveSQL常用优化方法全面总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;影响 Hive 效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、Job / IO过多、MapReduce 分配不合理等。&lt;/p&gt;
&lt;h2 id=&quot;架构优化&quot;&gt;&lt;a href=&quot;#架构优化&quot; class=&quot;headerlink&quot; title=&quot;架</summary>
      
    
    
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive 中的函数</title>
    <link href="http://example.com/2021/03/09/Hive-%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/03/09/Hive-%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-09T13:30:52.000Z</published>
    <updated>2021-04-21T08:41:04.808Z</updated>
    
    <content type="html"><![CDATA[<p>函数分类</p><ul><li><p>标准函数： 一列或多列作为参数传入，返回值是一个值的函数</p><p>如 to_date(string timestamp), sqrt(double a)</p></li><li><p>聚合函数： 接收0行、多行的列，返回单一的值</p></li><li><p>表生成函数： 接收 0 、 多个输入，产生多列 、 多行输出 如 explode</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> functions;</span><br><span class="line">desc function upper;</span><br><span class="line">desc function extended upper;</span><br></pre></td></tr></table></figure><h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>基础日期函数：</p><ul><li>current_date:</li><li>current_timestamp：</li><li>year(string date)</li><li>month(string date)</li><li>hour(string date)</li><li>minute(string date)</li><li>second(string date)</li><li><code>datediff(string enddate, string startdate)</code>: 计算时间差</li><li><code>from_unixtime(bigint unixtime[, string format])</code>：转换从 1970-01-01 00:00:00 UTC 开始的秒为日期</li><li><code>date_format(date/timestamp/string ts, string fmt)</code>： 日期、时间戳、字符串类型格式化输出标准时间格式</li><li>to_date(string timestamp)： 字符串转日期，2.1.0- 返回 String 类型，2.1.0+ 返回 date 类型</li><li><code>day(string date)</code> / <code>dayofmonth(date)</code>:  查询当月第几天</li><li><code>weekofyear(string date)</code>: 如weekofyear(“1970-11-01 00:00:00”) = 44, weekofyear(“1970-11-01”) = 44.</li></ul><p>相对日期相关的函数：</p><ul><li><p><code>last_day(string date)</code>：查询月末的最后一天</p></li><li><p><code>date_add(date/timestamp/string startdate, tinyint/smallint/int days)</code>： 增加指定多少天</p></li><li><pre><code>date_sub(date/timestamp/string startdate, tinyint/smallint/int days)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ： 减少指定多少天</span><br><span class="line"></span><br><span class="line">  - date_sub(current_date, dayofmonth(current_date)-1)：当月第一天</span><br><span class="line"></span><br><span class="line">- add_months(string start_date, int num_months, output_date_format)，</span><br><span class="line"></span><br><span class="line">  - add_months(date_sub(current_date, dayofmonth(current_date)-1), 1)： 下月第一天</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  next_day(string start_date, string day_of_week)</span><br></pre></td></tr></table></figure>： 返回第一个日期，该日期晚于 start_date 并命名为day_of_week。- day_of_week 为两个或三个字符，如 &quot;Mo&quot;, &quot;tue&quot;, &quot;FRIDAY&quot;- next_day(&#39;2021-03-26&#39;, &#39;mo&#39;) = 2021-03-29： 指定日期的下一个周一- date_add(next_day(&#39;2021-03-26&#39;, &#39;mo&#39;), -7) = 2021-03-22： 指定日期的上一个周一日期</code></pre></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">current_date</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURRENT_TIMESTAMP</span>();</span><br><span class="line"><span class="comment">-- unix 时间戳转换成日期</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">11111111</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">11111</span>, <span class="string">&#x27;yyyyMMdd&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1111111</span>, <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br><span class="line"><span class="comment">-- 日期转成时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">&#x27;2019-09-15 14:23:00&#x27;</span>);</span><br><span class="line"><span class="comment">-- 时间差, 返回日期相差的天数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2020-04-18&#x27;</span>, <span class="string">&#x27;2019-11-21&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">abs</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-04-18&#x27;</span>, <span class="string">&#x27;2019-11-21&#x27;</span>));</span><br><span class="line"><span class="comment">-- 日期为所处月的第几天</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>);</span><br><span class="line"><span class="comment">-- 日期所处月的最后一天日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">last_day</span>(<span class="keyword">current_date</span>);</span><br><span class="line"><span class="comment">-- 当月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">current_date</span>, <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 下月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> add_months(<span class="keyword">date_sub</span>(<span class="keyword">current_date</span>, <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>) - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- must 字符串转换成 date yyyy-MM-dd</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020-01-01 12:12:12&#x27;</span>);</span><br><span class="line"><span class="comment">-- 日期格式化成指定的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="keyword">current_timestamp</span>(), <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="keyword">current_date</span>(), <span class="string">&#x27;yyyyMMdd&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="string">&#x27;2020-06-01&#x27;</span>, <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>常用的日期处理</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 近3天的</span></span><br><span class="line"><span class="comment">-- 近一周的</span></span><br><span class="line">where dt &gt;= date_add(next_day(&#x27;$do_date&#x27;, &#x27;mo&#x27;), -7)</span><br><span class="line">    and dt &lt;= &#x27;$do_date&#x27;</span><br><span class="line"><span class="comment">-- 近一月的</span></span><br><span class="line">where dt &gt;= date_format(&#x27;$do_date&#x27;, &#x27;yyyy-MM-01&#x27;)</span><br><span class="line">    and dt &lt;= &#x27;$do_date&#x27;</span><br></pre></td></tr></table></figure><h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul><li><code>IF .. else</code></li><li><code>case when.. end &lt;column-name&gt;</code>: 多个条件的时候使用</li><li><code>nvl(T value, T default_value)</code>: value 为空的时候返回默认值</li><li><code>COALESCE(T v1, T v2, ...)</code>: 返回参数中第一个非空值</li><li><code>nullif(x, y)</code>:  相等为空，否则为x</li><li>isnull / isnull( a ):</li><li>assert_true(boolean condition): 不满足抛出异常</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试表定义</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> emp</span><br><span class="line">(</span><br><span class="line">    empno    <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;员工号&#x27;</span>,</span><br><span class="line">    ename    <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;员工姓名&#x27;</span>,</span><br><span class="line">    job      <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;工作名称&#x27;</span>,</span><br><span class="line">    mgr      <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    hiredate <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;雇佣日期&#x27;</span>,</span><br><span class="line">    sal      <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;薪水&#x27;</span>,</span><br><span class="line">    comm     <span class="built_in">int</span>,</span><br><span class="line">    deptno   <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;部门号&#x27;</span></span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- if (boolean testCondition, T valueTrue, T valueFalseOrNull)</span></span><br><span class="line"><span class="comment">-- 将 emp 表的员工工资等级分类：0-1500、1500-3000、3000以上</span></span><br><span class="line"><span class="keyword">SELECT</span> sal,</span><br><span class="line">       <span class="keyword">if</span>(sal &lt;= <span class="number">1500</span>, <span class="string">&#x27;primary&#x27;</span>, </span><br><span class="line">       <span class="keyword">if</span>(sal &lt;= <span class="number">3000</span>, <span class="string">&#x27;middle&#x27;</span>, <span class="string">&#x27;advanced&#x27;</span>))</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">-- case when 判断</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">CASE</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;accounting&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">20</span> <span class="keyword">THEN</span> <span class="string">&#x27;research&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">30</span> <span class="keyword">THEN</span> <span class="string">&#x27;sales&#x27;</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="string">&#x27;unknown&#x27;</span> <span class="keyword">END</span> deptname</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">-- 返回参数中的第一个非空值；如果所有值都为 NULL，那么返回NULL</span></span><br><span class="line"><span class="keyword">select</span> sal, <span class="keyword">coalesce</span>(comm, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- null 判断</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> isnotnull(comm);</span><br><span class="line"><span class="comment">-- 空值转换函数 nvl(T value, T default_value)</span></span><br><span class="line"><span class="keyword">select</span> empno,</span><br><span class="line">       ename,</span><br><span class="line">       job,</span><br><span class="line">       mgr,</span><br><span class="line">       hiredate,</span><br><span class="line">       deptno,</span><br><span class="line">       sal + nvl(comm, <span class="number">0</span>) sumsal</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- nullif(x, y) 相等为空，否则为x  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">nullif</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>), <span class="keyword">nullif</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><code>lower</code>：</li><li><code>length</code>:</li><li><code>concat</code> / <code>||</code> ：字符拼接</li><li><code>concat_ws(separator, [string | array(string)]+)</code>: 可指定分隔符进行拼接</li><li><code>substr</code>： 求子串, 指定开始和结束索引</li><li><code>split</code>： <code>.</code> 需要进行正则转义</li><li>instr(string str, string substr)： 返回substr在str中第一次出现的位置</li><li>parse_url(string urlString, string partToExtract [, string keyToExtract])： 从 url 中抽取值，可抽取的值包括 HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.<ul><li>如 parse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;</a>, ‘HOST’) returns ‘<a href="http://facebook.com/">facebook.com</a>‘。</li></ul></li><li>regexp_extract(string subject, string pattern, int index)： 按照正则匹配值<ul><li>如 regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2)， Index 参数为 Java 的 group</li></ul></li><li>regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT):正则替换<ul><li>如 regexp_replace(“foobar”, “oo|ar”, “”) returns ‘fb.’</li></ul></li><li>get_json_object(string json_string, string path)： 从 JSON 字符串中获取特定路径值<ul><li>JSON 路径只能为 [0-9a-z_], 没有大写或特殊字符, keys 不可以以 数字开头</li></ul></li><li>str_to_map(text[, delimiter1, delimiter2])： 返回 map</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子串截取</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">split</span>(<span class="string">&quot;www.janhen.com&quot;</span>, <span class="string">&quot;\\\\.&quot;</span>);</span><br><span class="line"><span class="keyword">select</span> empno || <span class="string">&quot; &quot;</span> || ename idname</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串拼接  指定分割符拼接 concat_ws(separator, [string | array(string)]+)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="built_in">array</span>(<span class="string">&#x27;janhen&#x27;</span>, <span class="string">&#x27;com&#x27;</span>));</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="number">-5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>get_json_object 获取 JSON 字符串信息</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;store&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;fruit&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;weight&quot;</span>: <span class="number">8</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;apple&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;weight&quot;</span>: <span class="number">9</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pear&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;bicycle&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: <span class="number">19.95</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;amy@only_for_json_udf_test.net&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;owner&quot;</span>: <span class="string">&quot;amy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">-- 获取值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.owner&#x27;) FROM src_json;</span><br><span class="line">amy</span><br><span class="line">-- 获取数组值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.store.fruit\\[0]&#x27;) FROM src_json;</span><br><span class="line">&#123;<span class="attr">&quot;weight&quot;</span>:<span class="number">8</span>,<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line">-- 获取不存在的值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.non_exist_key&#x27;) FROM src_json;</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li><code>round</code>: round x to d decimal places，可用于控制小数保留几位</li><li><code>ceil</code>:  向上取整</li><li><code>floor</code>:  向下取整。</li><li><code>exp(DOUBLE a)</code>, <code>exp(DECIMAL a)</code>:  指数函数</li><li>log10(DOUBLE a), log10(DECIMAL a)</li><li>log(DOUBLE base, DOUBLE a)</li><li>abs(DOUBLE a)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">314.15926</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">314.15926</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="number">3.1415926</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="number">3.1415926</span>);</span><br></pre></td></tr></table></figure><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul><li><code>size(Map&lt;K.V&gt;)</code> / <code>size(Array&lt;T&gt;)</code>： 返回元素个数</li><li><code>map_keys(Map&lt;K.V&gt;)</code> / <code>map_values(Map&lt;K.V&gt;)</code>: 将 Map 所有的 key、value 进行返回</li><li><code>array_contains(Array&lt;T&gt;, value):</code> 数组中是否包含某个值</li><li><code>sort_array(Array&lt;T&gt;)</code>： 对数组元素进行排序</li><li><code>concat_ws</code>： 将集合通过字符拼接起来</li></ul><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><ul><li>binary(string|binary)： 转换成二进制</li><li>cast(expr as <type>)： 类型转换，无法转换时，返回 NULL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="string">&#x27;23232&#x27;</span> <span class="keyword">AS</span> <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure><blockquote><p>UDTF</p></blockquote><h3 id="聚集函数-UDAF"><a href="#聚集函数-UDAF" class="headerlink" title="聚集函数(UDAF)"></a>聚集函数(UDAF)</h3><ul><li>count / sum / avg / min / max</li><li>collect_set(col): 将制定列聚集为一个 set，自动去重</li><li>collect_list(col)</li><li>ntile(INTEGER x): 将有序分区划分为x个称为存储桶的组，并为该分区中的每一行分配存储桶编号。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按照设备聚合用户，将 set 转换成一个 string 字段保存</span></span><br><span class="line"><span class="keyword">select</span> device_id, </span><br><span class="line">       <span class="keyword">concat_ws</span>(<span class="string">&#x27;|&#x27;</span>, collect_set(uid))</span><br><span class="line"><span class="keyword">from</span> start_log </span><br><span class="line"><span class="keyword">where</span> dt=<span class="string">&#x27;2021-01-01&#x27;</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> device_id;</span><br></pre></td></tr></table></figure><h3 id="表生成函数-UDTF"><a href="#表生成函数-UDTF" class="headerlink" title="表生成函数(UDTF)"></a>表生成函数(UDTF)</h3><blockquote><p>一行输入，多行输出</p></blockquote><p>配合 lateral view 进行使用，解决 UDTF 不能添加额外列的问题。</p><ul><li>explode(ARRAY<T> a)</li><li>explode(MAP&lt;Tkey,Tvalue&gt; m)</li><li>posexplode (array)： 带有原始位置的炸裂函数</li><li>json_tuple(string jsonStr,string k1,…,string kn)</li><li>parse_url_tuple(string urlStr,string p1,…,string pn)</li></ul><p><strong>explode 炸裂数组/Map值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lateral view 常与表生成函数 explode 结合使用，处理上述问题</span></span><br><span class="line"><span class="comment">-- ==&gt;  解决 UDTF 不能添加额外列的问题</span></span><br><span class="line"><span class="comment">-- lateral view udtf(expression) tableALias as  ...</span></span><br><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">&#x27;OK&#x27;</span> cola, <span class="keyword">split</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="string">&#x27;\\\\.&#x27;</span>) colb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> cola, colc</span><br><span class="line"><span class="keyword">from</span> t1 <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(colb) t2 <span class="keyword">as</span> colc;</span><br><span class="line">lateral view udtf(expression) tableALias as &lt;col1&gt;, &lt;col2&gt; ...</span><br><span class="line"><span class="comment">-- 炸裂 map 并给定别名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">explode</span>(<span class="keyword">map</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">30</span>)) <span class="keyword">as</span> (<span class="keyword">key</span>,<span class="keyword">value</span>);</span><br><span class="line">key value</span><br><span class="line">A10</span><br><span class="line">B20</span><br><span class="line">C30</span><br><span class="line"><span class="keyword">select</span> posexplode(<span class="built_in">array</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)) <span class="keyword">as</span> (pos,val);</span><br><span class="line">pos val</span><br><span class="line">2C</span><br><span class="line">1B</span><br><span class="line">0A</span><br></pre></td></tr></table></figure><p><strong>json_tuple 获取 JSON 多个值拆开</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.timestamp, b.*</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">log</span> a <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(a.appevent, <span class="string">&#x27;eventid&#x27;</span>, <span class="string">&#x27;eventname&#x27;</span>) b <span class="keyword">as</span> f1, f2;</span><br></pre></td></tr></table></figure><p><strong>parse_url_tuple 获取 URL 中的多个信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.*</span><br><span class="line"><span class="keyword">FROM</span> src <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> parse_url_tuple(fullurl, <span class="string">&#x27;HOST&#x27;</span>, <span class="string">&#x27;PATH&#x27;</span>, <span class="string">&#x27;QUERY&#x27;</span>, <span class="string">&#x27;QUERY:id&#x27;</span>) b <span class="keyword">as</span> host, <span class="keyword">path</span>, <span class="keyword">query</span>, query_id </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>脱敏函数： 对姓名、电话号码进行脱敏，不显示全部内容</p><ul><li>mask(string str[, string upper[, string lower[, string number]]]):<ul><li>如 mask(“abcd-EFGH-8765-4321”, “U”, “l”, “#”) results in llll-UUUU-####-####.</li></ul></li><li>collect_list： 列出该字段的所有值，不去重</li><li>current_user()： 当前用户</li><li>md5(string/binary)</li><li>version()</li></ul><h2 id="窗口与分析函数"><a href="#窗口与分析函数" class="headerlink" title="窗口与分析函数"></a>窗口与分析函数</h2><blockquote><p>和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。数据窗口大小可能会随着行的变化而变化。</p></blockquote><p><strong>窗口函数</strong></p><ul><li>使用之前一般要通过 <code>over()</code> 进行开窗</li><li>针对每一行数据的，若 over 中没有参数，默认是全部的结果集</li></ul><p><strong>partition by 子句</strong></p><ul><li>在 over 窗口中进行分区，对某一列进行分区统计，窗口的大小就是分区的大小</li></ul><p><strong>order by 子句</strong></p><ul><li>对输入的数据进行排序，有 order by 缺少 window 子句，默认窗口为 <code>range between unbounded preceding and current row</code></li></ul><p><strong>over 子句</strong></p><ul><li>后面可指定标准的聚集函数， count, sum, min, max, avg</li><li>使用 PARTITION BY 语句，具有任何原始数据类型的一个或多个分区列</li><li>带有 PARTITION BY 和 ORDER BY 以及任何数据类型的一个或多个分区和/或排序列，<ul><li>带有窗口规格，Windows 可以在 WINDOW 子句中单独定义。</li></ul></li></ul><p><strong>Window 子句</strong></p><p>窗口规范支持以下格式：</p><ul><li>指定 order by 并缺少 window 子句时，window 默认被指定为 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li><li>当同时缺少 order by 和 window 子句时，默认窗口指定为 <code>ROW BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li><li>不支持 Rank 函数， rank、ntile、denseRank、cusmeDis、percentRank，不支持 Lead 和 Lag 函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ROWS | RANGE) BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)</span><br><span class="line">(ROWS | RANGE) BETWEEN CURRENT ROW AND (CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)</span><br><span class="line">(ROWS | RANGE) BETWEEN [num] FOLLOWING AND (UNBOUNDED | [num]) FOLLOWING</span><br></pre></td></tr></table></figure><h3 id="窗口范围"><a href="#窗口范围" class="headerlink" title="窗口范围"></a>窗口范围</h3><ul><li>unbounded preceding: 组内第一行数据</li><li>n preceding: 组内当前行的前n行数据</li><li>current row: 当前行数据</li><li>n following: 组内当前行的后 n 行数据</li><li>unbounded following: 组内最后一行数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工姓名、薪水、部门薪水总和、占部门薪水的百分比</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno) depsalsum,</span><br><span class="line">       <span class="keyword">round</span>(sal / <span class="keyword">sum</span>(sal) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno) * <span class="number">100</span>, <span class="number">2</span>) || <span class="string">&#x27;%&#x27;</span> salofdeptsumpercent</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 等价。组内，第一行 ~ 当前行的和</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 组内，第一行 ~ 最后一行的和</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 组内，按照分区前后两行和当前行的总和，前一行 + 当前行 + 后一行</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h3 id="排名函数"><a href="#排名函数" class="headerlink" title="排名函数"></a>排名函数</h3><ul><li><code>row_number()</code>: 排名顺序增加不会重复</li><li><code>RANK()</code>: 排名相等会在名次中留下空位；如 1、2、2、4、5、…</li><li><code>DENSE_RANK()</code>: 排名相等会在名次中不会留下空位 ；如1、2、2、3、4、…</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t2</span><br><span class="line">(</span><br><span class="line">    cname <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;课程名&#x27;</span>,</span><br><span class="line">    sname <span class="keyword">string</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学生名&#x27;</span>,</span><br><span class="line">    score <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;课程分数&#x27;</span></span><br><span class="line">) <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">-- 求每个班级前3名的学员 </span></span><br><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cname, </span><br><span class="line">           sname, </span><br><span class="line">           score, </span><br><span class="line">           <span class="keyword">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cname <span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">rank</span></span><br><span class="line">    <span class="keyword">FROM</span> t2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> cname, sname, score, <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> tmp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rank</span> &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h3><ul><li><code>lag</code>: 返回当前数据行的上一行数据 常用</li><li><code>lead</code>: 返回当前数据行的下一行数据 常用</li><li><code>first_value</code>: 取分组内排序后，截止到当前行，第一个值</li><li><code>last_value</code>: 分组内排序后，截止到当前行，最后一个值</li><li><code>ntile</code>: 将分组的数据按照顺序切分成n片，返回当前切片值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> userpv (</span><br><span class="line">    cid   <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    ctime <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;时间&#x27;</span>,</span><br><span class="line">    pv    <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;页面访问次数&#x27;</span></span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="comment">-- 上两行数据， 下三行数据</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       lag(pv, <span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime)  lagpv,</span><br><span class="line">       <span class="keyword">lead</span>(pv, <span class="number">3</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime) leadpv</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- first_value 分组排序截止到当前行第一个值 / last_value 分组排序后截止到当前行最后一个值</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       <span class="keyword">first_value</span>(pv) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) firstpv,</span><br><span class="line">       <span class="keyword">last_value</span>(pv) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) lastpv</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- ntile 按照cid进行分组并按照 ctime 排序，将分组内的数据平均分成 2 份</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       ntile(<span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime) ntile</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- LAG specifying a lag of 3 rows and default value of 0</span></span><br><span class="line"><span class="keyword">SELECT</span> a, </span><br><span class="line">       LAG(a, <span class="number">3</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> b <span class="keyword">ORDER</span> <span class="keyword">BY</span> C)</span><br><span class="line"><span class="keyword">FROM</span> T;</span><br></pre></td></tr></table></figure><h2 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h2><p><strong>临时性添加函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- hive add jar</span></span><br><span class="line">add jar /home/hadoop/udf.jar</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">function</span> myconcat <span class="keyword">as</span> <span class="string">&#x27;con.janhen.hive.udaf.ConcatUDAF&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> FUNCTIONS;</span><br></pre></td></tr></table></figure><p><strong>永久添加到 Hive 中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jar ==&gt; hdfs </span></span><br><span class="line">hdfs dfs -put hiveudf.jar /user/hadoop/jar/</span><br><span class="line">-- 加载函数</span><br><span class="line">create <span class="keyword">function</span> mynvl2 as <span class="string">&#x27;com.janhen.bigdata.hive.nvl&#x27;</span></span><br><span class="line">    using jar <span class="string">&#x27;hdfs:/user/hadoop/jar/hiveudf.jar&#x27;</span>;</span><br><span class="line">show <span class="built_in">functions</span>;</span><br><span class="line">drop <span class="keyword">function</span> mynvl2;</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-Built-inFunctions">Built-in Functions</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics">Windowing and Analytics Functions</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标准函数： 一列或多列作为参数传入，返回值是一个值的函数&lt;/p&gt;
&lt;p&gt;如 to_date(string timestamp), sqrt(double a)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;聚合函数： 接收0行、多行的列，返回单</summary>
      
    
    
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive-HQL</title>
    <link href="http://example.com/2021/03/09/Hive-HQL/"/>
    <id>http://example.com/2021/03/09/Hive-HQL/</id>
    <published>2021-03-09T13:28:56.000Z</published>
    <updated>2021-04-21T08:49:21.854Z</updated>
    
    <content type="html"><![CDATA[<p>HQL 的特点：</p><ul><li><p>并不是所有的 HQL 都会被 Hive 转换成 MR 作业执行，对于简单不需要聚合的操作，如 <code>SELECT .. FROM xx LIMIT n</code>，直接通过 FetchTask 获取数据</p></li><li><p>HQL 是一种 SQL 方案，支持绝大部分的 SQL-92 标准</p></li></ul><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p><strong>从本地或 HDFS 中装载数据</strong></p><ul><li>LOCAL：<ul><li>LOAD DATA LOCAL …：从本地文件系统加载数据到 Hive 表中</li><li>LOAD DATA …：从HDFS加载数据到 Hive 表中</li></ul></li><li>INPATH：加载数据的路径</li><li>OVERWRITE：覆盖表中已有数据，否则表示追加数据，用于幂等</li><li>PARTITION：将数据加载到指定的分区</li></ul><p>一旦该表存在分区，那么在数据在加载时必须加载进入指定分区中，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加载数据并指定分区，HDFS 文件，已经被转移</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;/user/hadoop/data&#x27;</span> <span class="keyword">INTO</span> student_info </span><br><span class="line"><span class="keyword">PARTITION</span>(province=<span class="string">&#x27;sichuan&#x27;</span>, city=<span class="string">&#x27;chengdu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载数据覆盖表中已有数据</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;data/sourceA.txt&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tabA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载数据，覆盖表的数据，到指定的分区</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;/user/hadoop/o&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test3 </span><br><span class="line"><span class="keyword">PARTITION</span> (part = <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加分区并指定存储位置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (x = x1, y = y2) </span><br><span class="line"><span class="keyword">SET</span> LOCATION <span class="string">&#x27;/user/test/x1/y1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> tabC <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">&#x27;202001&#x27;</span>) <span class="keyword">values</span> (<span class="number">5</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;BJ&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;lishi&#x27;</span>, <span class="string">&#x27;SH&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;TJ&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入查询的结果数据到指定分区中 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> tabC <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">&#x27;202002&#x27;</span>) <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, area <span class="keyword">from</span> tabC <span class="keyword">where</span> <span class="keyword">month</span>=<span class="string">&#x27;202001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>创建表并插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> tabD <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> tabC;</span><br></pre></td></tr></table></figure><p><strong>多表（多分区）插入模式</strong></p><p>一次查询，产生多个不相交的输出</p><p>可以通过一次查询，产生多个不相交的输出。</p><p>这样只通过对 source 表的一次查询，就将符合条件的数据插入 test 表的各个分区，非常方便</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个查询差生多个不相交的输出</span></span><br><span class="line">FROM source</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">0</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">100</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">200</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">300</span></span><br></pre></td></tr></table></figure><p><strong>import 导入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import table student2 partition(month=&#x27;201709&#x27;) from &#x27;/user/hive/warehouse/export/student&#x27;;</span><br></pre></td></tr></table></figure><h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><ul><li>将结果导出到本地</li><li>将查询结果格式化到本地</li><li>将结果导出到 HDFS</li><li>通过 DataX、Sqoop 等工具将结果导出到 HBase、MySQL 等其他地方</li></ul><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">change</span> <span class="keyword">column</span> <span class="keyword">id</span> cid <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">add</span> <span class="keyword">columns</span> (common <span class="keyword">string</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除字段：replace columns</span></span><br><span class="line"><span class="comment">-- 在元数据中删除了字段，并没有改动hdfs上的数据文件</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">replace</span> <span class="keyword">columns</span>( <span class="keyword">id</span> <span class="keyword">string</span>, cname <span class="keyword">string</span>, score <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改序列化的编码格式</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> person <span class="keyword">SET</span> SERDEPROPERTIES (<span class="string">&#x27;serialization.encoding&#x27;</span>=<span class="string">&#x27;GBK&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改序列化反序列化的属性分割</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test.tmp1 <span class="keyword">set</span> serdeproperties(<span class="string">&#x27;field.delim&#x27;</span>=<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改编码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> COLUMNS_V2 <span class="keyword">modify</span> <span class="keyword">column</span> <span class="keyword">COMMENT</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> TABLE_PARAMS <span class="keyword">modify</span> <span class="keyword">column</span> PARAM_VALUE <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建了分区的话就要再执行两条命令</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> PARTITION_PARAMS <span class="keyword">modify</span> <span class="keyword">column</span> PARAM_VALUE <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> PARTITION_KEYS <span class="keyword">modify</span> <span class="keyword">column</span> PKEY_COMMENT <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="DB-与-Table"><a href="#DB-与-Table" class="headerlink" title="DB 与 Table"></a>DB 与 Table</h3><p><img src="http://img.janhen.com/202103030859484G2IXM.png" alt="http://img.janhen.com/202103030859484G2IXM.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看默认 hive 存放目录下的数据目录</span></span><br><span class="line">dfs -ls /user/hive/warehouse;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库并指定存放位置</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exit</span> <span class="keyword">comment</span> <span class="string">&#x27;test comment&#x27;</span> </span><br><span class="line">location <span class="string">&#x27;/usr/hive/mydb2.dbe&#x27;</span>;</span><br><span class="line"></span><br><span class="line">desc database extended mydb2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连同表一起删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">test</span> <span class="keyword">CASCADE</span>;</span><br><span class="line">DESC EXTENDED student;</span><br><span class="line">DESC FORMATTED student;</span><br><span class="line"><span class="comment">-- 根据其他表创建新的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test.student2 <span class="keyword">LIKE</span> test.student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表的情况查看，文件的大小，文件个数，是否分区,lastAccessTime,lastUpdateTime</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">extended</span> <span class="keyword">like</span> <span class="string">&#x27;dwd_start_log&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看指定分区的情况</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">extended</span> <span class="keyword">like</span> <span class="string">&#x27;dwd_start_log&#x27;</span> parititon(dt=<span class="string">&#x27;2020-07-22&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line">desc formatted dwd_start_log;</span><br><span class="line">desc formatted dwd_start_log partition (dt=&#x27;2020-07-22&#x27;);</span><br></pre></td></tr></table></figure><p><strong>Table</strong></p><p>建表的方式： 直接建表、查询建表、LIKE 建表</p><p>建表的语法：</p><ul><li>CREATE TABLE [IF NOT EXISTS]：创建表</li><li>EXTERNAL： 外部表创建，生产中一般创建的都是外部表，删除表不删除数据</li><li>comment： 表注释</li><li>partition by： 对表中数据进行分区</li><li>clustered by： 建立分桶表</li><li>sorted by： 对表中的一个或多个字段进行排序，较少使用</li><li>存储子句:  可指定 SerDe, 默认没有使用 ROW FORMAT 或者 ROW FORMAT DELIMITED，会默认使用 SerDe。建表时需要为表指定列在指定列的同时也会指定自定义的 SerDe。<strong>hive使用 Serde 进行行对象的序列与反序列化。</strong></li><li>stored as SEQUENCEFILE|TEXTFILE|RCFILE</li><li>LOCATION： 表在 HDFS 上的位置</li><li>TBLPROPERTIES：定义表的属性</li><li>AS： 接查询语句，根据查询结果建表</li><li>LIKE： 复制现有的表结构，不会复制数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] </span><br><span class="line">[COLLECTION ITEMS TERMINATED BY char] </span><br><span class="line">[MAP KEYS TERMINATED BY char] </span><br><span class="line">[LINES TERMINATED BY char] | </span><br><span class="line">SERDE serde_name </span><br><span class="line">[<span class="keyword">WITH</span> SERDEPROPERTIES (property_name=property_value, </span><br><span class="line">  property_name=property_value, ...)]</span><br></pre></td></tr></table></figure><p><strong>使用 JSONSerDe 进行建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;: 1,&quot;ids&quot;: [101,102,103],&quot;total_number&quot;: 3&#125;</span><br><span class="line">&#123;&quot;id&quot;: 2,&quot;ids&quot;: [201,202,203,204],&quot;total_number&quot;: 4&#125;</span><br><span class="line">&#123;&quot;id&quot;: 3,&quot;ids&quot;: [301,302,303,304,305],&quot;total_number&quot;: 5&#125;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> jsont2 (</span><br><span class="line">    <span class="keyword">id</span>           <span class="built_in">int</span>,</span><br><span class="line">    ids          <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">    total_number <span class="built_in">int</span></span><br><span class="line">) <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE <span class="string">&#x27;org.apache.hive.hcatalog.data.JsonSerDe&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="内外部表"><a href="#内外部表" class="headerlink" title="内外部表"></a>内外部表</h3><p>表的类型有两种，分别是内部表、外部表</p><ul><li>默认情况下，创建内部表</li><li>删除内部表，表的元数据和数据一起删除</li><li>删除外部表，删除表的定义，数据保留</li><li>生产环境中，多使用外部表</li><li>外部表不能执行 <code>TRUNCATE</code></li></ul><p>表类型转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内部表转外部表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">SET</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;TRUE&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外部表转内部表。EXTERNAL 大写，false 不区分大小</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;FALSE&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><blockquote><p>按照分区字段将表中的数据放置在不同的目录中，提高SQL查询的性能</p></blockquote><p>Hive 没有索引，分区的作用和索引非常类似，可将其看做一种简易索引。对于直接命中分区的查询，Hive 不会执行 MapReduce 作业。</p><p><strong>分区字段不是表中已经存在的数据，可以将分区字段看成伪列。</strong></p><p>多分区表，在表的目录下有多少分区就有多少级子目录。</p><p><strong>分区查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看分区</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> student_info;</span><br><span class="line"><span class="comment">-- partition count</span></span><br><span class="line">hive <span class="comment">--silent -e &quot;show partitions &lt;dbName&gt;.&lt;tableName&gt;;&quot; | wc -l</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> &lt;<span class="keyword">partition</span> <span class="keyword">key</span>&gt;) <span class="keyword">from</span> &lt;TableName&gt;;</span><br></pre></td></tr></table></figure><p><strong>新增分区，加载数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加分区，不加载数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加多个分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-05&#x27;</span>) <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-06&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加分区，加载数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-07&#x27;</span>) location <span class="string">&#x27;/user/hive/warehouse/mydb.db/t3/dt=2020-06-07&#x27;</span> </span><br><span class="line"><span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-08&#x27;</span>) location <span class="string">&#x27;/user/hive/warehouse/mydb.db/t3/dt=2020-06-08&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单独为外部表的分区键指定值和存储位置：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student _info <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (province = sichuan, city = chengdu) LOCATION <span class="string">&#x27;hdfs://master:9000/student/sichuan/chengdu&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>修改分区的hdfs路径</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-01&#x27;</span>) </span><br><span class="line"><span class="keyword">set</span> location <span class="string">&#x27;/user/hive/warehouse/t3/dt=2020-06-03&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>删除分区</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">drop</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-03&#x27;</span>), <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-04&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>动态分区</strong></p><p>Hive 会根据 SELECT 语句中的最后一个查询字段作为动态分区的依据，而不是根据字段名来选择。如果指定了 n 个动态分区的字段，Hive 会将 select 语句中最后 n 个字段作为动态分区的依据。 Hive 默认没有开启动态分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启自动分区</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span>(<span class="built_in">time</span>) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, modify_time <span class="keyword">FROM</span> <span class="keyword">source</span>;</span><br></pre></td></tr></table></figure><h3 id="分桶表"><a href="#分桶表" class="headerlink" title="分桶表"></a>分桶表</h3><blockquote><p>分区不能更细粒度的划分数据，就需要使用分桶技术将数据划分成更细的粒度。</p></blockquote><p>使用 <code>cluster by &lt;col-name&gt; into &lt;num&gt; buckets</code> 建表的时候指定。</p><p>分桶的原理</p><ul><li>MR 中： key.hashCode % reduceTask</li><li>Hive 中： 分桶字段.hashCode % 分桶个数</li></ul><p><strong>分桶表创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course( </span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>, </span><br><span class="line">  <span class="keyword">name</span> <span class="keyword">string</span>, </span><br><span class="line">  score <span class="built_in">int</span> ) </span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) <span class="keyword">into</span> <span class="number">3</span> buckets </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;\\t&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>分桶表加载数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通表加载数据 </span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/data/course.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> course_common;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 insert ... select ... 给桶表加载数据 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> course <span class="keyword">select</span> * <span class="keyword">from</span> course_common;</span><br></pre></td></tr></table></figure><p><strong>分区表和分桶表的区别</strong></p><p>存储格式： 分区表和分桶表的存储格式不同，分区表在多个分区时会有多级目录，分桶表按照字段散列分布。</p><p>作用： 分区表细化数据管理，缩小 MR 扫描的数据量；分桶表提高 join 查询效率，在一份数据被经常用作连接 hash 的时候建立分桶，分桶字段为连接字段，提高采样的效率。</p><p>数据粒度划分： 分桶表相对分区进行更细粒度的划分。</p><p>依据的列： 分桶表指定的分桶依据不是伪列，而是数据表中真实存在的列。</p><p><strong>大表 JOIN 分桶的原因</strong></p><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p><strong>正则匹配过滤</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正则匹配，使用 rlike。正则表达式，名字以A或S开头</span></span><br><span class="line"><span class="keyword">select</span> ename, </span><br><span class="line">   salfrom emp</span><br><span class="line"><span class="keyword">where</span> ename <span class="keyword">rlike</span> <span class="string">&#x27;^(A|S).*&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="lateral-view"><a href="#lateral-view" class="headerlink" title="lateral view"></a>lateral view</h3><blockquote><p>lateral view 首先将表生成函数 <a href="https://www.notion.so/Hive-07129ed27e8845c2b7ec7af785eea19f">UDTF</a> 应用于基础表的每一行，然后将结果输出行与输入行连接起来以形成具有提供的表别名的虚拟表。</p></blockquote><p>语法</p><ul><li>从 0.12.0 开始列别名可省略，从 UTDF 返回的 StructObjectInspector 的字段名称继承</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateralView: LATERAL VIEW udtf(expression) tableAlias AS columnAlias (&#x27;,&#x27; columnAlias)*</span><br><span class="line">fromClause: FROM baseTable (lateralView)*</span><br></pre></td></tr></table></figure><p><strong>使用案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> pageAds(</span><br><span class="line">  pageid <span class="keyword">string</span>,</span><br><span class="line">  adid_list <span class="built_in">Array</span>&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">);</span><br><span class="line">pageid      adid_list</span><br><span class="line">front_page   [1,2,3]</span><br><span class="line">contact_page [3,4,5]</span><br><span class="line"><span class="comment">-- 页面对应的广告</span></span><br><span class="line"><span class="keyword">SELECT</span> pageid, adid</span><br><span class="line"><span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br><span class="line"><span class="comment">-- 查看特定广告的展示次数</span></span><br><span class="line"><span class="keyword">SELECT</span> adid, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> adcnt</span><br><span class="line"><span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br><span class="line">pageid(string)    adid(int)</span><br><span class="line">&quot;front_page&quot;      1</span><br><span class="line">&quot;front_page&quot;      2</span><br><span class="line">&quot;front_page&quot;      3</span><br><span class="line">&quot;contact_page&quot;    3</span><br><span class="line">&quot;contact_page&quot;    4</span><br><span class="line">&quot;contact_page&quot;    5</span><br><span class="line"></span><br><span class="line">adid    adcnt</span><br><span class="line">1          1</span><br><span class="line">2          1</span><br><span class="line">3          2</span><br><span class="line">4          1</span><br><span class="line">5          1</span><br></pre></td></tr></table></figure><p><strong>多个 lateral view</strong></p><ul><li>from clause 可有多个 lateral view</li><li>后续的 LATERAL VIEWS 可以引用 LATERAL VIEW 左侧出现的任何表中的列。</li></ul><p>原始数据 ⇒ 建表语句 ⇒ 多个 lateral view 使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use1;18;male;&#123;&quot;id&quot;: 1,&quot;ids&quot;: [101,102,103],&quot;total_number&quot;: 3&#125;</span><br><span class="line">use2;20;female;&#123;&quot;id&quot;: 2,&quot;ids&quot;: [201,202,203,204],&quot;total_number&quot;: 4&#125; </span><br><span class="line">use3;23;male;&#123;&quot;id&quot;: 3,&quot;ids&quot;: [301,302,303,304,305],&quot;total_number&quot;: 5&#125;</span><br><span class="line">CREATE TABLE IF NOT EXISTS jsont1  (</span><br><span class="line">    username string,</span><br><span class="line">    age      int,</span><br><span class="line">    sex      string,</span><br><span class="line">    json     string</span><br><span class="line">) row format delimited fields terminated by &#39;;&#39;;</span><br><span class="line">-- 解析json串中的数组，并展开</span><br><span class="line">select username,</span><br><span class="line">       age,</span><br><span class="line">       sex,</span><br><span class="line">       ids1,</span><br><span class="line">       id,</span><br><span class="line">       num</span><br><span class="line">from jsont1 lateral view explode(janhen_json_array(json, &quot;ids&quot;)) t1 as ids1</span><br><span class="line">    lateral view json_tuple(json, &#39;id&#39;, &#39;total_number&#39;) t1 as id, num;</span><br></pre></td></tr></table></figure><h3 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br><span class="line"><span class="comment">-- 左外连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">left</span> <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br><span class="line"><span class="comment">-- 全外连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">full</span> <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br></pre></td></tr></table></figure><p><strong>多表连接</strong></p><p>Hive 总是按照从左到右的顺序执行，Hive 会对每对 JOIN 连接对象启动一个 MapReduce 任务。</p><p>会首先启动一个 MapReduce job 对表 t 和表 c 进行连接操作；然后再 启动一个 MapReduce job 将第一个 MapReduce job 的输出和表 s 进行连接操作； 然后再继续直到全部操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> techer t </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> score s <span class="keyword">on</span> s.c_id = c.c_id </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> student stu <span class="keyword">on</span> s.s_id = stu.s_id;</span><br></pre></td></tr></table></figure><p><strong>笛卡尔积</strong></p><p>满足下列条件</p><ul><li>没有连接条件</li><li>连接条件无效</li><li>所有表中的所有行互相连接</li></ul><p>Hive 默认不支持笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.strict.checks.cartesian.product=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1, u2;</span><br></pre></td></tr></table></figure><h3 id="union-子句"><a href="#union-子句" class="headerlink" title="union 子句"></a>union 子句</h3><p>union all 不会对合并的数据进行去重， union 会进行去重</p><p>可以使用 union all + group by 进行数据去重</p><p>使用 union all 要保证两个子查询得到的字段名称一致</p><h3 id="排序子句"><a href="#排序子句" class="headerlink" title="排序子句"></a>排序子句</h3><p><strong>MR 全局排序</strong></p><ul><li>排序字段需要出现在 select 字段中</li><li>ORDER BY 执行全局排序，只有一个 reduce</li><li>输出规模较大时，耗时高</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多列排序 </span></span><br><span class="line"><span class="keyword">select</span> empno, </span><br><span class="line">       ename, </span><br><span class="line">       job, mgr, </span><br><span class="line"> sal + nvl(comm, <span class="number">0</span>) salcomm, </span><br><span class="line">   deptno </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> deptno, salcomm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>MR 的内部排序(sort by)</strong></p><p>sort by 为每个 reduce 产生排序文件，在 reduce 内部进行排序，得到局部有序的结果，保证每个 reducer 的结果有序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置reduce个数</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 按照工资降序查看员工信息 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">sort</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 将查询结果导入到文件中（按照工资降序）。生成两个输出文件，每个文件内部数据按 工资降序排列 </span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/home/hadoop/output/sortsal&#x27;</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">sort</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>MR 分区排序(distribute by)</strong></p><ul><li>将特定的行发送到特定的 reducer 中</li><li>distribute by 要写在 sort by 之前</li><li>可结合 sort by 操作，使分区数据有序</li><li>类似于 MR 中的分区操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先按 deptno 分区，在分区内按照 sal + comm 排序</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  empno,       </span><br><span class="line">  ename,       </span><br><span class="line">  job,       </span><br><span class="line">  deptno,       </span><br><span class="line">  sal + nvl(comm, <span class="number">0</span>) salcomm</span><br><span class="line"><span class="keyword">FROM</span> emp    </span><br><span class="line"><span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> deptno    </span><br><span class="line"><span class="keyword">SORT</span> <span class="keyword">BY</span> sal comm <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 将数据分到 3 个区中，每个分区都有数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/home/hadoop/output/distBy1&#x27;</span> </span><br><span class="line"><span class="keyword">select</span> empno, </span><br><span class="line"> ename, </span><br><span class="line"> job, </span><br><span class="line"> deptno, </span><br><span class="line"> sal + nvl(comm, <span class="number">0</span>) salcomm </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">distribute</span> <span class="keyword">by</span> deptno </span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> salcomm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>Cluster By</strong></p><ul><li>distribute by 与 sort by 为同一个字段时，使用 cluster by 简化语法</li><li>只能是升序，不能指定排序规则</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+LateralView">LanguageManual LateralView</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins">LanguageManual Joins</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HQL 的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并不是所有的 HQL 都会被 Hive 转换成 MR 作业执行，对于简单不需要聚合的操作，如 &lt;code&gt;SELECT .. FROM xx LIMIT n&lt;/code&gt;，直接通过 FetchTask 获取数据&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Vagrent</title>
    <link href="http://example.com/2021/03/09/Vagrent/"/>
    <id>http://example.com/2021/03/09/Vagrent/</id>
    <published>2021-03-09T13:17:56.000Z</published>
    <updated>2021-03-09T13:22:08.136Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC] </p><h1 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h1><blockquote><p>快速搭建虚拟机环境，可通过 Vagrantfile 配置文件进行定制，类似 Docker 管理容器。</p></blockquote><p>一些特性：</p><ul><li>多种虚拟器支持，如 VirsualBox(默认)、 Vmware、Docker、Hyper-V</li><li>方便网络配置，支持端口转发，配置私有、公有网络</li><li>方便进行宿主机与虚拟机之间共享文件提供丰富的插件，简化日常使用</li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>Virtual Box</strong></p><p>Oracle 开源的虚拟机软件，跨平台</p><p>在 winows 上无法同时运行 Hyper-V 和 VisualBox，两者都是基于 CPU 等底层硬件的 Hypervisor 机制来实现的，而他们必须独占管理 Hypervisor。通过开启启动项选择是否加载 Hyper-V 服务，实现伪同时运行。</p><p>问题由来： Docker 安装在 win10 上需要开启 Hyper-V，方便进行本地镜像的打包部署，同时需要 VirtualBox 进行模拟集群。</p><p>问题处理：</p><p><a href="https://blog.csdn.net/enweitech/article/details/52180373">解决Win7/8/10系统中的Hyper-V和VMware虚拟机软件共存问题</a></p><p><a href="https://stackoverflow.com/questions/31642333/virtualbox-callee-rc-regdb-e-classnotreg-0x80040154">Virtualbox “Callee RC: REGDB_E_CLASSNOTREG” (0x80040154)?</a></p><p><strong>Hyper-V</strong></p><p>Win10 自带虚拟化工具，实现在 Win10 上运行 Docker 环境，而无需开启 Docker 的远程访问，开启后无法使用其他虚拟器</p><p>对应的 vagrant 设置内存和CPU参数参考文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boxes &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        :name &#x3D;&gt; &quot;docker-kubernetes&quot;,</span><br><span class="line">        :eth1 &#x3D;&gt; &quot;192.168.205.12&quot;,</span><br><span class="line">        :mem &#x3D;&gt; &quot;2048&quot;,</span><br><span class="line">        :cpu &#x3D;&gt; &quot;2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">  config.vm.provider &quot;hyperv&quot; do |v|</span><br><span class="line">    v.ip_address_timeout&#x3D;121</span><br><span class="line">    v.memory&#x3D;opts[:mem]</span><br><span class="line">    v.cpus&#x3D;opts[:cpu]</span><br><span class="line">  end</span><br><span class="line">bcdedit &#x2F;set hypervisorlaunchtype off</span><br><span class="line">bcdedit &#x2F; set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><p><strong>XShell</strong></p><p>SSH 命令工具</p><p>一些特性</p><ul><li>标签化页面管理，方便管理打开的连接</li><li>支持连接目录管理，方便进行多种环境管理</li><li>支持分屏，方便对集群中的主从进行区分</li><li>支持透明图，无需切换窗口查看遗忘的命令</li><li>侧栏显示连接信息，方便集群中配置 IP 地址</li></ul><p><strong>Vagrant 管理</strong></p><p>通过 Vagrantfile 文件设置好一些数值进行控制虚拟机，通过命令管理虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 全局管理</span><br><span class="line">vagrant global-status</span><br><span class="line">vagrant global-status --prune</span><br><span class="line">vagrant destroy &lt;vm_id&gt;</span><br><span class="line">vagrant halt &lt;vm_id&gt; &lt;vm_id2&gt;</span><br><span class="line">vagrant reload &lt;vm_id1&gt; &lt;vm_id2&gt;..</span><br><span class="line">vagrant up &lt;vm_id1&gt; &lt;vm_id2&gt;..</span><br></pre></td></tr></table></figure><p><strong>安装虚拟机环境</strong></p><p>快速安装环境，支持从远程获取对应的 Vagrantfile，之后拉取远程镜像；支持导入本地的 box 作为镜像；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vagrant 命令</span><br><span class="line"># 初始化一个安装 centos&#x2F;7 虚拟机的 Vagrantfile</span><br><span class="line"># 根据目录下的 Vagrantfile 进行启动</span><br><span class="line"># 删除虚拟机</span><br><span class="line"># 查案虚拟机运行状态</span><br><span class="line">vagrant init centos&#x2F;7</span><br><span class="line">vagrant up</span><br><span class="line">vagrant status</span><br></pre></td></tr></table></figure><p><strong>多种虚拟机支持</strong></p><p>支持多种虚拟机，对应的配置memory、Cpu 方式不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 vmware 虚拟机</span><br><span class="line"># 使用 hyper-v，需要管理员权限运行 vagrant，通过 Cmder 默认使用 admin 启动的 powershell 处理</span><br><span class="line">vagrant up --provider&#x3D;vmware_fusion</span><br><span class="line">vagrant up --provider&#x3D;hyperv</span><br></pre></td></tr></table></figure><h2 id="Vagrant-插件"><a href="#Vagrant-插件" class="headerlink" title="Vagrant 插件"></a>Vagrant 插件</h2><p><strong>vagrant-hostmanager</strong></p><p>实现多台虚拟机之间直接通过名称访问，原理为更改 host 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 安装并验证插件</span><br><span class="line">vagrant plugin install vagrant-hostmanager</span><br><span class="line">vagrant plugin list</span><br><span class="line"># 在 Vagrantfile 中修改</span><br><span class="line">config.hostmanager.enabled &#x3D; true</span><br><span class="line">config.hostmanager.manage_guest &#x3D; true</span><br><span class="line">config.hostmanager.manage_host &#x3D; true</span><br><span class="line"># 执行命令，更新虚拟机上的hosts，同时更新主机上的 hosts</span><br><span class="line">vagrant hostmanager</span><br></pre></td></tr></table></figure><p><strong>vagrant-vbguest</strong></p><p>处理 VisualBox 中无法设置共享目录问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant vbguest --status</span><br><span class="line">vagrant vbguest --do install node1</span><br><span class="line"># 配置 vagrantfile</span><br><span class="line">config.vbguest.auto_update&#x3D;false</span><br></pre></td></tr></table></figure><p><strong>vagrant-bindfs</strong></p><p>非使用 visualBox 自带的共享目录，自定义使用文件系统 nfs，性能更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-bindfs</span><br><span class="line"># 。。。</span><br><span class="line">node1. vm. synced_folder &quot;.&#x2F;app&quot;,&quot;&#x2F;mnt&#x2F;app-data&quot;, type:&quot;nfs</span><br><span class="line">node1. bindfs. bind_folder &quot;&#x2F;mnt&#x2F;app-data&quot;,&quot;&#x2F;app&quot;, force_user:&quot;root&quot;, force_group:&quot;root&quot;,o:&quot;nonempty&quot;</span><br><span class="line"># 代理设置插件</span><br><span class="line"># 在Vagrantfile中的config部分添加代理配置, 全部网络都走主机代理</span><br><span class="line">vagrant plugin install vagrant-proxyconf</span><br><span class="line">vim Vagrantfile</span><br><span class="line">  Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">    if Vagrant.has_plugin?(&quot;vagrant-proxyconf&quot;)</span><br><span class="line">      config.proxy.http     &#x3D; &quot;&lt;http:&#x2F;&#x2F;192.168.0.2:3128&#x2F;&gt;&quot;</span><br><span class="line">      config.proxy.https    &#x3D; &quot;&lt;http:&#x2F;&#x2F;192.168.0.2:3128&#x2F;&gt;&quot;</span><br><span class="line">      config.proxy.no_proxy &#x3D; &quot;localhost,127.0.0.1,.example.com&quot;</span><br><span class="line">    end</span><br><span class="line">    # ... other stuff</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line"># 复用虚拟机环境插件安装</span><br><span class="line">vagrant plugin list</span><br><span class="line">vagrant plugin install vagrant-scp</span><br><span class="line">vagrant scp</span><br><span class="line"></span><br><span class="line"># 处理虚拟机安装进行目录文件映射权限问题</span><br><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant plugin list</span><br></pre></td></tr></table></figure><h2 id="Vagrantfile"><a href="#Vagrantfile" class="headerlink" title="Vagrantfile"></a>Vagrantfile</h2><blockquote><p>构建虚拟机的硬件情况，实现控制 CPU、内存、Ip 等资源，同时支持虚拟机启动后执行初始化脚本，实现一些必要工具的安装，如 Docker。</p></blockquote><p>通过配置可实现：</p><ul><li>进行虚拟机目录与本地目录映射</li><li>选择网络</li><li>安装成功后执行特定脚本，直接安装要必要的工具以及 Docker 环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># config.vm.box 配置使用哪个box</span><br><span class="line">config.vm.box &#x3D; &quot;ubuntu16.04_louis&quot;# box ∈ vagrant box list</span><br><span class="line">config.vm.hostname               # 机器应该有的主机名</span><br><span class="line">aa.vm.hostname &#x3D; &quot;aa.test.com&quot;</span><br><span class="line">config.vm.network                # 在机器上配置网络</span><br><span class="line">config.vm.network&quot;forwarded_port&quot;,guest:80,host:8080</span><br><span class="line">aa.vm.network &quot;private_network&quot;, ip: &quot;192.168.55.100&quot;</span><br><span class="line">config.vm.provider               # 配置提供程序特定的配置，用于修改特定于某个 提供程序的设置</span><br><span class="line">config.vm.provision              # 配置置备 在机器上，使软件可以自动安装并创建机器时配置</span><br><span class="line">config.vm.synced_folder          # 配置 机器上的同步文件夹</span><br></pre></td></tr></table></figure><p>配置实例：</p><ul><li>参数注入</li><li>脚本执行，进行必要软件(vim,git…)、必要环境(如pip,java,docker) 的安装</li><li>资源配置，可 CPU、内存…. 等硬件资源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boxes &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        :name &#x3D;&gt; &quot;docker-host&quot;,</span><br><span class="line">        :eth1 &#x3D;&gt; &quot;192.168.205.10&quot;,</span><br><span class="line">        :mem &#x3D;&gt; &quot;1024&quot;,</span><br><span class="line">        :cpu &#x3D;&gt; &quot;1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">boxes.each do |opts|</span><br><span class="line">    config.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">      v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]]</span><br><span class="line">      v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]]</span><br><span class="line">    end</span><br><span class="line">    config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line">    # 从主机特定文件读入脚本执行</span><br><span class="line">    config.vm.provision &quot;shell&quot;, privileged: true, path: &quot;.&#x2F;setup.sh&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>根据需要设置虚拟机网络 IP 地址固定，实现虚拟机中的软件根据名称访问，设置虚拟机可以访问外部的网络。</p><p><strong>端口转发</strong></p><p>将宿主机的端口与虚拟机的端口绑定，从而让外部通过端口可以访问虚拟机</p><p>若 guest_ip 和 host_ip 两项配置为空，则局域网下的所有设备都可以访问该虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(2&quot;) do |config|</span><br><span class="line">config.vm.network</span><br><span class="line">&quot;forwarded_port&quot;(必选) &#x2F;&#x2F;端口转发标示</span><br><span class="line">,guest(必选):       # 虚拟端口</span><br><span class="line">,host(必选):        # 宿主机端口，值必须大于1024</span><br><span class="line">,gust_ip(可选):     # 虚拟机端口绑定虚拟机ip地址</span><br><span class="line">,host_ip(可选):     # 虚拟机端口绑定宿主机端口ip</span><br><span class="line">,protocol(可选):    # 指定通信协议，可以使用tcp&#x2F;udp,默认tcp</span><br><span class="line">,auto_correct(可选): # ture&#x2F;fasle,开机是否自动检测端口冲突</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 实际配置</span><br><span class="line"># 配置2个端口映射，把物理机的8080映射到虚拟机80，物理机的2100映射到虚拟机的22</span><br><span class="line"># host_ip 在主机 IP 较为固定情况下配置使用</span><br><span class="line">config.vm.network :&quot;forwarded_port&quot;, guest: 80, host: 8060,host_ip: &quot;10.2.11.203&quot;</span><br><span class="line">config.vm.network :&quot;forwarded_port&quot;, guest: 22, host: 2100, host_ip: &quot;10.2.11.203&quot;</span><br></pre></td></tr></table></figure><p><strong>私有网络</strong></p><p>虚拟机之间处在同一网段的地址可相互访问，主机可以访问虚拟机，无法通过虚拟机进行团队合作，不与宿主机的 IP 在同一个网段，防止冲突</p><p>配置 vagrant 里面的虚拟机的私有网段的时候，切记不能和企业（公司）内部的 DHCP 分配的 IP 地址在同一网段，否则会发生冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置 Static IP</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.10&quot;</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.55.20&quot;</span><br><span class="line"># 配置通过 DHCP 进行获取 IP，之后执行 &#96;vagrant reload&#96;</span><br><span class="line">config.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;</span><br><span class="line"></span><br><span class="line"># 实际使用</span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.10&quot;,</span><br><span class="line">auto_config: false</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>公有网络</strong></p><p>与宿主机一样的网络配置， vagrant1.3+ 支持设置固定 IP，虚拟机 IP 与主机 IP 处在同一个网段时，实现局域网之间的互通，需要有路由器分配 IP.一般来说开发和测试使用较为封闭的网络模型是比较好的方式，通常不建议 vm 配置有 public_network 的网卡关联</p><p>配置虚拟机自动获取公司内部DHCP服务器分配的IP地址，在局域网任何一台电脑上，都可以ssh到虚拟机，或访问虚拟机上提供的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;192.168.1.120&quot;</span><br><span class="line"></span><br><span class="line"># 配置动态 IP</span><br><span class="line"># 配置共有网络，使用主机上可以访问外网的接口(ipconfig)</span><br><span class="line"># 配置默认网关</span><br><span class="line">config.vm.network &quot;public_network&quot;,bridge: &quot;ens33&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;route add default gw 10.2.11.1&quot;</span><br><span class="line"></span><br><span class="line"># 配置静态 IP</span><br><span class="line"># auto_config：关闭自动配置</span><br><span class="line"># ifconfig enp0s8 10.2.11.196 netmask 255.255.255.0 up: 配置静态ip（这里的ip不能和公司内部的地址冲突）</span><br><span class="line"># route add default gw 10.2.11.1 指定网关（添加默认路由）</span><br><span class="line"># bridge： 绑定接口（物理机哪个接口可以上网）</span><br><span class="line">config.vm.network &quot;public_network&quot;, auto_config: false ,bridge: &quot;ens33&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;ifconfig eth1 10.2.11.196 netmask 255.255.0.0 up&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;alway&quot;,inline: &quot;route add default gw 10.2.11.1&quot;</span><br><span class="line">config.vm.network &quot;public_network&quot;, auto_config: false </span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;ip addr add 172.17.10.51&#x2F;21 dev eth1&quot; </span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;alway&quot;,inline: &quot;ip route add 172.17.8.0&#x2F;21 via 172.17.0.49&quot;</span><br></pre></td></tr></table></figure><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>配置宿主机中的数据与虚拟机的数据映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># src： 是物理机的目录，相对路径，（相对于项目目录（&#x2F;vagrant&#x2F;ubuntu））</span><br><span class="line"># &#x2F;srv&#x2F;website: 虚拟机的目录，绝对路径，如果没有，会自动创建</span><br><span class="line">config.vm.synced_folder &quot;src&#x2F;&quot;, &quot;&#x2F;srv&#x2F;website&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">config.vm.synced_folder &quot;.&quot;, &quot;&#x2F;vagrant&quot;, disabled: true</span><br><span class="line">config.vm.synced_folder &quot;src&#x2F;&quot;,&quot;&#x2F;srv&#x2F;website&quot;,owner: &quot;root&quot;,group: &quot;root&quot;</span><br></pre></td></tr></table></figure><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote><p>出现的问题以及对应的处理</p></blockquote><p>@Q: 处理本地下载对应镜像慢问题：</p><p>直接下载、设置代理</p><p>执行 <code>vagrant up --provider=hyperv</code>，在控制台找到下载地址，使用本地下载工具下载(代理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 执行下载</span><br><span class="line"># 获取地址重新下载</span><br><span class="line"># 重命名为指定格式</span><br><span class="line">vagrant up --provider&#x3D;hyperv</span><br><span class="line"># 将下载的 .box 添加</span><br><span class="line"># 使用下载的 .box 进行初始化 </span><br><span class="line">vagrant box add centos-7_hyperv hyperv.box</span><br><span class="line">vagrant init centos-7_hyperv</span><br></pre></td></tr></table></figure><p>@Q: 卸载重装 Vagrant 无法删除之前构建的虚拟机</p><p>@Q: 公有网络设置静态 IP 的接口选择问题，无法选择 Wifi、以太网接口?? 待验证 选择不同的连接网卡是否可相互通信？</p><p>选择以太网的桥接可实现内网互通</p><p>@Q: 使用以太网接口指定公司网关显示网络不可达? 公司内网的安全性??</p><p>相当于占用内网的一个 IP</p><p>@Q: 二次使用 vagrantfile 时，报错 chmod: cannot access ‘/etc/systemd/system/docker.service.d/http-proxy.conf’: No such file or directory</p><p>A： 通过 ssh 进入主机，创建该文件 // todo 搜寻更好的处理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</span><br></pre></td></tr></table></figure><p>原因是修改了网络配置(改成桥接)，重新配置 docker 的代理，需要创建文件的方式来配置代理，而默认情况下无权限访问</p><p>@Q: 同步文件夹显示编码问题， ==&gt; Test-Node: Rsyncing folder: /cygdrive/d/develop/Env2/Test-Node/ =&gt; /vagrant D:/ProgramFile/Vagrant/embedded/gems/2.2.5/gems/vagrant-2.2.5/lib/vagrant/util/io.rb:32:in `encode’: “5” from GBK to UTF-8 (Encoding::UndefinedConversionError)</p><p>管理员权限编辑对应的 io.rb 文件，更改 vagrant 源码</p><p><a href="https://github.com/hashicorp/vagrant/issues/9368">https://github.com/hashicorp/vagrant/issues/9368</a></p><h2 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a>Ref：</h2><ul><li><a href="https://www.vagrantup.com/intro/getting-started/providers.html">多种类型虚拟机支持</a></li><li><a href="https://zhuyasen.com/post/vv_evn.html">使用vagrant和vitrualBox搭建虚拟开发环境</a></li><li><a href="https://app.vagrantup.com/boxes/search?provider=hyperv">Box-Search: hyperv</a></li><li><a href="http://blog.lujun9972.win/blog/2018/07/29/vagrant%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html">Vagrant使用指南</a>: 插件、vagrant 代理、对应虚拟机代理</li><li><a href="https://juejin.im/entry/579015868ac247005ffa76ad">windows 下 使用 vagrant 来管理 linux 虚机开发环境</a></li><li><a href="https://superuser.com/questions/1354658/hyperv-static-ip-with-vagrant/1355010">HyperV - Static Ip with Vagrant</a></li><li><a href="https://www.cnblogs.com/hafiz/p/9175484.html">征服诱人的Vagrant！</a></li><li><a href="https://www.kancloud.cn/louis1986/vagrant">Vagrant学习文档</a></li><li><a href="https://blog.hedzr.com/2017/05/02/vagrant-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">VAGRANT 网络配置</a></li><li><a href="https://blog.51cto.com/xslwahaha/1438669">ifconfig命令和ip命令及route命令</a>： 配置公有网络设定 IP、掩码、网关</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC] &lt;/p&gt;
&lt;h1 id=&quot;Vagrant&quot;&gt;&lt;a href=&quot;#Vagrant&quot; class=&quot;headerlink&quot; title=&quot;Vagrant&quot;&gt;&lt;/a&gt;Vagrant&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;快速搭建虚拟机环境，可通过 Vagrantfi</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker-镜像构建-‘最佳实践’</title>
    <link href="http://example.com/2021/03/09/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/03/09/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-03-09T01:41:21.000Z</published>
    <updated>2021-04-15T02:51:15.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建发布"><a href="#构建发布" class="headerlink" title="构建发布"></a>构建发布</h2><p>一键构建发布</p><p>通过 node 命令合并，maven 插件集成，zsh 终端别名命令定制，Jenkins CICD 操作 Shell 脚本</p><h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a><strong>镜像构建</strong></h3><p>1、构建方式</p><ul><li>Dockerfile 一键构建，构建环境为当前运行环境</li><li>Dockerfile + Builder 容器进行构建，构建环境为 Builder 指定的容器环境</li><li>Jenkins + Agent 配合数据卷容器构建，构建环境为 agent 指定的或是新构建的容器环境</li></ul><p>2、常见构建目标</p><ul><li>中间件镜像构建，对于 redis、rabbitmq、nginx、haproxy、mysql 对外提供服务，需要更改启动方式为非后台启动，在配置中或是命令运行时进行更改处理</li><li>运行环境构建，Centos、Debian、Alpine 操作系统，JRE 、Tomcat、Nginx、Ruby、MySql 程序运行环境</li><li>构建工具构建，Maven、Node、Gradle 等工具镜像构建,保存公司私有仓库的账号密码进行打包发布</li></ul><p>3、镜像构建与 Git 配合</p><p>Docker 提供环境、Git 仓库提供最新的部署脚本，entrypoint 中指定运行特定的脚本(python)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;git_url&gt; -b &lt;branch&gt;</span><br><span class="line">chmod 777 &lt;git_master&gt;&#x2F;docker-entrypoint.sh</span><br><span class="line">docker build -t &lt;&gt; .</span><br><span class="line">docker push &lt;&gt;</span><br></pre></td></tr></table></figure><h3 id="镜像打包"><a href="#镜像打包" class="headerlink" title="镜像打包"></a><strong>镜像打包</strong></h3><p>镜像的 Tag 选择</p><ul><li><code>日期 + &lt;short_commid_id&gt;</code>: 持续交付方式的镜像打包，可保留以往的</li><li><code>&lt;mvn_version&gt;</code>: mvn 版本，不断的覆盖，随模块版本稳定而稳定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0-YYmmddHHMMSS-abddfd</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><p><strong>合并多个 RUN 减少镜像层数</strong></p><p>合并多个 RUN 成一个，因为每次 RUN 都是在原有的镜像上增加一层，可有效减少镜像中的层数</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt-get -y install \</span></span><br><span class="line"><span class="bash">    openjdk-8-jdk ssh vim </span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> target/app.jar /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>选取合适的基础镜像</strong></p><p>使用 alpine 架构的 Linux 一般生成的镜像比较小，根据需要选择可以满足运行条件的最小镜像，自己构建镜像，使用公司内部镜像，借助 Dockerfile 更改部分内容适配需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node:10.16.3-alpin   74M</span><br><span class="line">node:10.16.3         904M</span><br><span class="line">node:10.16.3-stretch</span><br><span class="line">node:10.16.3-bruster</span><br></pre></td></tr></table></figure><p><strong>可重建性</strong></p><p>制作镜像时将源码打包进入镜像中，在镜像提供的环境中进行源码的编译打包，之后运行此种方式配合容器的挂载映射，实现每次运行时的配置都是最新的</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.6</span>-jdk-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pom.xml .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src ./src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -e -B package</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>多阶段构建</strong></p><p>使用某个镜像作为构建环境，之后引用其中的文件，不会将该辅助镜像打包进最后生成的镜像中; 将编译和运行过程分离开，与通过 Jenkins 的 docker agent 进行编译镜像实现类似</p><p>方便控制构建环境的版本，不易出现版本问题</p><p>可以使用配有公司 Maven 私服地址的 Maven 镜像作为编译环境，之后在容器中编译打包，从构建包传递到 JDK 环境的运行包中，执行最终的构建</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jar 的打包和运行</span></span><br><span class="line"><span class="comment"># As Builder 指定构建过程中的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.6</span>-jdk-<span class="number">8</span>-alpine As builder </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app </span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pom.xml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -e -B dependency:resolve </span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src ./src </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -e -B package </span></span><br><span class="line"><span class="comment"># 实际运行的环境</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine </span><br><span class="line"><span class="comment"># 从 Builder 中复制</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/target/app.jar /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br><span class="line"><span class="comment"># Web 项目的打包和运行</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10.16</span>.<span class="number">3</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app/</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ../Doc ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build:docker</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker/nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /usr/src/app/dist  /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="运行参数和动态控制"><a href="#运行参数和动态控制" class="headerlink" title="运行参数和动态控制"></a>运行参数和动态控制</h3><p><strong>COPY 实现自定义配置</strong></p><p>可以实现容器内配置的覆盖，一般配合 WORKDIR 使用</p><p>可以实现相对路径下的文件拷贝到容器中，存在时覆盖原有文件</p><p>可自动实现文件的重命名</p><p>NOTE:</p><ul><li>对于可执行文件，需要进行赋权</li><li>对于配置文件，特定组件需要文件有指定的权限，如 MySQL 的配置文件</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工程文件复制到镜像</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ../devops ./</span></span><br><span class="line"><span class="comment"># 配置覆盖</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker/nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="comment"># 当前目录下文件作为容器中的部分配置</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="comment"># 相对路径下的所有文件拷贝到指定目录，不包含该路径文件夹</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./dist  /usr/share/nginx/html/</span></span><br><span class="line"><span class="comment"># Dockerfile_rabbit3.6</span></span><br><span class="line"><span class="keyword">FROM</span> docker.elastic.co/logstash/logstash:<span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"><span class="comment"># 别名指定</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> logstash.yml /usr/share/logstash/config/logstash.yml</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jvm.options /usr/share/logstash/config/jvm.options</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9600</span></span><br></pre></td></tr></table></figure><p>动态参数和配置</p><p><strong>RUN + echo 实现自定义配置</strong></p><p>通过 RUN 执行 shell 命令，将需要的配置插入到配置文件的尾部，从而覆盖之前编写的配置，实现自定义配置</p><p>只适合使用 key=val 方式的配置文件，对于 json 格式的配置文件无法使用</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.6</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;lower_case_table_names=1&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;max_allowed_packet=100M&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;innodb_log_file_size=500M&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;wait_timeout=57600&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;interactive_timeout=57600&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;transaction_isolation=READ-COMMITTED&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;event_scheduler=1&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;max_connections=500&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;innodb_lock_wait_timeout=500&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf</span></span><br></pre></td></tr></table></figure><p><strong>COPY + Shell + Sed + ENTRYPOINT 自定义配置</strong></p><p>将带有一定模板值的多个配置文件 COPY 进镜像中，将通过 sed 进行配置替换的脚本 COPY 进镜像，将配置替换脚本作为 ENTRYPOINT;</p><p>即使配置文件对应的应用不支持传入变量值和环境变量也可以通过此种方式使其支持;</p><p>实际使用：</p><ul><li>运行在 Nginx 容器中的 web 项目，动态替换框架打包的 umi 中的配置，实现环境的指定；</li><li>运行在 tomcat 容器中的 war Java 项目，在运行启动后，对应的 war 包的内容被解压开来，更改配置文件的位置，一般是 xx.properties、xxxx.yml，之后重启整个容器应用更改</li></ul><p><strong>ENV 指定实现特定功能</strong></p><p>三种语法</p><p>配合 Python 脚本将传入的环境变量进行解析成 Ansible 连接的信息</p><p>运行时指定环境变量实现动态运行控制</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定路径、版本...</span></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_HOME=/apache-maven-<span class="number">3.3</span>.<span class="number">9</span></span><br><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.6</span>.<span class="number">45</span>-<span class="number">1</span>debian9</span><br><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">8.9</span>.<span class="number">4</span></span><br><span class="line"><span class="comment"># 指定系统环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br><span class="line"><span class="comment"># 指定一组环境变量参数</span></span><br><span class="line"><span class="keyword">ENV</span> ANSIBLE_HOSTS=<span class="string">&quot;test1:127.0.0.1&quot;</span> \</span><br><span class="line">    ANSIBLE_PORT=<span class="string">&quot;22&quot;</span> \</span><br><span class="line">    ANSIBLE_USER=<span class="string">&quot;root&quot;</span> \</span><br><span class="line">    ANSIBLE_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">    ANSIBLE_FILE=<span class="string">&quot;centos_init_test&quot;</span></span><br></pre></td></tr></table></figure><p><strong>多用途构建文件拆分</strong></p><p>通过 Dockerfile、Dockerfile.hub、Dockerfile.dev、<a href="http://dockerfile.in/">Dockerfile.in</a> 增加文件后缀方式区分构建的用途</p><p>通过<code>Dockerfile_&lt;iamge_name&gt;&lt;image_version&gt;_&lt;env&gt;_for_&lt;gole&gt;</code> 指明所属环境版本、目的、特定版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dockerfile  </span><br><span class="line">Dockerfile.hub</span><br><span class="line">Dockerfile.dev</span><br><span class="line">Dockerfile_alpine_3.5</span><br><span class="line">Dockerfile_mysql5.6_v6</span><br><span class="line">Dockerfile_tomcat8539-jre811-for-prod</span><br></pre></td></tr></table></figure><p><strong>配合构建工具实现一键发布</strong></p><p>对于 Maven 项目，通过 docker-maven-plugin 实现自定义选择阶段，只需在命令后增加 <code>docker:build</code>， <code>docker:push</code> 即可，同时可以将阶段绑定到对应 mvn 命令，如 package、deploy</p><p>对于 Node 项目，可以自定义 npm run 命令，在 package.json 中定义好 scripts 指定好某个命令的执行指令，并支持多个命令的合并运行，命令之间顺序任意，以此方便项目的 CI</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;docker-hub:build&quot;: Dockerfile_jenkins_jdk8-maven3.6.1,</span><br><span class="line">&quot;docker:tag&quot;: &quot;docker tag docker.io/project/web&quot;,</span><br><span class="line">&quot;docker-registry:login&quot;:  &quot;docker login -u &lt;user-name&gt; -p&lt;password&gt;&quot;,</span><br><span class="line">&quot;docker:push&quot;: &quot;npm run docker-hub:build &amp;&amp; npm run docker:tag &amp;&amp; npm run docker-registry:login &amp;&amp; docker push &lt;image-name&gt;&quot;,</span><br><span class="line">mvn deploy</span><br><span class="line">mvn clean package docker:push -Pdocker</span><br></pre></td></tr></table></figure><p><strong>ENTRYPOINT + CMD 参数填充</strong></p><p>指定命令参数覆盖 -?，实现指定参数的运行，配合特定运行 jar 包随着 main 类传入参数定制容器的行为</p><p>适合 “一次性命令”，启动的容器目的只是依赖于容器内部的工具执行特定的脚本，方便实现数据库的安装、redis-trib 构建集群便是此种方式</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;setup.jar&quot;</span>] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-?&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>ENTRYPOINT + <a href="http://docker-entrypoint.sh/">docker-entrypoint.sh</a> + 环境变量实现定制化运行</strong></p><p>在 <a href="http://docker-entrypoint.sh/">docker-entrypoint.sh</a> 中指定多种后缀类型的文件执行不同的处理</p><p>通过执行一个初始化脚本，对于 MySQL 环境初始项目需要使用的数据库，并实现权限的分配。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh /opt/app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /opt/app/docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;/opt/app/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>不在其中进行修改文件</strong></p><p>镜像修改会新增一个层，对于修改文件或目录权限，会将文件复制一份</p><p>在 Dockerfile 之前设置好或是通 entrypoint 进行修改</p><p><strong>使用 dockerignore 文件</strong></p><p>执行 docker build 时忽略特定的路径和文件，加速构建过程</p><h3 id="运行时参数指定"><a href="#运行时参数指定" class="headerlink" title="运行时参数指定"></a>运行时参数指定</h3><p><strong>构建阶段动态配置</strong></p><p>常见的编译构建类型</p><ul><li>Docker 镜像的编译构建</li><li>Java 项目的编译构建成对应的 jar 可运行包</li><li>Web 进行编译构建成静态文件</li><li>Android 项目的打包构建</li><li>Flutter 项目的打包构建</li></ul><p>构建过程中的工具 Maven、Gradle、npm。</p><p>Profile： 指定 Maven 的 resource 为不同的目录，仅能够支持配置文件和一些 Maven 插件配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="comment"># 所有的通用配置</span></span><br><span class="line">resource.dev <span class="comment"># 开发配置</span></span><br><span class="line">resource.test <span class="comment"># 测试配置</span></span><br><span class="line">resource.prod <span class="comment"># 生产环境配置</span></span><br><span class="line">resource.docker <span class="comment"># docker ... 可等价于 生产环境</span></span><br></pre></td></tr></table></figure><p>3、Git 的分支控制</p><p>更改分支上的配置内容实现环境的拆分，可以实现非配置文件的更改，直接修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b prod</span><br><span class="line">git checkout -b dev</span><br><span class="line">git checkout -b test</span><br><span class="line">git checkout -b mock</span><br><span class="line">git checkout -b docker</span><br></pre></td></tr></table></figure><p>4、Jenkins 构建变量</p><p>在 Jenkins 中添加条件变量，在每次构建的时候选择需要构建的环境，配合 Shell 脚本将源码中的文件进行替换，实现和 Git 分支控制一样的效果</p><p>如在 WEB-INFO 下的 db.properties，无法通过 上述1、2处理，可以在对应目录下再建一个 db.prod.properties，Jenkins 判断为 prod 环境时，对 db.properties 删除，db.prod.properties 进行重命名即可</p><p><strong>Dockerfile 中的动态配置</strong> 通过 <code>COPY</code>, <code>ADD</code> 将自定义配置放入 image 中</p><p><strong>运行阶段动态配置</strong></p><p>通过 kube 控制 k8s 集群进行运行通过 docker 命令在本机运行通过 ansible 控制机器运行通过 jenkins 的 ssh 工具控制机器运行</p><p>关于运行的环境选择，针对 Java 项目当前已知三种方式进行环境区分： Spring 的 profile，更细致的是 Condition + 各种判断控制，控制较为灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application-dev.properties</span><br><span class="line">application-test.properties</span><br></pre></td></tr></table></figure><p><strong>构建后运行前阶段的动态配置</strong></p><p>1、通过 Docker 的 entrypoint 指定参数拼凑运行的配置或命令 从环境变量中取值，进行环境判断和动态赋值</p><p>2、通过 SpringBoot 的 jar 参数控制 SpringBoot 作为可运行 jar，内部调用一个 sh 脚本控制</p><p>3、通过 volumn 映射配置执行 将指定的配置文件进行映射 将指定的配置文件夹进行映射</p><p>4、镜像中集成 template 更新模板参数，对配置模板渲染生成后重启</p><h3 id="运行后配置"><a href="#运行后配置" class="headerlink" title="运行后配置"></a>运行后配置</h3><p>1、更改配置不重启(重启失效) 一些组件支持在运行过程中更改配置，一般重启后配置失效</p><p>redis 的动态配置</p><ul><li>连接的主服务器</li><li>持久化配置</li><li>..</li></ul><p>mysql 的动态配置</p><ul><li>字符集</li><li>信任function - ..</li></ul><p>2、更改配置重启 适合容器中的配置文件可见，对于使用 jar 包运行的参数拼接可更改对应的 <code>docker-entrypoint.sh</code> 中的 JVM 和 Springboot 配置文件参数实现</p><ul><li>直接在容器中更改配置文件重启</li><li>通过 <code>docker cp</code> 方式将更改好的配置复制到容器中后重启</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/10km/article/details/79046864">docker:mysql启动时自动执行初始建表脚本_10km的专栏-CSDN博客</a></p><p>docker:mysql启动时自动执行初始建表脚本</p><p><a href="https://www.cnblogs.com/han-1034683568/p/6941337.html">https://www.cnblogs.com/han-1034683568/p/6941337.html</a></p><p>让docker中的mysql启动时自动执行sql文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构建发布&quot;&gt;&lt;a href=&quot;#构建发布&quot; class=&quot;headerlink&quot; title=&quot;构建发布&quot;&gt;&lt;/a&gt;构建发布&lt;/h2&gt;&lt;p&gt;一键构建发布&lt;/p&gt;
&lt;p&gt;通过 node 命令合并，maven 插件集成，zsh 终端别名命令定制，Jenkins CIC</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Guava使用</title>
    <link href="http://example.com/2021/03/09/Guava%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/03/09/Guava%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-08T17:24:34.000Z</published>
    <updated>2021-04-14T01:14:06.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong>Joiner 字符拼接</strong></p><p><strong>1、Joiner | JDK8 Stream</strong> 字符拼接常见操作：</p><ul><li>不带空元素的拼接</li><li>对空元素使用默认值拼接</li><li>写入文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String result=Joiner.on(<span class="string">&quot;#&quot;</span>).join(stringList);</span><br><span class="line">String result =Joiner.on(<span class="string">&quot;#&quot;</span>).userorNull(<span class="string">&quot;DEAULT&quot;</span>).join(stringListwithNull);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StringBuilder builder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder resultBuilder=Joiner.on(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    .useForNull(<span class="string">&quot;DEFAULT&quot;</span>)</span><br><span class="line">    .appendTo(builder, stringListwithNullval);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer</span></span><br><span class="line"><span class="keyword">try</span> (Filewriter writer = <span class="keyword">new</span> Filewriter(<span class="keyword">new</span> File(targetFileName))) &#123;</span><br><span class="line">    Joiner.on(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">        .useForNull(<span class="string">&quot;DEFAULT&quot;</span>)</span><br><span class="line">        .appendTo(writer, stringListwithNullValue);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    fail(<span class="string">&quot;append to the writer occur fetal error.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK8 中的 Join 中的 Stream：跳过 Null 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String result=stringListwithNullValue.stream()</span><br><span class="line">    .filter(item-&gt;item!=<span class="keyword">null</span> &amp;&amp; !item.isEmpty()).collect(joining(<span class="string">&quot;#&quot;</span>));</span><br><span class="line"><span class="comment">// null to defalut</span></span><br><span class="line">String result=stringListwithNullValue.stream()</span><br><span class="line">    .map(item-&gt;item==<span class="keyword">null</span> || item.isEmpty()?<span class="string">&quot;DEFAULT&quot;</span>:item).collect(joining(<span class="string">&quot;#&quot;</span>));</span><br><span class="line"><span class="comment">// function infer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoiningByStreamwithDefaultyalue</span><span class="params">()</span></span>&#123;</span><br><span class="line">string result =stringListwithNullValue.stream()</span><br><span class="line">    .map(<span class="keyword">this</span>::defaultValue)</span><br><span class="line">    .collect(joining(<span class="string">&quot;#&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>2、Map 拼接</strong> 将 Map 的键值按照特定分隔符进行拼接 默认 key 和 val 通过 <code>=</code> 进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,string&gt; stringMap = of(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Guaga&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">assertThat(Joiner.on(<span class="string">&#x27;#&quot;).withKeyValueSeparator(&quot;=&quot;).join(stringMap), equalTo(&quot;Hello=Guava#Java=Scala&quot;));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">try(FileWriter writer=new Filewriter(new File(targetFileNameToMap)))&#123; </span></span><br><span class="line"><span class="string">  Joiner.on(&quot;#&quot;).withKeyValueSeparator(&quot;=&quot;).appendTo(writer, stringMap);</span></span><br><span class="line"><span class="string">  assertThat(Files.isFile().test(new File(targetFileNameToMap)), equalTo(true));</span></span><br><span class="line"><span class="string">&#125; catch (IOException e)&#123;</span></span><br><span class="line"><span class="string">  fail(&quot;append to the writer occur fetal error.&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Splitter 字符分隔</strong></p><p>剔除一些无用的 按照特定分隔符分隔并转化成 List 剔除掉空的字符并转化成 List</p><p>指定分隔符 剔除 Blank 字符 剔除剔除 Empty 字符 收集结果成为 List <strong>1、分隔与忽略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 普通分隔</span></span><br><span class="line">List&lt;String&gt;result=Splitter.on(<span class="string">&quot;|&quot;</span>).splitToList(<span class="string">&quot;hellolworld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2 忽略空串</span></span><br><span class="line">List&lt;string&gt;result=Splitter.on(<span class="string">&quot;|&quot;</span>).omitEmptystrings().splitroList(<span class="string">&quot;hellolworldlll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3 忽略空格并忽略空串</span></span><br><span class="line">result=Splitter.on(<span class="string">&quot;I&quot;</span>).trimResults().omitEmptystrings().splitroList(<span class="string">&quot;hel1o I worldlll&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>2、正则分隔</strong> 使用 <code>onPattern</code> 替代 <code>on</code>, 参数即为正则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1 传入正则表达式进行分隔</span></span><br><span class="line">List&lt;String&gt;result=Splitter.onPattern(<span class="string">&quot;\\\\\\\\l&quot;</span>).trimResults().omitEmptystrings().splitTorist(<span class="string">&quot;hello | worldl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 传入正则Pattern</span></span><br><span class="line">List&lt;string&gt;result =Splitter.on(Pattern.compile(<span class="string">&quot;\\\\l&quot;</span>)).trimResults(). omitEmptystrings().splitToList(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>3、结果分隔</strong> 通过字符长度截取字符串 截取结果中固定的个数，最后的保存剩余所有的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1 分隔固定长度，报文的固定长度截取 aaabbbccc</span></span><br><span class="line">List&lt;string&gt; result = Splitter.fixedtength(<span class="number">4</span>).splitToList(<span class="string">&quot;aaaabbbbccccdddd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 限制返回的结果数，多余的放在最后一个结果中</span></span><br><span class="line">List&lt;String&gt;result=Splitter.on(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .splitToList(<span class="string">&quot;hello# world# java# google# scala&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3 传入正则Pattern, 返回 Map</span></span><br><span class="line">Map&lt;String, String&gt; result = Splitter.on(Pattern.compile(<span class="string">&quot;\\\\\\\\l&quot;</span>))</span><br><span class="line">    .trimResults()</span><br><span class="line">    .omitEmptystrings()</span><br><span class="line">    .withKeyValueSeparator(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    .split(<span class="string">&quot;hello=HELLOl|world=WORLD|||&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>String 其他工具</strong></p><p><strong>1、Strings</strong> 填充字符串 获取公共前缀|后缀 重复指定次数的字符串: 和 python 进行重复类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assertlhat(strings.emptytovull(<span class="string">&quot;&quot;</span>) rnullvalue())</span><br><span class="line">assertThat(Strings.nullToEmpty(<span class="keyword">null</span>), equalro(<span class="string">&quot;&quot;</span>)); </span><br><span class="line">assertThat(strings.nullToEmpty(<span class="string">&quot;hello&quot;</span>), equalTo(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertThat(Strings.commonPrefix(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Hit&quot;</span>), equalTo(<span class="string">&quot;H&quot;</span>));</span><br><span class="line">assertThat(Strings.commonPrefix(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Xit&quot;</span>), equalro(<span class="string">&quot;&quot;</span>));</span><br><span class="line">assertThat(Strings.commonSuffix(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Echo&quot;</span>), equalTo(<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertThat(Strings.repeat(<span class="string">&quot;Alex&quot;</span>,<span class="number">3</span>), equalTo(<span class="string">&quot;AlexAlexAlex&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertlhat(btrings.<span class="number">1</span>sNullormpty(nulL), equallo(<span class="keyword">true</span>))</span><br><span class="line">assertThat(Strings.isNullOrEmpty(<span class="string">&quot;&quot;</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">assertThat(Strings.padstart(<span class="string">&quot;Alex&quot;</span>,<span class="number">3</span>,<span class="string">&#x27;H&#x27;</span>), equalTo(<span class="string">&quot;Alex&quot;</span>));</span><br><span class="line">assertThat(strings.padstart(<span class="string">&quot;Alex&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;H&#x27;</span>), equalTo(<span class="string">&quot;HAlex&quot;</span>));</span><br><span class="line">assertThat(Strings.padEnd(<span class="string">&quot;Alex&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;H&#x27;</span>), equalTo(<span class="string">&quot;AlexH&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>2、CharSet</strong></p><p><strong>3、CharMatcher</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assertThat(CharMatcher. javaDigit(). matches(<span class="string">&#x27;A&#x27;</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">assertThat(CharMatcher. javaDigit(). matches(<span class="string">&#x27;x&#x27;</span>), equalTo(<span class="keyword">false</span>)); </span><br><span class="line">assertrhat(CharMatcher. is(<span class="string">&#x27;A&#x27;</span>).countIn(<span class="string">&quot;Alex sharing the Google Guava to Us&quot;</span>), equalTo(<span class="number">1</span>));</span><br><span class="line">assertThat(CharMatcher. breakingwhitespace().collapseFrom(<span class="string">&quot;hello Guava &quot;</span>,<span class="string">&#x27;*&quot;), equalro(&quot;* hello Guaval&quot;);</span></span><br><span class="line"><span class="string">assertThat(CharMatcher. javaDigit(). or(CharMatcher. whitespace()). removeFrom(&quot;hello 234 world&quot;), equalTo(&quot;helloworld&quot;);</span></span><br><span class="line"><span class="string">asserThat(CharMatcher. javaDigit(). or(CharMatcher. whitespace()). retainFrom(&quot;hello 234 world&quot;), equalro(&quot;234&quot;));</span></span><br></pre></td></tr></table></figure><p><strong>类通用工具</strong></p><p><strong>1、MoreObjects</strong> 1、实战 toString 辅助编写： 支持忽略空值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">tostring</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Moreobjects.tostringHelper(<span class="keyword">this</span>).omitNullValues()</span><br><span class="line">.add(<span class="string">&quot;manufacturer&quot;</span>, <span class="keyword">this</span>.manufacturer)</span><br><span class="line">.add(<span class="string">&quot;version&quot;</span>, <span class="keyword">this</span>.version)</span><br><span class="line">.add(<span class="string">&quot;releaseDate&quot;</span>, <span class="keyword">this</span>.releaseDate).tostring();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、源码 链表结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ToStringHelper</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.holderHead = <span class="keyword">new</span> MoreObjects.ToStringHelper.ValueHolder();</span><br><span class="line">  <span class="keyword">this</span>.holderTail = <span class="keyword">this</span>.holderHead;</span><br><span class="line">  <span class="keyword">this</span>.omitNullValues = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// check and get</span></span><br><span class="line">  <span class="keyword">this</span>.className = (String)Preconditions.checkNotNull(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MoreObjects.ToStringHelper.<span class="function">ValueHolder <span class="title">addHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MoreObjects.ToStringHelper.ValueHolder valueHolder = <span class="keyword">new</span> MoreObjects.ToStringHelper.ValueHolder();</span><br><span class="line">  <span class="keyword">this</span>.holderTail = <span class="keyword">this</span>.holderTail.next = valueHolder;</span><br><span class="line">  <span class="keyword">return</span> valueHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、Objects 深度比较</strong> deepEquals hash: compare(a,b, cmp); requireNonNull template = String.valueOf(template); // null -&gt; “null”</p><p>在 JDK7+ 使用 JDK 提供的 Objects 方法替代</p><p><strong>3、ComparisonChain</strong> 链式的比较规则 JDK8 添加类似的实现在 Comparator 上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Guava <span class="keyword">this</span>, Guava o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Comparisonchain.start()</span><br><span class="line">        .compare(<span class="keyword">this</span>.manufacturer,o.manufacturer)</span><br><span class="line">        .compare(<span class="keyword">this</span>.version,o.version)</span><br><span class="line">        .compare(<span class="keyword">this</span>.releasepate,o.releaseDate).result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、源码 本身为抽象类 类中持有一个实例化的对象 提供该抽象类的一个继承实现类 针对 float,double,int,long,Object 提供比较，针对 Object 提供 classis 和基于 Comparator 的比较</p><p><strong>StopWatch</strong></p><p>工厂方式获取，createStarted() 省去创建之后开启的步骤 可控制返回的时间单位 对象可以来回复用记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;start process the order [&#123;&#125;]&quot;</span>, orderNo);</span><br><span class="line">Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">LOGGER.info(<span class="string">&quot;The orderNo [&#123;&#125;] process successful and elapsed [&#123;&#125;] min.&quot;</span>, orderNo, stopwatch.stop().elapsed(TimeUnit.MINUTES));</span><br></pre></td></tr></table></figure><p><strong>PreConditons</strong></p><p>运行时空判断 判断并可给出 message，默认通过 String 自带的格式化字符串实现 通过方法名空值语义： checkState: 判断状态 checkElementIndex: 判断容器的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preconditions.checkNotNull(list,<span class="string">&quot;The list should not be null and the size must be %s&quot;</span>,<span class="number">2</span>);</span><br><span class="line">Preconditions.checkArgument(type.equals(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">Preconditions.checkState(state.equals(<span class="string">&quot;B&quot;</span>), <span class="string">&quot;The state is illegal.&quot;</span>);</span><br><span class="line">Preconditions.checkElementIndex(<span class="number">10</span>, list.size());</span><br></pre></td></tr></table></figure><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p><strong>FluentIterable</strong></p><p>类似网络中的数据流处理</p><p><strong>1、将其当做链表操作：</strong> 链表的头结点、尾节点获取 两条链表的合并 链表中是否含有满足特定条件的值 链表中是否全部满足特定条件 链表中满足特定条件的第一个值 将链表按照特定的长度进行分割</p><p>从数组中构建链表 从迭代器中构建链表</p><p>链表的循环读取，先连接成环，之后扫描限定个数的节点</p><p>链表元素的转换(transform)，通过 Function 接口实现 链表元素进行转换，单个元素转化后是一个 迭代器，重新进行连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FluentIterable&lt;String&gt; fit = build();</span><br><span class="line"><span class="keyword">boolean</span> result = fit.allMatch(e -&gt; e != <span class="keyword">null</span> &amp;&amp; e.length() &gt;= <span class="number">4</span>);</span><br><span class="line">result = fit.anyMatch(e -&gt; e != <span class="keyword">null</span> &amp;&amp; e.length() == <span class="number">5</span>);</span><br><span class="line">Optional&lt;String&gt; optional = fit.firstMatch(e -&gt; e != <span class="keyword">null</span> &amp;&amp; e.length() == <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>Lists | Sets</strong></p><p><strong>List 构造</strong></p><blockquote><p>通过工厂提供方便的构造方式, 同时语义明确</p></blockquote><p>主要提供三种 List 的构造：</p><p>ArrayList 原始方式 提供根据迭代器构造 提供根据可变数组构造 提供容量构造，包含限定长度、给出期望长度</p><p>LinkedList 构造仅提供两种方式：  底层链表无法指定大小 原始方式 迭代器构造</p><p>CopyOnWriteArrayList： 构造方式同 LinkedList</p><p><strong>Set 构造</strong></p><p>HashSet: 方式和 ArrayList 方式类似</p><p>LinkedHashSet： 方式与 LinkedList 类似 增加限定容量，底层基于数组。。。</p><p>TreeSet： 普通构建，(), (comparator) 传入迭代器</p><p>EnumSet：</p><p><strong>Set 集合性质(&amp;)</strong></p><p>笛卡尔积 组合选取 两个集合不同的部分， difference(set1, set2) 返回在 set1 中的元素而不再 set2 中的元组 交集、并集</p><p><strong>MultiSet</strong></p><p>记录重复元素的个数</p><p><strong>Maps | BiMap | MultiMap</strong></p><p>构造方式</p><p>转换成不可变Map 根据 Set 转变成可变 Map 根据 Map 转换对应的值</p><p>BiMap</p><p>严格的一对一映射，通过接口声明通用的操作</p><p><strong>Table | Range</strong></p><p>ArrayTable TreeBaseTable HashBaseTable ImmutableTable</p><p>表名、列明、列值</p><p><strong>Range</strong></p><p>提供实现了自然排序类的范围： <code>&gt;= &lt;=, [)</code></p><p>范围映射，Key 为一个给定的范围，放入的为泛型 K 的一个 Range，支持按照某个具体的值获取到对应范围端的一个值</p><p><strong>Range | RangeMap | Ording</strong></p><p>Sorted 判断是否已经按照自然排序完成</p><p>给出相反的比较。。。</p><p>Getting Started with Google Guava.pdf</p><p>不可变设计： 提供工厂方式， of 提供构建器方式 CacheBuilder.newBuilder().build() 提供原型方式构建 copyOf</p><p><strong>Range</strong></p><p>存放在其中的元素必须是 Comparable 的</p><p>提供多种符合语义的工厂构造： 根据枚举值确定两端的开闭</p><p><strong>RangeMap</strong></p><p>另一种存在有序性的 Map</p><p><strong>Ording</strong></p><p>支持对 null 的特殊处理，将其放在第一位或者最后一位</p><p>与当前 JDK8 中 Comparator 中的 nullFirst 一致，配合 thenXXX 进行控制比较规则</p><h3 id="Guava-缓存"><a href="#Guava-缓存" class="headerlink" title="Guava 缓存"></a>Guava 缓存</h3><p><strong>原始缓存实现</strong></p><p>1、LinkedHashMap 通过 JDK 自带的实现</p><p>2、LinkedList 借助 LinkedList 实现</p><p>3、通过 SoftReference 实现 容量： 初始容量、最大容量 过期策略： 设置的大小、按照权重、访问、写入、更新、GC 并发等级： 并发使用 KV收集机制： 软引用、弱引用进行 GC</p><p><strong>过期策略(5)</strong></p><p>1、大小 限定缓存的个数，内存大小</p><p>2、LRU 限定大小的情况下，模式通过 LRU 算法进行淘汰</p><p>3、Time(W,R) 在访问命中某个元素多长时间后过期； 在更新某个元素多长时间后过期；</p><p>4、引用生命周期控制(GC) .softValues() .softKeys() 借助 GC 控制何时回收，何时保留</p><p>5、权重 通过为每个缓存的数据设定一定的权重进行控制是否过期 通过实体，给出计算规则： 入参为 key, values，返回的值为对应的权重</p><p><strong>其他特性(4)</strong></p><p>1、不存在的默认值(LoadingCache) 在获取不到的情况下给出的值 类似缓存雪崩情况下的熔断 通过 CacheLoader 抽象类实现： 给类提供根据 Function，Supplier 进行创建的工厂 是 LoadingCache 实现必须要指定的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheLoader&lt;K, V&gt; <span class="title">from</span><span class="params">(Function&lt;K, V&gt; function)</span></span></span><br><span class="line"><span class="function">CacheLoader&lt;Object, V&gt; <span class="title">from</span><span class="params">(Supplier&lt;V&gt; supplier)</span></span></span><br></pre></td></tr></table></figure><p>2、统计功能 .recordStats() 记录缓存的命中率，执行情况</p><p>3、监听缓存移除事件 可设置缓存移除监听器，监听到删除事件进行处理 封装成通知实体控制移除策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;K, V&gt; notification)</span></span>;</span><br></pre></td></tr></table></figure><p>4、灵活的构造方式</p><ul><li>支持根据特定的字符串构造 CacheBuilder： 类似读取配置文件实现缓存</li><li>根据函数式接口构造 CacheLoader</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String spec = <span class="string">&quot;maximumSize=5,recordStats&quot;</span>;</span><br><span class="line">CacheBuilderSpec builderSpec = CacheBuilderSpec.parse(spec);</span><br><span class="line">CacheLoader&lt;String, String&gt; loader = CacheLoader.from(String::toUpperCase);</span><br><span class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.from(builderSpec).build(loader);</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong></p><p>通过 ConcurrentHashMap 实现</p><p>Entry 中各种引用的获得： 有限的几个 每个实现都不同 有一定的规律(存在是否) ⇒  定义Enum, 将所有Enum放入数组中，定义工厂获取方法，按照将boolean作为参数进行掩码控制获得</p><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>消息的 pull 和 push</p><p>进程级别，内部</p><p>Listener 对其进行 subscribe 只能有一个参数：</p><p><strong>实战</strong></p><p>1、多种类型 同种类型的多个订阅方法会被调用</p><p>2、Listener 继承特性 都会被调用</p><p>3、Event继承 都会被调用</p><p>4、异步总线</p><p><strong>设计</strong></p><p>自己实现一个消息总线，实现与 Guava 中 EventBus 类似的功能</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><strong>Monitor</strong></p><p>LockCondition 的一个封装 可替换 synchronized 的实现，语义更加明确，同时更加方便编程</p><p>1、阻塞队列设计 (1) synchronized 方式设计</p><p>(2) Reentrant + Condition 方式设计</p><p>(3) Monitor 方式设计</p><p><strong>限流</strong></p><p>rateLimiter</p><p>Semaphore 通过 Semaphore 进行获取并释放令牌的方式进行控制访问的速率</p><p>令牌桶</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/google/guava/wiki">https://github.com/google/guava/wiki</a></p><p>Github Guava Wiki</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Guava&quot;&gt;&lt;a href=&quot;#Guava&quot; class=&quot;headerlink&quot; title=&quot;Guava&quot;&gt;&lt;/a&gt;Guava&lt;/h2&gt;&lt;h3 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Guava" scheme="http://example.com/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发学习笔记</title>
    <link href="http://example.com/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-17T14:53:30.000Z</published>
    <updated>2020-12-17T14:54:19.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>Java 代码首先会编译成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上进行执行。</p><p>Java中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。</p></blockquote><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>(1) extends Thread</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>(2) Runnable</p><p>(3) Callable</p><p>与 Runnable 相比，Callable 可以有返回值，且可以跑出异常，返回值通过 FutureTask 进行封装。</p><p>(4) ThreadPool</p><p><strong>继承与实现接口的比较</strong></p><p>优先实现接口</p><p>① Thread 只能够通过单继承来实现；</p><p>② Thread 创建开销大，Runnable 创建的开销小；</p><p>③ Runnable 实现解耦； 可以配合线程池使用</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="http://img.janhen.com/20201217224805image-20201217224803962.png" alt="image-20201217224803962" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING, </span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(1) 新建(NEW)</strong></p><p>创建后尚未启动。</p><p>当程序使用   new 关键字  创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。</p><p><strong>(2) 可运行(Runnable)</strong><br>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><p><strong>(3) 阻塞(Blocked)</strong><br>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><p>主要分为三种阻塞方式：</p><p>① 同步阻塞： </p><p>等待获取锁，获取同步锁时该同步锁被别的线程占用，JVM 将线程放入到锁池 (lock pool) 中。</p><p>② 等待阻塞</p><p>执行 o.wait() ，JVM会把该线程放入等待队列(waitting queue)中。</p><p>③ 其他阻塞</p><p>I/O 阻塞： 等待 I/O 操作完成；</p><p>执行 Thread.sleep() ；</p><p>执行 t.join() 方法；</p><p><strong>(4) 无限期等待(Waiting)</strong><br>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片；</p><p>都是交互性质的方法；</p><p>Object.wait()、Thread.join()、LockSupport.part() </p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p><strong>(5) 限期等待(Timed Waiting)</strong></p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p><strong>(6) 死亡(Terminated)</strong></p><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><p><strong>(1) 正常终止</strong></p><p>运行结束，正常终止；</p><p><strong>(2) 退出标志</strong></p><p>定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false.在定义exit时，<strong>使用了一个Java关键字volatile，这个关键字的目的是使exit同步</strong>，也就是说在同一时刻只能由一个线程来修改exit的值。</p><p>volatile 无锁同步的应用场景之一；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;   <span class="comment">// volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) Interrupt 方法结束</strong></p><p>①  阻塞下的结束</p><p>在线程处于阻塞状态下，调用 interrupt() 会抛出 InterrupteException，<u>一定要先捕获InterruptedException异常<strong>之后通过break来跳出循环，才能正常结束run方法</strong></u>。</p><p>死循环中的退出，只有在捕获后进行显示的 break 才能实现；</p><p>② 未阻塞下的结束</p><p>使用 isInterrupted() 判断线程的中断标志来退出循环。当使用 interrupt() 方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">// <span class="doctag">NOTE:</span> after catch exception must break to skip loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) stop 方法终止</strong></p><p>程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后  <u>导致了该线程所持有的所有锁的突然释放(不可控制)</u>  ，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。</p><p><strong>(5) Callable 通过 Future.camcel 来进行终止</strong></p><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><p><strong>(1) InterruptedException</strong></p><p>该线程<u>处于阻塞、限期等待或者无限期等待</u>状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>Thread.sleep()；</p><p>synchronized；</p><p>join()；</p><p><strong>(2) interrupted()</strong></p><p>无限循环不跳出，只有在该循环中执行 sleep() 等会抛出 InterruptedException 操作，</p><p>可通过其返回值来防止无线循环，作为一种退出标志；</p><p>调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><p><strong>(3) Executor 的中断操作</strong></p><p>① 关闭池子操作</p><p>shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>② 关闭指定的线程(Future)</p><p>只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>(1) join</p><p>进行线程之间的流程控制，进行线程通信的一种方式；</p><p>(2) yield()</p><p>让出当前 CPU，之后重新进行竞争；</p><p>(3) sleep()</p><p>不释放锁，在等待一定时间后自动唤醒；</p><p><strong>sleep() 与 wait() 的区别</strong></p><p>想到对应在阻塞队列中、以及延时双删策略中的场景；</p><p>① 设计|定义： sleep() 是 Thread 的静态方法，wait() 是 Object 的成员方法；</p><p>② 锁的占用： sleep() 导致程序暂停执行指定的时间，它的监控状态依然保持着，不释放锁， 而 wait() 释放对象锁，进入等待此对象的等待池中；</p><p>③ 使用范围： sleep() 可以用在任何地方， wait() 只能够用在同步控制方法或同步控制块中使用；</p><p>④ 唤醒方式： sleep() 给定时间内自动唤醒，wait() 需要调用 notify 显视唤醒；</p><p><strong>start() 与 run() 的区别</strong></p><ol><li>start() 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 </li><li> 通过调用 Thread 类的 start() 方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，直接运行。</li><li> 方法 run() 称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li></ol><h2 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h2><img src="http://img.janhen.com/20201217224608image-20201031111430904.png" alt="image-20201031111430904" style="zoom: 33%;" /><p><strong>(1) 进程与线程的比较</strong></p><p>进程是 OS 资源分配的单位，有自己独立的寻址空间；</p><p>线程是 OS 独立运行的单元，其共享同一个进程内的所有数据；</p><p>线程相较于进程更加轻量；</p><p>⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的元空间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈。</p><p><strong>(2) 实现多线程的方式</strong></p><p>Java 中通过将每个线程映射为一个进程实现的；</p><p>线程的实现<br>3种模型:<br>内核线程；<br>用户线程；<br>两者结合。 </p><p><strong>(3) 守护线程</strong></p><p>是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种。</p><p>① 停止执行情况</p><p>专门用于服务其他的线程，如果其他的线程(即用户自定义线程)都执行完毕，连main线程也执行完毕，那么jvm就会退出(即停止运行)——此时，连jvm都停止运行了，守护线程当然也就停止执行了。</p><p>② 优先级</p><p>优先级较低</p><p>③ 设置</p><ul><li><p>通过 setDaemon(true) 在 Thread 未 start() 之前显视设置</p></li><li><p>Daemon 线程产生的新线程也是 Daemon 的</p></li></ul><p>④ 性质</p><p>为 JVM 级别的线程，<u>即使你停止了Web应用，这个线程依旧是活跃的</u>。</p><p><strong>(4) 线程派生的联系</strong></p><p>继承对应的优先级、daemon等属性；</p><p>(5) 并发和并行</p><p>并发： 同⼀时间段，多个任务都在执⾏ (单位时间内不⼀定同时执⾏)； </p><p>并⾏： 单位时间内，多个任务同时执⾏。</p><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>while 循环监测</p><p>线程B是一直执行着while(true) 循环的，直到长度为5才终止执行，显然这种方式是很消耗资源的。所以，就需要一种机制能避免上述的操作又能实现多个线程之间的通信，这就是接下来需要学习的“wait/notify线程间通信”。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p><strong>(1) 进程间的通信方式</strong></p><p>① 管道(pipe)、有名管道(named pipe)</p><p>② 信号量(semophore)</p><p>③ 消息队列(message queue)</p><p>④ 信号(signal)</p><p>⑤ 共享内存(shared memory)</p><p>⑥ 套接字(socket)</p><p><strong>(2) 线程间的通信方式</strong></p><p>1、锁机制：<br>  1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。<br>  1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。<br>  1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。<br>对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br>2、信号量机制：包括无名线程信号量与有名线程信号量<br>3、信号机制：类似于进程间的信号处理。<br>线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的<br>通信机制。</p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><blockquote><p> Object.wait, notify 机制，需要配合 synchronized 一起使用</p></blockquote><p>1、wait()/notify 方法</p><p>(1)wait() 和 notify() 方法要在同步块或同步方法中(synchronized 关键字) 调用，即在调用前，线程也必须获得该对象的对象级别锁。<br>(2)wait方法是释放锁，notify方法是不释放锁的；<br>(3)notify 每次唤醒 wait 等待状态的线程都是随机的，且每次只唤醒一个；<br>(4)notifAll 每次唤醒 wait 等待状态的线程使之重新竞争获取对象锁，优先级最高的那个线程会最先执行；<br>(5)当线程处于 wait() 状态时，调用线程对象的 interrupt() 方法会出现 InterruptedException 异常；</p><p><strong>通过 等待通知模式实现阻塞队列</strong></p><p>(1) 结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">5</span>;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();      <span class="comment">// use for thread communication</span></span><br></pre></td></tr></table></figure><p>(2) 入队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object task)</span> </span>&#123;</span><br><span class="line">    synchronzied(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(task);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        lock.notify();         <span class="comment">// not empty conditon</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obejct oldFront = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait()；</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        oldFront = queue.poll();</span><br><span class="line">        count.getAndDecrment();</span><br><span class="line">        lock.notify();       <span class="comment">// not full condition</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong></p><p>(1) MyBatis 中</p><p>在数据库连接这个地方使用<br>到的：<br>org.apache.ibatis.datasource.pooled.PooledDataSource 类中，所以不用花<br>太多的时间去深究。<br>1、获取连接的时候，如果数据库连接池没有空闲的连接，那么当前线程就会进入等<br>待，直到被通知，这个地方就是popConnection()方法</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="*ThreadLocal"></a>*ThreadLocal</h2><blockquote><p>实现每⼀个线程都有⾃⼰的专属本地变量。</p><p>如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。</p></blockquote><p>如果使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本，  副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p><p>(1)概述</p><p>原理： 为每个使用该变量的线程都提供独立的变量副本，从而不会影响到其他线程所对应的副本。</p><p>是一种<u>多线程间并发访问变量的解决方案</u>，不使用锁来保证并发访问，本质是以空间换时间的方式，为每个线程提供变量的独立副本，以保证线程的安全。</p><p>(2) 作用</p><p>ThreadLocal 的作用是<font color="green">提供线程内的局部变量</font> ，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p><p><strong>底层结构</strong></p><img src="http://img.janhen.com/20201217224620394b8da0-ba21-11e8-87f1-559c9b456754.jpg" alt="img" style="zoom:67%;" /><p>一个Thread中只有一个ThreadLocalMap，</p><p>一个ThreadLocalMap中可以有多个ThreadLocal对象，</p><p>其中一个ThreadLocal对象对应一个ThreadLocalMap中一个的Entry实体</p><p>(也就是说：一个Thread可以依附有多个ThreadLocal对象)。</p><p>(1) Thread 中持有的结构</p><p><u>线程局部变量</u>  ，那么理所当然就应该存储在自己的线程对象中</p><p>线程局部变量存储在 Thread 对象的 threadLocals 属性中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) ThreadLocal.ThreadLocalMap</p><p>是实现 ThreadLocal 的原理，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p><p>KEY: 线程对象；</p><p>VALUE: 对应线程的变量副本；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一些操作</strong></p><p>(1) ThreadLocal 4 大 public 方法</p><p>根据当前线程获取到对应的 ThreadLocalMap，借助该 Map 操作实现；</p><p>get()、 set()、 remove()、 withInitial()。</p><p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上， ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与同步机制的比较</strong></p><pre><code>    a.ThreadLocal与同步机制都是为了 &lt;u&gt;解决多线程中相同变量的访问冲突问题&lt;/u&gt;。     b.前者采用以&quot;空间换时间&quot;的方法，后者采用以&quot;时间换空间&quot;的方式 </code></pre><p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal<br>采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后<br>者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p><p><strong>Thread 造成的内存溢出问题</strong></p><p>(1) 与线程池协作引发的内存溢出问题</p><p><u>ThreadLocal变量是维护在Thread内部的</u>，线程不退出，对象的引用就会一直存在。</p><p>当我们使用线程池的时候，就意味着当前线程未必会退出(比如<u>固定大小的线程池，线程总是存在的</u>)。如果这样的话，将一些很大的对象设置到ThreadLocal中(这个很大的对象实际保存在Thread的threadLocals属性中)，这样的话就可能会出现内存溢出的情况。</p><p>一种场景就是说如果使用了线程池并且设置了固定的线程，处理一次业务的时候存放到ThreadLocalMap中一个大对象，处理另一个业务的时候，又一个线程存放到ThreadLocalMap中一个大对象，但是这个线程由于是线程池创建的他会一直存在，不会被销毁，这样的话，以前执行业务的时候存放到ThreadLocalMap中的对象可能不会被再次使用，但是由于线程不会被关闭，因此无法释放Thread 中的ThreadLocalMap对象，造成内存溢出。</p><p>也就是说，ThreadLocal在没有线程池使用的情况下，正常情况下不会存在内存泄露，但是如果使用了线程池的话，就依赖于线程池的实现，如果线程池不销毁线程的话，那么就会存在内存泄露。所以我们在使用线程池的时候，使用ThreadLocal要格外小心！</p><p>(2) 原因</p><p>ThreadLocal内存泄漏的根源是：由于  <u>ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏</u>  ，而不是因为弱引用。</p><p><strong>弱引用与内存泄漏</strong></p><p>弱引用被回收了只是回收了Entry的key引用，但是Entry应该还是存在的吧？</p><p>ThreadLocal的get(),set(),remove() 的时候都会清除线程ThreadLocalMap里所有key为null的value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123; <span class="comment">/** The value associated with this ThreadLocal. */</span> </span><br><span class="line">  Object value;</span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; </span><br><span class="line">    <span class="keyword">super</span>(k); </span><br><span class="line">    value = v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就需要重新认识一下，什么是：<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>，这里的重点是：<strong>只被弱引用关联的对象</strong></p><p>上述过程尽管 GC 执行了垃圾收集，但是弱引用还是可以访问到结果的，也就是没有被回收，这是因为除了一个弱引用 userWeakReference 指向了User实例对象，还有 user 指向 User 的实例对象，只有当user和User实例对象的引用断了的时候，弱引用的对象才会被真正的回收</p><p>并不是所有弱引用的对象都会在第二次GC回收的时候被回收，而是  <u>回收掉只被弱引用关联的对象</u> 。因此，使用弱引用的时候要注意到！希望以后在面试的时候，不要上来张口就说，弱引用在第二次执行GC之后就会被回收！</p><p><strong>应用场景</strong></p><p>(1) 解决数据库连接</p><p>避免方法中总是出现 Connection 参数，每个线程每次使用的都是用一个  Connection；</p><p>(2) MyBatis 中用于 Session 管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">    Session s = (Session) threadSession.get(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">    &#125; <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池"><a href="#线程池" class="headerlink" title="*线程池"></a>*线程池</h1><p>(1) new Thread 弊端：</p><ul><li><p>每次<code>new Thread</code>新建对象，Thread 为大对象，性能差 ；</p></li><li><p>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或 OOM；</p></li><li><p>缺少更多功能，如更多执行、定期执行、线程中断；</p></li></ul><p>(2) 线程池好处</p><p>重用性： 重用存在的线程，减少对象创建、消亡的开销，性能佳 ；</p><p>可控性： 可有效控制最大井发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞 ；</p><p>功能性： 提供定时执行、定期执行、单线程、井发数控制等功能；</p><p><strong>线程池参数</strong></p><ul><li>corePoolSize: &lt;= x</li><li>maximumPoolSize: 最大线程数</li><li>workQueue: 工作队列，为BlockingQueue</li><li>threadFactory: 默认非守护，同优先级，名称</li><li>rejectHandler:  BlockingQueue 满，无空闲的线程池，拒绝cel，默认直接抛出 exception</li><li>keepAliveTime，unit: corePoolSize  –&gt;&gt; maximumPoolSize </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种拒绝策略： ThreadPoolExecutor 类中提供</p><ul><li><p>AbortPolicythrows exception</p></li><li><p>DiscardPolicy： 直接丢弃</p></li><li><p>CallerRunPolicy： 使用调用者 thread 执行</p></li><li><p>DiscardOldestPolicy： 丢弃 BlockingQueue 中最靠前的 task，执行当前 task</p></li></ul><p><strong>方法</strong></p><p>(1) 主要方法</p><p>生命周期及 ExecutorService：</p><p>- execute()</p><p>- submit(): execute + Future</p><p>- shutdown() : handle BlockingQueue in </p><p>- shutdownNow() : BlockingQueue not handler</p><p>(2) 监控方法：</p><ul><li>getTaskCount()：线程池已执行和未执行的任务总数 </li><li>getCompIetedTaskCount()：已完成的任务数量 </li><li>getPoolSize()：线程池当前的线程数量</li><li>getActiveCount()：当前线程池中正在执行任务的线程数量</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>① Executors.newCachedThreadPool </p><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<strong>调用 execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程</strong>。因此，长时间保持空闲的线程池不会使用任何资源。</p><p>② Executors.newFixedThreadPool</p><p><strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</strong>。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务(如果需要)。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><p>③ Executors.newSingleThreadExecutor</p><p>Executors.newSingleThreadExecutor()返回一个线程池(这个线程池只有一个线程)<strong>,这个线程池可以在线程死后(或发生异常时)重新启动一个线程来替代原来的线程继续执行下去</strong>！</p><p>④ Executors.newScheduIedThreadPool </p><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="number">3</span>); scheduledThreadPool.schedule(newRunnable()&#123; <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;延迟三秒&quot;</span>); &#125; &#125;, <span class="number">3</span>, TimeUnit.SECONDS); scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123; <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;延迟1秒后每三秒执行一次&quot;</span>); &#125; &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>⑤ <strong>线程池配置</strong></p><p>CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU + 1IO 密集型任务，参考值可以设置为 2 * NCPU；</p><p>选用基础：</p><p>- 小型应用不适合</p><p>- 线程调度时间开销大</p><p>@@计算密集型与IO密集型</p><p>密集型：  CPU 核 + 1<br>IO 密集： CPU 核数 / (1-阻塞系数)   一般0。8~0.9</p><p>@@如何正确的使用线程池</p><p>设置线程池，比设置界限；</p><p>hook 机制嵌入行为，由 beforeMethod, afterMethod 记录线程执行前和后做日志，异常结果；</p><p>优雅的关闭，hook 机制，推荐使用 JavaBean 创建线程池，在 destoryMethod 里面在销毁时调用 shutdown；</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>(1) 概述</p><p>Java 并发采用的是共享内存模型，线程之间的通信总是隐式执行。</p><p>定义： Java 线程之间的通信由 JMM 控制， <u>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</u>。</p><p>Java内存模型(JMM)解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”</p><ol><li><p>主内存与工作内存<br> 主内存副本拷贝，非对整个obj拷贝。<br> Java借助共享内存实现线程间的通信</p></li><li><p>内存间的交互操作<br> 8中操作, 主内存，保证原子性；<br> 对于long和double的特殊规则(了)<br> 64位</p></li><li><p>对于volatile变量的特殊规则<br> 语义：</p></li></ol><ul><li>可见性, 实现对于其修改立即写回主内存中, 非保证原子性;</li><li>有序性, 禁止指令重排序, 是一种同步机制, 轻量, 与DCL实现安全的单例.  </li></ul><ol start="4"><li>原子性、可见性与有序性<br>volatile：<br>finale: this 引用逃逸(读初始化一般的data)；<br>synchronized: “万能”, 重量, 阻塞</li></ol><p>硬件的效率与一致性:<br>缓存一致性协议</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="*volatile"></a>*volatile</h3><img src="http://img.janhen.com/20201217224645image-20201031124307603.png" alt="image-20201031124307603"  /><p>能够在线程之间保持可见性，能够被 <strong>多线程同时读</strong>，并且保证不会读到过期的值，但 <strong>只能被单线程写</strong>。<br>基于 happens-before 原则，对 volatile 字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile 变量。</p><p>volatile是轻量级的synchronized，他的意思是：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度</p><p>(1) 特性</p><p>a.volatile关键字为域变量的访问提供了一种免锁机制， </p><p>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， </p><p>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 </p><p>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 </p><p><strong>volatile 保证可见性</strong></p><p>有volatile变量修饰的共享变量进行写操作的时候会引发了两件事情：<br>(1)将当前处理器缓存行的数据写回到系统内存；<br>(2)这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效；</p><p>底层实现细节(了)：</p><p>① 发生 volatile  W， JVM 向处理器发送 Lock 前缀的汇编命令，将该变量缓存行写到系统内存；</p><p>② 为了保证写回到的数据被其他线程立即可见，借助  缓存一致性协议  实现，每个处理器 嗅探总线 上传播的数据检查自己是否过期，过期强制从系统内存中把数据读到处理器缓存中。</p><p><img src="http://img.janhen.com/202012172246521553822343527.png" alt="1553822343527"></p><p><strong>volatile 如何禁止指令重排序</strong> </p><p>借助内存屏障和禁止指令重排实现</p><ul><li>对 volatile 变量写操作时，会在<strong>写操作之后</strong>加上一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；</li><li>对 volatile 变量的读操作，会在<strong>读操作之前</strong>加上一条 load 屏障指令，从主内存中读取共享变量。</li></ul><p>使用volatile关键字修饰共享变量可以禁止重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序<br>volatile禁止指令重排序的一些规则：<br>　　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序</p><p>　　2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序</p><p>　　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</p><p>涉及到内存屏障(Memory Barrier)，它是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p><p><strong>一些应用</strong></p><ul><li><p>无锁读取数据： ConcurrencyHashMap 的 get 操作，通过 volatile 替换锁，AQS 中 state 变量；</p></li><li><p>作为终止标识，exit 来进行终止，类似 interrupt 终止；</p></li><li><p>那么在禁止重排序时是一个较好的使用场景，否则我们不需要再使用它，如 DCL 中通过 volatile 修饰；</p></li><li><p>热部署的变量： 通过线程修改之后立即被其他线程可见；</p></li></ul><p>适用场景： </p><p>(1) 对变量的写操作不依赖于当前值(比如 i++)，或者说是单纯的变量赋值(boolean flag = true)。 </p><p>(2)该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>字解决的是多个线程之间访问资源的同步性。</p><p>(1) 一些性质：</p><ul><li>提供原子性，实现同步功能；</li><li>是 JVM 提供的同步工具，使用 lock 和 unlock 字节码指令，保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏；</li><li>与 CAS 比较： 相比于 CAS 可以保证 <strong>一块</strong> 而非一个变量的原子性；</li><li>与 Lock 比较： 相比于 JDK Lock 可以保存 <strong>程序运行信息</strong> ，便于解决死锁和异常；</li></ul><p>(2) 使用的位置：</p><ul><li>code bloker： 显视锁住当前调用对象  synchronized(this)，通过监视器锁实现；</li><li>method: 锁住调用对象，通过访问标识位实现；</li><li>static method: 锁住该类的所有对象；</li><li>class: 显视锁住类对象 synchronized(xxx.class)；</li></ul><p>适用同一个对象调用锁住 obj 的可以实现同步，使其中的一个线程阻塞等待另一个线程执行完毕；不同对象调用时不适用；</p><p><strong>synchronized 保证可见性原理</strong></p><p>通过 javap -v xxx.class 获取字节码指令分析</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><p>JMM 对 synchronized 的规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存；</li><li>线程加锁时，将<em>清空工作内存</em> 中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值(注意，<code>加锁与解锁是同一把锁</code>)；</li></ul><p>本质是对一个对象的监视器(monitor) 进行获取，而这个获取过程是排他的，也就是说同一时刻只有一个线程<br>获取到由 synchronized 所保护对象的监视器。</p><p><strong>(1) 对代码块同步</strong></p><p>monitorenter 和 monitorexit 指令</p><p>Synchronized 每个对象有一个  <u>内置的监视器锁(monitor)</u>  。当 monitor 被占用时就会处于锁定状态，线程执行monitorenter 指令时尝试获取monitor的所有权，过程如下：<br>1、如果 monitor 的进入数为0，则该线程进入 monitor，然后将进入数设置为1，该线程即<br>为 monitor 的所有者。<br>2、如果线程己经占有该 monitor，只是重新进入，则进入monitor 的进入数加1．<br>3．如果其他线程巳经占用了 monitor ,则该线程进入阻塞状态，直到 monitor 的进入数为0，再重新尝试获取monitor的所有权。</p><p><strong>(2) 同步方法</strong></p><p>调用指令将会检查方法的 <code>ACC_SYNCHRONIZED</code> 访问标志是否被设置，如果设置了，  <u>执行线程将先获取 monitor，获取成功之后才能执行方法体</u>  ，方法执行完后再释放 monitor Synchronize和lock都属于同步阻塞。 </p><p><strong>synchronized 其他性质</strong></p><p>(1) 作为锁</p><p>见下部分锁相关</p><p>(2) 原子性</p><p>@Q: CAS 机制与 synchronized 保证原子性的区别？</p><p>① CAS 仅能够保证一个变量的原子性，而 synchronized 可用于方法、类、字段等多处；</p><p>② CAS 通过不断循环重试实现，存在不必要的开销，但是是一种无锁的实现；</p><p>③ CAS 存在 ABA 问题；</p><p>Q: JDK1.6+ 的 synchronized 关键字做了哪些优化?</p><p>对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗 化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：⽆锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈⽽逐渐升级。锁可以升级不可降级，提⾼获得锁和释放锁的效率。</p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p><strong>原子性</strong></p><p>提供了互斥访问，同一时刻只能有一个线程对它进行操作。</p><p>(1) 实现方式：</p><ul><li>锁的同步机制：  synchronized | Lock</li><li>CAS 机制： 包括 AtomicInteger 等原子类</li></ul><p><strong>可见性</strong> </p><p>一个线程对主内存中共享变量的修改，能够及时地被其他线程观察到。</p><p>(1) 不可见的原因： </p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul><p>(2) 实现方式</p><p>volatile 关键字可以保证共享变量的可⻅性。</p><p><strong>有序性：</strong> </p><p>代码在执⾏的过程中的先后顺序。</p><ul><li>Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性，导致代码的执⾏顺 序未必就是编写代码时候的顺序。</li><li>volatile、synchronized、Lock</li></ul><h2 id="happen-before-原则"><a href="#happen-before-原则" class="headerlink" title="*happen-before 原则"></a>*happen-before 原则</h2><ol><li>单一线程原则</li></ol><blockquote><p>Single Thread Rule</p></blockquote><p>一个线程内，程序前面的操作先于后面的操作。也叫程序次序原则。</p><ol start="2"><li>管程锁定原则</li></ol><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock option 先于后面同一个锁的 lock option。</p><ol start="3"><li>volatile 变量规则</li></ol><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先于后面对这个变量的读操作。</p><ol start="4"><li>传递性原则</li></ol><blockquote><p>Transitivity</p></blockquote><p>A –&gt; B, B –&gt; C  ==&gt;&gt; A –&gt; C</p><ol start="5"><li>线程启动规则</li></ol><blockquote><p>Thread Start Rule丶。 入</p></blockquote><p>Thread 对象的 start() 先于此线程的每一个动作</p><ol start="6"><li>线程中断规则</li></ol><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 的调用先于被中断线程的代码检测到中断事件的发生，即 isInterrupt().</p><ol start="7"><li>线程加入规则</li></ol><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先于 join() 方法返回</p><ol start="8"><li>对象终结规则</li></ol><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成(构造函数结束)先于它的 finalize() 方法的开始</p><h2 id="线程同步的实现"><a href="#线程同步的实现" class="headerlink" title="线程同步的实现"></a>线程同步的实现</h2><p>说明： 需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p><p><strong>1、 互斥同步</strong> </p><p>(1) 同步方法 、同步代码块 </p><p>(2) 使用重入锁实现线程同步</p><p>(3) 使用阻塞队列实现线程同步</p><p><strong>2、 非阻塞同步</strong></p><p>主要是 CAS 不断尝试实现</p><p>(1) 使用原子变量实现线程同步</p><p><strong>3、 无同步方案</strong></p><p>(1) 使用局部变量实现线程同步<br>    如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p><p>(2) 使用特殊域变量(volatile)实现线程同步</p><p> 注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 </p><h1 id="锁与锁优化"><a href="#锁与锁优化" class="headerlink" title="锁与锁优化"></a>锁与锁优化</h1><p><strong>线程安全</strong></p><ol><li>Java语言中的线程安全<br>绝对线程安全<br>相对线程安全<br>线程兼容<br>线程对立</li></ol><p><strong>2. 线程安全的实现方法</strong><br><em>1)同步互斥</em><br><strong>Synchronized：</strong>存在挂起、恢复，是<em><u>阻塞</u></em>  实现的，且java线程直接映射到OS原生线程上的，存在用户态到内核态的_<u>转换</u>_，因而性能较差。</p><p><strong>Lock：</strong>可重用锁</p><p>2)非阻塞<br>基于CAS+Loop实现</p><p>3)无同步</p><ul><li>可重入代码</li><li>TLC，线程本地， 是消息队列架构模式</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><strong>乐观锁</strong></p><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是  <u>在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</u>  (比较跟上一次的版本号，如果一样则更新)，如果失败则要重复读-比较-写的操作。 java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，  <u>  比较当前值跟传入值是否一样，一样则更新，否则失败</u>。</p><p><strong>悲观锁</strong></p><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是  <u>Synchronized</u>,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p><h2 id="JVM-锁优化"><a href="#JVM-锁优化" class="headerlink" title="JVM 锁优化"></a>JVM 锁优化</h2><p>锁有四种状态，无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><p>通过 对象头实现</p><p>(1) 原理：</p><p>基于对象头的Mark Word， 23位表示偏向的线程ID</p><p><strong>偏向锁</strong></p><p>偏向锁的目的是在某个线程获得锁之后，<u>消除这个线程锁重入(CAS)的开销</u>，看起来让这个线程得到了偏护</p><p>而偏向锁只需要在置换 ThreadID 的时候依赖一次CAS原子指令</p><p><strong>如果一个线程获得了锁，那么锁就进入了偏向模式。当这个线程再次请求锁时，无需再做任何同步操作</strong></p><p>(1) 设计原因</p><p>为什么会出现这种设计的方式那？这是因为根据HotSpot的作者研究，他发现  <u>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</u>  ，为了让线程获得锁的代价更低而引入了的偏向锁这个概念。</p><p>(2) 锁的升级</p><p>在锁竞争比较激烈的场景，最有可能的情况是每次不同的线程来请求相同的锁，这样的话偏向锁就会失效，倒不如不开启这种模式，幸运的是Java虚拟机提供了参数可以让我们有选择的设置是否开启偏向锁。<br>如果偏向锁失败，虚拟机并不会立即挂起线程，而是使用轻量级锁进行操作。</p><p>(3) 性质：</p><p>线程获取到锁之后，消除这个线程的重入开销；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking</span><br></pre></td></tr></table></figure><p><strong>轻量级锁</strong></p><p>轻量级锁是为了<u>在线程交替执行同步块时提高性能</u>，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><p>如果偏向锁失败，虚拟机并不会立即挂起线程，而是使用轻量级锁进行操作。轻<u>量级锁他只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。</u>  如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先夺到锁，那么当前线程的轻量级锁就会膨胀为重<br>量级锁。</p><p>轻量级锁所适应的场景是 <u>线程交替执行同步块</u> 的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p><p>(1) 说明：</p><p>嵌入在线程栈中的对象<br>使用 Displaced Mark Word 复制对象头到堆栈中，借助CAS实现同步。<br>还是需要进行 CAS , 出现竞争时，会尝试自旋</p><p>(2) 原理：</p><p>绝大部分锁在整个同步周期内都是不存在竞争的</p><p><strong>自旋锁(无锁)</strong></p><p>(1) 原理</p><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>(2) 优缺点</p><p>(3) 时间阈值</p><p>在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是  <u>由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</u>，基本认为一个线程上下文切换的时间是最佳的一个时间。</p><p>(4) 一些实现</p><p>在通过一定的自旋失败后，通常转化为加悲观锁实现，如 ConcurrentHashMap 中对于 put 在尝试 3 次失败后进行转换成对链表头进行加锁；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSpinning</span><br></pre></td></tr></table></figure><p><strong>自适应锁</strong><br>原来默认是10，现在可以实现自适应自旋</p><p>自适应，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><p>如ConcurrentHashMap的tryLock()</p><blockquote><p>-XX:+UseSpinning      1.7默认开启<br>-XX:PreBlockSpin     默认为10，代表</p></blockquote><p><strong>锁消除</strong><br>不存在共享数据竞争，需要对其进行<code>逃逸分析</code>，从而减少不必要的锁。</p><p><strong>锁粗化</strong><br>防止在循环中加锁，进行资源的浪费</p><p><strong>锁的对比</strong></p><h2 id="程序锁优化"><a href="#程序锁优化" class="headerlink" title="程序锁优化"></a>程序锁优化</h2><p><strong>1.减少锁粒度</strong></p><p>将大对象(这个对象可能会被很多线程访问)，拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。</p><p>() 应用</p><p>① 最最典型的减小锁粒度的案例就是ConcurrentHashMap。进而提高并发程度<br>如将 HashMap –&gt; ConcurrentHashMap使用Segment(16)增加并行度。</p><p><strong>2. 减少锁持有时间</strong></p><p>只用在有线程安全要求的程序上加锁</p><p>只在有必要的时候进行同步，这样就明显减少了线程持有锁的时间，从而<br>提高系统的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method1();                             <span class="comment">// cost much time</span></span><br><span class="line">    mutextMethod();   <span class="comment">// 实际需要进行同步的方法</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 锁分离</strong><br>如根据功能进行锁分离<br>(1) 应用</p><p>① ReadWriteLock，即保证了线程安全，又提高了性能。</p><p>在读多写少的情况下，通过 ReentrantReadWriteLock 替换 ReentrantLock，实现对于 Read 的不加锁实现；</p><p>② 读写分离思想可以延伸，  <u>只要操作互不影响，锁就可以分离</u>  。比如LinkedBlockingQueue 从头部取出，从尾部放数据。</p><p>如果使用独占锁的话，则要求两个操作在进行时首先要获取当前队列的锁，那么take<br>和put就不是先真正的并发了，因此，在JDK中正是实现了两种不同的锁，一个<br>是takeLock一个是putLock。</p><p><strong>4. 锁粗化</strong><br>不在循环中加锁，来回加和释放的开销大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第一次加锁</span></span><br><span class="line">    method1();</span><br><span class="line">    &#125;</span><br><span class="line">    method3();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第二次加锁</span></span><br><span class="line">    mutextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    method4();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第三次加锁</span></span><br><span class="line">    method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第一次和第二次加锁和线程上下文切换的时间超过了method1()、method2()method3()、method4() 的时间.</p><p>改进后的代码的执行时间可能小于上述分别加锁的时间，这就是锁粗化，也是一种锁<br>优化的方式，但是要根据具体的场景；</p><p><strong>5. 锁消除</strong></p><p>锁消除是在  <u>编译器级别的事情</u>。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。</p><p>引发原因：</p><p>① 多数是因为程序员编码不规范引起。</p><p>② 有时这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector<br>和StringBuffer 这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线<br>程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性<br>能。</p><p>**6. JVM 锁优化(volatile, synchronized) **</p><p>见上部分</p><h2 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="*synchronized"></a>*synchronized</h2><p>(1) 作用范围</p><p>(2) 核心组件</p><ol><li><p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p></li><li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p></li><li><p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p></li><li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； </p></li><li><p>Owner：当前已经获取到所资源的线程被称为Owner；</p></li><li><p>!Owner：当前释放锁的线程。</p></li></ol><p>() 底层实现</p><p><img src="http://img.janhen.com/202012172247111553496683656.png" alt="1553496683656"></p><p>是非公平锁，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList；</p><p>每个对象后有个 monitor 对象， <u>加锁就是在竞争 monitor 对象</u> ， 代码块加锁是在前后分别加上monitorenter和monitorexit指令来实现的，方法加锁是通过一个标记位来判断的。</p><p><strong>与 ReentrantLock 对比</strong></p><p>相同点： 都是可重入锁。</p><p>① 底层实现：ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的，为关键字，能够在出现异常时打印出对应的错误堆栈用于分析问题，同时 JVM 对 synchronized 提供了锁升级的优化；</p><p>② 锁的实现方式： ReentrantLock 是同步非阻塞，采用的是乐观并发策略，而 synchronized 是同步阻塞，使用的是悲观并发策略。</p><p>③ 锁的使用的安全性： ReentrantLock 需要显视加锁解锁，可能因为忘记解锁而陷入死锁，而 synchronized 为隐式加锁，不会因为忘记解锁而陷入死锁。</p><p>④ 功能灵活性：</p><ul><li>ReentrantLock 可尝试获取锁；</li><li>RentrantLock 可中断获取锁，提供了⼀种能够中断等待锁的线程的机制，<code>lock.lockInterruptibly()</code> ；</li><li>RentrantLock 能够支持公平锁, synchronized 只能实现非公平锁；</li><li>RentrantLock 可实现选择性通知： synchronizedf 使用 notify / notifyAll 进行通知时，通知的线程由 JVM 选择，ReentrantLock 更加灵活的绑定多个 Condition, 进行选择性通知。</li></ul><p>1 ReentrantLock显示的获得、释放锁，synchronized隐式获得释放锁<br>2 ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>3 ReentrantLock是API级别的，synchronized是JVM级别的<br>4 ReentrantLock可以实现公平锁<br>5 ReentrantLock通过Condition可以绑定多个条件<br>6 底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略<br>7 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。<br>8 synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。<br>9 Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。<br>10 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>11 Lock可以提高多个线程进行读操作的效率，既就是实现读写锁等。</p><p><strong>synchronized 与volatile 的比较</strong></p><p>① 实现与性能：volatile关键字是线程同步的 <u>轻量级</u>实现，所以 <font color="green">volatile性能肯定⽐synchronized关键字要好</font>。 但是 <font color="green">volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块</font>。 synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗 ⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤ synchronized 关键字的场景还是更多⼀些。</p><p>② 阻塞： 多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞</p><p>③ 三特性的： volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。synchronized关键字两者都能 保证。</p><p>④ 使用场景： volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是 多个线程之间访问资源的同步性。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><p>(1) 死锁的四个必要条件：</p><ul><li><p>互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。</p></li><li><p>持有和等待条件： ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</p></li><li><p>不可剥夺条件：线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后 才释放资源。</p></li><li><p>循环等待条件：:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</p></li></ul><p>(2) 避免线程死锁</p><p>① 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p>② 破坏请求与保持条件 ：⼀次性申请所有的资源。</p><p>③ 破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>④ 破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。</p><p><strong>相关问题</strong></p><p>(1) 如何确保N个线程可以访问N个资源同时又不导致死锁？</p><p>① 指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了；</p><p>② 使用带有超时时间的锁；</p><p>③ 通过死锁的检测和恢复机制进行规避；</p><p>(2) 写一个发生死锁的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock1</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;flag1 one level&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;flag 1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;flag2 one level&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;flag 2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock1(<span class="number">1</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock1(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><p><strong>无锁</strong></p><p>CAS算法的过程是这样：<u>它包含三个参数CAS(V,E,N): V表示要更新的变量，E</u><br><u>表示预期值，N表示新值。仅当V值等于E值时</u>，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。</p><p><strong>可重入锁(递归锁)</strong></p><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</p><p>偏向锁对于偏向的线程没有重入的开销。</p><p><strong>公平锁和非公平锁</strong></p><p>公平锁(Fair)</p><p> 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。</p><p>非公平锁(Nonfair) </p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</p><ol><li>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列 </li><li> Java中的synchronized是非公平锁，ReentrantLock 默认的lock()方法采用的是非公平锁。</li></ol><p><strong>读写锁</strong></p><blockquote><p>读读不互斥，读写互斥，写写互斥</p></blockquote><p>为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 </p><p>(1) 读锁 </p><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p><p>(2) 写锁 </p><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock。</p><p><strong>共享锁和独占锁</strong></p><p>java并发包提供的加锁模式分为独占锁和共享锁。 </p><p>(1) 独占锁</p><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p>(2) 共享锁</p><p> 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p><ol><li>AQS的内部类Node定义了两个常量 SHARED 和 EXCLUSIVE ，他们分别标识 AQS队列中等待线程的锁获取模式。 </li><li> java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</li></ol><p><strong>重量级锁(Mutex Lock)</strong> </p><p>Synchronized是通过对象内部的一个叫做监视器锁(monitor)来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p><p>因此，这种  <u>依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”</u>。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><p><strong>分段锁</strong></p><p>是一种思想ConcurrentHashMap是学习分段锁的最好实践</p><p><strong>活锁</strong></p><p>因为活跃性而引入的问题</p><h1 id="并发中的设计模式"><a href="#并发中的设计模式" class="headerlink" title="并发中的设计模式"></a>并发中的设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证全局唯一，并发情况下使用安全</p><p>见设计模式单例</p><p>7 种单例模式：</p><p>饿汉式；</p><p>双重监测懒汉式；</p><p>线程安全懒汉式；</p><p>静态内部类持有懒汉式；</p><p>枚举式；</p><p>变种的饿汉式；</p><p>变种的懒汉式；</p><h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>Future模式的核心思想：异步调用</p><p>不仅可以在子线程完成后收集其结果，还可以设定子线程的超时时间，避免主任务一直等待。</p><p>() 性质<br>Future模式不会立即返回你需要的数据，但是，他会返回一个契约 ，以后在使用到数据的时候就可以通过这个契约获取到需要的数据。</p><p>在广义的Future模式中，虽然获取数据是一个耗时的操作，但是服务程序不等数据完成就立即返回客户端一个伪造的数据(就是上述说<br>的“契约”)，实现了Future模式的客户端并不急于对其进行处理，而是先去处理其他业<br>务，充分利用了等待的时间，这也是Future模式的核心所在，在完成了其他数据无关的任务之后，最后在使用返回比较慢的Future数据。这样在整个调用的过程中就不会出现长时间的等待，充分利用时间，从而提高系统效率。</p><p>() JDK 中的 Future 模式</p><p>FutureTask实现了 Callable，Future接口，RunnableFuture接口继承了Future和<br>Runnable接口。因为RunnableFuture实现了Runnable接口，因此FutureTask可以提<br>交给Executor进行执行，FutureTask有两个构造方法，如下：</p><p>Runnable 与 Callable 的区别</p><p>(1) Callable规定的方法是call()，Runnable规定的方法是run()；<br>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值得；<br>(3) call()方法可以抛出异常，run()方法不可以；<br>(4) 运行Callable任务可以拿到一个Future对象，Future 表示异步计算的结果</p><p>() 异常</p><p>Future 的 get() 可能会阻塞当前线程的执行，会抛出 InterruptedExcpeiton、ExecutionException，若线程已经取消，抛出 CancellationException，取消由cancel 方法来执行。isDone确定任务是正常完成还是被取消了。</p><p>() 可取消性</p><p>一旦计算完成，就不能再取消计算。如果为了可取消性而使用Future 但又不提供可<br>用的结果，则可以声明Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>使用生产者消费者模式实现的一个例子；<br>模仿分布式爬虫；</p><p>单生产者单消费者</p><p>单生产者多消费者</p><p>多生产者单消费者</p><p>多生产者多消费者</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li>《Java 并发编程的艺术》</li><li>《深入理解Java虚拟机(第二版)》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 代码首先会编译成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="http://example.com/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-17T14:41:19.000Z</published>
    <updated>2021-04-15T02:51:11.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-基础"><a href="#Docker-基础" class="headerlink" title="Docker 基础"></a>Docker 基础</h1><blockquote><p>类似精简的 Linux 环境，含 root 权限、进程空间、用户空间和网络空间，以及运行在其中的应用程序</p></blockquote><p><img src="http://img.janhen.com/1566961968709.png" alt="1566961968709"></p><p>Client： 客户端通过 CLI 命令与 Docker 交互<br>Docker daemon： 宿主机的守护进程，通过 RESTful 接口处理 Client 的命令，连接 Registry 进行镜像的拉取的推送，具体配置见 [Daemon配置](#Daemon 配置)<br>Registry： 保存 image 的地方，实现 image 的维护、复用<br>Image： 静态的镜像，可根据 Image 运行 container<br>Container： 依据 Image 生成的具体的容器，实际运行的程序</p><p>Docker 底层实现原理：</p><ul><li>Namespaces：做隔离pid，net，ipc，mnt，uts</li><li>Control groups(cgroups)：做资源限制</li><li>Union file systems: Container和image的分层，分层文件系统</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><blockquote><p>一个特殊的文件系统，提供容器运行时所需的程序，同时包含一些为运行时准备的配置参数，无法更改</p></blockquote><p><strong>镜像的获取</strong></p><ul><li>根据 Dockerfile 构建镜像，配合 sh 脚本实现一些定制的初始化和参数判断逻辑，可重建</li><li>根据容器构建镜像，在只读镜像上操作可写容器重新打包成镜像，Docker 无状态，volume 不会打包进镜像，较少使用</li><li>从远程 Registry 拉取镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程 registry 拉取</span></span><br><span class="line">docker commit wonderful_mendeleev janhen/centos-vim-gcc:1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 Dockerfile 构建</span></span><br><span class="line">docker build -t janhen/myimage:1.0 .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器创建</span></span><br><span class="line">docker pull &lt;registry_host&gt;/&lt;username OR project_name&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span><br></pre></td></tr></table></figure><p><strong>镜像 tag</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> image 的查、交互</span></span><br><span class="line">docker images</span><br><span class="line">docker history &lt;image_id&gt;</span><br><span class="line">docker tag &lt;image_old_name&gt; &lt;image_new_name&gt;</span><br></pre></td></tr></table></figure><p><strong>镜像清理</strong></p><p>处理同一个版本多次覆盖，默认查找顺序为 Local -&gt; Registry 的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   删除指定的 image</span></span><br><span class="line">docker rmi &lt;image_id OR image_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">   强制删除指定|全部 image</span></span><br><span class="line">docker rmi -f $(docker images)</span><br><span class="line"><span class="meta">#</span><span class="bash">   删除 &lt;none&gt; 的镜像(<span class="comment">#)</span></span></span><br><span class="line">docker rmi $(docker images -f &quot;dangling=true&quot; -q)</span><br><span class="line">docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27; | xargs docker rmi</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote><p> 是镜像运行时的实体，构建在镜像上，可对容器进行写操作</p></blockquote><p><strong>Container 的启动并运行</strong></p><p>单机上使用最多，控制部署时候的各种参数，包含网络、存储、密码、变量…</p><p>常用的启动指定：</p><ul><li><p>指定网络，根据需要选择端口转发、单机桥接网络、多机网络、主机网络</p></li><li><p>指定文件映射，将程序中的配置文件、数据文件隔离出来，避免应容器销毁而丢失</p></li><li><p>指定命令，内部运行的程序自带的命令，如 Redis 中的命令控制持久化方式…</p></li><li><p>指定变量，通过命令方式、环境变量方式指定，让运行容器更加定制化</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --name: 按照特定名称启动，作为容器标识</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -d: 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -i: 交互式运行容器，打开STDIN，用于控制台交互 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -t: 终端方式交互, 通过 bash、shell... 进行命令式交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -p: 映射宿主机与容器的端口号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --network=&lt;value&gt;: 指定网络连接类(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -v: 进行宿主机文件与容器文件的映射(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --&lt;param&gt;=&lt;value&gt;: 进行特定参数指定，传入中的参数，在容器中的文件处可引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -e: 指定环境变量, 对应镜像提供，与 Dockerfile 中指定的 ENV 等同，可进入容器使用 env 查看(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --privileged=<span class="literal">true</span>: 给容器扩展的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --rm: 在容器终止运行后自动删除容器文件，避免磁盘浪费，常用于测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --restart=&lt;strategy&gt;: 重启策略，与 --rm 参数冲突，提供多种策略</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --entrypoint: 覆盖默认镜像的 ENTRYPOINT</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --link: 添加链接到另一个 container, 不建议使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -w: 指定工作目录，等价于 Dockerfile 中的 WORKDIR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动过后执行一段 Shell 脚本, 用于测试环境类镜像使用</span></span><br><span class="line">docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以命令行方式进入容器，查看镜像具体情况</span></span><br><span class="line">docker run -it --entrypoint bash openjdk:7-jre </span><br><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile 中环境变量配合运行指定 JVM 运行参数、运行端口，参数名仿照 spring-boot maven 插件</span></span><br><span class="line">docker run -d -p 7070:7070 -e JVM_OPTS=&quot;-Xms1024m -Xmx2048m&quot; -e PROGRAM_ARGS=&quot;--server.port=7070&quot; com.blinkfox/web-demo:1.0.0</span><br><span class="line">docker run -e &quot;JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=5005,server=y,suspend=n&quot; -p 8080:8080 -p 5005:5005 -t springio/gs-spring-boot-docker</span><br><span class="line">docker run -d --name test1 \</span><br><span class="line">  -e MYENV=AAAA \ </span><br><span class="line">  busybox /bin/sh -c &quot;while true;do sleep 3600;done&quot;</span><br></pre></td></tr></table></figure><p><strong>容器的信息查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器整体信息查询</span></span><br><span class="line">docker info</span><br><span class="line">docker info | grep &quot;Docker Root Dir&quot;</span><br><span class="line">docker ps [(-a)|(-aq)]?</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置信息</span></span><br><span class="line">docker inspect &lt;container&gt;</span><br><span class="line">docker inspect -f &#123;&#123;xx.yy&#125;&#125; &lt;container&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 交互，调试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   日志，  -f ： follow <span class="built_in">log</span> output，持续实时显示日志，   -t:......</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   命令交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在容器中执行特定命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志查看</span></span><br><span class="line">docker logs &lt;contain_id OR container_name&gt;</span><br><span class="line">docker logs -f &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内部执行</span></span><br><span class="line">docker exec -it &lt;container_id&gt; bash</span><br><span class="line">docker exec &lt;container_id&gt; ip a</span><br><span class="line">docker exec -it &lt;container_id OR container_name&gt; env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行信息</span></span><br><span class="line">docker stat &lt;container&gt;</span><br></pre></td></tr></table></figure><p><strong>容器基础命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的启、停</span></span><br><span class="line">docker container start|stop|restart &lt;container_id OR contaienr_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入导出</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   导出容器成指定的 tar 包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   容器快照文件导入为*镜像*</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   URL/目录导入</span></span><br><span class="line">docker export 7691a814370e &gt; ubuntu.tar</span><br><span class="line">cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><p><strong>容器的清理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除|强制删除指定的容器</span></span><br><span class="line">docker container rm &lt;container_id OR container_name&gt;</span><br><span class="line">docker contaienr rm -f &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已停止运行的容器(<span class="comment">#)</span></span></span><br><span class="line">docker rm $(docker ps -f &quot;status=exited&quot; -q)</span><br></pre></td></tr></table></figure><p><strong>Container 交互</strong></p><blockquote><p>容器内部可执行的命令，特定目录存储的配置内容，可以通过 CLI 的监控命令</p></blockquote><p>支持更改 /etc/hosts， /etc/hostname，/etc/resolv.conf ，只针对运行时，临时的更改</p><p>几种交互方式：</p><ul><li><p>运行时直接进入交互、运行时直接执行命令交互，包含对文件的操作、内部命令执行</p></li><li><p>运行后按特定终端进入交互、运行后按特定命令交互，同上</p></li><li><p>日志交互，logs，支持最后几行、最近的时间点、实时显示</p></li><li><p>基本情况，inspect，返回运行情况 JSON 字符串，可通过 Go  Templete 获取特定情况</p></li><li><p>运行的资源情况，stats，实时显示 CPU、内存、网络、磁盘情况</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器内部</span></span><br><span class="line">docker exec -it -u root jenkins sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行特定命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   创建之后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在已运行的容器中执行命令</span></span><br><span class="line">docker run -it --rm ubuntu:18.04  ip a</span><br><span class="line">docker run -it --rm ubuntu:18.04 --hostname=test.com --dns=172.16.3.3 ip a</span><br><span class="line">docker run -it --rm ubuntu:18.04  cat /etc/resolv.conf</span><br><span class="line">docker exec -it gitlab cat /etc/resolv.conf</span><br><span class="line">docker exec -it gitlab cat /etc/hostname</span><br><span class="line">docker exec -it gitlab cat /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内部执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看挂载情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看定义的环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 dns 情况, 与在宿主机上的 /etc/docker/daemon.json 上配置 dns 类似?</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看容器IP地址配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看路由情况</span></span><br><span class="line">mount</span><br><span class="line">env</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">ip addr show eth0</span><br><span class="line">ip route</span><br><span class="line"><span class="meta">#</span><span class="bash"> logs 查看</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   特定时间偏移, 特定时间段</span></span><br><span class="line">docker logs -f -t --since=40m --tail=10 jenkins</span><br><span class="line">docker logs -t --since=&quot;2019-08-01T13:23:37&quot; --until &quot;2018-08-31T12:23:37&quot; jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> inpect 查看</span></span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; 1f1f4c1f931a</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">stat</span> 查看</span></span><br><span class="line">docker stats &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝文件，作为 Dockerfile 中 COPY 的...</span></span><br><span class="line">docker cp &lt;host_machine file OR dir&gt; &lt;container_name&gt;:&lt;container_dir&gt;</span><br></pre></td></tr></table></figure><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><blockquote><p>Docker 的私有仓库，实现容器的复用共享</p></blockquote><p>发布镜像到 Registry 的方式：</p><ul><li><p>发布镜像到仓库</p><p>  直接将本地已经构建好的镜像发布到仓库中</p></li><li><p>根据指定 Dockerfile 由 Docker hub 进行构建形成镜像</p><p>自动在 git 发生变化的时候拉取数据进行构建重新发布到仓库上，自动构建发布，CICD</p><p>保证镜像的可再生性</p></li></ul><p>私有 Registry 搭建：</p><p>官方提供的 registry</p><p>Vmware 开源的 harbor，见 <a href="./B-%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%8E%AF%E5%A2%83.md#harbor">工具与环境</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录 docker hub 账号和密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送镜像到 docker hub</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker hub 关联 github or bitbucket</span></span><br><span class="line">docker login 172.17.11.29:5111 -u admin -p Harbor12345</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名镜像的名称(tag)</span></span><br><span class="line">docker push 172.17.11.29:5111/centos-vim-gcc:1.0.0</span><br><span class="line">docker tag janhen/centos-vim-gcc:1.0.0 172.17.11.29:5111/study-docker/centos-vim-gcc:1.0.0</span><br><span class="line">docker push 172.17.11.29:5111/study-docker/centos-vim-gcc:1.0.0</span><br></pre></td></tr></table></figure><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><blockquote><p>进行容器之间的访问，包含单机上的访问，多台机器之间的访问； 含端口映射、容器互联</p><p>关联文档:  <a href="https://yeasy.gitbooks.io/docker_practice/network/">使用网络</a>  |  <a href="https://yeasy.gitbooks.io/docker_practice/advanced_network/">高级网络配置</a></p></blockquote><p><strong>Linux 上网络访问</strong></p><blockquote><p> Linux 网络命名空间，进行网络的隔离</p></blockquote><p>Veth pair： 进行网络命名空间的连接，实现两个 net namspce 连接通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网络命名空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给命名空间分配 ip 地址, 默认情况下只有 mac 地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动接口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接双方使其网络互通</span></span><br><span class="line">ip netns list</span><br><span class="line">ip netns delete test1</span><br><span class="line">ip netns exec test2 ip link</span><br><span class="line">ip netns exec testl ip link set dev veth-testl up</span><br><span class="line">ip netns exec testz ip link set dev veth-test2 up</span><br></pre></td></tr></table></figure><h3 id="Docker-网络访问"><a href="#Docker-网络访问" class="headerlink" title="Docker 网络访问"></a>Docker 网络访问</h3><blockquote><p>通过link 方式实现容器之间的访问，直接通过名称而非 IP，适用于单台机器</p></blockquote><p><img src="http://img.janhen.com/1566531692115.png" alt="1566531692115"></p><p>一个容器对应一个网络空间</p><p>类似局域网连接，通过中间的交换机实现两个容器之间的通信， docker0 的内网指定默认为 172.17.0/16，自定义为 172.17.18.0/16…</p><p>访问外部网络，需要经过 NAT 转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络， bridge 网络</span></span><br><span class="line">docker network ls</span><br><span class="line">sudo docker network inspect &lt;network_id OR network_name&gt;</span><br><span class="line">ip a</span><br><span class="line">yum install bridge-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示系统当前桥接</span></span><br><span class="line">brctl show</span><br><span class="line">ip a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建指定类型的网络</span></span><br><span class="line">docker network create -d bridge net-my</span><br></pre></td></tr></table></figure><p><strong>Docker link 网络连接</strong></p><blockquote><p>通过命名 Docker 进行相连，类似网络命名空间中的 Veth pair，目前不推荐使用</p><p>命令格式： –link <container_name OR container_id>:<alias></p><p>替代方案： docker-compose.yml 中使用 depends_on，使用 overlay 网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 类似给 net-test2 添加 DNS 记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   link 方向性; 使用少</span></span><br><span class="line">docker run -d --name net-test2 \</span><br><span class="line">  --link net-test1 busybox \</span><br><span class="line">  /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker exec -it net-test2 /bin/sh</span><br><span class="line">  ip a </span><br><span class="line">  ping net-test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 指定网络类型， bridge|overlay</span></span><br><span class="line">docker network create -d bridge net-my</span><br><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line">docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --link &lt;name&gt; 支持通过名称访问容器 </span></span><br><span class="line">docker run -d --name flask-redis \</span><br><span class="line">  -p 5000:5000 \</span><br><span class="line">  --link redis \</span><br><span class="line">  -e REDIS_HOST=redis \</span><br><span class="line">  janhen/flask-redis </span><br><span class="line">docker run -d --name test1 \</span><br><span class="line">  -e PENG=testt1 \</span><br><span class="line">  busybox </span><br><span class="line">docker run -d --name test2 \ </span><br><span class="line">  -e PENG=testest \</span><br><span class="line">  busybox  \</span><br><span class="line">  /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br></pre></td></tr></table></figure><p><strong>自定义网络连接</strong></p><blockquote><p>避免使用 –link 进行容器之间网络的连接</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockernetwork create -d bridge net-demo</span><br></pre></td></tr></table></figure><h3 id="Docker-单机网络"><a href="#Docker-单机网络" class="headerlink" title="Docker 单机网络"></a>Docker 单机网络</h3><p><strong>Docker bridge 网络</strong></p><blockquote><p>可以创建自己的桥接网络，进行区分，docker-compose 默认管理的容器共享同一个 bridge 网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建自己的桥接网络</span></span><br><span class="line">docker network create -d bridge my-bridge</span><br><span class="line">docker network ls</span><br><span class="line">brctl show</span><br><span class="line">docker run -d \</span><br><span class="line">  -- name net-test3 \</span><br><span class="line">  --network my-bridge busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker network connect mybridge net-test2</span><br></pre></td></tr></table></figure><p>bridge 性能一般，对性能要求较高，可使用个 SR-IOV 网卡嵌入容器内。</p><p><strong>Docker host 和 none网络</strong></p><blockquote><p>none 网络： 不会有网络信息，孤立的网络，用来做私有的工具，如保存密码??，使用场景少</p><p>host 网络：无网络信息，与主机共享网络命名空间，存在端口冲突问题</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx </span><br></pre></td></tr></table></figure><h3 id="Docker-多机网络"><a href="#Docker-多机网络" class="headerlink" title="Docker 多机网络"></a>Docker 多机网络</h3><blockquote><p>实现多个不同机器之间的容器进行通信</p></blockquote><h4 id="Overlay-网络"><a href="#Overlay-网络" class="headerlink" title="Overlay 网络"></a>Overlay 网络</h4><blockquote><p>依赖一个分布式存储，保存对应的 IP，防止网络(172.18.0.0/16)、容器名称等的冲突</p></blockquote><p>实现 Docker 的多机网络，见 [Internel 访问](#Internel 访问)</p><p>两台机器之间可以相互通信，为了实现不同容器之间的通信需要借助第三方的分布式存储</p><p>使用etcd 建立的 cluster 中容器名称不允许重复、Ip 地址不允许重复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络，实现多态主机之间的同步创建 overlay 网络</span></span><br><span class="line">docker network ls</span><br><span class="line">docker netword create -d overlay net-overlay-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络情况，子网范围，容器情况</span></span><br><span class="line">docker network inspect net-overlay-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器指定到 overlay 网络</span></span><br><span class="line">docker run -d --name node1-test1 \</span><br><span class="line">  --net net-overlay-demo \</span><br><span class="line">  busybox sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker run -d --name node2-test1 \</span><br><span class="line">  --net net-overlay-demo \</span><br><span class="line">  busybox sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点上容器的地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 cluster 中网络的情况</span></span><br><span class="line">docker exec node1-test1 ip a</span><br><span class="line">docker exec node2-test1 ip a</span><br><span class="line">docker network inspect net-overlay-demo</span><br></pre></td></tr></table></figure><h4 id="Etcd-分布式存储"><a href="#Etcd-分布式存储" class="headerlink" title="Etcd 分布式存储"></a><strong>Etcd 分布式存储</strong></h4><blockquote><p>存储分布式系统中的 key-val，开源免费，保证 overlay 网络中分配的容器与容器对应的IP地址在整个网络中唯一</p><p>关联： <a href="https://github.com/etcd-io/etcd">GitHub</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在对应的两台机器上安装 etcd，容器安装/binary 安装</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过命令指定好集群启动</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证 cluster 的运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 etcd 文件夹执行健康检查，两台机器同时执行</span></span><br><span class="line">./etcdctl cluster-health</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭 Docker 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 etcd 作为分布式存储启动 docker， 手动启动 dockerd 守护进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 \</span><br><span class="line">  -H unix://var/run/docker.sock \</span><br><span class="line">  --cluster-store=etcd://192.168.xx.xx:2379 \</span><br><span class="line">  --cluster-advertise=192.168.xx.xx:2375 &amp;  </span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="Docker-持久化"><a href="#Docker-持久化" class="headerlink" title="Docker 持久化"></a>Docker 持久化</h2><blockquote><p>将容器与数据存储隔离开，如 Mysql 运行程序与数据保存位置</p></blockquote><p><img src="http://img.janhen.com/202012172237411566571502370.png" alt="1566571502370"></p><p>两种持久化的方式：</p><ul><li><p>本地 FS 的 Volumn</p></li><li><p>基于 plugin 的 Volume， 如 NAS</p></li></ul><p>本机上三种持久化实现, -mount 选项选择数据卷：</p><ul><li><p>bind :挂载在 Linux FS 中任意位置</p></li><li><p>volume：统一挂载在 daemon 设置的 docker 目录下，默认为 <code>/var/lib/docker/volumes/&lt;unique_str_id OR volume_name&gt;</code></p></li><li><p>tmpfs： 只挂载在内存中，易丢失</p></li></ul><p>使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker volume create -d local test</span><br><span class="line">docker volume inspect &lt;contaienr&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理</span></span><br><span class="line">docker volume prune &lt;&gt;</span><br><span class="line">docker volume rm &lt;&gt;</span><br><span class="line">docker run -d --mount type=bind, source=/data, destination=/redis/data xxxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定 :ro 容器无法对挂载数据卷内的数据进行修改</span></span><br><span class="line">docker run -d -v /webapp:/opt/webapp:ro</span><br></pre></td></tr></table></figure><p><strong>数据卷容器</strong></p><p>实现多个容器操作数据，任意容器修改都可被其他容器看到</p><p>–volumes-from 参数所挂载的数据卷容器无需处在运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --volumes-from dbdata xxx</span><br></pre></td></tr></table></figure><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><blockquote><p>通过 Dockerfile 中的 Volumn 控制，在宿主机上 docker 文件下建立目录存放文件</p></blockquote><p>建议 -v 参数指定在 docker 目录下 volume 的名称，默认为 <code>/var/lib/docker/volumes/&lt;-v_name OR long_str&gt;</code></p><p>针对官方镜像，到 Docker Hub 上查看对应的 volume 挂载目录位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 volume，查看所有|指定|删除volume</span></span><br><span class="line">docker volume create volume1</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect volume1</span><br><span class="line">docker volume rm volume2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行-&gt;删除-&gt;验证</span></span><br><span class="line">docker run -d -v mysql1:/var/lib/mysql  \</span><br><span class="line">  --name mysql1  \</span><br><span class="line">  -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql </span><br><span class="line">docker rm -f  mysql1 mysql2</span><br><span class="line">docker run -d -v mysql1:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql </span><br><span class="line">docker exec -it mysql2 /bin/bash</span><br><span class="line">  mysql -u root</span><br><span class="line">  show databases;</span><br></pre></td></tr></table></figure><h3 id="Bind-Mouting"><a href="#Bind-Mouting" class="headerlink" title="Bind Mouting"></a>Bind Mouting</h3><blockquote><p>指定容器目录与宿主机目录绑定，宿主机文件更改影响到容器中的运行</p></blockquote><p>可以实现本台电脑  –&gt;  虚拟机  –&gt;  容器三者的目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v: &lt;宿主机目录&gt;:&lt;容器目录&gt; 进行一一映射</span></span><br><span class="line">docker run -d -v $(pwd):/usr/share/nginx/html -p 80:80 --name web janhen/my-nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 Docker 作为本地开发环境</span></span><br><span class="line">docker run -d -p 80:5000  --name flask janhen/flask-skeleton </span><br></pre></td></tr></table></figure><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><blockquote><p>用于生成 Docker Image 的文件，一般只用于 <code>docker build -t janhen/xx:99 .</code> 命令执行使用 </p><p>关联： <a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html#dockerfile-%E6%8C%87%E4%BB%A4">Dockerfile 指令</a></p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>Dockerfile 的基本语法</strong></p><blockquote><p>FROM,WORKDIR,ENV,COPY,ADD</p><p>RUN,CMD,ENTRYPOINT</p><p>VOLUME,EXPOSE</p></blockquote><ul><li><p><code>FROM</code>： 根据特定的镜像制作，从头制作、 根据指定环境制作、某个镜像作为构建阶段使用</p></li><li><p><code>RUN </code>： 运行命令脚本, 可以通过此安装一些环境并对环境进行配置，如安装 Node 环境，每运行一个命令增加一层 ==&gt;  建议将多个命令合并成一个命令使用</p></li><li><p><code>WORKDIR</code>： 设定当前工作目录, 类似 cd 改变目录, 没有目录自动创建(#)<br>  直接通过绝对路径定位<br>  通过绝对路径+相对路径定位目录</p></li><li><p><code>ADD and COPY</code>： 将本地文件添加到 docker image 中,常 配合 WORKDIR 使用</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> LABEL 镜像的 metadata，帮助信息</span></span><br><span class="line">LABEL maintainer=&quot;janhen &lt;ipaam414@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">RUN yum update &amp;&amp; yum install -y vim \</span><br><span class="line">  python-dev</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y perl \</span><br><span class="line">    pwgen --no-install-recommends &amp;&amp; rm -rf \  </span><br><span class="line">    /var/lib/apt/lists/*</span><br><span class="line">RUN /bin/bash -c &#x27;source $HOME/.bashrc;echo $HOME&#x27;</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">WORKDIR /test</span><br><span class="line">WORKDIR demo</span><br><span class="line">RUN pwd</span><br><span class="line"></span><br><span class="line">ADD hello /</span><br><span class="line">ADD test.tar.gz /</span><br><span class="line">WORKDIR /root</span><br><span class="line">ADD hello test/</span><br><span class="line">COPY hello test/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENV 设定环境变量, 建议使用</span></span><br><span class="line">ENV MYSQL_VERSION 5.6</span><br><span class="line">RUN apt-get install -y mysql-server = &quot;$&#123;MYSQL_VERSION&#125;&quot; \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动后默认执行的命令和参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   docker run 指定其他命令, CMD 被忽略</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   定义多个 CMD，只运行最后一个</span></span><br><span class="line">docker run [image]                # CMD 会被执行</span><br><span class="line">docker run -it [image] /bin/bash  # CMD 不会执行</span><br><span class="line">CMD [&quot;mongod&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENTRYPOINT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动时运行的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器以应用程序/服务的形式运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   不会被忽略, 一定会执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   最佳实践: 通过 shell 脚本作为 entrypoint </span></span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin/     # 添加到容器中</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]           # 指定入口脚本</span><br><span class="line">EXPOSE 27017</span><br><span class="line">ENTRYPOINT [&quot;scripts/dev.sh&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行宿主机与容器中文件的映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射容器中的 /tmp 到宿主机上，默认在 /var/lib/docker/volumes/&lt;long_id OR name&gt; 下建立对应的映射</span></span><br><span class="line">VOLUME /tmp</span><br></pre></td></tr></table></figure><p><strong>命令格式</strong></p><blockquote><p>不同的命令执行写法，以及对应的区别</p></blockquote><p>Shell 格式, 默认通过 shell 执行</p><p>Exec 格式,   ENTRYPOINT [“/bin/bash”, “-c”, “echo”, “hello $name”]</p><p>针对 Exec 无法映射变量问题的处理： 通过命令方式编写语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV name Docker</span><br><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;hello $name&quot;]</span><br></pre></td></tr></table></figure><p><strong>命令区别</strong></p><p>1、RUN、CMD和ENTRYPOINT命令区别</p><p>RUN 运行在 image 的构建阶段执行，执行结果会被打包进 image 文件</p><p>CMD 在容器启动后执行，可用于在容器内启动某个服务、进程，只可使用一次，与 run 中年执行命令冲突</p><p>ENTRYPOINT 在容器启动后执行，出现多行不会忽略，一定执行，通常配合 COPY 到容器中的 sh 脚本使用</p><p>2、COPY 与 ADD 命令区别</p><p>ADD 可以获取网络资源，可以直接解压缩</p><p><strong>注意事项</strong></p><p>1、CMD 的最后一次有效性</p><p>官方镜像中大多最后运行 CMD，方便覆盖实现定制化的参数的启动</p><p>2、目录</p><p>COPY . /app 与 COPY . /app/ 映射不同</p><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><blockquote><p>多容器管理，通过 yml 配置管理容器之间的依赖关系，底层 python 编写，前身为开源的 Fig 项目。主要用于本地开发使用。</p><p>关联文档：<a href="https://yeasy.gitbooks.io/docker_practice/compose/compose_file.html">Compose 模板文件</a> | <a href="https://docs.docker.com/compose/compose-file">Doc</a></p></blockquote><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><blockquote><p>docker-compose 的启动、停止、交互</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> compose 后台启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并查看日志</span></span><br><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose -f &lt;compose_name&gt; up -d </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止并删除 容器、网络、volumes</span></span><br><span class="line">docker-compose stop &lt;service&gt;</span><br><span class="line">docker-compose down &lt;service&gt;</span><br><span class="line">docker-compose build</span><br><span class="line"><span class="meta">#</span><span class="bash"> compose 查看运行情况，状态、端口情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 compose 中定义容器使用的 images</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose images</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 compose 中的 service</span></span><br><span class="line">docker-compose exec mysql bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展</span></span><br><span class="line">docker-compose scale &lt;service_name&gt;=&lt;count&gt;</span><br></pre></td></tr></table></figure><p><strong>service 的扩展</strong></p><blockquote><p> 实现水平扩展，负载均衡，在不存在端口冲突的情况下通过 haproxy 进行负载均衡，在 Docker Swarm 运行时可直接通过 deploy 中的参数指定复制扩展的个数</p></blockquote><p>通过 docker-compose scale 命令进行扩展</p><p>处理 scale 中端口映射重复问题</p><p>在 docker-compose 中增加 dockercloud/haproxy 进行负载均衡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动时指定扩展</span></span><br><span class="line">docker-compose up --scale web=3 -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行后进行扩展</span></span><br><span class="line">docker-compose scale web=4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证扩展情况</span></span><br><span class="line">docker-compose ps</span><br><span class="line">for i in `seq 10`; do curl 127.0.0.1:8080; done</span><br></pre></td></tr></table></figure><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><blockquote><p>对应 docker-compose.yml 文件的语法</p></blockquote><p>三大实体：</p><ul><li><p>service: 服务</p></li><li><p>networks: 网络指定，指定网络类型，一般为 bridge、overlay，根据需要指定多个网络，进行一定的隔离</p></li><li><p>volumes: 进行数据卷的映射</p></li></ul><hr><p>image 获取方式： 通过 image 获取本地的或是拉取远程的，或者通过 build 进行构建，传入 Dockerfile 的目录以及对应的 Dockerfile 名称</p><p>ports: 进行宿主端口与容器端口的映射</p><p>depends_on: 解决容器的依赖，启动先后问题</p><p>links: 服务之间的依赖关系，在容器内部可以直接使用依赖服务名称对应的 IP 地址，不建议使用</p><p>deploy: 进行部署，控制集群中的各种情况，用于 Docker swarm，version 3 支持</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 特定片段参考</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置网络, 可多个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> frontend, backend 前后端设置</span></span><br><span class="line">networks:</span><br><span class="line">  - frontend</span><br><span class="line">  - backend</span><br><span class="line"><span class="meta">#</span><span class="bash"> 端口设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接引号设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 宿主机与容器端口映射</span></span><br><span class="line">ports:</span><br><span class="line">  - &quot;6379&quot;</span><br><span class="line">ports:</span><br><span class="line">  - 5000:80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 依赖</span></span><br><span class="line">depends_on:</span><br><span class="line">  - mysql</span><br></pre></td></tr></table></figure><h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><blockquote><p>Docker 自带的服务编排框架，大多数都由其中的 Manager 做管理，较难定制，不适合太多节点的部署</p></blockquote><p>Docker Swarm 特点：</p><p>符合传统IT的管理模式</p><p>平台本身集成性好，可当成云管平台使用</p><p>内置太多不易进行定制化，不好 Debug，不易干预</p><p><strong>不提供存储选项</strong>：Docker Swarm不提供将容器连接到存储的无障碍方式，其数据量需要在主机和手动配置上进行大量即兴创作</p><p><strong>监控不良</strong>：Docker Swarm提供有关容器的基本信息，如果您正在寻找基本的监控解决方案，那么Stats命令就足够了。如果您正在寻找高级监控，那么Docker Swarm永远不是一个选择。虽然有像CAdvisor这样的第三方工具可以提供更多监控，但使用Docker本身实时收集有关容器的更多数据是不可行的。</p><h2 id="Swarm-架构"><a href="#Swarm-架构" class="headerlink" title="Swarm 架构"></a>Swarm 架构</h2><p><img src="http://img.janhen.com/202012172238091566634422450.png" alt="1566634422450"></p><p><a href="http://thesecretlivesofdata.com/raft/">Raft</a> consensus group： 进行控制分布式场景下的协商:  内置的分布式的存储数据库，通过 Raft 协议进行同步，包含 Leader 选举、Log 复制</p><p>Internel distributed state store： 分布式存储数据库，功能如保证分布式场景下 Ip 等唯一，类似 etcd</p><p>Manager: 可以保存 Raft 关联的文件，用于 Secret 实现</p><p>Worker: 主要运行容器，通过 Gossip network 进行通信，保证分布式下的一致性</p><p>Gossip network： 各个 Worker 之间同步实现的协议</p><p>扩展：</p><p>  Service: 通过 swam manager 进行控制，具体 service 部署到哪个 node 上</p><p>  Replicas： 一个 Service 对应多个 Replicas，用于扩展</p><h2 id="集群搭建管理"><a href="#集群搭建管理" class="headerlink" title="集群搭建管理"></a>集群搭建管理</h2><blockquote><p>让几台服务器搭建成一个 Swarm Cluster</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 Manager Node</span></span><br><span class="line">docker swarm init --advertise-addr=192.169.xx.xx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 Worker Node 加入到特定的 Manager Node</span></span><br><span class="line">docker swarm join --token xxxfsdfsdf &lt;ip&gt;:&lt;port&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前 Node 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点查看</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点降级</span></span><br><span class="line">docker node ls  </span><br><span class="line">docker node inspect &lt;node_name&gt;</span><br><span class="line">docker node demote &lt;node_name&gt;</span><br><span class="line">docker node ps</span><br></pre></td></tr></table></figure><h2 id="Swarm管理"><a href="#Swarm管理" class="headerlink" title="Swarm管理"></a>Swarm管理</h2><p><strong>Swarm Services 管理</strong></p><blockquote><p>单个 Service 的管理，一个 Service 可扩展到多个 cluster node 上的 Container 运行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建容器，运行位置有 mananger 进行控制运行在哪个节点上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似 docker run 命令，在本地创建 container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 service 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   MODE: replicated</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   REPLICAS: 1/1 支持水平扩展，类似 docker compose 中的 scale</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看具体的 service 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   运行在哪个节点上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展servie，通过复制的方式(<span class="comment">#) </span></span></span><br><span class="line">docker service create --name demo busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps demo</span><br><span class="line">docker service scale demo=5</span><br><span class="line">docker service ps demo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 本机查看 docker 容器运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除某个正在运行中的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群自动恢复，确保一定数目的 scale 扩展有效，系统稳定运行时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示节点中容器运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除服务，对应的集群节点容器删除</span></span><br><span class="line">docker ps</span><br><span class="line">docker rm -f e64432</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps demo</span><br><span class="line">docker service rm demo</span><br></pre></td></tr></table></figure><h2 id="RoutingMesh"><a href="#RoutingMesh" class="headerlink" title="RoutingMesh"></a>RoutingMesh</h2><blockquote><p>Swarm 网络通信原理，管理集群服务间的通信，访问集群中任何一个节点特定端口都会被重定向到实际运行服务的节点上</p></blockquote><p><img src="http://img.janhen.com/202012172238131566634990023.png" alt="1566634990023"></p><p>DNS 服务发现，单机情况下可以通过 service 的名称进行相互访问，多机情况下通过 swarm 进行相互访问</p><p>VIP： 非真实机器的IP地址，避免多个IP地址变化问题，造成系统运行不稳定，一个 service 对应一个</p><p>LVS： 根据虚拟 IP 找出容器中的具体的 IP 地址</p><p>两种体现：</p><ul><li>Internel：容器之间通过 overlay 网络访问</li><li>Ingress ：服务绑定接口的情况，此服务通过任意 Swarm 节点对应接口访问</li></ul><h3 id="Internel-访问"><a href="#Internel-访问" class="headerlink" title="Internel 访问"></a>Internel 访问</h3><blockquote><p>容器间实现相互访问，通过 overlay 网络实现，实现 service 与 service 之间的通信</p></blockquote><p><img src="http://img.janhen.com/202012172238171568514162156.png" alt="1568514162156"></p><p>whoami 镜像： 提供 web 服务，访问 8000 端口，返回 container 的 hostname</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 whoami 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   端口映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   网络指定</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有 service </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 whoami 服务运行位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 到对应机器上验证</span></span><br><span class="line">docker network create -d overlay net-demo</span><br><span class="line">docker service create -d \</span><br><span class="line">  --name whoami \</span><br><span class="line">  -p 8000:8000 \</span><br><span class="line">  --network net-demo jwilder/whoami</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps whoami</span><br><span class="line">docker ps</span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 busybox 的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   连接到同一个 overlay 网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有服务，当前 busybox service 是否启动完成</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务 client 服务具体位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入对应的机器查看对应运行的 container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   10.0.0.7 IP 地址，为虚拟 IP， 将 whoiam 通过 scale 扩展</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 scale 进行扩展 whoami </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 whoami 位置，并进入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入对应 client contaienr 中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   连接 whoami </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查询 dns，只有一个虚拟IP 10.0.0.7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 whoami 查看网络地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 whoami(另一) 查看网络地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 client</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 task.whoami，返回对应的多个节点，为真实的 IP 地址（<span class="comment">#）</span></span></span><br><span class="line">docker service create -d \</span><br><span class="line">  --name client \</span><br><span class="line">  --network net-demo busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps client</span><br><span class="line">docker ps</span><br><span class="line">docerer exec -it &lt;container_id&gt; sh</span><br><span class="line">  ping whoami    </span><br><span class="line">docker service scale whoami=2    </span><br><span class="line">docker service ps whoami</span><br><span class="line">docker service ps client</span><br><span class="line">docker exec -it &lt;container_client_id&gt; sh </span><br><span class="line">  ping whoami </span><br><span class="line">  nslookup whoami</span><br><span class="line">docker exec 5b79 ip a</span><br><span class="line">docker execdf9 ip a</span><br><span class="line">docerk exec -it &lt;container_client_id&gt; sh</span><br><span class="line">  nslookup task.whoami</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展 whoami 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查案 client 对应的 task.whoami，显示三个对应的(whoami)IP 地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   ==&gt; 虚拟IP: 不会随 service 的扩展而变化, 包括增加、减少、机器之间的迁移不会变化(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问多次服务 whoami，相应的对应机器上的容器会因为负载均衡而不同，通过 LVS 实现</span></span><br><span class="line">docker service scale whoami=3</span><br><span class="line">docker service ps whoami</span><br><span class="line">---</span><br><span class="line">  nslookup task.whoami</span><br><span class="line">  wget whoami:8000</span><br><span class="line">  more index.html</span><br><span class="line">  rm -rf index.html</span><br><span class="line">  wget whoami:8000</span><br></pre></td></tr></table></figure><p>两种体现：</p><p>Internal: 容器键通过 overlay 网络(VIP)访问</p><p>Ingress: 服务绑定接口, 通过任意 swarm 节点的接口访问’</p><p>DNS + VIP + iptables + LVS 实现的过程图：</p><p>// todo 具体 Swarm 网络中数据的流动情况</p><p>小结： 容器之间连接到 overlay 网络进行通信，service 之间的通信通过  VIP + LVS 实现</p><h3 id="Ingress-负载均衡"><a href="#Ingress-负载均衡" class="headerlink" title="Ingress 负载均衡"></a>Ingress 负载均衡</h3><blockquote><p>绑定端口实现的容器之间的访问，通过 <node_ip>:<service_port> 直接访问服务</p><p>作用体现：集群中的 Node 对应的端口提供相同的服务，即使 Node 本地无服务也支持访问</p></blockquote><p>Ingress Network 的数据包走向图</p><p><img src="http://img.janhen.com/202012172238261568515008492.png" alt="1568515008492"></p><p>在  IPTables + IPVS 发往目的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常看网络桥接情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看机器的网络命令空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 ingress_sbox 网络命名空间</span></span><br><span class="line">iptables</span><br><span class="line">brctl show</span><br><span class="line">sudo ls /var/run/docker/netns</span><br><span class="line">sudo nsenter --net=/var/run/docker/netns/ingress_sbox</span><br><span class="line">ip a</span><br><span class="line">iptables -nL -t mangle</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 LVS 管理工具</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 LVS 情况，展示可选的服务 IP 地址，展示机器的 weight, </span></span><br><span class="line">yum install ipvsadm</span><br><span class="line">sudo nsenter --net=/var/run/docker/netns/ingress_sbox</span><br><span class="line">iptables -nL -t mangle</span><br><span class="line">ipvsadm -l</span><br></pre></td></tr></table></figure><h2 id="Docker-Stack-部署"><a href="#Docker-Stack-部署" class="headerlink" title="Docker Stack 部署"></a>Docker Stack 部署</h2><blockquote><p>进行多服务部署，可以使用 docker-compose.yml ，只能用于 swarm cluster，无法用于其他的服务编排框架</p></blockquote><p>docker-compose.yml 文件更改</p><p>compose file version 3: 增加 <a href="https://docs.docker.com/compose/compose-file/#deploy">deploy</a> 命令，具体参数如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy</span></span><br><span class="line"><span class="comment">#   endpoint_mode: vip 模式(默认), dnsrr 模式 循环访问(少用)</span></span><br><span class="line"><span class="comment">#   labels: 帮助描述信息</span></span><br><span class="line"><span class="comment">#   mode: global, replicated， global 全局唯一, 无法通过 scale 横向扩展，一般外部服务使用此种方式，如 mysql,nginx,redis等； replicated 默认，可通过复制来进行扩展</span></span><br><span class="line"><span class="comment">#   placement:   </span></span><br><span class="line"><span class="comment">#     constraint: </span></span><br><span class="line"><span class="comment">#       - node.role == manager # 限制部署到 manager 节点上</span></span><br><span class="line"><span class="comment">#     preferences: 优先喜好</span></span><br><span class="line"><span class="comment">#       -</span></span><br><span class="line"><span class="comment">#   replicas: 在 mod 是 replicated 的时候定义初始化时候需要的 replicas</span></span><br><span class="line"><span class="comment">#   resources: 进行资源的限制</span></span><br><span class="line"><span class="comment">#     limits:</span></span><br><span class="line"><span class="comment">#       cpus: &#x27;0.50&#x27;  # CPU 使用限制</span></span><br><span class="line"><span class="comment">#       memeory: 50M  # 内存使用限制</span></span><br><span class="line"><span class="comment">#     reservations:   # 优先保留，最小的情况</span></span><br><span class="line"><span class="comment">#       cpus: &#x27;0.25&#x27;</span></span><br><span class="line"><span class="comment">#       memory: 20M</span></span><br><span class="line"><span class="comment">#   restart_policy:         # 容器宕机后的处理</span></span><br><span class="line"><span class="comment">#     conditon: on-failure  # 什么情况下重启</span></span><br><span class="line"><span class="comment">#     delay: 5s             # 延迟</span></span><br><span class="line"><span class="comment">#     max_attempts: 3       # 最大重试次数</span></span><br><span class="line"><span class="comment">#     window: 120s</span></span><br><span class="line"><span class="comment">#   update_config:          # service 更新的配置</span></span><br><span class="line"><span class="comment">#     parallelism: 2</span></span><br><span class="line"><span class="comment">#     delay: 10s</span></span><br><span class="line"><span class="comment">#     order: stop-first</span></span><br></pre></td></tr></table></figure><p>部署的过程：</p><p>更改单机的 docker-compose.yml 为对应 cluster 部署(deploy)</p><p>按条件执行命令： 如下</p><p>验证： 通过访问任意一个 cluster 中的地址即可访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 整个 application 定义为一个 stack 为 wordpress</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   可通过 -c=docker-compose.yml 进行简化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   mysql: 限制只运行一个，只能运行在 manager 节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 stack 查看服务情况</span></span><br><span class="line">docker stack deploy wordpress --compose-file=docker-compose.yml</span><br><span class="line">docker stack ls</span><br><span class="line">docker stack ps wordpress</span><br><span class="line">docker stack services wordpress</span><br><span class="line">docker stack rm wordpress</span><br></pre></td></tr></table></figure><h2 id="Docker-Secret-管理"><a href="#Docker-Secret-管理" class="headerlink" title="Docker Secret 管理"></a>Docker Secret 管理</h2><blockquote><p>对一些密码进行管理， 处理 docker-compose.yml 中存储密码不安全问题，借助内部分布式存储数据库控制，只作用于 Docker Swarm</p><p>关联： <a href="https://docs.docker.com/engine/reference/commandline/secret/">Doc-CLI</a></p></blockquote><p><img src="http://img.janhen.com/202012172238471566631044524.png" alt="1566631044524"></p><p>Secret 类型： username password， SSH key, TLS 认证，不想让人看到的数据</p><p>生产环境至少要两个 Manager，分布式存储的天然加密环境</p><p>Secret 的管理：</p><p>将 Secret 存储在 Manager 中的分布式存储中的 Raft Database</p><p>Secret 给某个 service 指派</p><p><strong>Service 基本使用</strong></p><p>Secret 的创建方式：文件方式、输入方式。</p><p>存放在容器中的 <code>/run/secrets/&lt;secret_file_name&gt;</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按文件方式进行创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件，保证安全性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 secret</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 借助管道按照输入方式创建 secret</span></span><br><span class="line">vim password</span><br><span class="line">docker secret create my-file-pw password</span><br><span class="line">rm -rf password</span><br><span class="line">docker secret ls</span><br><span class="line">echo &quot;mypassword&quot; | docker secret create my-input-pw</span><br><span class="line">docker secret rm my-input-pw</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 swarm service 创建过程中指定 secret 进行使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器查看指定目录，找到 manager 通过 Raft Database 保存的 secret</span></span><br><span class="line">docker service create -d --name client \</span><br><span class="line">  --secret my-file-pw busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls </span><br><span class="line">docker service ps client</span><br><span class="line">docker ps</span><br><span class="line">docker exec -it &lt;client_container_id&gt; sh</span><br><span class="line">  cd /run/secrets/</span><br><span class="line">  ls</span><br><span class="line">  cat my-file-pw # 原文</span><br><span class="line"><span class="meta">#</span><span class="bash"> 实际使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建 service 的时候指定好 secret，并在环境变量中指定在容器中的位置</span></span><br><span class="line">docker service create -d --name db \</span><br><span class="line">  --secret my-file-pw \ </span><br><span class="line">  -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-file-pw mysql</span><br><span class="line">docker service ps db</span><br><span class="line">--</span><br><span class="line">docker exec -it &lt;db_container_id&gt; sh</span><br><span class="line">ls /run/secrets</span><br><span class="line">cat /run/secrets/my-file-pw</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><strong>在 Stack 中的使用</strong></p><p>在服务配置下增加 secrets，指定对应的 Secret</p><p>对应的密码参数使用指定的 secrets 在容器中的位置</p><p>可以连通创建 secret 一起使用，不建议</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 简化 --compose-file </span></span><br><span class="line"><span class="comment"># 查看服务是否全部启动完成</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stack</span> <span class="string">deploy</span> <span class="string">wordpress</span> <span class="string">\</span></span><br><span class="line">  <span class="string">-c=docker-compose.yml</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stack</span> <span class="string">services</span> <span class="string">wordpress</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Service-更新"><a href="#Docker-Service-更新" class="headerlink" title="Docker Service 更新"></a>Docker Service 更新</h2><blockquote><p>在运行过程中对 service 依赖的镜像进行升级，实现升级过程中不会中断原来的服务</p></blockquote><h3 id="单-Service-更新"><a href="#单-Service-更新" class="headerlink" title="单 Service 更新"></a>单 Service 更新</h3><p>进行 service 的更新，不会暂停运行的项目</p><p>@Q: 存在一段时间有 1.0和2.0并存的情况，如何处理??</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络，启动服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待服务启动完毕</span></span><br><span class="line">docker network create -d overlay net-demo</span><br><span class="line">docker network ls</span><br><span class="line">docker service create -d --name web \</span><br><span class="line">  --publish 8080:5000 \</span><br><span class="line">  --network net-demo</span><br><span class="line">  janhen/python-flask-demo:1.0.0</span><br><span class="line">docker service ps web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查服务运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写测试脚本方便验证</span></span><br><span class="line">docker service scale web=2</span><br><span class="line">docker service ps web</span><br><span class="line">curl 127.0.0.1:8080</span><br><span class="line">sh -c &quot;while true; do curl 127.0.0.1:8080&amp;&amp;sleep 1; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新镜像，一般通过 Dockerfile 进行构建，指定对应更新的版本，发布到私有 registry</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行环境拉取镜像，执行更新命令</span></span><br><span class="line">docker service update --image janehn/python-plask-demo:2.0.0 web</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新镜像并设置参数, 覆盖 docker-compose.yml</span></span><br><span class="line">docker service update --image westos.org/game2048 \</span><br><span class="line">  --update-parallelism 10 \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><h3 id="端口更新"><a href="#端口更新" class="headerlink" title="端口更新"></a>端口更新</h3><blockquote><p> 对 service 与宿主机的端口映射进行更改</p></blockquote><p>删除掉原来的端口映射，无法做到更新时业务不中断，通过 VIP + 端口实现原理导致的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service update --publish-rm 8080:500 \</span><br><span class="line">  --publish-add 8088:5000 web</span><br></pre></td></tr></table></figure><h3 id="Stack-更新"><a href="#Stack-更新" class="headerlink" title="Stack 更新"></a>Stack 更新</h3><blockquote><p>更改 Swarm Cluster 中多个容器中对于镜像、网络、部署配置的更新，关联 <service>.deploy.update_config 下的配置</p></blockquote><p>可更改 docker-compose.yml 中 deploy 下的 update_config 控制更新时的细节，允许几个 scale 进行更新，延迟信息。。。</p><p>第一次通过 deploy 进行启动进行了多 service 的部署</p><p>第二次通过 deploy 部署时，自动检测到 docker-compose.yml 的变化，进行更新    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy wordpress --compose-file docker-compose.yml </span><br></pre></td></tr></table></figure><h2 id="Docker-Swarm-监控"><a href="#Docker-Swarm-监控" class="headerlink" title="Docker Swarm 监控"></a>Docker Swarm 监控</h2><blockquote><p>实现对 Docker Swarm Cluster 中运行节点上容器的监控</p></blockquote><h3 id="CAdvisor-InfluxDB-Grafana"><a href="#CAdvisor-InfluxDB-Grafana" class="headerlink" title="CAdvisor+InfluxDB+Grafana"></a>CAdvisor+InfluxDB+Grafana</h3><blockquote><p>docker swarm集群的监控方案，开源免费</p><p>cAdvisor：数据收集模块，需要部署在集群中的每一个节点上，当然前提条件是节点接受task。</p><p>InfluxDB：数据存储模块</p><p>Grafana：数据展示模块</p></blockquote><p><strong>Docker Universal Control Plane(UCP)</strong></p><blockquote><p>docker原厂的可视化集群管理GUI，企业级的，只支持docker EE</p></blockquote><p><strong>portainer</strong></p><blockquote><p>在集群中部署portainer的service，只能被调度给manager角色的节点</p><p>关联： <a href="https://www.portainer.io/">Web</a></p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Daemon-配置"><a href="#Daemon-配置" class="headerlink" title="Daemon 配置"></a>Daemon 配置</h2><blockquote><p>对容器的 dockerd 守护线程进行配置</p><p>关联： <a href="https://docs.docker.com/config/daemon/">Configure the daemon</a></p></blockquote><p><strong>dameon.json</strong> </p><p>配置文件编写：</p><p>源镜像地址配置</p><p>私有源非 Https 配置</p><p>Debug 模式开启</p><p><code>/etc/docker/daemon.json</code></p><p>ip: 永久绑定到某个固定的 IP 地址</p><p>bridge： 将 Docker 默认桥接到创建的网桥上</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://reg-mirror.qiniu.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.17.11.29:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;172.17.11.29:5111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;192.168.205.23:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;192.168.205.23:5111&quot;</span>,</span><br><span class="line">     <span class="string">&quot;172.17.10.150:80&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span>: <span class="string">&quot;bridge-my&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更改后使其生效</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service</span><br><span class="line">sudo systemctl status docker -l</span><br><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><p><strong>设置运行时目录，存储驱动</strong></p><p><strong>设置 Http/Https 代理</strong></p><p>加快拉取国外访问、处理国内制作镜像无法访问国外资源问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加配置</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"></span><br><span class="line">[Service]    </span><br><span class="line">Environment=&quot;HTTP_PROXY=https://172.17.10.18:5720/&quot; &quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置生效</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置</span></span><br><span class="line">rm -f /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure><p> <a href="https://docs.docker.com/engine/admin/systemd/#/http-proxy">Docker systemd http-proxy</a> </p><h2 id="监控与管理"><a href="#监控与管理" class="headerlink" title="监控与管理"></a>监控与管理</h2><blockquote><p>人工进行容器的管理、<strong>监控</strong>、资源调整、<strong>故障排除</strong>，包括日志查看、容器实时运行情况、资源重分配，在无法使用或没有监控方案情况下使用</p></blockquote><p><strong>dockerd 支持</strong></p><blockquote><p>在发生故障后，通过设置 Docker 守护线程的一些参数方便调试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启守护线程的 debug 模式，给出更多的信息提示</span></span><br><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.169.9.2:2376</span><br></pre></td></tr></table></figure><p><strong>容器的运行日志查看</strong></p><p>使用 Go 模板尽心格式化日志输出</p><p>可使用日志驱动程序插件，企业版支持统一格式查看远程的日志，默认双重日志</p><p><a href="https://docs.docker.com/config/formatting/">Format command and log output</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $&#123;CID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个镜像对应的全部容器</span></span><br><span class="line">docker container ls | grep &lt;image&gt; | awk &#x27;&#123;print $1&#125;</span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&#x27; &lt;CONTAINER&gt;</span><br><span class="line">docker logs -f &lt;container_id&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 Go 的模板语法进行格式化展示数据</span></span><br><span class="line">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>容器日志</strong></p><blockquote><p>在 daemon 中的日志配置，根据实际需要进行优化，可选择日志插件</p></blockquote><p>指定容器日志最大大小                20M</p><p>最大的文件个数                            5</p><p>压缩，                                           开</p><p><strong>容器的运行情况</strong></p><blockquote><p>通过 stats 实时查看容器的资源信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实时查看容器统计信息，CPU、内存、网络、磁盘</span></span><br><span class="line">docker stats 13b9203f9f0b d42877298134 44fb90cd2f2c</span><br><span class="line">docker container stats --format &quot;table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>容器的资源分配</strong></p><blockquote><p>容器使用多少宿主机的资源，可以通过 docker-compose.yml 中设置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过参数限定容器访问内存、CPU</span></span><br><span class="line">docker run --help | grep cpu </span><br><span class="line">docker run --help | grep memory</span><br></pre></td></tr></table></figure><p><strong>容器可用性</strong></p><p>容器支持重启，可以通过 <code>--restart</code> 指定重启策略，保证可用性</p><p><strong>容器网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有网络</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络映射</span></span><br><span class="line">docker port nostalgic_morse 5000</span><br></pre></td></tr></table></figure><p><strong>.dockerignore</strong> </p><p>针对非 SpringBoot 项目，如前端项目需要忽略一些文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p><strong>默认的重要文件：</strong></p><p>/var/run/docker.sock</p><p>/var/lib/docker/volumes/<volume_name OR long_uuid></p><h2 id="Docker-卸载"><a href="#Docker-卸载" class="headerlink" title="Docker 卸载"></a><strong>Docker 卸载</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止并删除容器</span></span><br><span class="line">docker rm -f `docker ps -aq`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除安装</span></span><br><span class="line">yum list installed|grep docker</span><br><span class="line"> yum -y remove docker-ce.x86_64</span><br><span class="line"> yum -y remove docker-ce-cli.x86_64</span><br><span class="line"> yum -y remove containerd.io.x86_64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有镜像、Volume删除</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除 docker-compose</span></span><br><span class="line"> rm -rf /var/lib/docker</span><br><span class="line"> rm -rf /hdapp</span><br><span class="line"> rm -rf /etc/docker</span><br><span class="line"> rm -f /usr/local/bin/docker-compose</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 测试卸载情况</span></span><br><span class="line"> yum list installed|grep docker</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除 docker0 网卡</span></span><br><span class="line"> yum install bridge-utils</span><br><span class="line"> ip link set dev docker0 down</span><br><span class="line"> brctl delbr docker0</span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><a href="https://jiajially.gitbooks.io/dockerguide/content/dockerIND.html">Docker-guide</a>: 中文的 GitBook</p><p><a href="https://github.com/docker-library/docs">官方镜像示例</a>： Docker Hub 中一些镜像的开源示例</p><p><a href="https://labs.play-with-docker.com/p/blga8164315g00e59gs0">play-with-docker</a> ： 方便环境搭建， 保存 docker 4h，在网站上创建多个网络，进行互通访问</p><p><a href="https://zhuanlan.zhihu.com/p/53260098">10分钟看懂Docker和K8S</a>： 快速入门</p><p><a href="https://zhuyasen.com/post/docker_note.html">docker学习笔记</a>： 他人博客笔记</p><p><a href="https://yeasy.gitbooks.io/docker_practice/">Docker – 从入门到实践</a></p><p><a href="https://yeasy.gitbooks.io/docker_practice/appendix/debug.html">如何调试 Docker</a>： 总结调试方法</p><p><a href="https://www.jianshu.com/p/21d66ca6115e">关于对docker run –link的理解</a>： Docker 桥接网络理解</p><p><a href="https://yeasy.gitbooks.io/docker_practice/advanced_network/e">工具和示例</a>： Docker 相关工具</p><p><a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html#dockerfile-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">Dockerfile 最佳实践</a>： 编写 Dockerfile 的一些建议 </p><p><a href="https://blog.51cto.com/12227558/2096290">CentOS7.4—构建LVS+Keepalived高可用群集</a>： LVS </p><p><a href="https://www.centos.bz/2018/02/docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/">docker镜像操作</a>： 容器制作、本地导入、镜像导出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-基础&quot;&gt;&lt;a href=&quot;#Docker-基础&quot; class=&quot;headerlink&quot; title=&quot;Docker 基础&quot;&gt;&lt;/a&gt;Docker 基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;类似精简的 Linux 环境，含 root 权限、进程空间</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Arthas</title>
    <link href="http://example.com/2020/12/17/Arthas/"/>
    <id>http://example.com/2020/12/17/Arthas/</id>
    <published>2020-12-17T13:10:57.000Z</published>
    <updated>2021-04-09T09:34:39.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p><code>Arthas</code> 是Alibaba开源的Java诊断工具。</p><p><a href="https://github.com/alibaba/arthas">Github</a></p></blockquote><p>当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ol><h2 id="JVM-信息"><a href="#JVM-信息" class="headerlink" title="JVM 信息"></a>JVM 信息</h2><p>JVM 相关命令的</p><p>1.dashboard -&gt; </p><ol start="2"><li>thread -&gt; </li></ol><p>3.jvm -&gt; </p><p>4.sysprop -&gt; 查看和修改JVM的系统属性  </p><p>5.getstatic -&gt; 查看类的静态属性  </p><h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><blockquote><p>当前系统的实时数据面板  </p><p>线程、内存、运行信息 </p></blockquote><img src="http://img.janhen.com/image-20201217211858202.png" alt="image-20201217211858202" style="zoom: 50%;" /><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><blockquote><p>当前JVM 线程堆栈信息  </p></blockquote><ul><li>-b:  找出持有锁的</li><li>-n:  根据 cpu 使用排序</li><li>-i:  指定时间间隔</li><li>–state <value>: 过滤线程状态</li></ul><p>使用最繁忙的 5个线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -i 2000 -n 5</span><br></pre></td></tr></table></figure><p>查看指定线程堆栈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &lt;id&gt;</span><br></pre></td></tr></table></figure><p>查看特定状态的线程: RUNNABLE, TIMED_WAITING, WAITING, BLOCKED..</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread -i 2000 --state TIMED_WAITING</span><br><span class="line">thread -i 2000 --state RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><blockquote><p>查看当前JVM 的信息  </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> RUNTIME                                                                                                                            </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME                          8@e57d77f3ad01                                                                               </span><br><span class="line"> JVM-START-TIME                        2020-12-10 19:38:01                                                                          </span><br><span class="line"> MANAGEMENT-SPEC-VERSION               1.2                                                                                          </span><br><span class="line"> SPEC-NAME                             Java Virtual Machine Specification                                                           </span><br><span class="line"> SPEC-VENDOR                           Oracle Corporation                                                                           </span><br><span class="line"> SPEC-VERSION                          1.8                                                                                          </span><br><span class="line"> VM-NAME                               Java HotSpot(TM) 64-Bit Server VM                                                            </span><br><span class="line"> VM-VENDOR                             Oracle Corporation                                                                           </span><br><span class="line"> VM-VERSION                            25.11-b03                                                                                    </span><br><span class="line"> INPUT-ARGUMENTS                       -Xmx4096M                                                                                    </span><br><span class="line">                                       -Xms4096M                                                                                    </span><br><span class="line">                                       -Xmn1536M                                                                                                                                                     </span><br><span class="line">       ...                                                                   </span><br><span class="line">                                                                                                                                    </span><br><span class="line"> CLASS-PATH                            ...                                                             </span><br><span class="line"> BOOT-CLASS-PATH                       ...                               </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING                                                                                                                      </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT                    34980                                                                                        </span><br><span class="line"> TOTAL-LOADED-CLASS-COUNT              46897                                                                                        </span><br><span class="line"> UNLOADED-CLASS-COUNT                  11917                                                                                        </span><br><span class="line"> IS-VERBOSE                            false                                                                                        </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION                                                                                                                        </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> NAME                                  HotSpot 64-Bit Tiered Compilers                                                              </span><br><span class="line"> TOTAL-COMPILE-TIME                    549939(ms)                                                                                   </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS                                                                                                                 </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> ParNew                                5889/191768(ms)                                                                              </span><br><span class="line"> [count/time]                                                                                                                       </span><br><span class="line"> ConcurrentMarkSweep                   18/12942(ms)                                                                                 </span><br><span class="line"> [count/time]                                                                                                                       </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager                      Code Cache                                                                                   </span><br><span class="line">                                                                                                                                    </span><br><span class="line">...                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY                                                                                                                             </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE                     4133945344(3.85 GiB)/4294967296(4.00 GiB)/4133945344(3.85 GiB)/289171584(275.78 MiB)         </span><br><span class="line"> [committed/init/max/used]                                                                                                          </span><br><span class="line"> NO-HEAP-MEMORY-USAGE                  398196736(379.75 MiB)/2555904(2.44 MiB)/1862270976(1.73 GiB)/340835576(325.05 MiB)           </span><br><span class="line"> [committed/init/max/used]                                                                                                          </span><br><span class="line"> PENDING-FINALIZE-COUNT                0                                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM                                                                                                                   </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OS                                    Linux                                                                                        </span><br><span class="line"> ARCH                                  amd64                                                                                        </span><br><span class="line"> PROCESSORS-COUNT                      6                                                                                            </span><br><span class="line"> LOAD-AVERAGE                          0.35                                                                                         </span><br><span class="line"> VERSION                               3.10.0-957.el7.x86_64                                                                        </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> THREAD                                                                                                                             </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                                 99                                                                                           </span><br><span class="line"> DAEMON-COUNT                          75                                                                                           </span><br><span class="line"> PEAK-COUNT                            99                                                                                           </span><br><span class="line"> STARTED-COUNT                         70889                                                                                        </span><br><span class="line"> DEADLOCK-COUNT                        0                                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> FILE-DESCRIPTOR                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MAX-FILE-DESCRIPTOR-COUNT             1048576                                                                                      </span><br><span class="line"> OPEN-FILE-DESCRIPTOR-COUNT            298                                                                                          </span><br><span class="line">Affect(row-cnt:0) cost in 19 ms.</span><br></pre></td></tr></table></figure><h3 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h3><blockquote><p>查看当前JVM的系统属性(<code>System Property</code>)</p></blockquote><p>查看日志匹配，方便进行日志的收集<br>查看日志文件位置，方便日志的查看<br>查看执行的参数，SpringBoot 之后拼接的参数，方便定位自定义参数的实际指定情况<br>查看 JVM 运行的时区，方便处理日志的时间问题<br>查看运行时的版本，方便查看已知的 JDK bug 修复情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysprop FILE_LOG_PATTERN</span><br><span class="line">sysprop CONSOLE_LOG_PATTER</span><br><span class="line">sysprop LOG_FILE</span><br><span class="line">sysprop sun.java.command</span><br><span class="line">sysprop user.timezone</span><br><span class="line">sysprop java.runtime.version</span><br></pre></td></tr></table></figure><h3 id="getstatic"><a href="#getstatic" class="headerlink" title="getstatic"></a>getstatic</h3><blockquote><p> 查看类的静态属性 , 推荐直接使用 <code>ognl</code> 命令  </p></blockquote><ul><li>-c: 类加载器的 hash id</li><li>-E: 开启正则表达式匹配，默认通配符匹配  <ul><li><code>&lt;class-pattern&gt; </code>                 Class name pattern, use either ‘.’ or ‘/‘ as separator            </li><li><code>&lt;field-pattern&gt;</code>                  Field name pattern                                                </li><li><code>&lt;express&gt;</code>                        the content you want to watch, written by ognl </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic com.janhen.SapConstants JOB_RUNNING_INTERVAL</span><br><span class="line">field: JOB_RUNNING_INTERVAL</span><br><span class="line">@Integer[2]</span><br><span class="line">Affect(row-cnt:1) cost in 331 ms.</span><br><span class="line"></span><br><span class="line"><span class="meta">[arthas@8]$</span><span class="bash"> getstatic com.janhen.SapConstants ALCNTC_INTERFACE_NO</span></span><br><span class="line">field: ALCNTC_INTERFACE_NO</span><br><span class="line">@String[MD038]</span><br><span class="line">Affect(row-cnt:1) cost in 33 ms.</span><br></pre></td></tr></table></figure><p>查看私有的静态变量  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic org.springframework.amqp.rabbit.connection.CachingConnectionFactory DEFAULT_CHANNEL_CACHE_SIZE</span><br></pre></td></tr></table></figure><p>查看集合信息  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic org.springframework.amqp.rabbit.connection.CachingConnectionFactory txStarts</span><br></pre></td></tr></table></figure><p>指定的 classloader 加载的类查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getstatic -c 73ad2d6 io.netty.channel.nio.NioEventLoop logger &#x27;getClass().getName()&#x27;</span><br><span class="line">field: logger</span><br></pre></td></tr></table></figure><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><blockquote><p>查看JVM已加载的类信息</p><p>各个字段的类型，以及访问标识符  </p><p>父类信息、接口信息、类加载器信息、加载的来源文件</p></blockquote><p>search-class  </p><ul><li><p>-d, –details:  Display the details of class        </p></li><li><p>-f, –field: Display all the member variables<br> <class-pattern>                  Class name pattern, use either ‘.’ or ‘/‘ as separato  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -df org.springframework.amqp.rabbit.connection.CachingConnectionFactory*</span><br></pre></td></tr></table></figure></li></ul><h3 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h3><blockquote><p>查看已加载类的方法信息</p><p>声明的类、 构造器、注解、参数、异常、类加载器</p></blockquote><ul><li><p> -c, –classloader <value>        The hash code of the special class’s classLoader                    </p></li><li><p>-d, –details                    Display the details of method<br><code>&lt;class-pattern&gt;</code>                  Class name pattern, use either ‘.’ or ‘/‘ as separator<br><code>&lt;method-pattern&gt;</code>                 Method name pattern   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d org.springframework.amqp.rabbit.connection.CachingConnectionFactory</span><br></pre></td></tr></table></figure><p>查看具体的方法信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d org.springframework.amqp.rabbit.connection.CachingConnectionFactory toString</span><br></pre></td></tr></table></figure></li></ul><h3 id="classloader"><a href="#classloader" class="headerlink" title="classloader"></a>classloader</h3><blockquote><p>查看classloader的继承树，urls，类加载信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> classloader</span><br><span class="line"> name                                                        numberOfInstances  loadedCountTotal    </span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader      1                  15617               </span><br><span class="line"> java.net.URLClassLoader                                     1060               5560                </span><br><span class="line"> BootstrapClassLoader                                        1                  4535                </span><br><span class="line"> java.net.FactoryURLClassLoader                              2                  1666                </span><br><span class="line"> sun.reflect.DelegatingClassLoader                           1406               1406                </span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader                   1                  1116                </span><br><span class="line"> sun.misc.Launcher$AppClassLoader                            1                  47                  </span><br><span class="line"> com.alibaba.fastjson.util.ASMClassLoader                    1                  13                  </span><br><span class="line"> sun.misc.Launcher$ExtClassLoader                            1                  10                  </span><br><span class="line"> org.apache.cxf.common.util.ASMHelper$TypeHelperClassLoader  1                  6                   </span><br><span class="line">Affect(row-cnt:10) cost in 330 ms.</span><br></pre></td></tr></table></figure><h3 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h3><blockquote><p>载入外部 .class，直接修改线上的代码，不能恢复  </p></blockquote><ul><li>-c, –classloader <value>                       classLoader hashcode<br><classfilePaths>                                .class file paths  </li></ul><h3 id="ognl"><a href="#ognl" class="headerlink" title="*ognl"></a>*ognl</h3><blockquote><p>执行ognl表达式， ognl命令实际上包含了getstatic的功能</p></blockquote><p><strong>查看Spring的配置</strong></p><ul><li>-c, –classLoader <value>                     The hash code of the special class’s classLoader, default classLoader is SystemClassLoader. </li></ul><p>查看 Spring 中运行时指定属性的值，先找到持有 ApplicationContext 的类对应的类加载器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc -df com.janhen.SpringContextUtil | grep classLoaderHash</span><br><span class="line">ognl -c b1bc7ed &#x27;#spCtx=@com.janhen.SpringContextUtil@context,#spCtx.getEnvironment().getProperty(&quot;spring.redis.sentinel.nodes&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><strong>设置静态属性值</strong></p><p>一般由配置中心修改，防止 setstatic 不知道什么时候因为什么修改的<br>应该无法更改 final 的静态变量  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;#field=@demo.MathGame@class.getDeclaredField(&quot;random&quot;), #field.setAccessible(true), #field.set(null,null)&#x27;</span><br></pre></td></tr></table></figure><p>替换方式实现：  可以写一个新的类，里面设置 static field的值。然后用 classloader 命令把这个新的类 load到JVM里再执行。   </p><p>上传class到服务器上 redefine </p><p><a href="https://github.com/WangJi92/arthas-idea-plugin/issues/1">https://github.com/WangJi92/arthas-idea-plugin/issues/1</a>  </p><h3 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h3><blockquote><p>记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p></blockquote><p><code>-n &lt;count&gt;</code>: 指定次数, 通过 -n 参数指定需要记录的次数，当达到记录次数时 Arthas 会主动中断tt命令的记录过程，避免人工操作无法停止的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.amqp.rabbit.connection.CachingConnectionFactory toString</span><br></pre></td></tr></table></figure><h2 id="监控与执行"><a href="#监控与执行" class="headerlink" title="监控与执行"></a>监控与执行</h2><p>获取运行时的方法信息、返回信息、执行过程的耗时<br>通过字节码增强技术实现，使用完成之后需要执行shutdown 或者 将增强过的类执行reset 命令。  </p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p> -c, –cycle <value>                             The monitor interval (in seconds), 60 seconds by default<br>  <class-pattern>                                 Path and classname of Pattern Matching<br> <method-pattern>                                Method of Pattern Matching  </p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><blockquote><p>查看方法参数</p></blockquote><ul><li><p>-n, –limits <value>                            Threshold of execution times     </p></li><li><p>-b, –before                                    Watch before invocation  </p></li><li><p>-x, –expand <value>                            Expand level of object (1 by default)  </p></li></ul><p>查看入参对象(Object)以及返回对象(Set)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch com.janhen.ConsumingRtnProcessor getBinAlreadyExistContainerBarcodes &quot;&#123;params, returnObj&#125;&quot; -b -x 2</span><br><span class="line">watch com.janhen.ConsumingRtnProcessor verifyContainer &quot;&#123;params, returnObj&#125;&quot; -b</span><br><span class="line">watch -E .*ConsumingRtnProcessor verify|verifyContainer &quot;&#123;params, returnObj&#125;&quot; -b -x 3</span><br><span class="line">watch -E .*ConsumingRtnProcessor verify|verifyBin|verifyContainer &quot;&#123;params,returnObj&#125;&quot; -b -x 3</span><br><span class="line">watch -E .*ReceiveBillDao update &quot;&#123;params,returnObj&#125;&quot; -b -x 3</span><br><span class="line">watch com.janhen.StockServiceImpl query  &quot;&#123;params,target&#125;&quot; -x 3  </span><br></pre></td></tr></table></figure><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><blockquote><p>跟踪方法耗时</p></blockquote><p>跟踪方法的耗时情况，包含各个阶段的  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace com.janhen.OrderBillServiceImpl getByBillNumber|query</span><br></pre></td></tr></table></figure><p>匹配特定类的所有方法  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -E .*OrderServiceImpl .*</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -E com.janhen.OrderServiceImpl query</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Configure logging drivers<br><a href="https://docs.docker.com/config/containers/logging/configure/">https://docs.docker.com/config/containers/logging/configure/</a>  </p><p>Java线上诊断神器Arthas-2<br><a href="https://kamzhuyuqing.github.io/2018/12/20/Java%E7%BA%BF%E4%B8%8A%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8Arthas-2/">https://kamzhuyuqing.github.io/2018/12/20/Java%E7%BA%BF%E4%B8%8A%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8Arthas-2/</a>  </p><p>技术征文 | 那些年，我用 Arthas 排查过的问题<br><a href="https://mp.weixin.qq.com/s/gJ4ZVvFBuiXbirjTxjwGeQ">https://mp.weixin.qq.com/s/gJ4ZVvFBuiXbirjTxjwGeQ</a>  </p><p>是否可以考虑支持setstatic<br><a href="https://github.com/alibaba/arthas/issues/641">https://github.com/alibaba/arthas/issues/641</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Arthas&lt;/code&gt; 是Alibaba开源的Java诊断工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Percona-Toolkit-数据库工具</title>
    <link href="http://example.com/2020/12/17/Percona-Toolkit/"/>
    <id>http://example.com/2020/12/17/Percona-Toolkit/</id>
    <published>2020-12-17T11:20:54.000Z</published>
    <updated>2021-04-09T09:07:06.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>perl 语言编写, 不同的 linux 发行版不同的安装</p></blockquote><p><strong>DSN 语法</strong></p><ul><li>h: host</li><li>P: 端口</li><li>u: 用户</li><li>p: 密码</li><li>S: mysql_socket  </li><li>D: 数据库</li><li>A: charset  </li><li>t: table</li><li>F:   mysql_read_default_file  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h&#x3D;172.17.10.233,P&#x3D;3306,u&#x3D;root,p&#x3D;root,D&#x3D;testdb3,t&#x3D;testtable1</span><br></pre></td></tr></table></figure><p><strong>分类</strong></p><p>这些工具主要包括开发、性能、配置、监控、复制、系统、实用六大类</p><p align="center">PT 工具分类</p><table><thead><tr><th>工具类别</th><th>工具命令</th><th>工具作用</th><th>备注</th></tr></thead><tbody><tr><td>开发类</td><td>pt-duplicate-key-checker</td><td>列出并删除重复的索引和外键</td><td>优化使用，实用</td></tr><tr><td></td><td>pt-online-schema-change</td><td>在线修改表结构</td><td></td></tr><tr><td></td><td>pt-query-advisor</td><td>分析查询语句，并给出建议，有bug</td><td>已废弃</td></tr><tr><td></td><td>pt-show-grants</td><td>规范化和打印权限</td><td>分析使用</td></tr><tr><td></td><td>pt-upgrade</td><td>在多个服务器上执行查询，并比较不同</td><td></td></tr><tr><td>性能类</td><td>pt-index-usage</td><td>分析日志中索引使用情况，并出报告</td><td>索引查看，实用</td></tr><tr><td></td><td>pt-pmp</td><td>为查询结果跟踪，并汇总跟踪结果</td><td></td></tr><tr><td></td><td>pt-visual-explain</td><td>格式化执行计划</td><td></td></tr><tr><td></td><td>pt-table-usage</td><td>分析日志中查询并分析表使用情况</td><td>pt 2.2新增命令</td></tr><tr><td>配置类</td><td>pt-config-diff</td><td>比较配置文件和参数</td><td></td></tr><tr><td></td><td><strong>pt-mysql-summary</strong></td><td>对mysql配置和status进行汇总</td><td>整体信息，实用</td></tr><tr><td></td><td>pt-variable-advisor</td><td>分析参数，并提出建议</td><td></td></tr><tr><td>监控类</td><td>pt-deadlock-logger</td><td>提取和记录mysql死锁信息</td><td>死锁信息，实用</td></tr><tr><td></td><td>pt-fk-error-logger</td><td>提取和记录外键信息</td><td>pt-deadlock-logger</td></tr><tr><td></td><td>pt-mext</td><td>并行查看status样本信息</td><td></td></tr><tr><td></td><td><strong>pt-query-digest</strong></td><td>分析查询日志，并产生报告</td><td>常用命令</td></tr><tr><td></td><td>pt-trend</td><td>按照时间段读取slow日志信息</td><td>已废弃</td></tr><tr><td>复制类</td><td>pt-heartbeat</td><td>监控mysql复制延迟</td><td></td></tr><tr><td></td><td>pt-slave-delay</td><td>设定从落后主的时间</td><td></td></tr><tr><td></td><td>pt-slave-find</td><td>查找和打印所有mysql复制层级关系</td><td></td></tr><tr><td></td><td>pt-slave-restart</td><td>监控salve错误，并尝试重启salve</td><td></td></tr><tr><td></td><td><strong>pt-table-checksum</strong></td><td>校验主从复制一致性</td><td>实用</td></tr><tr><td></td><td><strong>pt-table-sync</strong></td><td>高效同步表数据</td><td>实用</td></tr><tr><td>系统类</td><td>pt-diskstats</td><td>查看系统磁盘状态</td><td></td></tr><tr><td></td><td>pt-fifo-split</td><td>模拟切割文件并输出</td><td></td></tr><tr><td></td><td>pt-summary</td><td>收集和显示系统概况</td><td></td></tr><tr><td></td><td>pt-stalk</td><td>出现问题时，收集诊断数据</td><td></td></tr><tr><td></td><td>pt-sift</td><td>浏览由pt-stalk创建的文件</td><td>pt 2.2新增命令</td></tr><tr><td></td><td>pt-ioprofile</td><td>查询进程IO并打印一个IO活动表</td><td>pt 2.2新增命令</td></tr><tr><td>实用类</td><td>pt-archiver</td><td>将表数据归档到另一个表或文件中</td><td></td></tr><tr><td></td><td>pt-find</td><td>查找表并执行命令</td><td></td></tr><tr><td></td><td>pt-kill</td><td>Kill掉符合条件的sql</td><td>常用命令</td></tr><tr><td></td><td>pt-align</td><td>对齐其他工具的输出</td><td>pt 2.2新增命令</td></tr><tr><td></td><td>pt-fingerprint</td><td>将查询转成密文</td><td>pt 2.2新增命令</td></tr></tbody></table><h1 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h1><h2 id="pt-summary"><a href="#pt-summary" class="headerlink" title="pt-summary"></a>pt-summary</h2><blockquote><p>可查看挂载情况、网络情况、进程情况  </p></blockquote><ul><li>–sleep:  通过 vmstat 收集的 sleep 时间, 默认 5  </li><li>–summarize-mounts:  挂载的文件系统、磁盘使用, 默认 TRUE  </li><li>–summarize-network:  网络收集、配置, 默认 TRUE   </li><li>–summarize-processes:  top process vmstat 输出, 默认 TRUE   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-summary</span><br></pre></td></tr></table></figure><h2 id="pt-mysql-summary"><a href="#pt-mysql-summary" class="headerlink" title="pt-mysql-summary"></a>pt-mysql-summary</h2><blockquote><p>精细地对 mysql 的配置和 sataus 信息进行汇总, 优先执行<br>各种类型字段在对应数据库中的数量<br>btree 在对应 db 中的数量<br>连接的 host </p><p>当前连接情况, Process list<br>主从连接情况  </p></blockquote><ul><li>–all-databases: 默认 false  </li><li>–databases:  查看指定的数据库  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有数据库</span></span><br><span class="line">pt-mysql-summary \</span><br><span class="line">  --host=127.0.0.1 --port=3306 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --all-databases</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指令数据库</span></span><br><span class="line">pt-mysql-summary \</span><br><span class="line">  --host=127.0.0.1 --port=3306 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --databases testdb</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">状态统计:</span><br><span class="line">Aborted_clients:  取消的连接</span><br><span class="line">Com_change_db:  更改 db 命令?</span><br><span class="line">Com_commit:  事务提交的个数</span><br><span class="line">Com_insert:  插入语句</span><br><span class="line">Com_select:  查询语句</span><br><span class="line">Com_show_engine_status:  查看存储引擎情况</span><br><span class="line">Com_show_table_status: 查看表状态</span><br><span class="line">Com_show_variables:  查看变量</span><br><span class="line">Connections:  连接数</span><br><span class="line">Created_tmp_disk_tables: 创建的临时表</span><br><span class="line">Handler_commit</span><br><span class="line">Handler_rollback</span><br><span class="line">Handler_update</span><br><span class="line">Handler_write</span><br><span class="line">Innodb_buffer_pool_bytes_data:  缓存池数据</span><br><span class="line">Innodb_row_lock_time:  行锁的时间</span><br><span class="line">Innodb_row_lock_waits:  锁等待</span><br><span class="line">Innodb_rows_deleted</span><br><span class="line">Innodb_rows_inserted</span><br><span class="line">Select_full_join:   全表连接</span><br><span class="line">Select_full_range_join:  范围连接</span><br><span class="line">Sort_rows: 排序的行</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pt-mysql-summary \</span><br><span class="line">  --host=127.0.0.1 --port=3306 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --databases testdb1,testdb2</span><br><span class="line"><span class="meta">#</span><span class="bash"> Note Processlist, Schema, InnoDB, Binary Logging</span></span><br><span class="line"> Server_id: 315</span><br><span class="line"> Master_id: 391</span><br><span class="line"> Slave_UUID: 7f80892a-650a-11ea-bb0f-0242ac110002</span><br><span class="line">                  Version | 5.6.47-log MySQL Community Server (GPL)</span><br><span class="line">                  Started | 2020-07-01 19:35 (up 43+14:06:36)</span><br><span class="line">                Databases | 9</span><br><span class="line">                  Datadir | /var/lib/mysql/</span><br><span class="line">                Processes | 60 connected, 4 running</span><br><span class="line">              Replication | Is not a slave, has 1 slaves connected</span><br><span class="line"><span class="meta">#</span><span class="bash"> Processlist <span class="comment">################################################</span></span></span><br><span class="line"></span><br><span class="line">  Command                        COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  Binlog Dump                           1       1      8000      8000</span><br><span class="line">  Daemon                                1       1     20000     20000</span><br><span class="line">  Query                                 1       1         0         0</span><br><span class="line">  Sleep                                60       0     22500      3500</span><br><span class="line"></span><br><span class="line">  User                           COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  event_scheduler                       1       1     20000     20000</span><br><span class="line">  user1                                45       1         0         0</span><br><span class="line">  user2                                 1       1      8000      8000</span><br><span class="line">  user3                                15       0         0         0</span><br><span class="line"></span><br><span class="line">  Host                           COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  127.0.0.1                             1       1         0         0</span><br><span class="line">  172.17.0.1                            2       0         0         0</span><br><span class="line">  192.168.199.116                       1       1      8000      8000</span><br><span class="line">...</span><br><span class="line">  localhost                             1       1     20000     20000</span><br><span class="line"></span><br><span class="line">  db                             COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  NULL                                  3       3     30000     20000</span><br><span class="line">  testdb1                           6       0         0         0</span><br><span class="line">  testdb2                            10       0         0         0</span><br><span class="line">  testdb3                         15       0         0         0</span><br><span class="line">  testdb4                          30       0         0         0</span><br><span class="line">  testdb5                            1       0         0         0</span><br><span class="line"></span><br><span class="line">  State                          COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">                                       60       0         0         0</span><br><span class="line">  Master has sent all binlog to         1       1      8000      8000</span><br><span class="line">  Waiting for next activation           1       1     20000     20000</span><br><span class="line">  init                                  1       1         0         0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Schema <span class="comment">#####################################################</span></span></span><br><span class="line"></span><br><span class="line">  Database     Tables Views SPs Trigs Funcs   FKs Partn</span><br><span class="line">  testdb1      35                           4</span><br><span class="line">  testdb3    223     1                     4</span><br><span class="line"></span><br><span class="line">  Database     InnoDB</span><br><span class="line">  testdb1      35</span><br><span class="line">  testdb3    223</span><br><span class="line"></span><br><span class="line">  Database     BTREE</span><br><span class="line">  testdb1    112</span><br><span class="line">  testdb3   653</span><br><span class="line"></span><br><span class="line">                 v   d   b   s   t   i   c   d   d   t</span><br><span class="line">                 a   a   i   m   e   n   h   e   a   i</span><br><span class="line">                 r   t   g   a   x   t   a   c   t   n</span><br><span class="line">                 c   e   i   l   t       r   i   e   y</span><br><span class="line">                 h   t   n   l               m       i</span><br><span class="line">                 a   i   t   i               a       n</span><br><span class="line">                 r   m       n               l       t</span><br><span class="line">                     e       t</span><br><span class="line">  Database     === === === === === === === === === ===</span><br><span class="line">  testdb1  209  34  13   3   4  17   5</span><br><span class="line">  testdb3 3482 283  88   1   2 132  37 433  73   4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> InnoDB <span class="comment">#####################################################</span></span></span><br><span class="line">                  Version | 5.6.47</span><br><span class="line">         Buffer Pool Size | 18.0G</span><br><span class="line">         Buffer Pool Fill | 100%</span><br><span class="line">        Buffer Pool Dirty | 0%</span><br><span class="line">           File Per Table | ON</span><br><span class="line">                Page Size | 16k</span><br><span class="line">            Log File Size | 2 * 500.0M = 1000.0M</span><br><span class="line">          Log Buffer Size | 8M</span><br><span class="line">             Flush Method |</span><br><span class="line">      Flush Log At Commit | 2</span><br><span class="line">               XA Support | ON</span><br><span class="line">                Checksums | ON</span><br><span class="line">              Doublewrite | ON</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Binary Logging <span class="comment">#############################################</span></span></span><br><span class="line">                  Binlogs | 15</span><br><span class="line">               Zero-Sized | 0</span><br><span class="line">               Total Size | 14.2G</span><br><span class="line">            binlog_format | ROW</span><br><span class="line">         expire_logs_days | 7</span><br><span class="line">              sync_binlog | 0</span><br><span class="line">                server_id | 391</span><br><span class="line">             binlog_do_db |</span><br><span class="line">         binlog_ignore_db |</span><br></pre></td></tr></table></figure><h2 id="pt-deadlock-logger"><a href="#pt-deadlock-logger" class="headerlink" title="pt-deadlock-logger"></a>pt-deadlock-logger</h2><blockquote><p>死锁检测, 收集和保存 mysql 上最近的死锁信息，可以直接打印死锁信息和存储死锁信息到数据库中，死锁信息包括发生死锁的服务器、最近发生死锁的时间、死锁线程 id、死锁的事务 id、发生死锁时事务执行了多长时间等信息。</p></blockquote><ul><li>–columns=A: 控制输出的列  </li><li>–daemonize:  后台运行  </li><li>–log=s:    后台运行将输出到处到指定文件  </li><li>–tab:   使用 tab 进行分割</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-deadlock-logger \</span><br><span class="line">  --h 127.0.0.1 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --tab</span><br></pre></td></tr></table></figure><h2 id="pt-duplicate-key-checker"><a href="#pt-duplicate-key-checker" class="headerlink" title="pt-duplicate-key-checker"></a>pt-duplicate-key-checker</h2><blockquote><p>找出重复的索引和外键，并生成删除重复索引的 SQL 语句   </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-duplicate-key-checker \</span><br><span class="line">  -h 127.0.0.1 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  -d testdb3,testdb1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># ########################################################################</span><br><span class="line"># testdb3.testtable1                                             </span><br><span class="line"># ########################################################################</span><br><span class="line"></span><br><span class="line"># idx_testtable1_06 is a left-prefix of id_testtable1_unique_01</span><br><span class="line"># Key definitions:</span><br><span class="line">#   KEY &#96;idx_testtable1_06&#96; (&#96;dcUuid&#96;)</span><br><span class="line">#   UNIQUE KEY &#96;id_testtable1_unique_01&#96; (&#96;dcUuid&#96;,&#96;billNumber&#96;),</span><br><span class="line"># Column types:</span><br><span class="line">#         &#96;dcuuid&#96; varchar(38) not null comment &#39;配送中心uuid&#39;</span><br><span class="line">#         &#96;billnumber&#96; varchar(30) not null comment &#39;单号&#39;</span><br><span class="line"># To remove this duplicate index, execute:</span><br><span class="line">ALTER TABLE &#96;testdb3&#96;.&#96;testtable1&#96; DROP INDEX &#96;idx_testtable1_06&#96;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># ########################################################################</span><br><span class="line"># Summary of indexes                                                      </span><br><span class="line"># ########################################################################</span><br><span class="line"></span><br><span class="line"># Size Duplicate Indexes   30832348</span><br><span class="line"># Total Duplicate Indexes  23</span><br><span class="line"># Total Indexes            707</span><br></pre></td></tr></table></figure><h2 id="pt-show-grants"><a href="#pt-show-grants" class="headerlink" title="pt-show-grants"></a>pt-show-grants</h2><blockquote><p>查看授权情况  </p></blockquote><ul><li>–flush: 刷新权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show all grants</span></span><br><span class="line">pt-show-grants \</span><br><span class="line"> -h 127.0.0.1 -P3306 \</span><br><span class="line"> -u root -p $MYSQL_ROOT_PASSWORD</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show database grants</span></span><br><span class="line">pt-show-grants \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  -D testdb4</span><br></pre></td></tr></table></figure><p><strong>pt-variable-advisor</strong>  </p><blockquote><p>分析 mysql 的参数变量，并对可能存在的问题提出建议</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pt-variable-advisor --h 172.17.10.233 --u root --p root </span><br><span class="line">pt-variable-advisor --h localhost --u root --p root \</span><br><span class="line">  --source-of-variables /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">  </span><br><span class="line">pt-variable-advisor \</span><br><span class="line">  h=172.17.10.233,P=3306,u=root,p=root, \</span><br><span class="line">  S=/var/run/mysqld/mysqld.sock \</span><br><span class="line">  --source-of-variables=mysql</span><br></pre></td></tr></table></figure><h2 id="pt-table-checksum"><a href="#pt-table-checksum" class="headerlink" title="pt-table-checksum"></a>pt-table-checksum</h2><blockquote><p>校验 MySQL 主从复制的完整性，存在锁表问题。</p></blockquote><p>参数：  </p><ul><li><p>–databases=：指定需要被检查的数据库，多个则用逗号隔开  </p></li><li><p>–tables=：指定需要被检查的表，多个用逗号隔开  </p></li><li><p>-h=127.0.0.1 ：Master的地址  </p></li><li><p>-u=xiaoml：用户名  </p></li><li><p>-p=123456：密码  </p></li><li><p>-P=3306：端口  </p></li><li><p>–tables-regex=s：  表正则匹配  </p></li><li><p>–ignore-tables-regex=s： 忽略的表</p></li><li><p>–replicate=s:  将校验结果保存到表中 <code>percona.checksums</code>  </p></li><li><p>–replicate-database=s:  指定数据库复制校验  </p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum -u root -p root \</span><br><span class="line">  --databases testdb5 \</span><br><span class="line">  --tables=QRTZ_TRIGGERS</span><br></pre></td></tr></table></figure><p>使用依赖： 需要一个既能登录主库，也能登录从库，而且还能同步数据库的账号  </p><p>生产环境使用 pt-table-checksum 检查MySQL数据一致性<br><a href="https://segmentfault.com/a/1190000004309169">https://segmentfault.com/a/1190000004309169</a>  </p><p><strong>pt-diskstats</strong>  </p><blockquote><p>为 GUN/LINUX 打印磁盘 io 统计信息,可以分析从远程机器收集的数据    </p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="pt-index-usage"><a href="#pt-index-usage" class="headerlink" title="pt-index-usage"></a>pt-index-usage</h2><blockquote><p>从 log 文件中读取查询语句，并用 explain 分析他们是如何利用索引。 完成分析之后会生成一份关于索引没有被查询使用过的报告。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-index-usage /var/lib/mysql/slow.log \</span><br><span class="line">  --h localhost --u root --p 123456 \</span><br><span class="line">  -d testdb3 \</span><br><span class="line">  --no-report --create-save-results-database</span><br></pre></td></tr></table></figure><h2 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="*pt-query-digest"></a>*pt-query-digest</h2><blockquote><p>分析查询执行日志，并产生一个查询报告，为 MySQL、PostgreSQL、 memcached 过滤、重放或者转换语句。<br><a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html">pt-query-digest</a></p></blockquote><ul><li><p><code>--database=s</code>:   连接的数据库, 非分析的数据库</p></li><li><p><code>--limit=A</code>:  限制输出的百分比/数量， (default 95%:20)</p></li><li><p><code>--report-all</code>：  所有的查询输出  </p></li><li><p><code>--ignore-attributes=a:</code>  忽略收集的属性   </p></li><li><p><code>--timeline:</code>   展示时间线的事件  </p></li><li><p><code>--review type</code>: DSN   保存查询结果供之后 review, 默认数据库和表为 <code>percona_schema.query_review</code>    </p></li><li><p><code>--report-histogram</code>=s:   属性的直方图，默认为 Query_time   </p></li><li><p><code>--type</code> tcpdump: 类型, 分析多种不同类型的日志  </p><ul><li>binlog: 分析 binlog</li><li>genlog: </li><li>slowlog: 分析慢查询</li><li>tcpdump: </li></ul></li><li><p><code>--order-by</code>: 默认根据查询时间排序， Query_time:sum ，<code>attribute:aggregate</code> 参数的语法  </p><ul><li>sum       Sum/total attribute value</li><li>min       Minimum attribute value</li><li>max       Maximum attribute value</li><li>cnt       Frequency/count of the query</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按照总耗时排序</span></span><br><span class="line">--order-by Query_time:sum </span><br></pre></td></tr></table></figure><ul><li><code>--since=s</code>: 过滤开始时间  </li><li><code>--until=s</code>  过滤结束时间  </li><li><code>--limit=A</code>:  限制输出的百分比/数量， (default 95%:20)  </li><li><code>--filter</code>:  过滤指定的事件, 不同的扫描条件    </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤语句 select：</span></span><br><span class="line">--filter &#x27;$event-&gt;&#123;arg&#125; =~ m/^select/i&#x27;，</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤指定用户：</span></span><br><span class="line">--filter &#x27;($event-&gt;&#123;user&#125; || &quot;&quot;) =~ m/^dba/i&#x27; ，</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤全表扫描：</span></span><br><span class="line">--filter &#x27;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤指定数据库</span></span><br><span class="line">--filter &#x27;$event-&gt;&#123;db&#125; &amp;&amp; $event-&gt;&#123;db&#125; =~ /testdb3/ &amp;&amp; $event-&gt;&#123;user&#125; =~ /root/&#x27; </span><br></pre></td></tr></table></figure><p><strong>使用案例</strong><br>分析所有慢查询日志  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-advisor /var/lib/mysql/slow-query.log</span><br></pre></td></tr></table></figure><p>指定的查询分析  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --query &quot;select * from mysql.user&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest \</span><br><span class="line"> -h127.0.0.1 -P3306 \</span><br><span class="line"> -uroot -proot \</span><br><span class="line"> --since &#x27;2020-07-25 00:00:00&#x27; \</span><br><span class="line"> --until &#x27;2020-07-26 00:00:00&#x27; \</span><br><span class="line"> --limit 20 \</span><br><span class="line"> /var/lib/mysql/mysql-slow.log.200725</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pt-query-digest \</span><br><span class="line"> -uroot -pimws \</span><br><span class="line"> --since &#x27;2020-07-25 00:00:00&#x27; \</span><br><span class="line"> --until &#x27;2020-07-26 00:00:00&#x27; \</span><br><span class="line"> --order-by Query_time:cnt \</span><br><span class="line"> --limit 20 \</span><br><span class="line"> /var/lib/mysql/mysql-slow.log.200725 \</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> slow-analyse-2.log</span></span><br></pre></td></tr></table></figure><h1 id="更改相关"><a href="#更改相关" class="headerlink" title="更改相关"></a>更改相关</h1><h2 id="pt-online-schema-change"><a href="#pt-online-schema-change" class="headerlink" title="*pt-online-schema-change"></a>*pt-online-schema-change</h2><blockquote><p>在线更改表结构，适用于大表结构的更改  </p></blockquote><ul><li><p><code>--host</code>: 连接mysql的地址</p></li><li><p><code>-P=3306</code>: 连接mysql的端口号</p></li><li><p><code>--user</code>: 连接mysql的用户名</p></li><li><p><code>--password</code>: 连接mysql的密码</p></li><li><p><code>--database=s / D</code>: 连接mysql的库名</p></li><li><p><code>t</code>:  连接mysql的表名</p></li><li><p><code>--alter</code>: 修改表结构的语句</p></li><li><p><code>--charset=utf8</code>: 使用utf8编码，避免中文乱码</p></li><li><p><code>--no-version-check:</code> 不检查版本，在阿里云服务器中一般加入此参数，否则会报错</p></li><li><p><code>--execute</code>:  执行修改表结构</p></li><li><p><code>--new-table-name=s</code>:  新创建的表，默认为 <code>&lt;old-table-name&gt;_new</code></p></li><li><p><code>--dry-run</code>:  常见并更改表, 不会创建触发器、复制数据..</p></li><li><p><code>--print</code>:  打印 SQL 执行语句  </p></li><li><p><code>--statistics</code>：  打印内部计数器的统计信息</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert_sql=&quot;ADD COLUMN addColumn varchar(30) DEFAULT &#x27;QTY&#x27; COMMENT &#x27;增加列备注&#x27;,ADD COLUMN addColumn2 varchar(30) DEFAULT 0 COMMENT &#x27;增加列2备注&#x27;,CHANGE COLUMN modColumn varchar(100)&quot;</span><br><span class="line">pt-online-schema-change \</span><br><span class="line">  --user=root --password=root --host=127.0.0.1 \</span><br><span class="line">  --alter  &quot;$alert_sql&quot; \</span><br><span class="line">  D=testdb3,t=testtable1 \</span><br><span class="line">  --print --dry-run</span><br></pre></td></tr></table></figure><h2 id="pt-heartbeat"><a href="#pt-heartbeat" class="headerlink" title="-pt-heartbeat"></a>-pt-heartbeat</h2><blockquote><p>监控 mysql 复制延迟，测量复制落后主 mysql 或者主 PostgreSQL 多少时间，可以使用这个脚本去更新主或者监控复制</p></blockquote><p>通过 <code>show slave status\G</code> 命令中的 <code>Seconds_Behind_Master</code> 值来判断主从延迟并不靠谱。</p><p>原理：<code>pt-heartbeat</code> 通过真实的复制数据来确认 mysql 和 postgresql 复制延迟，避免了对复制机制的依赖，能得出准确的落后复制时间。</p><p>包含两部分：</p><p>第一部分在主上 <code>pt-heartbeat</code> 的 <code>--update</code> 线程会在指定的时间间隔更新一个时间戳，</p><p>第二部分是 <code>pt-heartbeat</code> 的 <code>--monitor</code> 线程或者 <code>--check</code> 线程连接到从上检查复制的心跳记录（前面更新的时间戳），并和当前系统时间进行比较，得出时间的差异。</p><p>可以手工创建 heartbeat 表或者添加 –create-table 参数。</p><ul><li>-D / –database=s: 指定数据库, 必须的参数</li><li>–update, –monitor, –check: 互斥参数</li><li>–daemonize, –check: 互斥参数</li><li>–config: 指定配置文件的位置， key 必须为全称</li><li>–create-table： 创建heartbeat表如果该表不存在，该表由–database和–table参数来确认</li><li>–file： 将最新的–monitor信息输出到文件中，新的信息会覆盖旧的信息，通常和–daemonize参数一起使用</li><li>–frames：  统计的时间窗口，默认为1m,5m,15m</li><li>-master-server-id： 指定master的server_id，在检测从的延迟时，必须指定该参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建 heartbeat 表, 保存主从执行情况</span></span><br><span class="line">master_server_id=$(</span><br><span class="line"> mysql -uroot -proot \</span><br><span class="line">   -e &quot;SHOW VARIABLES LIKE &#x27;server_id&#x27;\G&quot; \</span><br><span class="line">   | grep Value \</span><br><span class="line">   | sed -n -e &#x27;s/^.*: //p&#x27;</span><br><span class="line">)</span><br><span class="line">slave_server=192.168.199.116</span><br><span class="line"></span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --create-table \</span><br><span class="line">  --update </span><br><span class="line"></span><br><span class="line">mysql -uroot -proot -e &quot;SELECT * FROM testdb3.heartbeat &quot;;</span><br><span class="line"></span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --update &amp;</span><br></pre></td></tr></table></figure><p>查看主从延迟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -h $slave_server \</span><br><span class="line">--monitor \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --print-master-server-id</span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --check</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">实时延迟，1分钟延迟，5分钟延迟，15分钟延迟</span></span><br><span class="line">0.00s [  0.00s,  0.00s,  0.00s ] 391</span><br><span class="line">0.00s [  0.00s,  0.00s,  0.00s ] 391</span><br></pre></td></tr></table></figure><p>守护线程方式执行， 2s 执行一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pt-heartbeat \</span><br><span class="line"> -u root -proot \</span><br><span class="line"> -D testdb3 \</span><br><span class="line"> --master-server-id=$master_server_id \</span><br><span class="line"> --update --daemonize --interval=2</span><br><span class="line"></span><br><span class="line">pt-heartbeat --stop</span><br></pre></td></tr></table></figure><p>监控从库并输出日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pt-heartbeat \</span><br><span class="line"> -u root -proot \</span><br><span class="line"> -D testdb3 \</span><br><span class="line"> --master-server-id=$master_server_id \</span><br><span class="line"> --monitor --print-master-server-id \</span><br><span class="line"> --daemonize --interval=2 \</span><br><span class="line"> --log=/var/lib/mysql/slave-lag.log</span><br></pre></td></tr></table></figure><p>使用pt-heartbeat监控主从复制延迟<br><a href="https://cloud.tencent.com/developer/article/1183713">https://cloud.tencent.com/developer/article/1183713</a><br>pt-heartbeat<br><a href="https://www.cnblogs.com/ivictor/p/5901853.html">https://www.cnblogs.com/ivictor/p/5901853.html</a></p><h2 id="pt-table-sync"><a href="#pt-table-sync" class="headerlink" title="-pt-table-sync"></a>-<strong>pt-table-sync</strong></h2><blockquote><p>主从过程中不同步的表进行同步, 解决主从数据不一致的问题。</p></blockquote><p>注意事项：<br>使用 <code>--dry-run</code> 和 <code>--print</code> 选项总是先测试同步。  </p><p>无法同步表结构，和索引等对象，只能同步数据  </p><p>使用该工具来解决主从数据不一致的问题，也可以用来对两个不在一个主从拓扑实例，进行数据 sync  </p><ul><li><p>–[no]check-slave: 检查目标服务器是否是从数据库，默认为 Yes    </p></li><li><p>–sync-to-master and/or –replicate:  只有当需要sync的表都有唯一键(主键或唯一索引)，才能使用–sync-to-master and/or –replicate。(没有唯一键，则只能在desitination上直接修改，而指定–sync-to-master and/or –replicate时只能在主库上修改)，如果sync主从时没有指定–replicate或者–sync-to-master则所有修改都在从库上执行(不论表上是否有唯一键)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看数据不一致</span></span><br><span class="line">pt-table-sync --print  \</span><br><span class="line">  h=127.0.0.1,P=3306,u=root,p=root h=127.0.0.1,P=3307 \</span><br><span class="line">  --database=testdb5 --tables=testtable1  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复</span></span><br><span class="line">pt-table-sync --execute \</span><br><span class="line">h=127.0.0.1,P=3306,u=root,p=root h=127.0.0.1,P=3307 \</span><br><span class="line">--database=testdb5 --tables=testtable2</span><br></pre></td></tr></table></figure><h2 id="pt-archiver"><a href="#pt-archiver" class="headerlink" title="pt-archiver"></a>pt-archiver</h2><blockquote><p>将 mysql 数据库中表的记录归档到另外一个表或者文件，也可以直接进行记录的删除操作</p></blockquote><p>只是归档旧的数据，不会对线上数据的 OLTP 查询造成太大影响，可以将数据插入另外一台服务器的其他表中，也可以写入到一个文件中，方便使用 <code>load data infile</code> 命令导入数据。还可以用来执行 delete 操作, <font color="green">默认的会删除源中的数据</font>。使用的时候请注意  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> create table</span></span><br><span class="line">mysql -uroot -proot \</span><br><span class="line">  -e &quot;CREATE TABLE IF NOT EXISTS testdb4.bak_mis_wm_testtable1 LIKE testdb4.mis_wm_testtable1&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> archive data to bak table and file</span></span><br><span class="line">pt-archiver \</span><br><span class="line">  --source h=172.17.10.233,u=root,p=root,D=testdb4,t=mis_wm_testtable1 \</span><br><span class="line">  --dest h=172.17.10.233,u=root,p=root,D=testdb4,t=bak_mis_wm_testtable1 \</span><br><span class="line">  --file &#x27;/var/lib/mysql/%Y-%m-%d-%D.%t&#x27; \</span><br><span class="line">  --where &quot;dispatchState = &#x27;FINISHED&#x27;&quot; \</span><br><span class="line">  --limit 1000 --commit-each</span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><a href="https://www.cnblogs.com/chenpingzhao/p/4850420.html">percona-toolkit工具的使用</a><br>Percona-Toolkit 示例说明<br><a href="https://blog.csdn.net/kk185800961/article/details/85016523">https://blog.csdn.net/kk185800961/article/details/85016523</a>  </p><p>pt-query-digest（percona toolkit）小解<br><a href="https://www.cnblogs.com/shengdimaya/p/7063204.html">https://www.cnblogs.com/shengdimaya/p/7063204.html</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;perl 语言编写, 不同的 linux 发行版不同的安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/12/17/Blog/"/>
    <id>http://example.com/2020/12/17/Blog/</id>
    <published>2020-12-17T01:14:13.711Z</published>
    <updated>2020-12-17T01:14:13.711Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>旋转数组类问题</title>
    <link href="http://example.com/2020/11/10/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/10/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-09T17:03:57.000Z</published>
    <updated>2020-11-09T17:07:11.087Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数组旋转 k 位</strong></p><p><a href="https://leetcode.com/problems/rotate-array/">189. Rotate Array</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    k = k % n;                     <span class="comment">// prevent unnecessary rotate</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, n-k-<span class="number">1</span>);</span><br><span class="line">    reverse(nums, n-k, n-<span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;数组旋转 k 位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-array/&quot;&gt;189. Rotate Array&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二分查找及变种</title>
    <link href="http://example.com/2020/11/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2020/11/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-11-09T16:56:19.000Z</published>
    <updated>2021-04-13T00:32:22.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>（1） 算法</p><p>（2） 复杂度</p><p>O(logN)</p><p>（3）性质</p><ul><li><p>适用于处理 ceil、floor 等操作；</p></li><li><p>配合索引相当于是实现了跳表结构；</p></li></ul><p><strong>1、 普通二分查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、 带有重复元素的二分查找-最先&amp;最后</strong></p><p>（1） 查找含有重复元素的数组集合中元素第一次出现的位置</p><p>在相等的情况下，进行判断决定是否进行缩小范围或找到对应的值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == aim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] != nums[mid])  <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; aim) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 查找含有重复元素的数组集合中元素最后一次出现的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid] != nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; key) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 二分查找-大于&amp;小于</strong></p><p>（1） 查找小于等于给定元素的最小元素在数组中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchFloor</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length-<span class="number">1</span> || nums[mid+<span class="number">1</span>] &gt; key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 查找大于等于给定元素的最小元素在数组中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchCeil</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] &lt; key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、 带偏移的二分查找</strong></p><p>用于旋转数组的查找，偏移后数据有序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchOffset</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> realMid = (mid + offset) % nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[realMid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; key) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;p&gt;（1） 算法&lt;/p&gt;
&lt;p&gt;（2） 复杂度&lt;/p&gt;
&lt;p&gt;O(logN)&lt;/p&gt;
&lt;p&gt;（3）性质&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础排序及变种</title>
    <link href="http://example.com/2020/11/10/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2020/11/10/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-09T16:51:39.000Z</published>
    <updated>2021-04-19T15:04:00.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本的排序算法，以及变种</p></blockquote><p><a href="https://www.notion.so/f0d201fbc4234aa292d96bca0100661d">排序比较</a></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>（1） 算法:</p><p>选择数组中最小的元素, 将它与数组的第一个元素交换, 之后开始次小元元素… （2） 复杂度</p><p>比较: N²/2, 交换: N 最坏: O(n²)</p><p>最好: O(n²)，</p><p>平均: O(n²)</p><p>（3） 性质:</p><ul><li>运行时间与输入无关；</li><li>不稳定；</li><li>原地排序；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>（1） 算法: 从左到右不断交换相邻逆序的元素, 经过一次循环确定最后一个元素到达最右侧 存在传入数组已经有序的情况</p><p>（2） 复杂度分析: 最坏: O(n²) 最好: O(n), 集合有序, 需要进行一次冒泡 平均: O(n²)</p><p>（3） 性质：</p><ul><li>元素交换的次数为固定值, 原始数据的逆序度 需要三次赋值操作；</li><li>稳定；</li><li>原地排序；</li></ul><p><strong>1、基础冒泡</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --)  <span class="comment">// insure N-1~1 position, 0 must in correct position</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序性优化"><a href="#有序性优化" class="headerlink" title="有序性优化"></a><strong>有序性优化</strong></h3><p>对于已经有序的数据，不进行元素交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasSorted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !hasSorted; i --) &#123;  <span class="comment">// except bad condtion</span></span><br><span class="line">        hasSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;    <span class="comment">// when equal not modify original order</span></span><br><span class="line">                hasSorted = <span class="keyword">false</span>;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>（1）算法: 将数组分为两部分，将后部分元素逐一与前部分元素比较，如果前部分元素比 array[i] 小，就将前部分元素往后移动。当没有比 array[i] 小的元素，即是合理位置，在此位置插入 array[i]。</p><p>（2） 复杂度分析</p><p>最坏: O(n²), 数组逆序, 需要 N²/2 比较 N²/2 交换</p><p>最好: O(n), 正序, 需要 N-1 比较 0 次交换 平均: O(n^2) N²/4 比较 N²/4 交换</p><p>（3） 性质:</p><ul><li>复杂度取决于数组的初始顺序， 移动次数为逆序对的数量；</li><li>稳定；</li><li>原地排序；</li></ul><p><strong>基础插入排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortB</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j --)</span><br><span class="line">            swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值优化"><a href="#赋值优化" class="headerlink" title="赋值优化"></a><strong>赋值优化</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[i], j;   <span class="comment">// e current element, j should put position</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e &lt; arr[j-<span class="number">1</span>])</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表实现插入排序"><a href="#链表实现插入排序" class="headerlink" title="链表实现插入排序"></a><strong>链表实现插入排序</strong></h3><p><a href="https://leetcode.com/problems/insertion-sort-list/">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode first = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode cur = head;  <span class="comment">//the node will be inserted</span></span><br><span class="line">  ListNode pre = first; <span class="comment">//insert node between pre and pre.next</span></span><br><span class="line">  ListNode next = <span class="keyword">null</span>; <span class="comment">//the next node will be inserted</span></span><br><span class="line">  <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    next = cur.next;</span><br><span class="line">    <span class="comment">//find the right place to insert</span></span><br><span class="line">    <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val) &#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//insert between pre and pre.next</span></span><br><span class="line">    cur.next = pre.next;</span><br><span class="line">    pre.next = cur;</span><br><span class="line">    pre = first;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="http://img.janhen.com/20210130164857image-20201122224138741.png" alt="http://img.janhen.com/20210130164857image-20201122224138741.png"></p><p>希尔排序可视轨迹</p><p>（1） 算法：使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p>（2） 复杂度分析： 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。</p><p>（3） 性质：</p><ul><li>交换不相邻元素，将逆序数量减少大于1；</li><li>基于原来的插入排序；</li><li>不稳定；</li><li>原地排序；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i += h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h; j -= h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j-h]) swap(arr, j, j - h);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>（1） 思想: 分治, 分区</p><p>（2） 复杂度: 由每次选取的分割点控制 最好: 每次分割点都为中间的元素， O(logN) 最坏: 每次分割点都为最后元素 O(n²)</p><p>（3） 性质:</p><ul><li>每趟排序就有一个元素排在了最终的位置上，第n趟结束，<strong>至少</strong>有n个元素已经排在了最终的位置上；</li><li>非稳定</li><li>原地排序</li></ul><p>（4） 归并 VS 快排: 归并由下到上, 先处理子问题之后合并，快排由上到下, 先进行分区然后处理子问题；</p><p>归并非原地排序，需要辅助空间，快排通过原地分区函数实现原地排序；</p><p>归并排序为稳定的排序，保留原来相同值的顺序；</p><p>（5） 优化: 三数取中法 随机选取法</p><p><strong>随机取枢纽元</strong></p><p>小数据集使用插入排序；</p><p>随机选择枢纽元比较；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        insertSort(arr, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = partition(arr, lo, hi);</span><br><span class="line">    quickSort(arr, lo, j - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, j +<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速选择；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    swap(arr,lo,lo +(<span class="keyword">int</span>) Math.random() * (hi-lo+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[++ i] &lt; pivot) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[-- j] &gt; pivot) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, j, lo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三路快排优化"><a href="#三路快排优化" class="headerlink" title="三路快排优化"></a><strong>三路快排优化</strong></h3><p><img src="http://img.janhen.com/20210130164902image-20201122224436315.png" alt="http://img.janhen.com/20210130164902image-20201122224436315.png"></p><p>三向切分快排可视轨迹</p><p>对重复元素较多的情形优化；</p><p>函数返回重复元素第一次和最后一次出现位置；</p><p>类似荷兰国旗问题的处理；</p><p>相关： <a href="https://leetcode.com/problems/sort-colors/description/">75. Sort Colors</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo,<span class="keyword">int</span> hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo - <span class="number">1</span>, gt = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;              <span class="comment">// 各个区间的语义</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] == pivot) </span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            swap(arr, i ++, ++ lt);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            swap(arr, i, -- gt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;lt+<span class="number">1</span>, gt-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数取中值确定枢纽元优化"><a href="#三数取中值确定枢纽元优化" class="headerlink" title="三数取中值确定枢纽元优化"></a><strong>三数取中值确定枢纽元优化</strong></h3><p>枢纽元的选取上进行优化；</p><p>选取边界和中间数将三处进行排序，选择中间元素作为枢纽元，并放入 [hi-1] 位置；</p><p>之后 [lo], [hi] 可以作为快排内循环的哨兵；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort three element AND put hi-1 position</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">medianOf3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[lo] &gt; arr[mid]) swap(arr, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (arr[lo] &gt; arr[hi]) swap(arr, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[hi]) swap(arr, mid, hi);</span><br><span class="line">    swap(arr, mid, hi - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[hi - <span class="number">1</span>];        <span class="comment">// pivot is mid value, and position is hi-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> pivot)</span> </span>&#123;  <span class="comment">// pivot original position hi - 1</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++ i] &lt; pivot);   <span class="comment">// <span class="doctag">NOTE:</span> [hi-1] as sentinel</span></span><br><span class="line">        <span class="keyword">while</span> (arr[-- j] &gt; pivot);   <span class="comment">// [lo] as sentinel</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, hi - <span class="number">1</span>);  <span class="comment">// put pivot as correct position</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt;= INSERTITION_SORT_THRESHOLD) &#123;</span><br><span class="line">        insertSort(arr, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> median = medianOf3(arr, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = partition(arr, lo, hi, median);</span><br><span class="line">    quickSort(arr, lo, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr,i +<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>（1） 算法</p><p>（2） 复杂度</p><p>大部分为 O(NlogN)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T(n) = 2T(n/2) + n = 2(2T(n/4) + n/2) + n </span><br><span class="line">     = 4T(n/4) + 2n = 4(2T(n/8) + n/4) + 2n </span><br><span class="line">     = 8T(n/8) + 3n = 8(2T(n/16) + n/8) + 3n </span><br><span class="line">     = 16T(n/16) + 4n …… = 2^k  T(n/2^k) + k * n</span><br></pre></td></tr></table></figure><p>（3） 性质</p><ul><li>大数据量情况下出现无法分配空间情况；</li><li>稳定的排序；</li><li>非原地排序；</li></ul><p><strong>基础归并排序</strong></p><p><img src="http://img.janhen.com/20210130164907image-20201122224009106.png" alt="http://img.janhen.com/20210130164907image-20201122224009106.png"></p><p>自顶向下归并排序可视轨迹</p><p>① 对排序的两个子数组 [lo,mid], [mid+1, hi]，在 [mid] &gt;= [mid+1] 数组整体有序情况下跳过合并；</p><p>② 分配当前两个数组对应的数组空间作为辅助；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; INSERTITION_SORT_THRESHOLD) &#123;</span><br><span class="line">        insertSort(arr, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, lo, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])    loopArrQueue</span><br><span class="line">    merge(arr, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[hi - lo + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; aux.length; k ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) aux[k] = arr[j ++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) aux[k] = arr[i ++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; arr[j]) aux[k] = arr[i ++];</span><br><span class="line">        <span class="keyword">else</span> aux[k] = arr[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; aux.length; k ++) </span><br><span class="line">       arr[k + lo] = aux[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a><strong>自底向上的归并排序</strong></h3><p><img src="http://img.janhen.com/20210130164913image-20201122223815424.png" alt="http://img.janhen.com/20210130164913image-20201122223815424.png"></p><p>自底向上的归并排序可视轨迹</p><p>考虑处理两种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P1  __ __ | __ __ | __ __ | _       i + sz &lt; arr.length to control</span><br><span class="line">P2  __ __ | __ __ | __ __ | __ _    min&#123;i + sz + sz - 1, arr.length - 1&#125; to control</span><br></pre></td></tr></table></figure><p>sz 为两个子数组的区间大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N;  sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; N; i += sz + sz) &#123;  loopArrQueue</span><br><span class="line">            merge(arr, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, N-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用链表进行归并排序"><a href="#使用链表进行归并排序" class="headerlink" title="使用链表进行归并排序"></a><strong>使用链表进行归并排序</strong></h3><p>执行过程：</p><p>① 找出中间节点，分割链表；</p><p>② 对分割的链表分别进行归并排序；</p><p>③ 将链表合并；</p><p>相关： <a href="https://leetcode.com/problems/sort-list/">leetcode</a> | <a href="https://leetcode-cn.com/problems/sort-list/">leetcode-cn</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. find mid node and cut two list</span></span><br><span class="line">  ListNode preMid = preMidNode(head);</span><br><span class="line">  ListNode mid = preMid.next;</span><br><span class="line">  preMid.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 2. handle two sub problem</span></span><br><span class="line">  ListNode l1 = sortList(head);</span><br><span class="line">  ListNode l2 = sortList(mid);</span><br><span class="line">  <span class="comment">// 3. merge result</span></span><br><span class="line">  <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">preMidNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  ListNode pre = <span class="keyword">null</span>, fast = head, slow = head;</span><br><span class="line">  <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = merge(l1.next, l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    l2.next = merge(l1, l2.next);</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并-k-个已经排序的链表"><a href="#合并-k-个已经排序的链表" class="headerlink" title="合并 k 个已经排序的链表"></a><strong>合并 k 个已经排序的链表</strong></h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">leetcode-cn</a> | <a href="https://leetcode.com/problems/merge-k-sorted-lists/">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mergeSortList(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSortList</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">      <span class="keyword">return</span> lists[lo];  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    ListNode left = mergeSortList(lists, lo, mid);</span><br><span class="line">    ListNode right = mergeSortList(lists, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">return</span> merge(left, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并两个排序的链表</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      l1.next = merge(l1.next, l2);</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l2.next = merge(l1, l2.next);</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="http://img.janhen.com/20210130164926image-20201122225020506.png" alt="http://img.janhen.com/20210130164926image-20201122225020506.png"></p><p>堆排序可视轨迹</p><p>（1） 算法</p><p>（2） 复杂度</p><p>O(logN)</p><p>（3） 性质</p><ul><li>无法利用到现代处理器的缓存局部性原理，一般不使用；</li><li>不稳定；</li><li>原地排序，适用于嵌入式系统中内存小的情况；</li></ul><p><strong>基础堆排序</strong></p><p>先通过向堆中不断插入元素，向上调整形成堆结构；</p><p>之后不断删除堆顶元素实现排序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i ++)</span><br><span class="line">        heapify(arr, i);                            <span class="comment">// heapInsert</span></span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;                              <span class="comment">// heapify: delete and adjust heap structure</span></span><br><span class="line">        swap(arr, -- N, <span class="number">0</span>);</span><br><span class="line">        sink(arr, N, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[k] &gt; arr[(k - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, k, (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        k = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">            j ++;</span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt;= arr[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a><strong>算法优化</strong></h3><p>与 java.util.ProrityQueue 中实现逻辑相同</p><p>① 通过 sink 向下调整进行优化；</p><p>② 下沉操作中使用赋值替代交换，常数级优化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (N - <span class="number">2</span>)  / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)      <span class="comment">// build heap</span></span><br><span class="line">        sink(arr, i, N);</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;                   <span class="comment">// delete max ⇔ put into last position</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, -- N);</span><br><span class="line">        sink(arr, <span class="number">0</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = arr[k];</span><br><span class="line">    <span class="keyword">while</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">    j = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= arr[j])  <span class="keyword">break</span>;</span><br><span class="line">        arr[k] = arr[j];</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[k] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并-k-个已经排序的链表-1"><a href="#合并-k-个已经排序的链表-1" class="headerlink" title="合并 k 个已经排序的链表"></a><strong>合并 k 个已经排序的链表</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化加载所有链表的头节点</span></span><br><span class="line">  PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, Comparator.comparingInt(l -&gt; l.val));   <span class="comment">// list like each data flow</span></span><br><span class="line">  <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pq.offer(list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较每条链表当前的头节点</span></span><br><span class="line">  ListNode first = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">  ListNode cur = first;</span><br><span class="line">  <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">    cur.next = pq.poll();</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pq.offer(cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基本的排序算法，以及变种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/f0d201fbc4234aa292d96bca0100661d&quot;&gt;排序比较&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;选择排序</summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
