<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Janhen</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-19T14:56:28.090Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Janhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构设计</title>
    <link href="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-04-19T14:53:47.000Z</published>
    <updated>2021-04-19T14:56:28.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><h3 id="Array-实现-Queue"><a href="#Array-实现-Queue" class="headerlink" title="Array 实现 Queue"></a>Array 实现 Queue</h3><p>和 Java 中的 ArrayDequeue 实现类似，记录队列头部和尾部的索引实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> E[] data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> frontIdx;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tailIdx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    frontIdx = <span class="number">0</span>;</span><br><span class="line">    tailIdx = <span class="number">0</span>;</span><br><span class="line">    N = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == data.length)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;LinkedQueue is full.&quot;</span>);</span><br><span class="line">    data[tailIdx] = e;</span><br><span class="line">    tailIdx = (tailIdx + <span class="number">1</span>) % data.length;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;LinkedQueue is empty.&quot;</span>);</span><br><span class="line">    E oldFront = data[frontIdx];</span><br><span class="line">    data[frontIdx] = <span class="keyword">null</span>;</span><br><span class="line">    frontIdx = (frontIdx + <span class="number">1</span>) % data.length;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;LinkedQueue is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data[frontIdx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array-实现-Stack"><a href="#Array-实现-Stack" class="headerlink" title="Array 实现 Stack"></a>Array 实现 Stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> E[] data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    N = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == data.length)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">    data[N] = e;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">    E oldTop = data[N - <span class="number">1</span>];</span><br><span class="line">    data[N - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">return</span> oldTop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data[N - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stack-实现-Queue"><a href="#Stack-实现-Queue" class="headerlink" title="Stack 实现 Queue"></a>Stack 实现 Queue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="comment">// peek element always is first put element when pop or peek operation</span></span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    in.push(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in2out();</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in2out();</span><br><span class="line">    <span class="keyword">return</span> out.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// maintain out first pop is first input</span></span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">        out.push(in.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-实现-Stack"><a href="#Queue-实现-Stack" class="headerlink" title="Queue 实现 Stack"></a>Queue 实现 Stack</h3><p>两个队列实现, 在弹出时进行结构调整 peek, poll   O(N) push         O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    data.offer(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">while</span> (data.size() &gt; <span class="number">1</span>)</span><br><span class="line">      help.offer(data.poll());</span><br><span class="line">    <span class="keyword">int</span> oldTop = data.poll();</span><br><span class="line">    swap();</span><br><span class="line">    <span class="keyword">return</span> oldTop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">while</span> (data.size() &gt; <span class="number">1</span>)</span><br><span class="line">      help.offer(data.poll());</span><br><span class="line">    <span class="keyword">int</span> top = data.poll();</span><br><span class="line">    help.offer(top);</span><br><span class="line">    swap();</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; t = data;</span><br><span class="line">    data = help;</span><br><span class="line">    help = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二： 一个队列实现</p><p>同一个队列实现, 将队尾元素重新插入到队首元素实现逆序 push  O(N) pop   O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue.offer(x);</span><br><span class="line">    <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">    <span class="comment">// reverse queue element, offer(poll())</span></span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      queue.offer(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> queue.poll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h3><p>实现一种狗猫队列的结构，要求如下： 用户可以调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add        方法，将cat类或dog类的实例放入队列中； 用户可以调用</span><br><span class="line">pollAll    方法，将队列中所有的实例按照进队列的先后顺序依次弹出； 用户可以调用</span><br><span class="line">pollDog    方法，将队列中dog类的实例按照进队列的先后顺序依次弹出； 用户可以调用</span><br><span class="line">pollCat    方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； 用户可以调用</span><br><span class="line">isEmpty    方法，检查队列中是否还有dog或cat的实例； 用户可以调用</span><br><span class="line">isDogEmpty 方法，检查队列中是否有dog类的实例； 用户可以调用</span><br><span class="line">isCatEmpty 方法，检查队列中是否有cat类的实例。</span><br></pre></td></tr></table></figure><p>每个 Pet 加入时通过 index 标识次序, 用于弹出时比较. 分开存储, Cat、Dog 分别存放到一个队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatDogQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;WrappedPet&gt; dogs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;WrappedPet&gt; cats = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequence; <span class="comment">// as index to keep order</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dogs.isEmpty() &amp;&amp; cats.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cats.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dogs.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Pet pet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add pet to different queue by pet type</span></span><br><span class="line">    <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">      dogs.add(<span class="keyword">new</span> WrappedPet(pet, sequence++));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">      cats.add(<span class="keyword">new</span> WrappedPet(pet, sequence++));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;not a dog or cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pet <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// one queue is empty</span></span><br><span class="line">    <span class="keyword">if</span> (dogs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> cats.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cats.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> dogs.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare sequence number</span></span><br><span class="line">    <span class="keyword">return</span> dogs.peek().getCount() &lt; cats.peek().getCount() ?</span><br><span class="line">      dogs.poll().getPet() :</span><br><span class="line">      cats.poll().getPet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cat <span class="title">pollCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cats.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;have no cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Cat) cats.poll().getPet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Dog <span class="title">pollDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dogs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;have no dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Dog) dogs.poll().getPet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedPet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedPet</span><span class="params">(Pet pet, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.pet = pet;</span><br><span class="line">      <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有最小值的栈"><a href="#带有最小值的栈" class="headerlink" title="带有最小值的栈"></a>带有最小值的栈</h3><p>min 栈与 data 栈存放元素个数不一致</p><p>min 栈只存放小元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty() || x &lt;= min.peek()) &#123;</span><br><span class="line">      min.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    data.push(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (data.peek().equals(min.peek()))</span><br><span class="line">      min.pop();</span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> data.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> min.peek();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="LRU-实现"><a href="#LRU-实现" class="headerlink" title="LRU 实现"></a>LRU 实现</h3><p><a href="https://leetcode.com/problems/lru-cache/">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> );</span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br></pre></td></tr></table></figure><p>使用构建一个双向链表来维护 LRU 的关系，一个 Map 对应 element value → Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="keyword">private</span> Node head;</span><br><span class="line">  <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    Integer key;</span><br><span class="line">    Integer val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer k, Integer v)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = k;</span><br><span class="line">      <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity * <span class="number">4</span> / <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = cache.get(key);</span><br><span class="line">    remove(node);</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">      Node oldNode = cache.get(key);</span><br><span class="line">      oldNode.val = value;</span><br><span class="line">      remove(oldNode);</span><br><span class="line">      setHead(oldNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">      <span class="keyword">if</span> (cache.size() &gt;= capacity) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cache is FULL! Removing &quot;</span> + tail.val + <span class="string">&quot; from cache...&quot;</span>);</span><br><span class="line">        cache.remove(tail.key);</span><br><span class="line">        remove(tail);</span><br><span class="line">      &#125;</span><br><span class="line">      setHead(newNode);</span><br><span class="line">      cache.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove from list node, note head tail edge</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.prev.next = node.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      head = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.next.prev = node.prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tail = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// make node(newNode or accessed node) to head</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    node.next = head;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init or remove no element</span></span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      head.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    head = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init or remove no element</span></span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">      tail = head;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LFU-实现"><a href="#LFU-实现" class="headerlink" title="LFU 实现"></a>LFU 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">headList</span><br><span class="line">   <span class="number">1</span>  &lt;-&gt;  <span class="number">3</span>  &lt;-&gt;  <span class="number">4</span>  &lt;-&gt;  <span class="number">7</span></span><br><span class="line">   F       G       H       I</span><br><span class="line">   ^       ^       ^       ^</span><br><span class="line">   |       |       |       |</span><br><span class="line">   v       v       v       v</span><br><span class="line">   A       D</span><br><span class="line">   ^</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">   C</span><br><span class="line">   ^</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">   E</span><br></pre></td></tr></table></figure><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h3><p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">nowcoder</a></p><p>思路: 原始拆分存储在不同的容器中 通过维护左右两个堆实现, 左边的为最大堆, 右边的为最小堆 插入元素时, 若当前容器大小为偶数, 通过先放入右边的最大堆, 之后弹出左边最大堆的堆顶元素放入右边的最小堆实现有序性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// max heap</span></span><br><span class="line">  <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; leftSmall = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">  <span class="comment">// min heap</span></span><br><span class="line">  <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; rightBig = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;   <span class="comment">// even, put rightBig AND ordered</span></span><br><span class="line">      leftSmall.offer(num);</span><br><span class="line">      rightBig.offer(leftSmall.poll());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">// odd, right N/2+1</span></span><br><span class="line">      rightBig.offer(num);</span><br><span class="line">      leftSmall.offer(rightBig.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    N++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> (leftSmall.peek() + rightBig.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">double</span>) rightBig.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leftSmall.isEmpty() &amp;&amp; rightBig.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h3><p>一对一的映射</p><p>一个 Map 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;K, V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!map.get(key).equals(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// O(n)</span></span><br><span class="line">      <span class="keyword">if</span> (map.containsValue(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      map.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 Map 实现</p><p>分别保存 key 和 val，使用一个 sequence 来唯一确定是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneMap2</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;K, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;V, Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequence;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// O(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">    Integer keyReplace = map1.put(key, sequence);</span><br><span class="line">    Integer valReplace = map2.put(val, sequence);</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(keyReplace, valReplace) == <span class="keyword">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sequence++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有最大值的滑动窗口"><a href="#带有最大值的滑动窗口" class="headerlink" title="带有最大值的滑动窗口"></a>带有最大值的滑动窗口</h3><p><a href="https://leetcode.com/problems/sliding-window-maximum/">leetcode-sliding-window-maximum</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], and k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>方式一： 单调的双向队列实现</p><p>offer, poll O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// keep original enqueue order</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Tuple&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// Monotone decreasing, last element is max</span></span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Tuple&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">// increasing sequence</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequencer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// poll not meet to main monotonicity</span></span><br><span class="line">    <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; val &gt;= qmax.peekLast().val) &#123;</span><br><span class="line">      qmax.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tuple tuple = <span class="keyword">new</span> Tuple(val, sequencer++);</span><br><span class="line">    queue.offer(tuple);</span><br><span class="line">    qmax.offerLast(tuple);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple oldFront = queue.poll();</span><br><span class="line">    <span class="comment">// remove relate max value</span></span><br><span class="line">    <span class="keyword">if</span> (qmax.peekFirst().idx == oldFront.idx) &#123;</span><br><span class="line">      qmax.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldFront.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qmax.peekFirst().val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wrapped value with idx to record original put order</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    Tuple(<span class="keyword">int</span> val, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val = val;</span><br><span class="line">      <span class="keyword">this</span>.idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二： 使用堆实现</p><p>offer, poll O(nlogn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue2</span> </span>&#123;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    queue.offer(e);</span><br><span class="line">    heap.offer(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">int</span> oldFront = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (oldFront == heap.peek())</span><br><span class="line">      heap.poll();  <span class="comment">// time: O(nlogn)</span></span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// O(1) 获取队列中的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> heap.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三： 使用 MaxStack 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (max.isEmpty()) &#123;</span><br><span class="line">        max.push(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt;= max.peek()) &#123;</span><br><span class="line">        max.push(e);</span><br><span class="line">      &#125;</span><br><span class="line">      data.push(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Integer oldTop = data.pop();</span><br><span class="line">      <span class="keyword">if</span> (max.peek() == oldTop)</span><br><span class="line">        max.pop();</span><br><span class="line">      <span class="keyword">return</span> oldTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (max.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="keyword">return</span> max.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MaxStack in = <span class="keyword">new</span> MaxStack();</span><br><span class="line">  <span class="keyword">private</span> MaxStack out = <span class="keyword">new</span> MaxStack();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    in.push(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty())</span><br><span class="line">        out.push(in.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty())</span><br><span class="line">        out.push(in.pop());</span><br><span class="line">    <span class="keyword">return</span> out.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// O(1) 获取队列中的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> Math.max(in.isEmpty() ? Integer.MIN_VALUE : in.max(),</span><br><span class="line">      out.isEmpty() ? Integer.MIN_VALUE : out.max());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.size() + out.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流中第一个重复元素"><a href="#数据流中第一个重复元素" class="headerlink" title="数据流中第一个重复元素"></a>数据流中第一个重复元素</h3><p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">nowcoder</a></p><p>通过 Map 记录当前所有字节流中的词频, loopArrQueue 保留原始的字节流插入顺序,同时保证 loopArrQueue 的队首元素词频为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Character, Integer&gt; freqs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// record original sequence</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    freqs.put(ch, freqs.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    queue.offer(ch);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; freqs.get(queue.peek()) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      queue.poll(); <span class="comment">// pop head of queue and keep head freq is 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列与栈&quot;&gt;&lt;a href=&quot;#队列与栈&quot; class=&quot;headerlink&quot; title=&quot;队列与栈&quot;&gt;&lt;/a&gt;队列与栈&lt;/h2&gt;&lt;h3 id=&quot;Array-实现-Queue&quot;&gt;&lt;a href=&quot;#Array-实现-Queue&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spark实现KNN近邻算法</title>
    <link href="http://example.com/2021/04/16/Spark%E5%AE%9E%E7%8E%B0KNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/04/16/Spark%E5%AE%9E%E7%8E%B0KNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-16T02:32:24.000Z</published>
    <updated>2021-04-16T02:33:10.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KNN-近邻算法"><a href="#KNN-近邻算法" class="headerlink" title="KNN 近邻算法"></a>KNN 近邻算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p><img src="http://img.janhen.com/202104160847096mLEpK.jpg" alt="http://img.janhen.com/202104160847096mLEpK.jpg"></p><p><strong>KNN 算法描述</strong></p><p>KNN（k-NearestNeighbor）又被称为最近邻算法。</p><p>思路是：若一个样本在特征空间中的 k 个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>KNN 算法是机器学习中最简单的方法之一。KNN 是一种分类算法，KNN 没有显式的学习过程，即没有训练阶段，待收到新样本后直接进行处理。</p><p><strong>距离计算</strong></p><p>计算待测案例与训练样本之间的距离，常用的距离有欧式距离、曼哈顿距离、余弦距离等。</p><p>在欧几里得空间中，点x =(x1,…,xn)和 y =(y1,…,yn)之间的欧氏距离为</p><p><img src="http://img.janhen.com/20210416090249gfm1go.png" alt="http://img.janhen.com/20210416090249gfm1go.png"></p><p>欧几里得距离</p><p><strong>算法实现流程：</strong></p><ol><li>读文件中的测试数据、训练数据集，形成数据集 X,Y</li><li>求数据集 Y 中的每个点到数据集 X 中每个点的位置，得到数据集 D</li><li>找到数据集 D 中最小的 K 个点</li><li>求 K 个点的分布情况</li><li>返回前 K 个点中出现频率最高的类别作为测试数据的预测分类</li></ol><h3 id="鸢尾花数据集"><a href="#鸢尾花数据集" class="headerlink" title="鸢尾花数据集"></a>鸢尾花数据集</h3><p>数据集内包含 3 类共 150 条 记录，每类各 50 个数据，</p><p>记录都有 4 项特征：花萼长度、花萼宽度、花瓣长度、花瓣宽度，可以通过这 4个 特征预测鸢尾花卉属于哪一品种(iris-setosa, iris-versicolour, iris-virginica)。</p><p>原始的数据集：Iris.csv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Id,SepalLengthCm,SepalWidthCm,PetalLengthCm,PetalWidthCm,Species</span><br><span class="line">1,5.1,3.5,1.4,0.2,Iris-setosa</span><br><span class="line">2,4.9,3.0,1.4,0.2,Iris-setosa</span><br><span class="line">3,4.7,3.2,1.3,0.2,Iris-setosa</span><br><span class="line">..</span><br><span class="line">52,6.4,3.2,4.5,1.5,Iris-versicolor</span><br><span class="line">53,6.9,3.1,4.9,1.5,Iris-versicolor</span><br><span class="line">..</span><br><span class="line">102,5.8,2.7,5.1,1.9,Iris-virginica</span><br><span class="line">103,7.1,3.0,5.9,2.1,Iris-virginica</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>未知的数据集：unknown_iris.csv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8888,5.7,4.4,1.5,0.4,Iris-setosa22</span><br><span class="line">7777,5.5,2.4,4.0,1.4,Iris-versicolor22</span><br><span class="line">6666,6.8,3.2,5.1,2.3,Iris-virginica22</span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KNNDriver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="type">K</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;knn-test&quot;</span>).setMaster(<span class="string">&quot;local[4]&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">        sc.setLogLevel(<span class="string">&quot;WARN&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取实际的数据   id, (x1,y1,z1,e1)</span></span><br><span class="line">        <span class="keyword">val</span> realRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])] = sc.textFile(<span class="string">&quot;data/Iris.csv&quot;</span>).map(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (fields(<span class="number">0</span>).equals(<span class="string">&quot;Id&quot;</span>)) &#123;</span><br><span class="line">                (<span class="string">&quot;unknown&quot;</span>, <span class="type">Array</span>(<span class="number">-1.0</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (fields.last, fields.init.tail.map(_.toDouble))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">val</span> realBc: <span class="type">Broadcast</span>[<span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])]] = sc.broadcast(realRdd.collect)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取待验证的数据</span></span><br><span class="line">        <span class="keyword">val</span> toValidRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])] = sc.textFile(<span class="string">&quot;data/unknown_iris.csv&quot;</span>).map(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (fields(<span class="number">0</span>).equals(<span class="string">&quot;Id&quot;</span>)) &#123;</span><br><span class="line">                (<span class="string">&quot;unknown&quot;</span>, <span class="type">Array</span>(<span class="number">-1.0</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (fields.last, fields.init.tail.map(_.toDouble))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> varData: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Double</span>])] = toValidRdd.collect()</span><br><span class="line">        varData.foreach(elem =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> res: <span class="type">Array</span>[(<span class="type">Double</span>, <span class="type">String</span>)] = realBc.value.map(point =&gt; (distance(point._2, elem._2), point._1))</span><br><span class="line">            <span class="keyword">val</span> kNeastNeighbor: <span class="type">Array</span>[(<span class="type">Double</span>, <span class="type">String</span>)] = res.sortBy(_._1).take(<span class="type">K</span>)</span><br><span class="line">            <span class="keyword">val</span> labels: <span class="type">Array</span>[<span class="type">String</span>] = kNeastNeighbor.map(_._2)</span><br><span class="line">            print(<span class="string">s&quot;TestData: <span class="subst">$&#123;elem._2.toBuffer&#125;</span>, NearestNeighbor: &quot;</span>)</span><br><span class="line">            labels.groupBy(x =&gt; x).mapValues(_.length).foreach(print)</span><br><span class="line">            println()</span><br><span class="line">        &#125;)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个点之间的欧式距离</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span></span>(x: <span class="type">Array</span>[<span class="type">Double</span>], y: <span class="type">Array</span>[<span class="type">Double</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">        math.sqrt(x.zip(y).map(z =&gt; math.pow(z._1 - z._2, <span class="number">2</span>)).sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestData: ArrayBuffer(5.7, 4.4, 1.5, 0.4), NearestNeighbor: (Iris-setosa,15)</span><br><span class="line">TestData: ArrayBuffer(5.5, 2.4, 4.0, 1.4), NearestNeighbor: (Iris-versicolor,15)</span><br><span class="line">TestData: ArrayBuffer(6.8, 3.2, 5.1, 2.3), NearestNeighbor: (Iris-virginica,14)(Iris-versicolor,1)</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><p>训练时间复杂度低，为O(n)；</p><p>简单，易于理解；</p><p>可用于非线性分类；</p><p>缺点：</p><p>使用懒散学习方法，基本上不学习，导致预测时速度比起逻辑回归之类的算法慢；</p><p>KNN 模型可解释性不强。</p><p>分类的时候，未考虑权重等因素，仅根据投票数量来决定分类结果。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm#Algorithm">k-nearest neighbors algorithm - Wikipedia</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB">欧几里得距离 - 维基百科，自由的百科全书</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KNN-近邻算法&quot;&gt;&lt;a href=&quot;#KNN-近邻算法&quot; class=&quot;headerlink&quot; title=&quot;KNN 近邻算法&quot;&gt;&lt;/a&gt;KNN 近邻算法&lt;/h2&gt;&lt;h3 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spark-内存管理与持久化</title>
    <link href="http://example.com/2021/04/14/Spark-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2021/04/14/Spark-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-04-14T07:10:07.364Z</published>
    <updated>2021-04-15T02:50:00.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>静态内存管理</strong></p><p>Spark 2.0 以前版本采用静态内存管理机制。存储内存、执行内存和其他内存的大小在 Spark 应用程序运行期间均为固定的。 容易造成存储内存和执行内存中的一方剩余大量的空间，而另一方却早早被占满，不得不淘汰或移出旧的内容以存储新的内容。目前已经被淘汰。</p><p><strong>统一内存管理</strong></p><p>Spark 2.0 之后引入统一内存管理机制，存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域，统一内存管理的堆内内存结构。</p><p>可以借用内存</p><p>最重要的优化在于动态占用机制</p><p>在执行过程中：执行内存的优先级 &gt; 存储内存的优先级</p><p>凭借统一内存管理机制，Spark 在一定程度上<strong>提高了堆内和堆外内存资源的利用率</strong>， 降低了开发者维护 Spark 内存的难度</p><h3 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h3><p><strong>RDD 持久化机制</strong></p><p>Task 在启动之初读取一个分区时：</p><ul><li>先判断这个分区是否已经被持久化</li><li>如果没有则需要检查 Checkpoint 或按照血统重新计算。</li></ul><p>RDD 的持久化由 Spark 的 Storage(BlockManager) 模块负责，实现了 RDD 与物理存储的解耦合。</p><p>Storage 模块在逻辑上以 Block 为基本存储单位，RDD 的每个 Partition 经过处理后 唯一对应一个Block。</p><p><strong>RDD 缓存过程</strong> RDD 缓存的源头：Other (Iterator / 内存空间不连续)</p><p>Record 的对象实例在逻辑上占用了 JVM 堆内内存的 other 部分的空间，同一 Partition 的不同 Record 的存储空间并不连续。</p><p>RDD 在缓存到存储内存之后，Partition 被转换成 Block，Record 在堆内或堆外存储内存中占用一块连续的空间 将 Partition 由不连续的存储空间转换为连续存储空间的过程，Spark 称之为展开（Unroll）。</p><p><strong>淘汰与落盘</strong> 存储内存的淘汰规则为：</p><ul><li>被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存</li><li>新旧 Block 不能属于同一个 RDD，避免循环淘汰</li><li>旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题</li><li>遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MemoryStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    blockInfoManager: <span class="type">BlockInfoManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    serializerManager: <span class="type">SerializerManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    memoryManager: <span class="type">MemoryManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    blockEvictionHandler: <span class="type">BlockEvictionHandler</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> entries = <span class="keyword">new</span> <span class="type">LinkedHashMap</span>[<span class="type">BlockId</span>, <span class="type">MemoryEntry</span>[_]](<span class="number">32</span>, <span class="number">0.75</span>f, <span class="literal">true</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行内存管理"><a href="#执行内存管理" class="headerlink" title="执行内存管理"></a>执行内存管理</h3><p>主要用来存储任务在执行 Shuffle 时占用的内存</p><p>Spark 会使用一种叫 <code>AppendOnlyMap</code> 的哈希表在堆内执行内存中存储数据</p><p>Spark 的存储内存和执行内存使用不同的管理方式：</p><ul><li>对存储内存来说，Spark 用一个 <code>LinkedHashMap</code> 来集中管理所有的 Block， Block 由需要缓存的 RDD 的 Partition 转化而成；</li><li>对执行内存来说，Spark 用 <code>AppendOnlyMap</code> 来存储 Shuffle 过程中的数据， 在 Tungsten 排序中甚至抽象成为页式内存管理，开辟了全新的 JVM 内存管理机制。</li></ul><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>数据持久化/缓存的目的：</p><p>Spark 默认数据存放在内存中，适合高速迭代，多个步骤只有第一个输入数据，中间不产生临时数据，风险很高，容易出错，需要进行容错。 RDD 出错/分片可以根据血统重新计算出来，如果没有父 RDD 进行 persist 或者 cache，就需要重新做，耗时较大。将数据缓存起来，方便进行迭代计算。</p><h3 id="RDD-持久化"><a href="#RDD-持久化" class="headerlink" title="RDD 持久化"></a>RDD 持久化</h3><p>RDD 中的数据持久化：</p><p>对于 Spark 中 RDD 不支持的持久化方式，可使用 foreachPartition 进行自定义。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">saveAsObjectFile()</span><br><span class="line">saveAsTextFile()</span><br><span class="line">saveAsHadoopFile()</span><br><span class="line">saveAsHadoopDataset()</span><br><span class="line">saveAsSequenceFile()</span><br></pre></td></tr></table></figure><h3 id="cache-和-persist-比较"><a href="#cache-和-persist-比较" class="headerlink" title="cache 和 persist 比较"></a>cache 和 persist 比较</h3><p>都是用于将一个 RDD 缓存，之后使用的时候就不用重新计算了，节省程序运行时间</p><ul><li>cache 只有一个默认的缓存级别 MEMORY_ONLY, cache 调用了persist，而 persist 可以根据情况设置其它的缓存级别；</li><li>executor 执行的时候，默认 60% 做 cache，40% 做 task 操作，persist 是最根本的函数，最底层的函数。</li></ul><h3 id="persist-适用场景"><a href="#persist-适用场景" class="headerlink" title="persist 适用场景"></a>persist 适用场景</h3><ul><li>特定步骤耗时高</li><li>计算的链条长，重新计算步骤多</li><li>checkpoint 所在的 rdd 要持久化 persist</li><li>shuffle 之后进行 percist, shuffle 需要进行网络传输，风险大</li><li>shuffle 之前进行 precast，框架默认将数据持久化到磁盘，自动执行的</li></ul><h3 id="cache-和-checkpoint-比较"><a href="#cache-和-checkpoint-比较" class="headerlink" title="cache 和 checkpoint 比较"></a>cache 和 checkpoint 比较</h3><p>cache 和 checkpoint 是有显著区别的，缓存把 RDD 计算出来然后放在内存中，但是 RDD 的依赖链还在， 当某个点某个 executor 挂掉了，上面 cache 的 RDD 就会丢掉，需要通过依赖链重放计算。checkpoint 是把 RDD 保存在 HDFS 中，是多副本可靠存储，依赖链可以丢掉，斩断了依赖链，在 executor 发生故障的时候，从 HDFS 中取出，无需重放计算。</p><h3 id="Partition-与-Block-的关联关系"><a href="#Partition-与-Block-的关联关系" class="headerlink" title="Partition 与 Block 的关联关系"></a>Partition 与 Block 的关联关系</h3><ul><li>HDFS 中的 Block 是分布式存储的最小单位，等分，可设置冗余，可能有一部分磁盘空间的浪费</li><li>Spark 中的 Partition 是 RDD 的最小单元，RDD 是由分布在各个节点上的 Partition 组成。Partition 指的是 Spark 计算过程中，生成的数据在计算空间内的最小单元，同一份数据(RDD) 的 partition 大小不一、数量不定，根据 Application 里的算子和最初读入的数据分块决定</li><li>Block 位于存储空间、Partition 位于计算空间，Block 的大小是固定的，Partition 的大小是不固定的。</li></ul><h2 id="BlockManager"><a href="#BlockManager" class="headerlink" title="BlockManager"></a>BlockManager</h2><blockquote><p>管理数据块。是一个嵌入在 Spark 中的 key-value 型分布式存储系统，也是 Master-Slave 结构的，RDD-cache、 shuffle-output、broadcast 等的实现都是基于 BlockManager 来实现的。</p></blockquote><p><img src="http://img.janhen.com/20210414144422ZnWph0.jpg" alt="http://img.janhen.com/20210414144422ZnWph0.jpg"></p><p><strong>BlockManager 中的组件：</strong></p><ul><li>DiskStore：负责对磁盘数据进行读写</li><li>MemoryStore：负责对内存数据进行读写</li><li>BlockTransferService：负责建立到远程其他节点 BlockManager 的连接，对远程其他节点的 BlockManager 的数据进行读写</li></ul><p><strong>存储和管理机制：</strong></p><p>每个节点上存储的 block 信息都会汇报给 Driver 端的 BlockManager Master 作统一管理，BlockManager 对外提供 get 和 set 数据接口，可将数据存储在 Memory、Disk、Off-heap。</p><p><strong>BlockManger 在 Spark 中的使用</strong></p><ul><li>shuffle 的过程中使用 BlockManager 作为数据的中转站</li><li>将广播变量发送到 Executor 时， broadcast 底层使用的数据存储层</li><li>spark streaming 一个 ReceiverInputDStream 接收到的数据，先放在 BlockManager 中， 然后封装为一个 BlockRdd 进行下一步运算</li><li>如果对一个 RDD 进行了 cache，CacheManager 也是把数据放在了 BlockManager 中， 后续 Task 运行的时候可以直接从 CacheManager 中获取到缓存的数据，不用再从头计算</li></ul><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><ul><li><code>spark.storage.memoryFraction</code><ul><li>用于设置 RDD 持久化数据在 Executor 内存中能占的比例，默认是 0.6， 默认 Executor 60% 的内存，可以用来保存持久化的 RDD 数据。根据的持久化策略，如果内存不够时，可能数据就不会持久化，或者数据会写入磁盘；</li><li>如果持久化操作比较多，可以提高 <code>spark.storage.memoryFraction</code> 参数，使得更多的持久化数据保存在内存中，提高数据的读取性能，如果 shuffle 的操作比较多，有很多的数据读写操作到 JVM 中，那么应该调小一点，节约出更多的内存给 JVM，避免过多的 JVM gc 发生。</li></ul></li><li><code>spark.shuffle.memoryFraction</code><ul><li>为 Spark 调优中的重要参数，shuffle 从上一个 task 拉去数据过来，要在Executor进行聚合操作， 聚合操作时使用Executor内存的比例由该参数决定，默认是20%如果聚合时数据超过了该大小，那么就会spill到磁盘，极大降低性能；</li><li>如果Spark作业中的RDD持久化操作较少，shuffle操作较多时，建议降低持久化操作的内存占比，提高shuffle操作的内存占比比例， 避免shuffle过程中数据过多时内存不够用，必须溢写到磁盘上，降低了性能。此外，如果发现作业由于频繁的gc导致运行缓慢，意味着task执行用户代码的内存不够用， 那么同样建议调低这个参数的值。</li></ul></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://books.japila.pl/apache-spark-internals/storage/BlockManager/">BlockManager - The Internals of Apache Spark</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;静态内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark 2.0 以前版本采用静态内存管理机制。存储内存、执</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-管理</title>
    <link href="http://example.com/2021/04/09/Kafka%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/04/09/Kafka%E7%AE%A1%E7%90%86/</id>
    <published>2021-04-09T15:33:00.000Z</published>
    <updated>2021-04-15T02:50:31.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h2><p>需要依赖 Zookeeper 进行协调</p><p>// TODO 补充集群安装</p><h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><p><strong>服务的启停</strong></p><p>kafka-server-start 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前台启动</span></span><br><span class="line">kafka-server-start.sh <span class="variable">$KAFKA_HOME</span>/config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop</span></span><br><span class="line">kafka-server-stop.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># send message</span></span><br><span class="line">curl linux123/<span class="built_in">log</span> -d <span class="string">&quot;message send to kafka ..0000000088888&quot;</span></span><br><span class="line"></span><br><span class="line">vi <span class="variable">$KAFKA_HOME</span>/config/server.properties</span><br><span class="line">bootstrap.servers=linux121:9092,linux122:9092,linux123:9092</span><br></pre></td></tr></table></figure><h3 id="主题操作"><a href="#主题操作" class="headerlink" title="主题操作"></a><strong>主题操作</strong></h3><ul><li><p><code>--zookeeper:</code> 指定 zk 的元数据地址</p></li><li><p><code>--list</code>: 展示主题列表</p></li><li><pre><code>--describe<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ： 查看主题详情</span><br><span class="line"></span><br><span class="line">  - &#96;--topics-with-overrides&#96;： 覆盖默认主题配置的参数</span><br><span class="line"></span><br><span class="line">操作：</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  --create</span><br></pre></td></tr></table></figure>: 创建操作- `--partitions`: 指定分区个数，不能大于可用的 broker 数量- `--replication-factor`： 指定复制因子- `--replica-assignment`：</code></pre></li><li><p><code>--alter</code>： 变更主题，如变更主题的分区数</p></li><li><p><code>--delete</code>： 删除</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">topic=jsonori</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 all 主题</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建指定的 topic broker count =&gt; replication-factor</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --create \\</span><br><span class="line">  --topic <span class="variable">$topic</span> \\</span><br><span class="line">  --partitions 1 \\</span><br><span class="line">  --replication-factor 1</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看 topic 的信息</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --describe --topic <span class="variable">$topic</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除 topic, 标记</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --delete \\</span><br><span class="line">  --topic <span class="variable">$topic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖默认参数的配置查看</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --topics-with-overrides \\</span><br><span class="line">  --describe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改主题配置</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --alter \\</span><br><span class="line">  --topic <span class="variable">$topic</span> \\</span><br><span class="line">  --config max.message.bytes=1048576</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调高主题的分区数</span></span><br><span class="line">kafka-topics.sh --zookeeper localhost/myKafka \\</span><br><span class="line">  --alter \\</span><br><span class="line">  --topic <span class="variable">$topic</span> \\</span><br><span class="line">  --partitions 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的配置  </span></span><br><span class="line">kafka-topics.sh --zookeeper localhost:2181/myKafka \\</span><br><span class="line">  --alter --delete-config max.message.bytes \\</span><br><span class="line">  --topic <span class="variable">$topic</span></span><br></pre></td></tr></table></figure><p>再均衡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照配置的分配进行再均衡</span></span><br><span class="line">kafka-topics.sh --zookeeper node1:2181/myKafka \\</span><br><span class="line">  --create \\</span><br><span class="line">  --topic tp_demo_03 \\</span><br><span class="line">  --replica-assignment <span class="string">&quot;0:1,1:0,0:1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="生产者操作"><a href="#生产者操作" class="headerlink" title="生产者操作"></a><strong>生产者操作</strong></h3><ul><li><code>--broker-list &lt;String: broker-list&gt;</code>: 指定 Brokder 地址</li><li><code>--line-reader &lt;String: reader_class&gt;</code>:</li><li><code>--property &lt;String: prop&gt;</code>:</li><li><code>--producer.config &lt;String: config file&gt;</code>:</li><li><code>--topic &lt;String: topic&gt;</code>:</li><li><code>--value-serializer &lt;String:encoder_class&gt;</code>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer.sh --broker-list localhost:9092 \\</span><br><span class="line">  --topic <span class="variable">$topic</span></span><br></pre></td></tr></table></figure><h3 id="消费者操作"><a href="#消费者操作" class="headerlink" title="消费者操作"></a><strong>消费者操作</strong></h3><ul><li>–bootstrap-server： 指定消费的地址</li><li>–from-beginning：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费指定的 topic 的消息</span></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 \\</span><br><span class="line">  --topic <span class="variable">$topic</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 指定从何消费 - 从头消费</span></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 \\</span><br><span class="line">  --topic <span class="variable">$topic</span> \\</span><br><span class="line">  --from-beginning</span><br></pre></td></tr></table></figure><p><strong>Offset 的操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查指定主题的 offset 情况</span></span><br><span class="line">kafka-run-class.sh kafka.tools.GetOffsetShell \\</span><br><span class="line">  --broker-list linux121:9092,linux122:9092,linux123:9092 \\</span><br><span class="line">  --topic topicB \\</span><br><span class="line">  --time -1</span><br></pre></td></tr></table></figure><h3 id="消费组操作"><a href="#消费组操作" class="headerlink" title="消费组操作"></a>消费组操作</h3><p>操作消费组的偏移量：</p><ul><li>–reset-offsets<ul><li>–to-latest：</li><li>–shift-by：</li><li>–to-earliest：</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看正在进行消费的 group ID </span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server linux121:9092 --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 offsets 信息</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server linux121:9092 -describe --group user_consumer</span><br><span class="line"></span><br><span class="line"><span class="comment"># offsets 设置为最早的</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server linux121:9092 \\</span><br><span class="line">  --reset-offsets --group user_consumer \\</span><br><span class="line">  --to-earliest --topic <span class="variable">$topic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># offsets 设置为最新的</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server linux121:9092 \\</span><br><span class="line">  --reset-offsets --group user_consumer \\</span><br><span class="line">  --to-latest --topic <span class="variable">$topic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定主题的指定分区的偏移量向前移动 10 个消息</span></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server linux121:9092 \\</span><br><span class="line">  --reset-offsets --group user_consumer \\</span><br><span class="line">  --shift-by 10 --topic <span class="variable">$topic</span>:2</span><br><span class="line"></span><br><span class="line">kafka-consumer-groups.sh --bootstrap-server linux121:9092 \\</span><br><span class="line">  --reset-offsets --group user_consumer \\</span><br><span class="line">  --shift-by -10 --topic <span class="variable">$topic</span>:1</span><br></pre></td></tr></table></figure><h3 id="分区重新分配"><a href="#分区重新分配" class="headerlink" title="分区重新分配"></a>分区重新分配</h3><p>定义哪些 topic 需要重新分区, 文件 topics-to-move.json {</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;topics&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;topic&quot;</span>:<span class="string">&quot;tp_re_01&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行分配，可根据需要修改生成后建议的计划。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再分配, 给出建议的分配结果</span></span><br><span class="line">kafka-reassign-partitions.sh --zookeeper linux121:2181/myKafka \\\\</span><br><span class="line">  --reassigment-json-file topics-to-execute.json \\\\</span><br><span class="line">  --execute</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 验证, 数据较多的情况下验证是否执行完毕</span></span><br><span class="line">kafka-reassign-partitions.sh --zookeeper linux121:2181/myKafka \\\\</span><br><span class="line">  --reassigment-json-file topics-to-execute.json \\\\</span><br><span class="line">  --verify</span><br></pre></td></tr></table></figure><p><strong>自动再均衡</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper node1:2181/myKafka \\</span><br><span class="line">  --create --topic tp_demo_03 \\</span><br><span class="line">  --replica-assignment <span class="string">&quot;0:1,1:0,0:1&quot;</span></span><br></pre></td></tr></table></figure><p><a href="http://kafka-preferred-replica-election.sh/">kafka-preferred-replica-election.sh</a> 用于自动再均衡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka-preferred-replica-election.sh --zookeeper linux121:2181/myKafka \\</span><br><span class="line">  --path-to-json-file preferred-replica.json</span><br></pre></td></tr></table></figure><p><strong>修改副本因子</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;partitions&quot;</span>: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;topic&quot;</span>: <span class="string">&quot;tp_re_02&quot;</span>,</span><br><span class="line"><span class="attr">&quot;partition&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;replicas&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;topic&quot;</span>: <span class="string">&quot;tp_re_02&quot;</span>,</span><br><span class="line"><span class="attr">&quot;partition&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;replicas&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;topic&quot;</span>: <span class="string">&quot;tp_re_02&quot;</span>,</span><br><span class="line"><span class="attr">&quot;partition&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;replicas&quot;</span>: [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">kafka-reassign-partitions.sh --zookeeper linux121:2181/myKafka \\</span><br><span class="line">  --reassignment-json-file increase-replicationfactor.json \\</span><br><span class="line">  --execute</span><br></pre></td></tr></table></figure><h3 id="物理存储查看"><a href="#物理存储查看" class="headerlink" title="物理存储查看"></a>物理存储查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kafka-run-class.sh kafka.tools.DumpLogSegments \\</span><br><span class="line">  --files 00000000000000000000.log \\</span><br><span class="line">  --print-data-log | head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 offset 索引文件</span></span><br><span class="line">kafka-run-class.sh kafka.tools.DumpLogSegments \\</span><br><span class="line">  --files 00000000000000000000.index \\</span><br><span class="line">  --print-data-log | head</span><br></pre></td></tr></table></figure><h2 id="Kafka-配置"><a href="#Kafka-配置" class="headerlink" title="Kafka 配置"></a>Kafka 配置</h2><p><a href="http://broader.id/">broader.id</a>: 建议与主机相关</p><p>log.dirs: 持久化的数据目录, 可指定多个</p><p><strong>再平衡参数</strong></p><ul><li><code>auto.offset.reset</code>： Kafka 中没有初始偏移量或当前偏移量在服务器中不存在时的处理， earliest， latest, none, anything</li><li><code>enable.auto.commit</code>: 设置为 true，消费者会自动周期性地向服务器提交偏移量。</li><li><code>auto.commit.interval.ms</code>: 自动提交间隔</li><li><a href="http://max.poll.interval.ms/">max.poll.interval.ms</a>: 心跳</li><li><a href="http://session.timeout.ms/">session.timeout.ms</a>: 心跳超时时间</li><li>fetch.min.bytes:</li><li><a href="http://fetch.max.wait.ms/">fetch.max.wait.ms</a>:</li><li>fetch.max.bytes:</li><li><a href="http://connections.max.idle.ms/">connections.max.idle.ms</a>:</li><li>check.crcs:</li><li>exclude.internal.topics:</li><li>isolation.level： 控制如何读取事务消息。</li><li><a href="http://heartbeat.interval.ms/">heartbeat.interval.ms</a>:</li><li>max.poll.records:</li><li>max.partition.fetch.bytes:</li><li>send.buffer.bytes:</li><li><a href="http://retry.backoff.ms/">retry.backoff.ms</a>:</li><li>offsets.topic.num.partitions： __consumer_offsets 分区个数</li><li>partition.assignment.strategy: 指定分配策略</li></ul><p><strong>主题相关参数</strong></p><ul><li>compress.type= 压缩格式 gzip, snappy， 默认是没有压缩的, producer 为…</li><li>cleanup.policy: 默认 delete, 对旧日志的利用方式，可选 compact</li><li><a href="http://delete.retention.ms/">delete.retention.ms</a></li><li><a href="http://flush.ms/">flush.ms</a></li><li>flush.messages</li><li>max.message.bytes=512:</li><li>retention.bytes: 默认不配置, 日志保留的最大大小</li><li><a href="http://rendition.ms/">rendition.ms</a>: 默认保留的日志时间</li><li>segment.bytes: 默认 1G，持久化存储时分段</li><li>segment.index.bytes: 10MB,   .log, .index, .idx，一般不关注</li><li><a href="http://segment.ms/">segment.ms</a>: 7days</li><li>unclean.leader.election.enable: 是否可让不在 ISR 中 replicas 设置作为 leader, 可能丢数据</li><li>min.cleanable.dirty.ratio=0.5: 避免清楚压缩率超过 50% 的数据</li><li>min.insync.replicas=1: lacks 中对与 ISR 的确认..</li></ul><p><strong>物理存储相关配置</strong></p><ul><li><code>log.index.interval.bytes</code>: 4096(4K) 网络中的索引项达到此大小，写 .index</li><li><code>log.roll.hours</code>: 168(7天)</li><li><code>log.index.size.max.bytes</code>: 10485760(10MB) 限制索引文件的大小…</li><li><code>log.cleanup.policy=compact</code>：默认为 delete?</li><li><code>log.cleaner.max.compaction.lag.ms</code>：</li><li><code>log.cleaner.max.compaction.lag.ms</code>：</li><li><code>log.retention.hours</code>/<code>log.retention.minutes</code>/<code>log.retention.ms</code>： 日志保留的时间，默认 7 天</li></ul><p><strong>事务配置</strong></p><ul><li><code>transaction.id.timeout.ms</code>: 事务 ID 的最长时间，默认 7 day。</li><li><code>max.transaction.timeout.ms</code>: 事务超时时间，默认 15分钟</li><li><code>transaction.state.log.replication.factor</code>: 事务状态 topic 的副本数量，默认3</li><li><code>transaction.state.log.num.partitions</code>: 事务状态 topic 的分区数，默认 50</li><li><code>transaction.state.log.min.isr</code>:</li><li><a href="http://transactional.id/">transactional.id</a>: 生产者配置</li><li>isolation.level: 消费组配置, 事务的级别，可配置为 read_committed …</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://kafka.apache.org/documentation/#producerconfigs">Apache Kafka</a></p><p>Producer config</p><p><a href="https://kafka.apache.org/documentation/#consumerconfigs">Apache Kafka</a></p><p>Consumer config</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kafka-安装&quot;&gt;&lt;a href=&quot;#Kafka-安装&quot; class=&quot;headerlink&quot; title=&quot;Kafka 安装&quot;&gt;&lt;/a&gt;Kafka 安装&lt;/h2&gt;&lt;p&gt;需要依赖 Zookeeper 进行协调&lt;/p&gt;
&lt;p&gt;// TODO 补充集群安装&lt;/p&gt;
</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-存储和高级特性</title>
    <link href="http://example.com/2021/04/09/Kafka-%E5%AD%98%E5%82%A8%E5%92%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/04/09/Kafka-%E5%AD%98%E5%82%A8%E5%92%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</id>
    <published>2021-04-09T15:32:47.000Z</published>
    <updated>2021-04-15T02:50:35.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p><strong>LogSegment</strong></p><ul><li>顺序写入</li><li>基准偏移来那个，日志文件名称为第一条消息的偏移量</li></ul><p>相关文件的作用：</p><ul><li>.index: 偏移量索引, RandomReader.seek(xx)</li><li>.timestamp: 时间戳索引文件，一般服务器生成, 客户端使用可能时间不一致</li><li>.log:</li><li>.snapshot:</li><li>.deleted:</li><li>.cleaned:</li><li>.swap:</li></ul><p><strong>文件的切分</strong></p><p><strong>索引文件切分</strong></p><p>预分配大小，实际切分的时候进行实际的大小，降低代码逻辑的复杂性。</p><p>offset 实际长度 64 位，默认日志文件使用 20 位</p><p><strong>索引文件</strong></p><p>偏移量索引。相对偏移量(4B)和物理地址(4B)组成。</p><p>索引文件是稀疏索引，不会为每条日志都建立索引信息。</p><p>offset 与 position 没有直接关系，因为会删除数据和清理日志。</p><p>Q:  如何查看偏移量为 23 的消息？</p><p>Kafka 中存在一个 ConcurrentSkipListMap 来保存在每个日志分段，通过跳跃表方式，定位到在 00000000000000000000.index ，通过二分法在偏移量索引文件中找到不大于 23 的最大索引项，即 offset 20 那栏，然后从日志分段文件中的物理位置为 320 开始顺序查找偏移量为 23 的消息。</p><p><strong>时间戳索引文件</strong></p><p>通过时间戳方式进行查找消息，需要通过查找时间戳索引和偏移量索引两个文件。</p><p>Q: 查找时间戳为 1557554753430 开始的消息？</p><p>timestamp 文件中的 offset 与 index 文件中的 relativeOffset 不是一一对应的。因为数据的写入是各自追加。</p><p><strong>日志清理</strong></p><p>删除、压缩</p><p>log.cleanup.policy: 默认 delete, 可选择 compact，业务数据一般不删除。</p><p>基于时间删除</p><p>log.retention.hours/log.retention.minutes/log.retention.ms，默认 7 days。</p><h3 id="磁盘存取"><a href="#磁盘存取" class="headerlink" title="磁盘存取"></a>磁盘存取</h3><p><strong>零拷贝</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内核缓冲区 &#x3D;&#x3D;&gt; 用户缓冲区(JVM 堆内存) &#x3D;&#x3D;&gt; 内核缓冲区 &#x3D;&#x3D;&gt; 网卡...</span><br><span class="line">内核缓冲区 &#x3D;&#x3D;&gt; 网卡</span><br></pre></td></tr></table></figure><p><strong>页缓存</strong></p><p>操作系统级别的特性，实现的磁盘缓存。</p><p>Mmap 不可靠， NIO 提供 MappedByteBuffer 实现映射。</p><p>mmap 的文件映射，在 Full GC 时才会进行释放， close 时需要手动清理内存映像文件。</p><p>消息先被写入页缓存，由操作系统负责刷盘任务。判断是否有脏页, 通过 Swap 虚拟内存。</p><p>内核缓冲区，启动异步线程进行落盘，<strong>在生产和消费速率趋近一致时，页缓存中有需要的数据，直接从内核缓冲区区数据，从网卡发送出去，不需要访问磁盘。</strong></p><p><strong>顺序写入机制</strong></p><p>多个文件相同的大小与一个文件进行传输，一个文件更快，读取的时候效率更高。</p><p>RocketMQ 在消费消息时，使用了 mmap。kafka 使用了 sendFile。</p><p><strong>Kafka 使用磁盘存储速度快的原因</strong></p><ul><li>partition 顺序读写，充分利用磁盘特性；</li><li>Producer 生产的数据持久化到 broker，采用 mmap 文件映射，实现顺序的快速写入；</li><li>Customer 从 broker 读取数据，采用 sendfile，将磁盘文件读到 OS 内核缓冲区后，直接转到 socket buffer进行网络发送。</li></ul><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务的使用场景：</p><p>分布式事务，引入 RPC，通过事务协调者</p><p>需要一个内部 topic 保存事务日志， <code>__transaction_state</code>，一般存在时间短。</p><p>消息队列需要表示事务状态，Control Message。</p><p>TransactionId 控制 producer 挂掉或漂移到其他机器。</p><p>producer epoch 保证只有一个 TransactionId 进行消费。</p><p>使用场景</p><ul><li>单个 Producer，使用事务保证消息的仅一次发送</li><li>在消费-转换-生产模式，使用事务保证仅一次发送</li></ul><p><strong>事务协调器</strong></p><p>为 <code>__transaction_state</code> 主题特定个分区的 Leader 分区的 Broker。</p><p>存储正在处理的事务。</p><p>确保何种保留策略，都不会删除事务的消息。</p><p><strong>事务配置</strong></p><ul><li><code>transaction.id.timeout.ms</code>: 事务 ID 的最长时间，默认 7 day。</li><li><code>max.transaction.timeout.ms</code>: 事务超时时间，默认 15分钟</li><li><code>transaction.state.log.replication.factor</code>: 事务状态 topic 的副本数量，默认3</li><li><code>transaction.state.log.num.partitions</code>: 事务状态 topic 的分区数，默认 50</li><li><code>transaction.state.log.min.isr</code>:</li><li><a href="http://transactional.id/">transactional.id</a>: 生产者配置</li><li>isolation.level: 消费组配置, 事务的级别，可配置为 read_committed …</li></ul><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h3><blockquote><p>保证在消息重发的时候，消费者不会重复处理。即使在消费者收到重复消息的时候，重复处理，也要保证最终结果的一致性。</p></blockquote><p>为消息加一个唯一的标记。</p><p>幂等性实现：</p><ul><li>ProducerID: 每个新的 Producer 初始化时，会被分配</li><li>SequenceNumber: 每个 ProducerID，Producer 发送数据的每个 Topic 和 Partition 都对应一个从 0 开始单调递增的 SequenceNumber</li></ul><p>异常时的执行图</p><p><img src="http://img.janhen.com/202104142257212GHamO.jpg" alt="http://img.janhen.com/202104142257212GHamO.jpg"></p><h3 id="集群控制器"><a href="#集群控制器" class="headerlink" title="集群控制器"></a>集群控制器</h3><blockquote><p>为一个 Broker，负责 Leader 分区的选举。通过 Zookeeper 的分布式锁特性选举集群控制器。</p></blockquote><p>避免选择多个 Leader, 或者 Controller 再次上线。</p><p>控制器使用 epoch 来避免 “脑裂”。</p><p>控制器需要那个 Broder 宕机了，宕机的 Broder 上负责的哪些分区的 Leader 副本分区。</p><p>默认 50 个分区。</p><p>变动的临时节点 xx/broders/ids。</p><p>监听 ids 的节点，监听到哪些节点宕机。</p><p>xx/broders/topic: 非临时节点。</p><p>xx/broders/seqid:</p><p><strong>__consumer_offsets 主题</strong></p><p>默认 50 个 partition， Kafka 的集群控制器管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定格式化查看 offset 信息</span></span><br><span class="line">kafka-console-consumer.sh --topic __consumer_offsets \\</span><br><span class="line">  --bootstrap-server linux121:9092 \\</span><br><span class="line">  --formatter <span class="string">&quot;kafka.coordinator.group.GroupMetadataManager\\<span class="variable">$OffsetsMessageFormatter</span>&quot;</span> \\</span><br><span class="line">  -consumer.config config/consumer.properties \\</span><br><span class="line">  --from-beginning</span><br></pre></td></tr></table></figure><p>指定 consumer group 的位移信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kafka-simple-consumer-shell.sh \\</span><br><span class="line">  --topic __consumer_offsets \\</span><br><span class="line">  -partition 19 \\</span><br><span class="line">  --broker-list linux121:9092 \\</span><br><span class="line">  --formatter <span class="string">&quot;kafka.coordinator.group.GroupMetadataManager\\<span class="variable">$OffsetsMessageFormatter</span>&quot;</span></span><br><span class="line">...</span><br><span class="line">[console-consumer-49366,tp_test_01,3]:: [OffsetMetadata[20,NO_METADATA],CommitTime 1596424702212,ExpirationTime 1596511102212] </span><br><span class="line">[console-consumer-49366,tp_test_01,4]:: [OffsetMetadata[20,NO_METADATA],CommitTime 1596424702212,ExpirationTime 1596511102212]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="可靠性保证"></a>可靠性保证</h3><ul><li>分区可靠性： 创建 TOPIC 指定副本数</li><li>Producer 发送的可靠性： 设置为 all,  对应的 Follower 发送 ack…</li></ul><p>相关的参数：</p><ul><li><code>replica.lag.time.ms</code>: 默认 10000ms，落后改时间，Follower 没有向 Leader 发送 fetch 请求，用于失效的副本判定参数</li><li><code>acks=all</code> 保证 Producer 发送消息的可靠性</li></ul><h2 id="特殊队列"><a href="#特殊队列" class="headerlink" title="特殊队列"></a>特殊队列</h2><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><blockquote><p>Kakfa 内部实现，延迟拉取操作(DelayedFetch), 等待拉取到足够数量的消息。</p></blockquote><p><a href="http://request.timeout.ms/">request.timeout.ms</a>： 默认 30s，进行消息确认。</p><p>没有消息放到炼狱中，等有消息后恢复 Follower。</p><h3 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h3><blockquote><p>kafka 没有重试机制不支持消息重试，也没有死信队列，因此使用 kafka 做消息队列时，需要自己实现消息重试的功能。</p></blockquote><p>RabbitMQ 中自带重试队列。</p><p>可使用 Kafka 实现重试队列, 实现见代码，<a href="https://github.com/Janhen/bg-kafka/tree/main/src/main/java/com/janhen/bigdata/kafka/retry">这里</a>。</p><h3 id="保证消息的消费顺序"><a href="#保证消息的消费顺序" class="headerlink" title="保证消息的消费顺序"></a>保证消息的消费顺序</h3><p>业务场景需要严格保证消息的消费顺序，若消息消费顺序不一致，会造成最终结果不同。</p><p>Kafka 只能保证 Partition 中的消息有序，无法保证 Topic 中的 Partition 的有序，实现有序性的方式</p><ul><li>(1) 1 个 Topic 对应一个 Partition，破坏 Kafka 设计的初衷</li><li>(2) Producer 发送消息的时候指定 key/Partition，指定 topic、partition、key、data, 可以让消息全局有序</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h3><ul><li>Producer 数据丢失情况：Producer 调用 send 方法后，消息因为网络问题没有发送过去<ul><li>ack=0，不重试，数据会丢</li><li>ack=1, 对应的 Leader 副本 crash，未来得及通过到 ISR 中</li><li>unclean.leader.election.enable 为 true 且当前无可用的 ISR</li></ul></li><li>Broker 数据丢失：Leader 副本所在的 Broker 挂掉，Leader 中的数据还没有被 Follower 副本同步，造成消息的丢失</li><li>Consumer 数据丢失： 消费者拉取到分区的消息后，Consumer 自动提交 offset，当 Consumer 获取到消息后挂掉，消息实际未被消费，此时 offset 已经被提交了<ul><li>保证不丢失，消息处理完就提交 offset 可能出现数据丢失，关闭自动提交 offset, 每次消费完消息后手动提交 offset。可能会存储重复消费的问题。还没提交 offset，服务挂掉，此时消息会被消费两次。</li></ul></li></ul><p><strong>消息确认机制</strong></p><ul><li>acks=0, 在使用异步模式的时候，Kafka 无法保证消息，可能数据丢失</li><li>acks=1： 默认值。 只保证写入 Leader 成功，此时 Leader 宕机，数据没有同步到 ISR 中，数据丢失</li><li>acks=all, 所有副本写入成功并确认，设置合理的 retries 值, 设置消息至少被写入多少副本才算成功, 不允许非 ISR 被选举为 Leader</li></ul><p><strong>其他相关参数</strong></p><ul><li>replication.factor: 每个分区有的副本数量，生产环境推荐 ≥3</li><li>min.insync.replicas： 默认值为 1。代表消息至少要被写入到 N 个副本才算是被成功发送<ul><li>一般推荐设置 replication.factor = min.insync.replicas + 1</li></ul></li><li>unclean.leader.election.enable： 默认值为 false。Leader 副本发生故障时，在没有 ISR 的时候可以使用 USR 作为 Leader。</li></ul><h3 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h3><p><strong>生产阶段重复</strong></p><p>Producer 重复消费问题：发送的消息没有收到正确的 broke 响应， Producer 重试</p><p>Producer 重复消费处理：</p><ul><li>方式一： 启用幂等性，参数 enable.idempotence=true，同时 ack=all，retries &gt; 1</li><li>方式二： ack=0： 不进行重试，对于吞吐量指标重要性高于数据丢失场景使用</li></ul><p><strong>消费阶段重复</strong></p><p>Consumer 重复消费问题： 数据消费完没有及时提交 offset 到 broker。</p><p>Consumer 重复消费处理：</p><ul><li>取消自动提交</li><li>下游做幂等：</li></ul><p><strong>消费阶段重复</strong></p><p>消费者没有及时的提交 offset</p><h3 id="消费能力不足"><a href="#消费能力不足" class="headerlink" title="消费能力不足"></a>消费能力不足</h3><p>// TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;物理存储&quot;&gt;&lt;a href=&quot;#物理存储&quot; class=&quot;headerlink&quot; title=&quot;物理存储&quot;&gt;&lt;/a&gt;物理存储&lt;/h2&gt;&lt;h3 id=&quot;存储机制&quot;&gt;&lt;a href=&quot;#存储机制&quot; class=&quot;headerlink&quot; title=&quot;存储机制&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-基础</title>
    <link href="http://example.com/2021/04/09/Kafka-%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/04/09/Kafka-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-09T15:32:28.000Z</published>
    <updated>2021-04-15T02:50:27.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>一个分布式、分区的、多副本的、多生产者、多订阅者，基于 zookeeper 协调的分布式日志系统, 常见可以用于 web/nginx 日志、访问日志，消息服务等。</p></blockquote><p>消息中间件的模式，<strong>只有消息的拉取，没有推送</strong>，可通过轮询实现消息的推送。</p><p>消息被分批写入 Kafka。 批次为一组消息，消息属于同一个主题和分区。可对批次进行压缩。吞吐量大。</p><p><strong>优点</strong></p><p>持久化存储： 零拷贝、顺序读与顺序写、Linux 的页缓存。</p><p><strong>流平台关键功能：</strong></p><ul><li>消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列 的原因。</li><li>容错的持久⽅式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的⻛险。</li><li>流式处理平台： 在消息发布的时候进⾏处理，Kafka 提供了⼀个完整的流式处理类库。</li></ul><p><strong>主要应⽤场景：</strong></p><ul><li>消息队列：建⽴实时流数据管道，以可靠地在系统或应⽤程序之间获取数据。</li><li>数据处理：构建实时的流数据处理程序来转换或处理数据流。<ul><li>用户活动跟踪</li><li>运营指标</li><li>流式处理</li><li>日志、消息</li></ul></li></ul><p><strong>Kafa 设计中的两个反常识：</strong></p><ul><li>消息使用磁盘存储，非内存</li><li>分区副本保持数据一致性(高可用保证)，非过半机制，随机选择一个 ISR，依据配置可选一个 USR。</li></ul><p><strong>Kafka 的扩展性：</strong> 可对生产者、消费者、 Brokder、主题的分区进行横向扩展。</p><p>consumer 采用 pull 模式从 brokder 中读取数据，可自主控制消费消息的速率, 可控制消费方式..</p><p>推送, 保证及时性, RabbitMq 保证 um, 小而美。</p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><img src="http://img.janhen.com/image-20201121171728810.png" alt="http://img.janhen.com/image-20201121171728810.png" style="zoom:50%;" /><ul><li>Producer: 生产者<ul><li>给定 key, 无 key, 自定义分区器</li><li>生产端通过轮询、哈希(基于 Key)、指定放到特定分区(基于分区号)</li></ul></li><li>Consumer:  消费者<ul><li>再平衡, 如某个 Consumer 挂掉，对多个分区进行重新分配。</li><li>可横向扩展，需要保证不能重复消费。一个分区只能被一个消费组中的一个消费者消费。</li><li>Consumer Group: 同一个消费组中的消费者不会对 Topic 的消息进行重复消费。</li></ul></li><li>Broker:  可看作为一个 Kafka 实例，多个 Broker 组成 Kafka 分布式集群<ul><li>对于 topic 的 N partition，分区数不能大于 broker 的数量</li><li>集群控制器：特殊的 Brokder, 用于分区的分配、监控 broker</li><li>Broker 与集群： 单个 Broker 可处理多个分区和每秒百万级的消息量。</li></ul></li><li>Topic: 类似 DB 的表，分库分表的逻辑表。</li><li>Partiton:  主题实际存储的分片, 无法保证主题范围内消息的顺序，通过分区实现数据冗余与伸缩。</li><li>Replicas：首领副本、追随者副本。主题分区的，不让相同分区的副本在同一台机器上。<ul><li>AR(Assigned Replicas): 分区的所有副本为</li><li>ISR(In-Sync Replicas): 同步副本</li><li>OSR(Out-Sync Replicas): 不同步副本</li></ul></li><li>Offset：递增序列，可指定从 0 开始消费，或者指定的偏移量进行消费。<ul><li>偏移量 HW: 决定对外提供消息的最大偏移量，再 HW 前可见、可消费，之后不允许消费</li><li>下一条待写入消息的 offset(LEO):</li></ul></li><li>Event(Message): 生产者发送的消息，需要指定 topic、key、分区、消息内容</li></ul><h3 id="对比其他-MQ-的比较"><a href="#对比其他-MQ-的比较" class="headerlink" title="对比其他 MQ 的比较"></a>对比其他 MQ 的比较</h3><p>Kafka 相⽐其他消息队列主要的优势如下：</p><ul><li>极致的性能：基于 Scala 和 Java 语⾔开发，设计中⼤量使⽤了批量处理和异步的思想，最⾼可以每秒处理千万级别的消息。</li><li>⽣态系统兼容性高：Kafka 与周边⽣态系统的兼容性好，尤其在⼤数据和流计算领域。</li></ul><p>与 RabbitMQ, Rocket MQ 相比，吞吐量大，延迟高，提供的功能少，如相对于 RabbitMQ 没有提供默认的 RetryQueue。</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><img src="http://img.janhen.com/image-20201117215502433.png" alt="http://img.janhen.com/image-20201117215502433.png" style="zoom: 67%;" /><p>生产者执行原理</p><p>两个线程：</p><p>① 主线程：负责消息创建，拦截器，序列化器，分区器等操作，并将消息追加到消息收集器  RecoderAccumulator 中</p><p>② Sender 线程：</p><img src="http://img.janhen.com/image-20201116223818141.png" alt="http://img.janhen.com/image-20201116223818141.png" style="zoom: 50%;" /><p>生产者发送过程</p><p>① Producer 创建时，会创建一个 Sender 线程并设置为守护线程 ② Producer 生产消息时，内部是异步流程；生产的消息先经过拦截器-&gt;序列化器-&gt;分区器，然后将消息缓存在缓冲区（该缓冲区也是在 Producer 创建时创建）。 ③ 发送批次消息，批次发送的条件为：缓冲区数据大小达到 <code>batch.size</code> 或者 <code>linger.ms</code> 达到上限。 ④ 批次发送后，发往指定分区，然后落盘到 broker；如果生产者配置了 retrires 参数大于 0 并且失败原因允许重试，那么 Client 内部会对该消息进行重试。 ⑤ 落盘到 broker 成功，返回生产元数据给生产者。 ⑥ Producer 根据元数据进行处理，元数据返回有两种方式：一种是通过阻塞直接返回，另一种是通过回调返回。</p><h3 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h3><ul><li>Avro 序列化： 提供了一种紧凑的序列化格式，模式和消息体分开。当模式发生变化时，不需要重新生成代码，还支持强类型和模式进化，其版本既向前兼容，也向后兼容。</li><li>Kyro 序列化： Spark 中常用的。</li><li>自定义序列化器需要实现 <code>org.apache.kafka.common.serialization.Serializer&lt;T&gt;</code> 接口，并实现其 中的 serialize 方法。</li></ul><h3 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h3><p>生产端控制消息发送到哪个分区，有轮询、哈希、指定分区号等方式。</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>Interceptor 可能被运行在多个线程中，在具体实现中<strong>需要自行保证线程安全性。</strong></p><h3 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h3><ul><li><pre><code>request.required.acks<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - acks&#x3D;0, 在使用异步模式的时候，Kafka 无法保证消息，可能数据丢失</span><br><span class="line">  - acks&#x3D;1： 默认值。 只保证写入 Leader 成功，此时 Leader 宕机，数据没有同步到 ISR 中，数据丢失</span><br><span class="line">  - acks&#x3D;all, 所有副本写入成功并确认，设置合理的 retries 值, 设置消息至少被写入多少副本才算成功, 不允许非 ISR 被选举为 Leader</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  min.insync.replicas</span><br></pre></td></tr></table></figure>： 默认值为 1。代表消息至少要被写入到 N 个副本才算是被成功发送- 一般推荐设置 replication.factor = min.insync.replicas + 1</code></pre></li></ul><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul><li><code>bootstrap.servers</code>:</li><li><code>key.serializer</code> / <code>value.serializer</code>:=</li><li><code>request.required.acks</code>:  确认机制</li><li><code>request.timeout.ms</code>：</li><li>retries:</li><li>compression.type： 默认 NONE，可选择 gzip, snappy, lz4。</li><li>partitioner.class： 分区器类</li><li><a href="http://retry.backoff.ms/">retry.backoff.ms</a>：</li><li>batch.size：</li><li><a href="http://client.id/">client.id</a>: 生产者发送请求的时候传递给 broker 的 id 字符串。</li><li>send.buffer.bytes：发送缓冲</li><li>buffer.memory：</li><li><a href="http://connections.max.idle.ms/">connections.max.idle.ms</a>：</li><li><a href="http://linger.ms/">linger.ms</a>：</li><li><a href="http://max.block.ms/">max.block.ms</a>：</li></ul><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费消息的偏移量保存在 Kafka 的名字是 <code>__consumer_offsets</code> 的主题中。</p><p><strong>消费组</strong></p><p>设置 <a href="http://gorup.id/">gorup.id</a></p><p>消费组均衡地给消费者分配分区，每个分区只由消费组中一个消费者消费。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><p>自定义需要实现 <code>org.apache.kafka.common.serialization.Deserializer&lt;T&gt;</code> 接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer.wrap(data);</span><br></pre></td></tr></table></figure><h3 id="拦截器-1"><a href="#拦截器-1" class="headerlink" title="拦截器"></a>拦截器</h3><p>按照给定的顺序执行</p><p>可将第三方组件引入 消费者应用程序，用于定制的监控、日志处理等。</p><p>ConsumerInterceptor 方法抛出的异常会被捕获、记录，但是不会向下传播。如果用户配置了错误的 key 或 value 类型参数，消费者不会抛出异常，而仅仅是记录下来。</p><h3 id="Offset-提交"><a href="#Offset-提交" class="headerlink" title="Offset 提交"></a>Offset 提交</h3><p>kafka 会定期把 group 消费情况保存起来，做成一个 offset map。</p><p>有默认的主题 <code>__consumer_offsets</code> 控制偏移量，位移提交有同步和异步提交。</p><p>(1) 自动提交</p><p>可能导致重复消费</p><p>自动提交不会出现消息丢失，但可能会重复消费。</p><p>(2) 异步提交</p><p>异步提交不会进行自动重复，推荐的方式。</p><p>大部分进行异步，每隔一段时间/数据量进行一次同步提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 处理消息 </span></span><br><span class="line">    process(records); </span><br><span class="line">    <span class="comment">// 使用异步提交规避阻塞 </span></span><br><span class="line">    commitAysnc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  handle(e); <span class="comment">// 处理异常 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    consumer.commitSync(); <span class="comment">// 最后一次提交使用同步阻塞式提交 </span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>offset 特殊场景</strong></p><p>消费者第一次消费数据，或者消费者查找之前保留的 offset 没查到时候的处理</p><p><code>auto.offset.reset</code>：</p><ul><li>earliest：从最早的数据开始消费</li><li>latest(default): 从最新的数据开始消费</li><li>none：根据指定的 <a href="http://group.id/">group.id</a> 未找到之前消费的 offset 信息，抛异常</li></ul><h3 id="消费组管理"><a href="#消费组管理" class="headerlink" title="消费组管理"></a><strong>消费组管理</strong></h3><p>满足正则表达式的 Topic 的匹配，需要弹性扩展。</p><p><strong>消费组的状态</strong></p><img src="http://img.janhen.com/20210130164345image-20201118204202363.png" alt="http://img.janhen.com/20210130164345image-20201118204202363.png" style="zoom:50%;" /><ul><li>Dead：组内已经没有任何成员的最终状态</li><li>Empty：组内无成员</li><li>PreparingRebalance：组准备开启新的rebalance，等待成员加入</li><li>AwaitingSync：正在等待 leader consumer 将分配方案传给各个成员</li><li>Stable：再均衡完成</li></ul><h3 id="再平衡"><a href="#再平衡" class="headerlink" title="再平衡"></a><strong>再平衡</strong></h3><p>一种协议，规定了如何让消费者组下的所有消费者来分配 topic 中的每一个分区。</p><p>RangeAssignor 范围划分， RoundRobin 轮询、StickyAssignor 分配。</p><p>控制一个主题的多个分区对应一个消费组中的多个消费者。</p><p><strong>Group Coordinator</strong></p><p>为一个 Brokder，组协调器</p><p>__consumer_xx partition</p><p><strong>Rebalance Generation</strong></p><p>主题分区与消费主中的映射关系的一个版本，主要隔离 xxx 无效的请求。</p><p><strong>协议</strong></p><p>Heatbeat 请求</p><p>LeaveGroup</p><p>SyncGroup</p><p>JoinGroup</p><p>DescribeGroup: 用于管理</p><p>组协调器在再平衡中使用到前四种请求。</p><p><strong>再平衡的过程</strong></p><p>SyncGroup</p><p>版本之间的演进，由客户端进行控制，提供更好的灵活性。</p><h3 id="配置参数-1"><a href="#配置参数-1" class="headerlink" title="配置参数"></a>配置参数</h3><ul><li><code>group.id</code>：</li><li><code>bootstrap.servers</code>： 指定 broker 地址</li><li><code>key.deserializer</code> / <code>value.deserializer</code>：</li><li><code>enable.auto.commit</code>： 是否自动提交 offset 功能，默认开启</li><li><code>auto.commit.interval.ms</code>： 自动提交 offset 的时间间隔</li><li><code>auto.offset.reset</code>：</li></ul><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>对应保存在 Zookeeper 的 <code>/&lt;base-dr&gt;/config/topics/&lt;topic-name&gt;</code> 下。</p><p>主题的命令操作见 <a href="https://www.notion.so/Kafka-71dac1d34b5347289fc8b8c9f0c573e8">这里</a>。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><blockquote><p>为了做到均匀分布，通常 partition 的数量通常是 Broker Server 数量的整数倍。</p></blockquote><h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h3><ul><li>分区中会有多个副本，其中一个副本为 Leader 其他的副本为 Follower。发送消息的时候会被发送到 Leader，之后 Follower 副本会从 Leader 副本中拉取消息进行同步。</li><li>Producer 和 Consumer 只和 Leader 副本进行交互，其他 Follower 副本为 Leader 的拷贝，用于保证消息存储的安全性，只有 Leader 副本发生故障时使用，从 Follower 中徐安全一个 Leader。</li><li>Follower 副本中的数据可能和 Leader 副本不同步，在 Leader 不可用时先跳过不同步的 Follower 副本，即 USR。</li><li>Follower 分区和普通 Kafka 消费者一样，消费 Leader 分区消息，允许 Follower 进行批处理，并将其持久化到自己的日志。</li></ul><p><strong>Kafka 分区和多副本机制的好处</strong></p><ul><li>给特定的 Topic 指定多个 Partition，各个 Partition 分布在不同的 Broker 上，提供很好的并发能力</li><li>Partition 可指定对应的副本数量，提高了消息存储的安全性，提高了容灾能力</li></ul><p><strong>分区副本在 Broker 上的存放策略</strong></p><p>(1) 不考虑机架的分配方案：</p><p>第一轮顺序放</p><p>第二轮，Partiton1 –&gt; Brokder1，Partition2 –&gt; Brokder2，Partiton3 –&gt; Broder3</p><p>第三轮, Partiton1 –&gt;  Brokder, Partition2 –&gt; Brokder3, Partiton3 –&gt; Brokder4</p><p>(2) 考虑机架的分配情况</p><p>按照基本规则分配，达到特定情况区分于基本规则配置，防止某几个 Broker 总是出现问题。</p><p><strong>出现问题时选取 Partition 的副本</strong></p><p>此处由集群控制器控制，判断条件如下：</p><p>① 有 ISR 存在，随机找一个 ISR 进行恢复</p><p>② 所有的 ISR 都宕机，等一个 ISR 恢复</p><p>③ 所有的 ISR 都宕机，在配置可选择 OSR 时，选择一个 OSR 作为 Leader</p><h3 id="分区重新分配"><a href="#分区重新分配" class="headerlink" title="分区重新分配"></a>分区重新分配</h3><blockquote><p>向已经部署好的 Kafka 集群里面添加机器，从已经部署好的 Kafka 节点中复制相应的配置文件，把里面的 broker id 修改成全局唯一的，最后启动这个节点即可将它加入到现有 Kafka 集群中。 ⇒ 新添加的 Kafka 节点并不会自动地分配数据，无法分担集群的负载</p></blockquote><p><strong>手动再均衡</strong></p><p><a href="http://kafka-reassign-partitions.sh/">kafka-reassign-partitions.sh</a> 重新分布分区, 三种模式, plan, execute, verify。</p><p>具体使用见 <a href="https://www.notion.so/Kafka-71dac1d34b5347289fc8b8c9f0c573e8">这里</a>。</p><h3 id="分区与消费者的再分配"><a href="#分区与消费者的再分配" class="headerlink" title="分区与消费者的再分配"></a>分区与消费者的再分配</h3><blockquote><p>再平衡的时候无法进行消费，导致消费能力下降。</p></blockquote><p><strong>触发条件：</strong></p><p>① 消费者组内成员发生变更： 增减消费者</p><p>② 主题的分区数发生变更： 增加主题的分区</p><p>③ 订阅的主题发生变化： 消费组通过正则订阅主题, 对应消费组订阅的 Topic 数量变更</p><p><strong>再平衡</strong></p><p>消费者进行横向扩展</p><p>分区不能被多个消费者消费, Topic 的分区越多，越有利于消费组的扩展。</p><p><strong>心跳机制</strong></p><p>Kafka 的心跳是 Kafka Consumer 和 Broker 之间的健康检查，只有当 Broker Coordinator 正常时，Consumer 才会发送心跳。</p><p>控制 Topic 的分区与消费组中的消费者对应关系。</p><p><strong>再平衡的影响：</strong></p><p>重平衡过程中，消费者无法从 kafka 消费消息，对 kafka 的 TPS 影响极大，重平衡可能会耗时极多，这段时间 kafka 基本处于不可用状态。</p><p><strong>再平衡的过程</strong></p><p>在协调器收集到所有成员请求前，它会把已收到请求放入一个叫 purgatory(炼狱)的地方。</p><p>消费组的分区分配方案在客户端执行。Kafka 交给 Client 可以有更好的灵活性。</p><p><strong>分区分配策略</strong></p><p>Kafka 默认采用 RangeAssignor 分配算法</p><p>1、RangeAssignor</p><p>偏向于字典序小的消费组中的消费者比较 “贪婪”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assign(topic, consumers) &#123; <span class="comment">// 对分区和Consumer进行排序 </span></span><br><span class="line">  List&lt;Partition&gt; partitions = topic.getPartitions();</span><br><span class="line">  sort(partitions);</span><br><span class="line">  sort(consumers); <span class="comment">// 计算每个Consumer分配的分区数 </span></span><br><span class="line">  <span class="keyword">int</span> numPartitionsPerConsumer = partition.size() / consumers.size(); <span class="comment">// 额外有一些Consumer会多分配到分区 </span></span><br><span class="line">  <span class="keyword">int</span> consumersWithExtraPartition = partition.size() % consumers.size();</span><br><span class="line">  <span class="comment">// 计算分配结果 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = consumers.size(); i &lt; n; i++) &#123; <span class="comment">// 第i个Consumer分配到的分区的index </span></span><br><span class="line">    <span class="keyword">int</span> start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition); </span><br><span class="line">    <span class="comment">// 第i个Consumer分配到的分区数 </span></span><br><span class="line">    <span class="keyword">int</span> length = numPartitionsPerConsumer + (i + <span class="number">1</span> &gt; consumersWithExtraPartition ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 分装分配结果</span></span><br><span class="line">    assignment.get(consumersForTopic.get(i)).addAll(partitions.subList(start, start + length));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、RoundRobinAssignor</p><p>轮询的方式进行指定。</p><p>3、StickyAssignor</p><p>分区的分配尽量的均衡，每一次重分配的结果尽量与上一次分配结果保持一致,和 JDK8 中 HashMap 的 rehash 对低位的不变相同思想。</p><p>4、自定义分配策略</p><p><strong>可控制再平衡的三个参数</strong></p><ul><li><a href="http://session.timeout.ms/">session.timeout.ms</a>: 控制心跳的超时时间, 6s</li><li><a href="http://heartbeat.interval.ms/">heartbeat.interval.ms</a>: 心跳的频率, 2s, 一般为上面值的三分之一</li><li><a href="http://max.poll.interval.ms/">max.poll.interval.ms</a>: poll 的间隔, 1 分钟</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Zookeeper-作用"><a href="#Zookeeper-作用" class="headerlink" title="Zookeeper 作用"></a>Zookeeper 作用</h3><p>存储 Kafka 中的元数据，在 Kafka 2.8+ 后移除，不再使用</p><p>ZK 为 Kafka 提供的功能:</p><ul><li>Broker 注册： 有一个记录 Broker 服务器列表的节点，每次 Broker 启动时，都会到 ZooKeeper 上进行注册，写数据到 brokers/ids 下新建节点，将 Broker 中的 IP 地址和端口信息记录进去。</li><li>Topic 注册：同一个 Topic 被分成多个分区分布到多个 Broker 中，分区信息与 Broker 的对应关系由 ZooKeeper 维护。对应到文件夹 brokers/topics/<topic-name>/Partitons/<num> 新建节点。</li><li>负载均衡：Kafka 通过特定 Topic 指定多个 Partition，各个 Partition 分布到不同的 Broker 中，提供较好的并发能力。对同一个 Topic 的多个 Partition，尽量将 Partition 分布到不同的 Broker 上，生产者投递消息到不同的 Broker 的 Partition 中。当 Consumer 消费时，ZooKeeper 根据当前 Partition 数量和 Consumer 数量实现动态负载均衡。</li></ul><p>消费者的消费状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">admin&#x2F;delete_topics</span><br><span class="line">brokders&#x2F;ids</span><br><span class="line">brokers&#x2F;topics&#x2F;&lt;topic-name&gt;&#x2F;partitions&#x2F;num</span><br><span class="line">cluster&#x2F;id</span><br><span class="line">config&#x2F;clients</span><br><span class="line">config&#x2F;topics&#x2F;&lt;topic-name&gt;</span><br><span class="line">config&#x2F;changes</span><br><span class="line">consumers</span><br><span class="line">controller_epoch</span><br><span class="line">isr_change_notification</span><br><span class="line">latest_producer_id_block</span><br><span class="line">log_dir_event_notification</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://kafka.apache.org/documentation/">Apache Kafka</a></p><p>Kafka 官网</p><p><a href="https://avro.apache.org/docs/current/gettingstartedjava.html">https://avro.apache.org/docs/current/gettingstartedjava.html</a></p><p>Avro 序列化文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个分布式、分区的、多副本的、多生产者、多订阅者，基于 zookeeper 协调的分布式日志系统, 常见可以用于 </summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spark-管理</title>
    <link href="http://example.com/2021/04/09/Spark-%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/04/09/Spark-%E7%AE%A1%E7%90%86/</id>
    <published>2021-04-09T05:52:17.000Z</published>
    <updated>2021-04-15T02:49:55.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><p>命令参数：</p><ul><li><p><code>–-class</code>： 指定运行的入口类</p></li><li><p><code>--master</code></p><p>：Standalone 模式时指定集群地址，yarn 模式时指定为 yarn，</p><ul><li><code>–-deploy-mode</code>：运行模式，client 代表 yarn-client，cluster 代表 yarn-cluster</li></ul></li></ul><p>资源分配参数：</p><ul><li><code>--num-executors 2</code>: 指定多少个 executor 进程进行执行</li><li><code>--total-executor-cores</code>: 总的核心数量</li><li><code>--executor-memory=1G</code>: 每个 executor 使用的内存, PROD 中可以设置为2~4G即可</li><li><code>--executor-cores 2</code>： 每个 executor 分配的 CPU</li><li><code>--driver-memory 1G</code>: 设置 Driver 进程的内存，使用类似于 collect 之类的 action 算子向 Driver 端拉取数据时，需要调大</li><li><code>--driver-cores 1:</code> driver 进程分配多少 core，默认为 1</li></ul><p>覆盖运行的配置参数：</p><ul><li>–conf：指定运行时候的配置<ul><li><code>spark.default.parallelism=10</code>: 设置每个 stage 的默认 task 数量，也可以认为是分区数，<strong>官网建议设置该参数为 num-executors * executor-cores 的 2~3倍 较为合适</strong></li><li><code>spark.storage.memoryFraction</code>: 设置 RDD 持久化数据在 Executor 内存中能占的比例，默认是 0.6</li></ul></li><li><code>spark.shuffle.memoryFraction</code>: 设置 shuffle 过程中一个 task 拉取到上个 stage 的 task 的输出后，进行聚合操作时能够使用的 Executor 内存的比例，默认是0.2。</li></ul><p>其他参数：</p><ul><li><code>--jars fastjson.jar,abc.jar</code>： 设置 job 依赖的第三方 jar 包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地模式启动计算 PI</span></span><br><span class="line">spark-submit --master local-cluster[4,2,1024] \\</span><br><span class="line">    --class org.apache.spark.examples.SparkPi \\</span><br><span class="line">    <span class="variable">$SPARK_HOME</span>/examples/jars/spark-examples_2.11-2.4.5.jar \\</span><br><span class="line">    10</span><br><span class="line"></span><br><span class="line"><span class="comment">#  分配执行内存和 cpu 进行计算</span></span><br><span class="line"><span class="variable">$SPARK_HOME</span>/bin/spark-submit \\</span><br><span class="line">--class org.apache.spark.examples.SparkPi \\</span><br><span class="line">--executor-memory 1G \\</span><br><span class="line">--total-executor-cores 2 \\</span><br><span class="line">./examples/jars/spark-examples_2.11-2.1.1.jar \\</span><br><span class="line">100   </span><br><span class="line"><span class="comment"># Standalone 模式下的运行</span></span><br><span class="line"><span class="variable">$SPARK_HOME</span>/bin/spark-submit \\</span><br><span class="line">--class org.apache.spark.examples.SparkPi \\</span><br><span class="line">--master spark://linux122:7077 \\</span><br><span class="line">--executor-memory 1G \\</span><br><span class="line">--total-executor-cores 2 \\</span><br><span class="line">./examples/jars/spark-examples_2.11-2.1.1.jar \\</span><br><span class="line">100</span><br><span class="line"><span class="comment"># Yarn-client 模式下运行</span></span><br><span class="line"><span class="variable">$SPARK_HOME</span>/bin/spark-submit \\</span><br><span class="line">--master yarn \\</span><br><span class="line">--deploy-mode client \\</span><br><span class="line">--class org.apache.spark.examples.SparkPi \\</span><br><span class="line">  --executor-memory 1G \\</span><br><span class="line">  --num-executors 5 \\</span><br><span class="line">  --executor-cores 2</span><br><span class="line">./examples/jars/spark-examples_2.11-2.1.1.jar \\</span><br><span class="line">100</span><br><span class="line"><span class="comment"># 配置额外参数运行</span></span><br><span class="line">spark-submit \\ </span><br><span class="line">  --name <span class="string">&quot;My app&quot;</span> \\ </span><br><span class="line">  --master <span class="built_in">local</span>[4] \\  </span><br><span class="line">  --conf spark.eventLog.enabled=<span class="literal">false</span> \\ </span><br><span class="line">  --conf <span class="string">&quot;spark.executor.extraJavaOptions=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps&quot;</span> \\ </span><br><span class="line">  --conf spark.hadoop.abc.def=xyz \\ </span><br><span class="line">  myApp.jar</span><br></pre></td></tr></table></figure><h2 id="Spark-配置"><a href="#Spark-配置" class="headerlink" title="Spark 配置"></a>Spark 配置</h2><ul><li><code>spark.master</code>： 部署模式, 运行时的必选参数</li><li><code>spark.app.name</code>： 应用程序名称</li></ul><p><strong>运行相关的资源参数：</strong></p><ul><li><code>spark.driver.memory</code>： 默认 1G?</li><li><code>spark.default.parallelism</code>：默认的 RDD 分区数，分布式模式 max(应用程序持有executor的core总数, 2)，官网建议 task 个数为 CPU 的核数 * executor的个数的 2~3倍</li><li><code>spark.executor.memory</code>： 指定 Executor 占用的内存的大小，也可通过配置系统变量 SPARK_EXECUTOR_MEMORY 或者  SPARK_MEM 设置其大小</li><li><code>spark.executor.extraJavaOptions</code>：Executor 执行额外的 JVM 参数</li></ul><p><strong>Shuffle 重要参数：</strong></p><ul><li><code>spark.shuffle.file.buffer</code>： 默认值为32K。shuffle write阶段buffer缓冲大小</li><li><code>spark.reducer.maxSizeInFlight</code>： 默认值为48M。shuffle read阶段buffer缓冲区大小</li><li><code>spark.shuffle.io.maxRetries</code>： 默认值3。Shuffle read阶段拉取数据失败时的最大重试次数</li><li><code>spark.shuffle.io.retryWait</code>： 默认值5s。Shuffle read阶段拉取数据失败重试时的等待时间</li><li><code>spark.shuffle.sort.bypassMergeThreshold</code>： 默认值为200。使用bypass机制，RDD分区数的限制</li><li><code>spark.memory.fraction &amp; spark.memory.storageFraction</code>： 调整Shuffle相关内存</li><li><code>spark.memory.fraction</code>： 缺省值0.6。存储内存和执行内存占（heap内存 - 300M）的百分比</li><li><code>spark.memory.storageFraction</code>： 缺省值0.5。存储内存 与 （存储内存与执行内存之和）的百分比</li></ul><p><strong>SQL 相关</strong></p><ul><li><code>spark.sql.parquet.writeLegacyFormat</code>: 连接 Hive 时候使用，使用与 Hive 相同的约定写 parquet 数据</li><li><code>spark.sql.autoBroadcastJoinThreshold</code>： SQL.Broadcase Hash Join 小表控制的大小，默认 10MB</li><li><code>spark.sql.join.preferSortMergeJoin</code>： 默认为 true, 默认选择 Sort Merge Join</li><li><code>spark.sql.shuffle.partitions</code>： 分区个数，默认 200</li><li><code>spark.sql.inMemoryColumnarStorage.compressed</code>： 压缩</li><li><code>spark.sql.inMemoryColumnarStorage.batchSize</code> ： 批量操作的大小</li><li><code>fs.local.block.size</code>: 文件 block 大小配置，设置本地文件切分大小</li></ul><p>历史服务器：</p><ul><li><code>spark.history.retainedApplications</code>： 设置缓存 Cache 中保存的应用程序历史记录的个数（默认50），如果超过这个值，旧的将被删除；</li></ul><p>广播变量相关：</p><ul><li><code>spark.broadcast.blockSize</code>： 缺省值为 4M</li><li><code>spark.broadcast.checksum</code>: 校验和，默认为 true</li><li><code>spark.broadcast.compress</code>： 压缩，默认为 true</li></ul><p>SparkUI 相关</p><ul><li><code>spark.ui.enabled</code>： SparkUI 是否开启</li></ul><p>调试相关：</p><ul><li><code>spark.logLineage</code>： 调用 Action 时打印 rdd 的 lineage 信息。</li></ul><p>部署相关参数:</p><ul><li><code>spark.deploy.recoveryMode</code>： 在集群模式时的恢复，在 Master 的 onStart 方法中选择恢复</li><li><code>spark.deploy.zookeeper.url</code>： 当 spark.deploy.recoveryMode 设置为 ZOOKEEPER, 此配置生效</li><li><code>spark.deploy.zookeeper.dir</code>： 配置用于将 Zookeeper 目录设置为存储恢复状态</li></ul><p>Spark 的堆外内存配置，可用于缓存级别 StorageLevel.OFF_HEAP</p><ul><li><code>spark.memory.offHeap.enabled</code> ：是否开启堆外内存，默认值为 false，需要设置为 true</li><li><code>spark.memory.offHeap.size</code> : 堆外内存空间的大小，默认值为 0，需要设置为正值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spark.master              spark://linux121:7077</span><br><span class="line">spark.eventLog.enabled    <span class="literal">true</span></span><br><span class="line">spark.eventLog.dir        hdfs://linux121:9000/spark-eventlog</span><br><span class="line">spark.serializer          org.apache.spark.serializer.KryoSerializer</span><br><span class="line">spark.driver.memory       512m</span><br><span class="line"><span class="comment"># 与 hadoop historyserver集成</span></span><br><span class="line">spark.yarn.historyServer.address linux121:18080</span><br><span class="line">spark.history.ui.port 18080</span><br></pre></td></tr></table></figure><h3 id="Spark-env-sh"><a href="#Spark-env-sh" class="headerlink" title="Spark-env.sh"></a><code>Spark-env.sh</code></h3><ul><li>SPARK_WORKER_CORES：工作核心数</li><li>SPARK_WORKER_MEMORY： 工作内存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_251</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/opt/janhen/servers/hadoop-2.9.2</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/opt/janhen/servers/hadoop-2.9.2/etc/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_DIST_CLASSPATH=$(/opt/janhen/servers/hadoop-2.9.2/bin/hadoop classpath)</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=linux121</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077</span><br><span class="line"></span><br><span class="line"><span class="comment"># History </span></span><br><span class="line"><span class="built_in">export</span> SPARK_HISTORY_OPTS=<span class="string">&quot;-Dspark.history.ui.port=18080 -Dspark.history.retainedApplications=50 -Dspark.history.fs.logDirectory=hdfs://linux121:9000/spark-eventlog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HA</span></span><br><span class="line"><span class="built_in">export</span> SPARK_DAEMON_JAVA_OPTS=<span class="string">&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=linux121,linux122,linux123 -Dspark.deploy.zookeeper.dir=/spark&quot;</span></span><br></pre></td></tr></table></figure><p><strong>配置日志</strong></p><p>Spark 使用 log4j 记录日志, 配置文件位置 config/log4j.properties</p><p><strong>配置文件覆盖</strong></p><p>默认的配置文件夹为 <code>SPARK_HOME/conf</code>, 可以指定 <code>SPARK_CONF_DIR</code> 变量, Spark 将会使用该目录下的 spark-defaults.conf, <a href="http://spark-env.sh/">spark-env.sh</a>, log4j.properties 等配置文件。</p><h2 id="Spark-安装"><a href="#Spark-安装" class="headerlink" title="Spark 安装"></a>Spark 安装</h2><p>// TODO 集群环境安装的补充</p><h3 id="历史服务器"><a href="#历史服务器" class="headerlink" title="历史服务器"></a>历史服务器</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark.eventLog.enabled=<span class="literal">true</span></span><br><span class="line">spark.eventLog.compress=<span class="literal">true</span></span><br><span class="line">spark.eventLog.dir=hdfs:<span class="comment">//linux121:9000/tmp/logs/root/logs</span></span><br><span class="line">spark.history.fs.logDirectory=hdfs:<span class="comment">//linux121:9000/tmp/logs/root/logs</span></span><br><span class="line">spark.yarn.historyServer.address=http:<span class="comment">//linux121:18080</span></span><br></pre></td></tr></table></figure><p><a href="http://spark-env.sh/">spark-env.sh</a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export <span class="type">SPARK_HISTORY_OPTS</span>=<span class="string">&quot;-Dspark.history.ui.port=18080 -Dspark.history.fs.logDirectory=hdfs://linux121:9000/tmp/logs/root/logs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><ul><li>/spark：为容器内 spark home</li></ul><p>在资源不怎么充足的时候，使用单机的 Spark 进行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f spark-master</span><br><span class="line">docker run -d --name spark-master \\</span><br><span class="line">  -h spark-master \\</span><br><span class="line">  -e ENABLE_INIT_DAEMON=<span class="literal">false</span> \\</span><br><span class="line">  -p 4040:4040 \\</span><br><span class="line">  -p 7077:7077 \\</span><br><span class="line">  bde2020/spark-master:2.4.5-hadoop2.7</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/Spark%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/Spark%E8%B0%83%E4%BC%98/%E8%B5%84%E6%BA%90%E8%B0%83%E4%BC%98.md">wangzhiwubigdata/God-Of-BigData</a></p><p>Spark 资源调优</p><p><a href="http://spark.apache.org/docs/2.4.5/sql-performance-tuning.html">http://spark.apache.org/docs/2.4.5/sql-performance-tuning.html</a></p><p>2.4.5 Spark 性能调优官方文档</p><p><a href="https://archive.apache.org/dist/spark/">Index of /dist/spark</a></p><p>Spark 官网下载地址</p><p><a href="https://github.com/big-data-europe/docker-spark/tree/2.4.5-hadoop2.7">big-data-europe/docker-spark</a></p><p>Spark2.4.5 版本的 Docker</p><p><a href="https://spark.apache.org/docs/latest/configuration.html">Spark Configuration</a></p><p>Spark 配置官方文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;命令操作&quot;&gt;&lt;a href=&quot;#命令操作&quot; class=&quot;headerlink&quot; title=&quot;命令操作&quot;&gt;&lt;/a&gt;命令操作&lt;/h2&gt;&lt;p&gt;命令参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;–-class&lt;/code&gt;： 指定运行的入口类&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark-运行机制和作业执行</title>
    <link href="http://example.com/2021/04/09/Spark-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2021/04/09/Spark-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C/</id>
    <published>2021-04-09T05:52:17.000Z</published>
    <updated>2021-04-19T14:45:30.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><img src="http://img.janhen.com/20210414133828LsT0ZS.jpg" alt="http://img.janhen.com/20210414133828LsT0ZS.jpg" style="zoom:50%;" /><p>通用的执行过程：</p><p>① 使用 spark-submit，用户提交应用 ② 调用用户指定类的 main() 方法，启动 Driver 程序 ③ Driver 程序向 Cluster Manager 要执行 Executor 的资源 ④ Cluster Manager 为 Driver 启动 Executor ⑤ 基于在 RDD 中的 Action 和 Transformation 算子，Driver 发送任务到 Executor ⑥ Executor 执行任务，通过 Cluster Manager 将结果发回到 Driver</p><h3 id="Yarn-Client-任务提交"><a href="#Yarn-Client-任务提交" class="headerlink" title="Yarn-Client 任务提交"></a>Yarn-Client 任务提交</h3><p><img src="http://img.janhen.com/20210414125540yarn-client-img.jpg" alt="http://img.janhen.com/20210414125540yarn-client-img.jpg"></p><p>① Driver 端在任务提交的本地机上运行</p><p>② Driver 启动之后就会和 ResourceManager 通讯，申请启动一个 ApplicationMaster</p><p>③ ResourceManager 会分配 container 容器，在合适的 NodeManager 上启动 ApplicationMaster，负责向 ResourceManager 申请 Executor 内存</p><p>④ ResourceManager 接到 ApplicationMaster 的资源申请后会分配 container，然后 ApplicationMaster 在资源分配指定的 NodeManager 上启动 Executor 进程</p><p>⑤ Executor 进程启动后会向 Driver 反向注册，Executor 全部注册完成后 Driver 开始执行 main 函数</p><p>⑥ 执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 stage，每个 stage 生成对应的 TaskSet，之后 Driver 将 task 分发到各个 Executor 上执行</p><p>⑦ Executor 执行任务，将执行的结果/状态返回给 Driver</p><p>⑧ 应用程序执行完毕，通知 ResourceManager 注销应用，释放资源</p><h3 id="Yarn-cluster-提交步骤"><a href="#Yarn-cluster-提交步骤" class="headerlink" title="Yarn-cluster 提交步骤"></a>Yarn-cluster 提交步骤</h3><p><img src="http://img.janhen.com/20210414111428aV7jPc.jpg" alt="http://img.janhen.com/20210414111428aV7jPc.jpg"></p><p>Yarn-cluster 运行过程</p><p>① Client 先向 ResourceManager 提交请求，并上传 jar 到 HDFS 上</p><p>② ResourceManager 在集群中选择一个 NodeManager，在其上启动 AppMaster，在 AppMaster 中实例化 SparkContext(Driver)</p><p>③ AppMaster 向 ResourceManager 注册应用程序，注册的目的是申请资源。ResourceManager 监控 App 的运行状态直到结束</p><p>④ AppMaster 申请到资源后，与 NodeManager 通信，在 Container 中启动 Executor 进程</p><p>⑤ Executor 向 Driver 反向注册，申请任务</p><p>⑥ Driver 对应用进行解析，最后将 Task 发送到 Executor 上</p><p>⑦ Executor 中执行 Task，并将执行结果或状态汇报给 Driver</p><p>⑧ 应用执行完毕，AppMaster 通知 ResourceManager 注销应用，回收资源</p><h3 id="WordCount-执行过程"><a href="#WordCount-执行过程" class="headerlink" title="WordCount 执行过程"></a>WordCount 执行过程</h3><p><img src="http://img.janhen.com/20210419224401Untitled.png" alt="http://img.janhen.com/20210419224401Untitled.png"></p><p>① Master 与 Worker 启动</p><p>都为 RPCEntpoint，有对应的生命周期，主要为 onStart, 对于 Master 的 onStart 主要为恢复操作，对于 Worker 的 Start， 向 Master 发送心跳，进行注册</p><p>② 应用程序启动(SparkContext 的初始化)</p><p>启动三大组件</p><ul><li>DAGScheduler</li><li>TaskScheduler</li><li>SchedulerBackend</li></ul><p>向 Master 注册应用程序</p><p>命令 Worker 启动 Executor</p><p>Executor 向 Driver(应用程序) 注册(反向)，Driver 获取到资源</p><p>③ 遇上 Action，触发 Job</p><p>④ DAGScheduler.runJob： 根据 RDD 的依赖，从后向前扫描，遇到宽依赖进行 Stage 的划分</p><p>⑤ TaskScheduler 获得 Stage(Taskset)，将 Task 放到资源池中</p><p>⑥ SchedulerBackend 将 Task 发送到 Executor</p><p>⑦ task 在 Executor 中<strong>以 pipeline 方式执行</strong>。</p><p>⑧ 执行 Shuffle Writer，根据不同条件选择 Shuffle 的方式</p><ul><li>ByPassMergeSortShuffleWriter： …</li><li>UnSafedShuffleWriter： …</li><li>SortShuffleWriter： …</li></ul><p>⑨ 开始下一个Stage *</p><ul><li>Shuffle Reader</li><li>中间的转换以 pipeline 的方式执行</li><li>Shuffle Writer</li></ul><p>⑩ Executor 执行完毕向 Driver 汇报结果或状态</p><h3 id="执行参数"><a href="#执行参数" class="headerlink" title="执行参数"></a>执行参数</h3><p>建议通过 spark-submit 执行的时候指定，根据实际需要配置 Executor、Driver 中的资源，具体见 <a href="https://www.notion.so/Spark-d9ea53abd72843698ff2926693798d16">这里</a>。</p><h2 id="作业执行"><a href="#作业执行" class="headerlink" title="作业执行"></a>作业执行</h2><p><img src="http://img.janhen.com/20210411083210pOJ8JY.jpg" alt="http://img.janhen.com/20210411083210pOJ8JY.jpg"></p><h3 id="Job-触发"><a href="#Job-触发" class="headerlink" title="Job 触发"></a>Job 触发</h3><p><img src="http://img.janhen.com/202104141345489VRAyj.jpg" alt="http://img.janhen.com/202104141345489VRAyj.jpg"></p><ul><li><p>Job: 遇到一个 Action 方法则触发一个 Job</p></li><li><p>Stage: 分为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShuffleMapStage</span><br></pre></td></tr></table></figure><p> 和 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultStage</span><br></pre></td></tr></table></figure><ul><li>ShuffleMapStage，是其他 Stage 的输入，内部的转换操作（map、filter 等）会组成 pipeline，连在一起计算，会产生 map 输出文件</li><li>ResultStage，一个 job 中只有一个 ResultStage</li></ul></li><li><p>Task: 为 Stage 的子集，以并行度(分区数)来衡量，分区数是多少，则有多少个 task</p></li></ul><h3 id="Stage-划分"><a href="#Stage-划分" class="headerlink" title="Stage 划分"></a>Stage 划分</h3><p>由 DAGScheduler 完成</p><ul><li>DAGScheduler 根据 RDD 的血缘关系构成的 DAG 进行切分，将一个 Job 划分为 若干 Stages，具体划分策略是：从最后一个 RDD 开始，通过回溯依赖判断父依赖 是否是宽依赖（即以 Shuffle 为界），划分 Stage；窄依赖的 RDD 之间被划分到同一个 Stage 中，可以进行 pipeline 式的计算</li><li>在向前搜索的过程中使用 DFS</li><li>最后一个 Stage 称为 ResultStage，其他的都是 ShuffleMapStage</li><li>一个 Stage 是否被提交，需要判断它的父 Stage 是否执行。只有父 Stage 执行完毕才能提交当前 Stage，如果一个 Stage 没有父 Stage，那么从该 Stage 开始提交</li></ul><p>DAGSchedulerEventProcessLoop：DAGScheduler 内部的事件循环处理器，用于处理 <code>DAGSchedulerEvent</code> 类型的事件</p><p>自己处理自己发送的消息</p><p>EventLoop 是个消息异步处理策略抽象类（abstract class）</p><h3 id="Task-调度"><a href="#Task-调度" class="headerlink" title="Task 调度"></a>Task 调度</h3><p>由 TaskScheduler 来完成，属于底层的调度。DAGScheduler 将 Stage 打包到 TaskSet 交给 TaskScheduler，TaskScheduler 会将 TaskSet 封装为 TaskSetManager 加入到调度队列中。</p><p>TaskSetPool DAGScheduler</p><p>SchedulerBackend 负责跟外界打交道，接收 Executor 的注册，维护 Executor 的状态。</p><p>TaskScheduler 在 SchedulerBackend “问”它的时候，会从调度队列中按照指定的调度策略选择 TaskSetManager 去调度运行</p><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>由 TaskManager 进行控制，将 DAGScheduler 的 Task 转变为 TaskSetManager 进入到任务队列中，按照一定的策略从中取出来交给选择的 SchedulerBackend 发送到对应的 Executor 执行。</p><p>TaskScheduler 以树的方式来管理任务队列，树中的节点类型为 Schedulable，叶子节点为 TaskSetManager，非叶子节点为 Pool。</p><p><strong>FIFO 调度策略</strong></p><p>FIFO 调度策略是默认模式，在此模式下，只有一个 TaskSetManager 池</p><p><strong>Fair 调度策略</strong></p><p>该模式下有一个 rootPool 和多个子 Pool，各个子 Pool 中存储着所有待分配的 TaskSetManager；</p><p>各个子 Pool，以及子 Pool 中的 TaskSetManager 需要进行排序，Pool 与 TaskSetManager 可使用相同的排序算法。</p><p>排序的对象包含三个属性(<code>fairscheduler.xml</code> 配置文件中指定):</p><ul><li>runningTasks 值（正在运行的 Task 数）</li><li>minShare 值（时间）</li><li>weight 值（权重）</li></ul><h3 id="本地化调度"><a href="#本地化调度" class="headerlink" title="本地化调度"></a>本地化调度</h3><p>本地化调度：</p><ul><li>PROCESS_LOCAL: 计算节点和数据在一起</li><li>NODE_LOCAL: 数据节点和计算节点在一起</li><li>NO_PREF:</li><li>RACK_LOCAL:</li><li>RACK_LOCAL:</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TaskLocality</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Process local is expected to be used ONLY within TaskSetManager for now.</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">PROCESS_LOCAL</span>, <span class="type">NODE_LOCAL</span>, <span class="type">NO_PREF</span>, <span class="type">RACK_LOCAL</span>, c = <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">TaskLocality</span> </span>= <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isAllowed</span></span>(constraint: <span class="type">TaskLocality</span>, condition: <span class="type">TaskLocality</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    condition &lt;= constraint</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Executor-结果返回"><a href="#Executor-结果返回" class="headerlink" title="Executor 结果返回"></a>Executor 结果返回</h3><p>对于从 Executor 中获取数据到 Driver 端的结果返回处理：</p><ul><li>计算结果在（0，200KB-128MB）区间内：通过 Netty 直接发送给 Driver 终端 Netty 的预留空间 reservedSizeBytes，200KB <code>spark.rpc.message.maxSize</code>，默认值是 128MB</li><li>计算结果在 [128MB， 1GB] 区间内：将结果以 taskId 为编号存入到 BlockManager 中，然后通过 Netty 把编号发送给 Driver；阈值可通过 Netty 框架传输参数设置 <code>spark.driver.maxResultSize</code>，默认值 1G</li><li>计算结果在（1GB，∞）区间内：直接丢弃，可通过 <code>spark.driver.maxResultSize</code> 配置</li></ul><h3 id="失败重试与黑名单机制"><a href="#失败重试与黑名单机制" class="headerlink" title="失败重试与黑名单机制"></a>失败重试与黑名单机制</h3><p>提交上报的过程：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SchedulerBackend</span>(<span class="type">DriverEndPoint</span>) =&gt; <span class="type">TaskScheduler</span> =&gt; <span class="type">TaskSetManager</span></span><br></pre></td></tr></table></figure><p>对于失败的 Task，会记录它失败的次数，如果失败次数还没有超过最大重试次数， 那么就把它放回待调度的 Task 池子中，否则整个 Application 失败；</p><p>在记录 Task 失败次数过程中，会记录它上一次失败所在的 Executor Id 和 Host。下次再调度这个 Task 时，会使用黑名单机制，避免它被调度到上一次失败的节点上，起到一定的容错作用；</p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul><li><code>spark.logLineage</code>: 调用 Action 时打印 rdd 的 lineage 信息</li><li><code>spark.rpc.message.maxSize</code>： Netty 直接发送给 Driver 终端的阈值，默认 128M</li><li><code>spark.driver.maxResultSize</code>： Netty 框架传输参数，默认 1G,大于该值，Executor 向 Driver 发送的数据丢弃</li></ul><p>fairscheduler.xml</p><ul><li><code>minShare</code>：</li><li><code>weight</code>：</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://spark.apache.org/docs/latest/job-scheduling.html">Job Scheduling</a></p><p>Job Scheduling 文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;执行过程&quot;&gt;&lt;a href=&quot;#执行过程&quot; class=&quot;headerlink&quot; title=&quot;执行过程&quot;&gt;&lt;/a&gt;执行过程&lt;/h2&gt;&lt;img src=&quot;http://img.janhen.com/20210414133828LsT0ZS.jpg&quot; alt=&quot;ht</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-管理</title>
    <link href="http://example.com/2021/04/09/MySQL-%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/04/09/MySQL-%E7%AE%A1%E7%90%86/</id>
    <published>2021-04-08T17:10:05.000Z</published>
    <updated>2021-04-08T17:15:27.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本管理"><a href="#基本管理" class="headerlink" title="基本管理"></a>基本管理</h2><p>查看数据库中行数大于 0 的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找表行大于0的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(table_schema, <span class="string">&#x27;.&#x27;</span>, table_name)                    <span class="keyword">AS</span>  TABLE_NAME</span><br><span class="line">      ,<span class="keyword">engine</span>                                                   <span class="keyword">AS</span>  TABLE_ENGINE </span><br><span class="line">      ,table_type                                               <span class="keyword">AS</span>  TABLE_TYPE</span><br><span class="line">      ,table_rows                                               <span class="keyword">AS</span>  TABLE_ROWS</span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(data_length  / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_DATA_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(index_length / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_IDX_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>((data_length + index_length ) </span><br><span class="line">            / ( <span class="number">1024</span> * <span class="number">1024</span> ), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)                         <span class="keyword">AS</span>  TOTAL_SIZE</span><br><span class="line">      ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span>  data_length =<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">ELSE</span>  <span class="keyword">ROUND</span>(index_length / data_length, <span class="number">2</span>) <span class="keyword">END</span>      <span class="keyword">AS</span>  TB_INDX_RATE</span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>( data_free / <span class="number">1024</span> / <span class="number">1024</span>,<span class="number">2</span>), <span class="string">&#x27;MB&#x27;</span>)          <span class="keyword">AS</span>  TB_DATA_FREE </span><br><span class="line">      ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span> (data_length + index_length) = <span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="keyword">ROUND</span>(data_free/(data_length + index_length),<span class="number">2</span>) </span><br><span class="line">       <span class="keyword">END</span>                                                        <span class="keyword">AS</span>  TB_FRAG_RATE</span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES  </span><br><span class="line"><span class="keyword">WHERE</span> TABLE_ROWS &gt; <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> table_name <span class="keyword">in</span> (<span class="string">&#x27;entitylog&#x27;</span>,<span class="string">&#x27;iterfacelog&#x27;</span>,<span class="string">&#x27;stockshiftflow&#x27;</span>,<span class="string">&#x27;stockoperlog&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_length </span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><ul><li><code>-e</code>: 执行 SQL 语句</li><li><code>-D</code>: 连接的数据库</li><li><code>-s</code>, <code>--silent</code>: 使用 tab 作为分隔符，row ⇒ line，用于制作报表</li><li><code>-C</code>, <code>--compress</code>: 使用压缩在 client/server 之间</li><li>输出： 配合 Excel 制表<ul><li><code>-B</code>: 使用 Tab 替换分隔符</li><li><code>-N</code>: 不输出列信息</li><li><code>-E</code>: 垂直输出，展示格式</li><li><code>-H</code>: 以 HTML 输出</li><li><code>-X</code>: 以 XML 输出</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 DB 执行 SQL，让结果按照特定格式显示，方便 awk, sed 处理</span></span><br><span class="line">mysql -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> -h&lt;ip&gt; -D school -e <span class="string">&quot;SELECT * FROM student;&quot;</span></span><br><span class="line">mysql -udbuser -p123456 -h&lt;ip&gt; -D school -N -B -e <span class="string">&quot;SELECT * FROM student;&quot;</span></span><br><span class="line">mysql -udbuser -p123456 -h&lt;ip&gt; -D school -N -H -B -e <span class="string">&quot;SELECT * FROM student;&quot;</span> &gt; result.html</span><br></pre></td></tr></table></figure><h3 id="服务信息查看"><a href="#服务信息查看" class="headerlink" title="服务信息查看"></a>服务信息查看</h3><p>查看最近的 InnoDB 信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> <span class="keyword">INNODB</span> <span class="keyword">STATUS</span> \\G</span><br></pre></td></tr></table></figure><p>查看存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUE <span class="keyword">LIKE</span> <span class="string">&#x27;.*&#x27;</span> \\G</span><br></pre></td></tr></table></figure><p>查看函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUE <span class="keyword">LIKE</span> <span class="string">&#x27;.*&#x27;</span> \\G</span><br></pre></td></tr></table></figure><p>查找出所有 function,routines</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SPECIFIC_NAME <span class="keyword">FROM</span> information_schema.Routines \\G</span><br></pre></td></tr></table></figure><p>查看服务器状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;%lock%&#x27;</span>\\G</span><br></pre></td></tr></table></figure><p>查询是否锁表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录当前锁表状态 </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">where</span> In_use &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>查询 MySQL 进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Top 100</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure><p>查看正在锁的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS; </span><br></pre></td></tr></table></figure><p>查看等待锁的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS; </span><br></pre></td></tr></table></figure><p>慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看慢查询时间</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;long_query_time&quot;</span>;</span><br><span class="line"><span class="comment">-- 查看慢查询配置情况</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&quot;%slow_queries%&quot;</span>;</span><br><span class="line"><span class="comment">-- 查看慢查询日志路径</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;%slow%&quot;</span>;</span><br></pre></td></tr></table></figure><p>查看当前有那些表是打开的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span> <span class="keyword">from</span> <span class="keyword">database</span>;</span><br></pre></td></tr></table></figure><p>查看服务器超时参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> ‘%<span class="keyword">timeout</span>%’;</span><br><span class="line"><span class="comment">-- 隔离级别SHOW VARIBALES LIKE &#x27;ios%&#x27;</span></span><br><span class="line"><span class="comment">-- innodb</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span></span><br><span class="line"><span class="comment">-- 日志缓冲区</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">lIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span></span><br><span class="line"><span class="comment">-- 表的索引信息查看</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> &lt;mytab&gt;</span><br><span class="line"><span class="comment">-- 表信息查看</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;mytab&gt; \\G</span><br><span class="line"><span class="comment">-- warning 出现后的查看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span>;</span><br><span class="line"><span class="comment">-- 时区设置</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">time_zone</span>=<span class="string">&#x27;+10:00&#x27;</span>;</span><br><span class="line"><span class="comment">-- 隔离级别设置</span></span><br><span class="line"><span class="keyword">SET</span> SESSSION <span class="keyword">TRANSACTION</span> <span class="keyword">LEVEL</span></span><br></pre></td></tr></table></figure><h3 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h3><p>对于连接程序的账户，不给予 <code>ALERT</code> 权限，但是给定 DML 语句的 <code>EXEC</code>，让用户通过 <code>EXEC</code> 执行函数或是存储过程来变更表结构，防止权限造成的表结构更改混乱问题</p><p><a href="https://www.notion.so/1d0ad58b7c5b441e84544c888ba6b395">权限</a></p><p>创建检查账号:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,process,super,<span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> . </span><br><span class="line"><span class="keyword">to</span> <span class="string">&#x27;mysql_check&#x27;</span>@<span class="string">&#x27;x.x.x.x&#x27;</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;mysql_check&#x27;</span>; </span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p><strong>如何在给定场景下为某用户授权？</strong></p><p>对于对接的数据库授权，主要为 DML 权限</p><p><strong>如何为用户授权</strong></p><ul><li>遵循最小权限原则</li><li>使用 Grant 命令对用户授权(非改 db)</li></ul><p><strong>用户管理流程规范</strong> 数据库用户管理流程规范 (1) 最小权限原则 (2) 密码强度策略 (3) 密码过期原则。5.7 中引入 (4) 限制历史密码重用原则</p><p><strong>定义账号</strong> 如何定义MySQL数据库账号？ (1) 用户名@可访问控制列表 1.%：代表可以从所有外部主机访问 2.192.168.1.%：表示可以从192.168.1网段访问 3.localhost: DB服务器本地访问 (2) 使用CREATE USER命令建立用户</p><p>8.0 信息更多</p><p><strong>如何从一个实例迁移数据库账号到另一个实例？</strong> 根据 mysql 的数据库版本是否一致判断</p><ul><li>一致，备份 mysql 数据库，目的实例进行恢复 - 不一致，到处授权 sql</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pt-show-grants u=root，p=123456，h=localhost</span><br><span class="line">show priviledges;  </span><br><span class="line">CREATE USER userinfo IDENTIFIED BY <span class="string">&#x27;3UuQuskw2k%k&#x27;</span>;</span><br><span class="line">RENAME USER userinfo TO janhen;</span><br><span class="line">DROP USER janhen;</span><br><span class="line">SHOW GRANTS FOR janhen;</span><br><span class="line"></span><br><span class="line">-- 授权给新增的用户</span><br><span class="line">GRANT SELECT,UPDATE,INSERT,DELETE ON openapi.* TO openapi;</span><br><span class="line"></span><br><span class="line">-- 取消授权</span><br><span class="line">REVOKE DELETE ON openapi.* FROM openapi;、</span><br><span class="line"></span><br><span class="line">-- 更改密码</span><br><span class="line">SET PASSWORD FOR openapi = PASSWORD(<span class="string">&#x27;!BrJ%4MROWvN&#x27;</span>);</span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR <span class="string">&#x27;dbadmin&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> = bigshark;</span><br><span class="line"></span><br><span class="line">-- 设置登陆用户的密码</span><br><span class="line">SET PASSWORD = PASSWORD(<span class="string">&#x27;xxxxx&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>权限查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>权限收回</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span> <span class="keyword">on</span> test.* <span class="keyword">from</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>常见权限</strong></p><p>(1) 管理权限</p><p>不提供 MySQL 的 root 权限，给管理员权限，防止误操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="keyword">ON</span> *.* </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;janhenadmin&#x27;</span>@<span class="string">&#x27;sjfksjfaksdjfad&#x27;</span> </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></span><br><span class="line"><span class="keyword">grant</span> super,process,<span class="keyword">file</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;janhen&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p>(2) 数据库的读写权限</p><p>主要用于系统对接使用， SELECT, INSERT, UPDATE, DELETE, EXECUTE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">EXECUTE</span> </span><br><span class="line"><span class="keyword">ON</span> openapi.* </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;openapi&#x27;</span>@<span class="string">&#x27;%&#x27;</span> </span><br><span class="line"><span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>(3) 监控权限</p><p>用于命令行监控，或是 Prometheus 进行监控信息的获取 基本的主从命令 对于统计数据库的权限</p><p>基本的要求： SHOW MASTER LOGS SHOW ENGINE INNODB STATUS SHOW VIEW, PROCESS, REPLICATION CLIENT, SELECT and SHOW DATABASES</p><p>对 mysql 表的查看</p><p>(4) 备份权限</p><p>通过 mysqldump 或是 xtracback 执行备份，需要对 VIEW、Function、event 等进行备份 SELECT, RELOAD, LOCK TABLES, REPLICATION CLIENT, SHOW VIEW, EVENT, PROCESS</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">select</span>,reload,<span class="keyword">lock</span> <span class="keyword">tables</span>,<span class="keyword">replication</span> <span class="keyword">client</span>,<span class="keyword">show</span> <span class="keyword">view</span>,<span class="keyword">event</span>,process </span><br><span class="line"><span class="keyword">ON</span> *.* </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;backup&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5) 登陆权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">usage</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="MySQL-监控"><a href="#MySQL-监控" class="headerlink" title="MySQL 监控"></a>MySQL 监控</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>监控什么</strong></p><p>1、可用性: 端口检测，执行 select 1 或 show status 作为测试 SQL</p><p>2、性能监控: 并发线程监控</p><p>3、对主从复制进行监控</p><p>4、服务器资源的监控</p><p><strong>可用性监控</strong></p><p>本地 | 网络, 自带命令 ping 进行检测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -umonitor -p -h pingtelnet ip db_port</span><br></pre></td></tr></table></figure><p>2、Telent 连接</p><p>3、程序通过网络建立数据库</p><p>@Q: 确定 DB 是否读写 read_only 参数，主从中注意，定期检查</p><p>简单查询 SELECT @@version</p><p>连接数量监控：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 运行最大</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"><span class="comment">-- 当前连接</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;Threads_connected&#x27;</span>;</span><br><span class="line"><span class="comment">-- 比例监控</span></span><br><span class="line">Threads_connected/max_connections&gt;0.8;</span><br></pre></td></tr></table></figure><p><strong>性能监控</strong></p><p>@Q: QPS 和 TPS TPS 每秒的事务数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRU QPS=(Queries2-Queries1)/(Uptime_since_flush_status2- Uptime_since_flush_status1)</span><br><span class="line"></span><br><span class="line">TPS=((Com_insert2+Com_update2+Com_delete2)- (Com_insert1+Com_update1+Com_delete1))/ (Uptime_ since_flush_status2-Uptime_since_flush_ status1)</span><br></pre></td></tr></table></figure><p><strong>主从复制监控</strong></p><p>@Q: 监控主从复制链路的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Master_Log_File:mysql-bin.001083</span><br><span class="line">Read_Master_Log_Pos:228613650</span><br><span class="line">Relay_Log_File:mysqld-relay-bin.003606</span><br><span class="line">Relay_Log_Pos:228613813</span><br><span class="line">Relay_Master_Log_File:mysql-bin.001083</span><br><span class="line">Slave_Io_Running:Yes Slave_SQL_Running:Yes Replicate_Do__DB: Replicate_Iqnore_DB:</span><br></pre></td></tr></table></figure><p>@Q: 主从延迟 #{。。。}</p><p>@Q: 验证主从复制的数据一致性</p><p><strong>MySQL 信息查看</strong></p><blockquote><p>不使用其他的工具，借助 MySQL 自带的命令或表进行查看</p></blockquote><p><strong>MySQL 状态信息查看</strong></p><p>收集这些信息可以用于检测数据库的运行情况 分为全局状态、会话状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> ‘%下面变量%’;  </span><br></pre></td></tr></table></figure><ul><li>Aborted_clients 由于客户没有正确关闭连接已经死掉,已经放弃的连接数量.</li><li>Flush_commands 执行FLUSH命令的次数.</li><li>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数.</li><li><code>Max_used_connections</code> 同时使用的连接的最大数目.</li><li><code>Slow_queries</code>：要花超过long_query_time时间的查询数量.</li><li>Open_tables 打开表的数量.</li><li>Open_files 打开文件的数量.</li><li>Open_streams 打开流的数量(主要用于日志记载）</li><li>Opened_tables 已经打开的表的数量.</li><li>Threads_connected 当前打开的连接的数量.</li></ul><p><strong>INFORMATION_SCHEMA</strong></p><blockquote><p>辅助表信息</p></blockquote><p>transaction</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_TRX;  </span><br></pre></td></tr></table></figure><p>PERFORMANCE_SCHEMA</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">&#x27;perf%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可不与 mysql 在同一个机器上，作为额外的监控组件进行操作 支持服务器分组，支持多个 mysql 连接，较少的配置易于执行</p><h3 id="Innotop"><a href="#Innotop" class="headerlink" title="Innotop"></a>Innotop</h3><p>Innotop 为 MySQL和 InnoDB 事务/状态的监视器，类似 MySQL 的 top 命令，显示查询、InnoDB 事务、锁等待、死锁、打开的表、复制的状态、缓冲信息等。</p><p><strong>运行的参数</strong></p><ul><li>d：多久时间更新一次</li><li>h：连接的主机名</li><li>p：连接的端口</li><li>S：socket的位置</li><li>u：连接的用户</li><li>c: 指定配置文件运行</li></ul><p><code>#</code> 进行服务器分组<code>@</code> 进行选择连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innotop -h 127.0.0.1 \\</span><br><span class="line">  -u root -p<span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br></pre></td></tr></table></figure><p><strong>服务器分组</strong></p><p>保存配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[server_groups]</span><br><span class="line"></span><br><span class="line">inner&#x3D;master233 slave158</span><br><span class="line"></span><br><span class="line">[&#x2F;server_groups] </span><br><span class="line"></span><br><span class="line">[connections]</span><br><span class="line">master233&#x3D;user&#x3D;slave have_user&#x3D;1 pass&#x3D;slave have_pass&#x3D;1 dsn&#x3D;DBI:mysql:;host&#x3D;172.17.10.233;port&#x3D;3306 savepass&#x3D;1</span><br><span class="line">slave158&#x3D;user&#x3D;slave have_user&#x3D;1 pass&#x3D;slave have_pass&#x3D;1 dsn&#x3D;DBI:mysql:;host&#x3D;172.17.10.158;port&#x3D;3306 savepass&#x3D;1</span><br><span class="line"></span><br><span class="line">[&#x2F;connections]</span><br></pre></td></tr></table></figure><p><strong>面板</strong></p><p>M: 主从情况 T: 事务情况</p><p>O: 打开的表 是否在使用，是否被锁住</p><h2 id="数据存储碎片化"><a href="#数据存储碎片化" class="headerlink" title="数据存储碎片化"></a>数据存储碎片化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>碎片分类</strong></p><p>三种类型的数据碎片化</p><ul><li>行碎片（Row fragmentation）</li><li>行间碎片（Intra-row fragmentaion）</li><li>剩余空间碎片（Free space fragmentation）</li></ul><p><strong>碎片的影响</strong></p><p>磁盘上索引页的物理排序不接近页面上记录的索引排序，或者64页块中有许多未使用的页面被分配给索引</p><ul><li>占用的空间比“应该”占用的空间多，所有 InnoDB 数据和索引都存储在 B-trees 中，它们的 fill factor 可能在50％到100％之间变化。</li><li>表扫描需要比“应该”花费更多的时间。</li></ul><p><strong>碎片查看</strong></p><p>(1)碎片大小=数据总大小-实际表空间文件大小</p><p>(2)数据总大小=data_length+index_length=15220736</p><p>(3)实际表空间文件大小=rows<em>avg_rog_length=299335</em>50=14966750</p><p>(4)碎片大小=（15220736-14966750)/1024/1024=0.2M</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span>  mall <span class="keyword">like</span> <span class="string">&#x27;stockshiftflow&#x27;</span> \\G;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> mall <span class="keyword">like</span> <span class="string">&#x27;stockoperlog&#x27;</span> \\G;</span><br><span class="line"><span class="comment">-- 查询空闲空间超过 50M 大小的表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(table_schema, <span class="string">&#x27;.&#x27;</span>, table_name)                    <span class="keyword">AS</span>  TABLE_NAME</span><br><span class="line">      ,<span class="keyword">engine</span>                                                   <span class="keyword">AS</span>  TABLE_ENGINE </span><br><span class="line">      ,table_type                                               <span class="keyword">AS</span>  TABLE_TYPE</span><br><span class="line">      ,table_rows                                               <span class="keyword">AS</span>  TABLE_ROWS</span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(data_length  / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_DATA_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(index_length / ( <span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)     <span class="keyword">AS</span>  TB_IDX_SIZE </span><br><span class="line">      ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>((data_length + index_length ) </span><br><span class="line">            / ( <span class="number">1024</span> * <span class="number">1024</span> ), <span class="number">2</span>), <span class="string">&#x27;M&#x27;</span>)                         <span class="keyword">AS</span>  TOTAL_SIZE</span><br><span class="line">      ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span>  data_length =<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">ELSE</span>  <span class="keyword">ROUND</span>(index_length / data_length, <span class="number">2</span>) <span class="keyword">END</span>      <span class="keyword">AS</span>  TB_INDX_RATE</span><br><span class="line">    ,<span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>( data_free / <span class="number">1024</span> / <span class="number">1024</span>,<span class="number">2</span>), <span class="string">&#x27;MB&#x27;</span>)            <span class="keyword">AS</span>  TB_DATA_FREE </span><br><span class="line">    ,<span class="keyword">CASE</span> <span class="keyword">WHEN</span> (data_length + index_length) = <span class="number">0</span> <span class="keyword">THEN</span> <span class="number">0</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="keyword">ROUND</span>(data_free/(data_length + index_length),<span class="number">2</span>) </span><br><span class="line">     <span class="keyword">END</span>                                                        <span class="keyword">AS</span>  TB_FRAG_RATE</span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">ROUND</span>(DATA_FREE/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>) &gt;=<span class="number">50</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_free <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>, <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><p><strong>optimize table table_name</strong></p><p>OPTIMIZE 操作会暂时锁住表,而且数据量越大,耗费的时间也越长。</p><p>OPTIMIZE TABLE 后，表的变化跟存储引擎有关。</p><p>对于 INNODB 表,OPTIMIZE TABLE 映射到 ALTER TABLE … FORCE（或者这样翻译：在 InnoDB 表中等价 ALTER TABLE … FORCE），它重建表以更新索引统计信息并释放聚簇索引中未使用的空间。当您在InnoDB表上运行时，它会显示在 OPTIMIZE TABLE 的输出中</p><p>对于 <code>innodb_file_per_table=1</code> 的 InnoDB 表，OPTIMIZE TABLE 会重组表和索引的物理存储，将空闲空间释放给操作系统。也就是说 <code>OPTIMIZE TABLE [tablename]</code> 这种方式只适用于独立表空间</p><p><strong>ALTER TABLE table_name ENGINE = Innodb</strong></p><p>实际上重新整理碎片了.当执行优化操作时,实际执行的是一个空的 ALTER 命令,但是这个命令也会起到优化的作用,它会重建整个表,删掉未使用的空白空间。</p><p>ALTER TABLE ENGINE= INNODB,会重新整理在聚簇索引上的数据和索引。</p><p>在有些情况下，ALTER TABLE xxxx ENGINE= INNODB 更好。例如old_alter_table 系统变量没有启用等等。另外对于 MyISAM 类型表，使用 ALTER TABLE xxxx ENGINE= INNODB 是明显要优于 OPTIMIZE TABLE 这种方法的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stockshiftflow <span class="keyword">ENGINE</span> = <span class="keyword">Innodb</span>;</span><br></pre></td></tr></table></figure><p><strong>pt-online-schema-change</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change  \\</span><br><span class="line"> --user=<span class="variable">$&#123;user&#125;</span> \\</span><br><span class="line"> --password=<span class="variable">$&#123;passwd&#125;</span> \\</span><br><span class="line"> --host=<span class="variable">$&#123;host&#125;</span>  \\</span><br><span class="line"> P=3306,D=<span class="variable">$&#123;database&#125;</span>,t=<span class="variable">$table</span> \\</span><br><span class="line"> --charset=utf8 \\</span><br><span class="line"> --alter=<span class="string">&quot;ENGINE=InnoDB&quot;</span>  \\</span><br><span class="line"> --nocheck-replication-filters \\</span><br><span class="line"> --alter-foreign-keys-method=auto  \\</span><br><span class="line"> --execute</span><br></pre></td></tr></table></figure><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>文件名 clean_pieces.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#********************************************************************</span></span><br><span class="line"><span class="comment">#$1         :         清理碎片的数据库名称</span></span><br><span class="line"><span class="comment">#$2         :         清理碎片的表名称</span></span><br><span class="line"><span class="comment">#Description:         清理 MySQL 表的碎片</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">args=($*)</span><br><span class="line">database=<span class="variable">$&#123;args[0]&#125;</span></span><br><span class="line">tables=( <span class="variable">$&#123;args[@]:1&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;database: <span class="variable">$database</span>&quot;</span></span><br><span class="line"><span class="keyword">for</span> table <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;tables[@]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;table: <span class="variable">$table</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">host=<span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">user=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">passwd=<span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> table <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;tables[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">sql=<span class="string">&quot;</span></span><br><span class="line"><span class="string">select</span></span><br><span class="line"><span class="string">  CONCAT(table_schema, &#x27;.&#x27;, table_name)                           AS  TABLE_NAME,</span></span><br><span class="line"><span class="string">  concat(round(sum((DATA_LENGTH+Index_length)/1024/1024),2),&#x27;MB&#x27;) AS TABLE_SIZE,</span></span><br><span class="line"><span class="string">  concat(round(sum(DATA_LENGTH/1024/1024),2),&#x27;MB&#x27;)                AS DATA_SIZE,</span></span><br><span class="line"><span class="string">  concat(round(sum(Index_length/1024/1024),2),&#x27;MB&#x27;)               AS INDEX_SIZE,</span></span><br><span class="line"><span class="string">  table_rows                                                      AS  TABLE_ROWS,</span></span><br><span class="line"><span class="string">  CASE WHEN  data_length =0 THEN 0</span></span><br><span class="line"><span class="string">            ELSE  ROUND(index_length / data_length, 2) END        AS  TB_INDX_RATE</span></span><br><span class="line"><span class="string">from TABLES where table_schema=&#x27;<span class="variable">$database</span>&#x27; and table_name=&#x27;<span class="variable">$table</span>&#x27;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------- <span class="subst">$(date +%s)</span> Database: <span class="variable">$database</span>, Table: <span class="variable">$table</span>, Begin clean ... --------------- &quot;</span></span><br><span class="line">mysql -u<span class="variable">$user</span> -p<span class="variable">$passwd</span> -P3306 -h<span class="variable">$host</span> information_schema -e <span class="string">&quot;<span class="variable">$sql</span>&quot;</span></span><br><span class="line"></span><br><span class="line">time pt-online-schema-change  \\</span><br><span class="line">  --user=<span class="variable">$&#123;user&#125;</span> \\</span><br><span class="line">  --password=<span class="variable">$&#123;passwd&#125;</span> \\</span><br><span class="line">  --host=<span class="variable">$&#123;host&#125;</span>  \\</span><br><span class="line">  P=3306,D=<span class="variable">$&#123;database&#125;</span>,t=<span class="variable">$table</span> \\</span><br><span class="line">  --charset=utf8 \\</span><br><span class="line">  --alter=<span class="string">&quot;ENGINE=InnoDB&quot;</span>  \\</span><br><span class="line">  --nocheck-replication-filters \\</span><br><span class="line">  --alter-foreign-keys-method=auto  \\</span><br><span class="line">  --execute</span><br><span class="line"></span><br><span class="line">mysql -u<span class="variable">$user</span> -p<span class="variable">$passwd</span> -P3306 -h<span class="variable">$host</span> information_schema -e <span class="string">&quot;<span class="variable">$sql</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行 CASE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理 mall 数据库中表 interfacelog stockoperatelog stockshiftflow 的碎片</span></span><br><span class="line">bash clean_pieces.sh mall interfacelog stockoperatelog stockshiftflow</span><br></pre></td></tr></table></figure><h2 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h2><h3 id="服务器参数"><a href="#服务器参数" class="headerlink" title="服务器参数"></a>服务器参数</h3><p><strong>基本参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto-increment-increment &#x3D; 2      </span><br><span class="line">auto-increment-offset &#x3D; 2    </span><br><span class="line">slave-skip-errors &#x3D; all </span><br></pre></td></tr></table></figure><p><strong>InnoDb基本参数</strong></p><p>状态变量</p><p>基本配置</p><p><strong>innodb_buffer_pool_size</strong></p><p>缓冲池并不仅仅缓存素引：它还会缓存行的数据、自适应哈希索引、插入缓冲（Insert Buffer）、锁，以及其他内部数据结构。 来帮助延迟写入，可合并多个写入操作</p><p><strong>innodb_log_file_size</strong></p><p><strong>max_connections</strong></p><p>最大连接数，阿里云的 MySQL5.8, 8C16G 默认为 4000</p><p><strong>Innodb 参数</strong></p><p><strong>innodb_file_per_table</strong></p><p>每张表都是一个独立表空间，对应每张表都是一个 <code>idb</code> 文件。</p><p>配置成独立表空间后可以对表进行数据、索引碎片整理。</p><p><strong>Innodb_flush_log_at_trx_commit</strong></p><p>事务刷写磁盘日志的策略</p><ul><li>0: 数据不安全，适合配置 slave 机器</li><li>1: 默认值，最安全的设置，每次事务后日志都会刷新到磁盘。</li><li>2: 每秒刷新一次事务，有丢失的风险，对于 master 有时可以接受; MySQL 进挂掉，不会丢任何事务，整个服务器挂了或断点，可能会丢失一些事务</li></ul><p>缓冲区大小</p><p>Innodb read io threads innodb write io threads</p><p>以上两个参数決定了 Innodb 读写的 I0 进程数，默认为 4</p><p>Innodb stats on metadata</p><p>决定了 MYSQL 在什么情況下会刷新 innodb 表的统计信息。</p><p>配置的内容：</p><ul><li>个数 - 字节 - 开启与关闭 - 百分比</li></ul><p>table_cache: 表可被缓存的数量</p><p>key_buffer_size:  以字节为单位</p><p>max_heap_table_size: 指定隐式内存临时表最大允许的大小</p><p>table_cache_size: 结果值比缓存中的表数小，MYSQL 将从缓存中删除不常使用的表</p><p>thread_cache_size:</p><p>query_cache_size:</p><p>sort_buffer_size:</p><p>innodb_buffer_pool_pages_dirty: 状态变量，缓冲池中的脏页数量</p><p>innodb_buffer_pool_instances:  5.5+ 新增</p><p>open_files_limit:  设置的较少，可能出现 too many open files</p><p><strong>参数动态配置</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> sort_buffer_size = &lt;<span class="keyword">value</span>&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> sort_buffer_size = &lt;<span class="keyword">value</span>&gt;</span><br><span class="line"><span class="keyword">SET</span> @@sort_buffer_size := &lt;<span class="keyword">value</span>&gt;</span><br><span class="line"><span class="keyword">SET</span> @@session.sort_buffer_size := &lt;<span class="keyword">value</span>&gt;</span><br><span class="line">@@global.sort_buffer_size := &lt;<span class="keyword">value</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>控制 Innodb 并发</strong></p><p>innodb_thread_concurrency: 并发设置，默认为 0，表示不限制 建议并发值 = CPU 数量 * 磁盘数量 * 2</p><p>innodb_thread_sleep_delay: 微秒为单位, 在进入内核线程超过运行的数量后，第一次休眠的时间，之后重试，若不能进入，则放入到等待队列，由 OS 处理</p><p>innodb_concurrency_tickets: 较少小改</p><p>innodb commit concurrency: 変量控制有多少个线程可以在同时间提交</p><p><strong>排序</strong></p><p>max_length_for_sort_data： 影响使用哪种排序算法</p><p>max_connect_errors:  网络、配置、权限等问题导致大连个链接重试，记录黑名单设置的大，有效地禁用主机黑名单</p><p>read_only： 建议备库设置成只读模式</p><p>slave_net_timeout： 默 1h，可缩短到 1min</p><p><strong>I/O 配置</strong></p><p>innodb_log_file_in_group</p><p><strong>主从配置</strong></p><p>跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断 1062: 一些主键重复 1032: 主从数据库数据不一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave_skip_errors&#x3D;1062  </span><br></pre></td></tr></table></figure><p>忽略指定的数据库同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog-ignore-db&#x3D;mysql</span><br></pre></td></tr></table></figure><p><strong>sync_binlog</strong></p><p>控制何时 binlog 刷新到磁盘上</p><p>0: 由 OS 进行控制 1: 每次事务提交的时候写入，最为安全，但影响性能</p><h3 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h3><p><strong>Connection</strong></p><ul><li>createDatabaseIfNotExist： 默认为 false</li><li>rollbackOnPooledClose: 默认为 true, 在 Driver 因为问题回滚..</li><li>useAffectedRows: 默认为 false</li></ul><p><strong>Session</strong></p><ul><li><code>characterEncoding=utf8</code>: 设置 session 对应的编码格式，告知 server 返回的结果编码格式，默认为 “autodetect”。</li><li>useUnicode=true： 使用 Unicode</li><li><code>serverTimezone=Asia/Shanghai</code>： 设置时区</li></ul><p><strong>Networking</strong></p><ul><li>connectTimeout： 默认为 0，连接超时, 单位 ms</li><li>socketTimeout: 默认为 0，单位 ms. 网络 socket 操作的超时时间</li><li>maxAllowedPacket： 默认为 65535，最大允许发送的网络包 Packet 大小</li><li>useCompression： 默认为 false，使用 zlib 压缩，当与服务器通信的时候</li></ul><p><strong>Statements</strong></p><ul><li>cacheDefaultTimezone： 默认为 true，缓存客户端默认时区，MySQL8.0.20 后添加的</li><li>queryTimeoutKillsConnection: 默认 false</li></ul><p><strong>Performance Extensions</strong></p><p>If ‘cacheCallableStmts’ is enabled, how many callable statements should be cached?</p><p>Default: 100</p><ul><li>metadataCacheSize: 结果元数据缓存的大小，在 cacheResultSetMetaData 设置为 true 时有效，默认 50</li><li>prepStmtCacheSize： 多少 prepared statements 被缓存，默认 25</li><li><code>rewriteBatchedStatements=true</code>：默认 false，重写批量的语句，提高批量的操作效率</li><li><code>allowMultiQueries=true</code>： 允许多查询</li></ul><h3 id="归档数据库配置"><a href="#归档数据库配置" class="headerlink" title="归档数据库配置"></a>归档数据库配置</h3><p>可定期对 MySQL 进行数据归档，可考虑使用 Archive 存储引擎，对于归档的数据库可适当减少配置，关闭一些耗时的配置。</p><p>配置如下：</p><ul><li>使用 4G 的 innodb 缓冲区</li><li>更改事务隔离级别为 READ-UNCOMMITTED，一般只是导入导出无事务操作</li><li>适当调整 mysqldump 的 max_allowed_packet，方便进行必要数据的恢复</li><li>关闭慢查询、binlog</li><li>减小相应的 buffer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port                            &#x3D; 3306</span><br><span class="line">socket                          &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">pid-file                        &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">datadir                         &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">log-error                       &#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;mysql-error.log</span><br><span class="line">tmpdir                          &#x3D; &#x2F;tmp</span><br><span class="line"></span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line"></span><br><span class="line"># binlog setting</span><br><span class="line">#log-bin                         &#x3D; mysql-bin</span><br><span class="line">#binlog_format                   &#x3D; MIXED      # can be mixed, decrease ..</span><br><span class="line">#binlog_format                   &#x3D; ROW      # can be mixed, decrease ..</span><br><span class="line">#binlog_row_image                &#x3D; minimal</span><br><span class="line">sync_binlog                     &#x3D; 1  # default 0    affect performance，</span><br><span class="line">                                      # safe to guarantee replication</span><br><span class="line">slave_net_timeout               &#x3D; 60 # defacult 3600</span><br><span class="line"></span><br><span class="line">#expire_logs_days                &#x3D; 7</span><br><span class="line">#relay_log                       &#x3D; mysql-relay</span><br><span class="line">#server_id                       &#x3D; &#123;&#123;server_id | default(&#39;555&#39;)&#125;&#125;</span><br><span class="line">#log_bin_trust_function_creators &#x3D; 1</span><br><span class="line">wait_timeout                    &#x3D; 57600</span><br><span class="line">interactive_timeout             &#x3D; 57600</span><br><span class="line"></span><br><span class="line">max_allowed_packet              &#x3D; 512M # or 100M</span><br><span class="line">event_scheduler                 &#x3D; 1</span><br><span class="line">max_connections                 &#x3D; 2000</span><br><span class="line"></span><br><span class="line"># log setting &#123;slow query, not using indexs&#125;</span><br><span class="line">#slow_query_log                  &#x3D; &#123;&#123;slow_query_log | default(&#39;0&#39;)&#125;&#125;</span><br><span class="line">#slow_query_log_file             &#x3D; mysql-slow.log</span><br><span class="line">#long_query_time                 &#x3D; &#123;&#123;long_query_time | default(&#39;0.20&#39;)&#125;&#125;</span><br><span class="line">#log_queries_not_using_indexes   &#x3D; &#123;&#123;log_queries_not_using_indexes | default(&#39;0&#39;)&#125;&#125;</span><br><span class="line"></span><br><span class="line"># character</span><br><span class="line">character-set-server            &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line"># tx</span><br><span class="line">transaction-isolation                   &#x3D; READ-UNCOMMITTED #REPEATABLE-READ req for ACID, SERIALIZABLE req XA</span><br><span class="line"></span><br><span class="line"># innodb</span><br><span class="line">#innodb_buffer_pool_size         &#x3D; 768M</span><br><span class="line">innodb_buffer_pool_size         &#x3D; 4G</span><br><span class="line">                                  # old 128M, 70%-80% mache mem</span><br><span class="line">innodb_log_file_size            &#x3D; 32M # old 500M, total 1G,  can bigger to 1024M</span><br><span class="line">                                       # Note: modify need to move old file to other position,may start fail</span><br><span class="line">                                       # 64G_RAM+ &#x3D; 768, 24G_RAM+ &#x3D; 512, 8G_RAM+ &#x3D; 256, 2G_RAM+ &#x3D; 128</span><br><span class="line">#innodb_log_files_in_group       &#x3D; 2 # defacult 2</span><br><span class="line">innodb_log_buffer_size          &#x3D; 64M  # defalut 8M</span><br><span class="line">innodb_buffer_pool_instances    &#x3D; 8    # default</span><br><span class="line">innodb_flush_log_at_trx_commit  &#x3D; 2 # defalut 1, per second trx flush  2&#x2F;0 &#x3D; perf, 1 &#x3D; ACID</span><br><span class="line">innodb_file_per_table           &#x3D; 1</span><br><span class="line">innodb_lock_wait_timeout        &#x3D; 60  # timeout 500</span><br><span class="line">innodb_status_output            &#x3D; ON</span><br><span class="line">innodb_status_output_locks      &#x3D; ON</span><br><span class="line">innodb_print_all_deadlocks      &#x3D; ON</span><br><span class="line">innodb_read_io_threads          &#x3D; 6  # default 4</span><br><span class="line">innodb_write_io_threads         &#x3D; 6  # default 4</span><br><span class="line">#innodb_thread_concurrency       &#x3D; 16 # default 0  recommend 2x core quantity</span><br><span class="line">#innodb_additional_mem_pool_size &#x3D; 8M #default 8M</span><br><span class="line">#innodb_open_files               &#x3D; 2000  # default 2000, can open *.idb file count</span><br><span class="line"># buffer setting</span><br><span class="line">sort_buffer_size                &#x3D; 256K # default 0.25M</span><br><span class="line">join_buffer_size                &#x3D; 256K # default 0.25M,     can bigger to 128M</span><br><span class="line">read_buffer_size                &#x3D; 512K # default 0.125M</span><br><span class="line">read_rnd_buffer_size            &#x3D; 512K # default 0.25M</span><br><span class="line">#max_length_for_sort_data        &#x3D; 1024 # default 1024</span><br><span class="line">#max_connect_errors              &#x3D; 100 # defacult 100</span><br><span class="line">#innodb_doublewrite              &#x3D; 1 # default on</span><br><span class="line">#thread_concurrency              &#x3D; 12  # default 10    recommend 2x CPU cores</span><br><span class="line">#thread_cache_size               &#x3D; 28 # defacult 28    recommend 5% of max_connections</span><br><span class="line">#open_files_limit                &#x3D; 1048576 # default 1048576</span><br><span class="line"></span><br><span class="line"># MyISAM</span><br><span class="line">#key_buffer_size                 &#x3D; 32M   # default 8M</span><br><span class="line">#query_cache_size                &#x3D; 1M # default 1M</span><br><span class="line"></span><br><span class="line"># table size</span><br><span class="line">tmp_table_size                  &#x3D; 128M  # default 16M</span><br><span class="line">max_heap_table_size             &#x3D; 128M  # default 16M recommend same size as tmp_table_size</span><br><span class="line"></span><br><span class="line"># concat</span><br><span class="line">group_concat_max_len            &#x3D; 100000000</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set           &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set           &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">quote-names</span><br><span class="line">max_allowed_packet              &#x3D; 256M</span><br></pre></td></tr></table></figure><h3 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port                            = 3306</span><br><span class="line">socket                          = /var/run/mysqld/mysqld.sock</span><br><span class="line">pid-file                        = /var/run/mysqld/mysqld.pid</span><br><span class="line">datadir                         = /var/lib/mysql</span><br><span class="line">log-error                       = /var/log/mysql/mysql-error.log</span><br><span class="line">tmpdir                          = /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># binlog setting</span></span><br><span class="line">log-bin                         = mysql-bin</span><br><span class="line"><span class="comment">#binlog_format                   = MIXED      # can be mixed, decrease ..</span></span><br><span class="line">binlog_format                   = ROW      <span class="comment"># can be mixed, decrease ..</span></span><br><span class="line">binlog_row_image                = minimal</span><br><span class="line"><span class="comment">#sync_binlog                     = 1  # default 0    affect performance，</span></span><br><span class="line">                                      <span class="comment"># safe to guarantee replication</span></span><br><span class="line">slave_net_timeout               = 60 <span class="comment"># defacult 3600</span></span><br><span class="line"></span><br><span class="line">expire_logs_days                = 7</span><br><span class="line">relay_log                       = mysql-relay</span><br><span class="line">server_id                       = 199192</span><br><span class="line">log_bin_trust_function_creators = 1</span><br><span class="line">wait_timeout                    = 57600</span><br><span class="line">interactive_timeout             = 57600</span><br><span class="line"></span><br><span class="line">max_allowed_packet              = 256M <span class="comment"># or 100M</span></span><br><span class="line">event_scheduler                 = 1</span><br><span class="line">max_connections                 = 2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># log setting &#123;slow query, not using indexs&#125;</span></span><br><span class="line">slow_query_log                  = 1</span><br><span class="line">slow_query_log_file             = mysql-slow.log</span><br><span class="line">long_query_time                 = 0.20</span><br><span class="line">log_queries_not_using_indexes   = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># character</span></span><br><span class="line">character-<span class="keyword">set</span>-<span class="keyword">server</span>            = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># tx</span></span><br><span class="line"><span class="keyword">transaction</span>-<span class="keyword">isolation</span>                   = REPEATABLE-<span class="keyword">READ</span> <span class="comment">#REPEATABLE-READ req for ACID, SERIALIZABLE req XA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># innodb</span></span><br><span class="line">innodb_buffer_pool_size         = <span class="number">18</span>G</span><br><span class="line">                                  <span class="comment"># old 128M, 70%-80% mache mem</span></span><br><span class="line">innodb_log_file_size            = <span class="number">500</span>M <span class="comment"># old 500M, total 1G,  can bigger to 1024M</span></span><br><span class="line">                                       <span class="comment"># <span class="doctag">Note:</span> modify need to move old file to other position,may start fail</span></span><br><span class="line">                                       <span class="comment"># 64G_RAM+ = 768, 24G_RAM+ = 512, 8G_RAM+ = 256, 2G_RAM+ = 128</span></span><br><span class="line"><span class="comment">#innodb_log_files_in_group       = 2 # defacult 2</span></span><br><span class="line">innodb_log_buffer_size          = <span class="number">8</span>M  <span class="comment"># defalut 8M</span></span><br><span class="line">innodb_buffer_pool_instances    = <span class="number">8</span>    <span class="comment"># default</span></span><br><span class="line">innodb_flush_log_at_trx_commit  = <span class="number">2</span> <span class="comment"># defalut 1, per second trx flush  2/0 = perf, 1 = ACID</span></span><br><span class="line">innodb_file_per_table           = <span class="number">1</span></span><br><span class="line">innodb_lock_wait_timeout        = <span class="number">60</span>  <span class="comment"># timeout 500</span></span><br><span class="line">innodb_status_output            = <span class="keyword">ON</span></span><br><span class="line">innodb_status_output_locks      = <span class="keyword">ON</span></span><br><span class="line">innodb_print_all_deadlocks      = <span class="keyword">ON</span></span><br><span class="line">innodb_read_io_threads          = <span class="number">6</span>  <span class="comment"># default 4</span></span><br><span class="line">innodb_write_io_threads         = <span class="number">6</span>  <span class="comment"># default 4</span></span><br><span class="line"><span class="comment">#innodb_thread_concurrency       = 16 # default 0  recommend 2x core quantity</span></span><br><span class="line"><span class="comment">#innodb_additional_mem_pool_size = 8M #default 8M</span></span><br><span class="line"><span class="comment">#innodb_open_files               = 2000  # default 2000, can open *.idb file count</span></span><br><span class="line"><span class="comment"># buffer setting</span></span><br><span class="line">sort_buffer_size                = <span class="number">1</span>M <span class="comment"># default 0.25M</span></span><br><span class="line">join_buffer_size                = <span class="number">1</span>M <span class="comment"># default 0.25M,     can bigger to 128M</span></span><br><span class="line">read_buffer_size                = <span class="number">1</span>M <span class="comment"># default 0.125M</span></span><br><span class="line">read_rnd_buffer_size            = <span class="number">1</span>M <span class="comment"># default 0.25M</span></span><br><span class="line"><span class="comment">#max_length_for_sort_data        = 1024 # default 1024</span></span><br><span class="line"><span class="comment">#max_connect_errors              = 100 # defacult 100</span></span><br><span class="line"><span class="comment">#innodb_doublewrite              = 1 # default on</span></span><br><span class="line"><span class="comment">#thread_concurrency              = 12  # default 10    recommend 2x CPU cores</span></span><br><span class="line"><span class="comment">#thread_cache_size               = 28 # defacult 28    recommend 5% of max_connections</span></span><br><span class="line"><span class="comment">#open_files_limit                = 1048576 # default 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyISAM</span></span><br><span class="line"><span class="comment">#key_buffer_size                 = 32M   # default 8M</span></span><br><span class="line"><span class="comment">#query_cache_size                = 1M # default 1M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># table size</span></span><br><span class="line">tmp_table_size                  = <span class="number">128</span>M  <span class="comment"># default 16M</span></span><br><span class="line">max_heap_table_size             = <span class="number">128</span>M  <span class="comment"># default 16M recommend same size as tmp_table_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># concat</span></span><br><span class="line">group_concat_max_len            = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>           = utf8mb4</span><br><span class="line"></span><br><span class="line">[<span class="keyword">client</span>]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>           = utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line"><span class="keyword">quick</span></span><br><span class="line">quote-<span class="keyword">names</span></span><br><span class="line">max_allowed_packet              = <span class="number">128</span>Mr</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="MySql-大表数据删除"><a href="#MySql-大表数据删除" class="headerlink" title="MySql 大表数据删除"></a>MySql 大表数据删除</h3><p>Mysql 官网对于大表数据的删除说明</p><blockquote><p>If you are deleting many rows from a large table, you may exceed the lock table size for an InnoDB table. To avoid this problem, or simply to minimize the time that the table remains locked, the following strategy (which does not use DELETE at all) might be helpful: Select the rows not to be deleted into an empty table that has the same structure as the original table: INSERT INTO t_copy SELECT * FROM t WHERE … ; Use RENAME TABLE to atomically move the original table out of the way and rename the copy to the original name: RENAME TABLE t TO t_old, t_copy TO t; Drop the original table:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> copy_interfacelog </span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> mall.servicelog </span><br><span class="line"><span class="keyword">WHERE</span> logtime <span class="keyword">between</span> <span class="string">&#x27;2020-04-07 02:00:00&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-04-14 10:23:24&#x27;</span>;</span><br><span class="line"><span class="comment">-- 使用 mysqldump, file...备份恢复</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> mall.servicelog  <span class="keyword">TO</span> mall.old_servicelog copy_interfacelog <span class="keyword">TO</span> interfacelog;  </span><br></pre></td></tr></table></figure><p>通过 <code>INSERT INTO &lt;table-name&gt; SELECT ..</code> 筛选出不需要删除的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`table`</span> <span class="keyword">WHERE</span> (whatever criteria) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line">MYSQL=<span class="string">&quot;mysql -uroot -p$MYSQL_ROOT_PASSWORD &quot;</span></span><br><span class="line"><span class="keyword">sql</span>=<span class="string">&quot;select uuid from mail.interfacelog where (condition) order by uuid desc limit 1000 &quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">`seq 1 1000`</span>; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">$MYSQL -e <span class="string">&quot;$sql&quot;</span> | sed <span class="string">&#x27;s;/|;;g&#x27;</span> | awk <span class="string">&#x27;&#123;if(NR&gt;1)print &quot;delete from table_name where uuid = &quot;,$1,&quot;;&quot; &#125;&#x27;</span> | $MYSQL; </span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://stackoverflow.com/questions/1318972/deleting-millions-of-rows-in-mysql">Deleting millions of rows in MySQL</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">MySQL :: MySQL 8.0 Reference Manual :: 13.7.3.4 OPTIMIZE TABLE Statement</a></p><p>官网对于 OPTIMIZE TABLE 说明</p><p><a href="https://www.cnblogs.com/kerrycode/p/10943122.html">潇湘隐者</a></p><p>MySQL 数据存储碎片化</p><p><a href="https://gist.github.com/fevangelou/fb72f36bbe333e059b66">Optimized my.cnf configuration for MySQL/MariaSQL (on Ubuntu, CentOS etc. servers)</a></p><p>优化的 mysql 配置</p><p><a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/">Ten MySQL performance tuning settings after installation</a></p><p>percona 网站对于 MySQL 性能调整配置说明</p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html</a></p><p>官网对于属性的配置</p><p><a href="https://stackoverflow.com/questions/32286518/whats-the-difference-between-cacheprepstmts-and-useserverprepstmts-in-mysql-jdb">What’s the difference between cachePrepStmts and useServerPrepStmts in MySQL JDBC Driver</a></p><p><a href="https://stackoverflow.com/questions/2993251/jdbc-batch-insert-performance">https://stackoverflow.com/questions/2993251/jdbc-batch-insert-performance</a></p><p>批量操作参数的更改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本管理&quot;&gt;&lt;a href=&quot;#基本管理&quot; class=&quot;headerlink&quot; title=&quot;基本管理&quot;&gt;&lt;/a&gt;基本管理&lt;/h2&gt;&lt;p&gt;查看数据库中行数大于 0 的表&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-备份与恢复</title>
    <link href="http://example.com/2021/04/09/MySQL-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://example.com/2021/04/09/MySQL-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2021-04-08T17:06:57.000Z</published>
    <updated>2021-04-08T17:16:05.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份概述"><a href="#备份概述" class="headerlink" title="备份概述"></a>备份概述</h2><blockquote><p>备份决定了数据库的安全，在主从不一致的情况下删除从库的所有数据，进行数据重新整理。</p></blockquote><p>对于 MyISAM 备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br></pre></td></tr></table></figure><h3 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h3><p><strong>逻辑备份：</strong> 结果为 sql 文件，方法适用于所有 Engine</p><p><strong>物理备份：</strong> 数据库目录的拷贝，对于内存表只备份结构</p><p><strong>备份的内容：</strong></p><ul><li>事务的 innodb 表，不带有事务的(无法保证一致性)</li><li>函数(routines)、触发器、视图</li><li>包含的表，有时无需对整个数据库所有的表进行备份，只需要备份重要的业务表，用于以后的恢复</li><li>排除的表，在做全量备份的时候，排除掉日志表、记录表、备份表等与业务非强相关的表，提高备份的效率</li></ul><p><strong>备份的类型：</strong></p><ul><li>热备份： 在线备份，不需要任何的服务停机时间，ibbackup 商业工具可实现</li><li>冷备份： 备份 .frm, .idb 文件，需要离线备份</li><li>温备份： 非离线备份，在线执行，会影响线上的数据库运行</li></ul><p><strong>备份的方案:</strong></p><ul><li>全量备份</li><li>增量备份</li><li>压缩备份</li><li>加密备份</li></ul><p>备份的数据存放到另一块物理磁盘上或是传输到另一台机器上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">data</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> xxx.txt</span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">data</span> <span class="keyword">INFILE</span> xxx.txt <span class="keyword">INTO</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dc_mp_fans <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/data/fans.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line">zip fans.zip /data/fans.txt</span><br><span class="line">scp fans.zip root@ip:/data/ </span><br><span class="line">unzip /data/fans.zip</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">&#x27;/data/fans.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> wxa_fans(</span><br><span class="line">  <span class="keyword">id</span>,appid,openid,unionid,created_at);</span><br></pre></td></tr></table></figure><p><strong>备份场景</strong></p><p>备份业务中重要的业务表</p><p>日志表的归档，归档到另一个表中</p><p>备份/导出/ETL 到大数据平台</p><h3 id="强制恢复"><a href="#强制恢复" class="headerlink" title="强制恢复"></a>强制恢复</h3><p>处理恢复过程中启动不起来的情况</p><p>MySQL 配置参数 innodb_force_recovery 控制</p><ul><li>1: (SRV_FORCE_IGNORE_CORRUPT): 忽略检查到的 corrupt 页。</li><li>2: (SRV_FORCE_NO_BACKGROUND): 阻止主线程的运行，如主线程需要执行 full purge 操作，会导致 crash。</li><li>3: (SRV_FORCE_NO_TRX_UNDO): 不执行事务回滚操作。</li><li>4: (SRV_FORCE_NO_IBUF_MERGE): 不执行插入缓冲的合并操作。</li><li>5: (SRV_FORCE_NO_UNDO_LOG_SCAN): 不查看重做日志，InnoDB 存储引擎会将未提交的事务视为已提交。</li><li>6: (SRV_FORCE_NO_LOG_REDO): 不执行前滚的操作。</li></ul><p>当 innodb_purge_threads 和 innodb_force_recovery 一起设置会出现一种loop 现象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_force_recovery&#x3D;6</span><br><span class="line">innodb_purge_thread&#x3D;0</span><br></pre></td></tr></table></figure><p>当设置参数值大于0后，可以对表进行 select,create,drop 操作,但 insert,update 或者 delete 这类操作是不允许的</p><p>MySQL crash 或者 MySQL 数据库服务器 crash 会导致各种各样的问题 ，比如主备之间的 error 1594 (5.6 版本开启crash-safe ，会最大程度上避免 error 1594的问题)，error 1236， 日志损坏，数据文件损坏等。</p><h3 id="物理文件离线备份"><a href="#物理文件离线备份" class="headerlink" title="物理文件离线备份"></a>物理文件离线备份</h3><p>离线方式的备份，需要停止整个服务 存在复制过程中的文件损坏，对应表空间没法使用，数据库服务一直尝试重启</p><p>注意数据库的 <code>.frm</code>, <code>.idb</code> 的权限 660；目录为 700；目录的属主为 <code>mysql:mysql</code></p><h3 id="基于日志点的恢复"><a href="#基于日志点的恢复" class="headerlink" title="基于日志点的恢复"></a>基于日志点的恢复</h3><p>增量恢复</p><p>备份二进制日志，使用 <code>FLUSH LOGS</code> 开始一个新的二进制日志</p><p><a href="https://dba.stackexchange.com/questions/60722/how-to-recover-truncate-table-in-mysql">https://dba.stackexchange.com/questions/60722/how-to-recover-truncate-table-in-mysql</a></p><p>mysqlbinlog：</p><ul><li><code>--start-position</code>: 开始位置</li><li><code>--stop-position</code>: 停止位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -v mysqlbin.000002 | grep -B5 TRUNCATE --color</span><br><span class="line"></span><br><span class="line">mysqlbinlog \\</span><br><span class="line">  --start-position=1603 \\</span><br><span class="line">  --stop-position=919664 \\</span><br><span class="line">  mysqlbin.000002 &gt; /mysqlbackup/binlog_`date +%y%m%d%H`.sql</span><br><span class="line">show binary logs;</span><br><span class="line">show master logs;</span><br><span class="line">SHOW BINLOG EVENTS;</span><br><span class="line">show binlog events <span class="keyword">in</span> <span class="string">&quot;mysql-bin.000005&quot;</span>;</span><br><span class="line">mysqlbinlog binlog.[0-9]* | mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p>可直接使用 DBver, Navicate, DataGrip 等图形化连接客户端进行各种格式的导出，包含 INSERT 语句、UPDATE 语句、HTML 表格、CSV(TSV)、JSON、格式化的text文本、Markdown 的表格等。</p><p><img src="http://img.janhen.com/20210324225548Pk0vYq.png" alt="http://img.janhen.com/20210324225548Pk0vYq.png"></p><p>SELECT … INTO OUTFILE</p><p>需要登录的 mysql 账号具有 FILE 权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> entitylog <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/var/lib/mysql/backup/entitylog.txt&#x27;</span>;</span><br><span class="line"><span class="comment">-- 指定分割符合换行符， 导出为 CSV 格式</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> entitylog <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/var/lib/mysql/backup/entitylog.txt&#x27;</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">&#x27;&quot;&#x27;</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;\\r\\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>mysql 命令导出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出为 CSV 格式</span></span><br><span class="line">mysql -uroot -p -e &quot;<span class="keyword">select</span> * <span class="keyword">from</span> entitylog<span class="string">&quot; --skip-column-names test|sed -e &quot;</span>s/[\\t]/,/<span class="string">&quot; -e &quot;</span>s/$/\\r/<span class="string">&quot; &gt; entity.txt</span></span><br></pre></td></tr></table></figure><h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><blockquote><p>MySQL 自带的备份工具，可以对数据库进行全备份和部分备份,不支持增量备份。</p></blockquote><p>使用场景： 10G 以下的数据库操作简单</p><p>缺点： 数据量范围：30G –&gt; TB级别 的时候备份、恢复操作很慢，效率低</p><p><strong>基本配置：</strong></p><ul><li><code>-h</code> / -P / -u / -p: 基本连接参数</li><li><code>--single-transaction</code>: 保证导出的数据一致性，保证备份 InnoDB 的一致性逻辑备份，和 –lock-tables 选项是互斥的</li><li><code>-l</code> / <code>--lock-tables</code>:一般用于 MyIsam 备份，与上面的互斥</li><li><code>x, --lock-all-tables</code>: 数据库</li><li><code>-master-data</code>: [1/2]</li></ul><p><strong>备份内容配置:</strong></p><ul><li><code>--all-databases</code>: 备份全部的 DB</li><li><code>--databases &lt;db1&gt; &lt;db2&gt;</code>: 备份指定的多个数据库</li><li><code>--tables a1 a2</code>: 备份指定的多个 Table</li><li><code>-w, --where=&quot;&quot;</code>: 备份表中筛选后的数据</li><li><code>-R, --routines</code>: 备份 procedures, functions</li><li><code>--triggers</code>: 备份触发器</li><li><code>-e, --events</code>:</li><li><code>--no-data</code>: 只导出表结构，不导出数据</li></ul><p><strong>控制输出内容配置：</strong></p><ul><li><code>--skip-add-drop-table</code>: <strong>取消每个数据表创建之前添加 drop 数据表语句</strong>(默认每个表之前存在drop语句)，对于部分恢复的情况下需要注意。</li><li><code>--skip-add-locks</code>: 跳过锁表语句</li><li><code>--no-create-info</code>： 导出的 SQL 中不包含 create table 语句</li><li><code>--set-gtid-purged</code>： 跳过导 GTID</li><li><code>--add-drop-database</code>: 增加删除数据库 sql（默认不会）</li><li>-opt： 等同于 <code>--add-drop-table</code>, <code>--add-locks</code>, <code>--create-options</code>, <code>--quick</code>, <code>--extended-insert</code>, <code>--lock-tables</code>, <code>--set-charset</code>, <code>--disable-keys</code>，默认开启</li><li><code>-c</code>, <code>--complete-insert</code>: 生成的 Insert 语句中带有字段名称, insert into T(col1,col2..) values(…)</li></ul><p>其他配置</p><ul><li><code>–-lock-all-tables</code>: 锁住所有的表，表变为只读的</li><li>–master-data=: 将当前服务器的binlog的位置和文件名追加到输出文件，不会停止当前服务器的主从服务</li><li>-F: 生成新的 binlog 文件</li><li>-C： 启用压缩传递</li><li><code>--dump-slave</code></li></ul><h3 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--all-databases \\</span></span><br><span class="line">  <span class="comment">--master-data \\</span></span><br><span class="line">  <span class="comment">--single-transaction \\</span></span><br><span class="line">  &gt; backup_$(date +%y%m%d).sql</span><br></pre></td></tr></table></figure><h3 id="多服务器数据传输"><a href="#多服务器数据传输" class="headerlink" title="多服务器数据传输"></a>多服务器数据传输</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --host=h1 -uroot -proot --databases db1 | mysql --host=h2 -uroot -proot db2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩传输</span></span><br><span class="line">mysqldump --host=192.168.80.137 -uroot -proot -C --databases <span class="built_in">test</span> | mysql --host=192.168.80.133 -uroot -proot <span class="built_in">test</span> </span><br></pre></td></tr></table></figure><h3 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h3><p>线上环境导入导出使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩备份</span></span><br><span class="line">mysqldump -P3306 \\</span><br><span class="line">  -uroot -p  \\</span><br><span class="line">  -q -Q --set-gtid-purged=OFF \\</span><br><span class="line">  --default-character-set=utf8 \\</span><br><span class="line">  --hex-blob --skip-lock-tables \\</span><br><span class="line">  --databases abc 2&gt;/abc.err |gzip &gt;/abc.sql.gz</span><br><span class="line"><span class="comment"># 还原</span></span><br><span class="line">gunzip -c abc.sql.gz | mysql -uroot -p -vvv -P3306 --default-character-set=utf8 abc 1&gt; abc.log 2&gt;abc.err</span><br></pre></td></tr></table></figure><h3 id="按条件备份"><a href="#按条件备份" class="headerlink" title="按条件备份"></a>按条件备份</h3><p><strong>备份指定数据库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqldump  \\</span><br><span class="line">  -hlocalhost -P3306 \\</span><br><span class="line">  -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --add-drop-table \\</span><br><span class="line">  --master-data=2 \\</span><br><span class="line">  --single-transaction \\</span><br><span class="line">  --routines --triggers --events \\</span><br><span class="line">  --databases account basic report \\</span><br><span class="line">  &gt; backup_$(date +%y%m%d).sql</span><br></pre></td></tr></table></figure><p><strong>备份满足特定条件的表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份指定时间的日志数据</span></span><br><span class="line">mysqldump -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --databases basic \\</span><br><span class="line">  --tables interfacelog \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;logtime &lt; &#x27;2020-05-01 00:00:00&#x27; and logtime &gt; &#x27;2020-04-08 00:00:00&#x27;&quot;</span> \\</span><br><span class="line">   &gt; backup-interfacelog-`date +%y%m%d`</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从重命名的表中备份数据</span></span><br><span class="line">mysqldump -uroot -proot \\</span><br><span class="line">  --databases basic \\</span><br><span class="line">  --tables old_interfacelog \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;logtime between &#x27;2020-04-13 00:00:00&#x27; and &#x27;2020-04-14 00:00:00&#x27;&quot;</span> \\</span><br><span class="line">   &gt; backup-interfacelog-`date +%y%m%d`</span><br></pre></td></tr></table></figure><p>备份表并在 insert 语句中插入字段</p><p>使用场景： 备份数据，并恢复到变更表结构的该表</p><ul><li>归档表重命名原始表名，对应 INSERT INTO <table-name> 与生产库的表名一致</li><li>对于表结构变更的，需要 Insert 增加字段名</li><li>用于从归档到生产库的，需要去除逻辑备份前面的 Drop 语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试输出的结果</span></span><br><span class="line">db=account</span><br><span class="line">table=entitylog</span><br><span class="line">time mysqldump -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --databases <span class="variable">$db</span> \\</span><br><span class="line">  --tables <span class="variable">$table</span> \\</span><br><span class="line">  --complete-insert \\</span><br><span class="line">  --skip-add-locks \\</span><br><span class="line">  --no-create-info \\</span><br><span class="line">  --skip-add-drop-table \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;1=1 limit 0,1&quot;</span> \\</span><br><span class="line">   &gt; test.sql</span><br><span class="line">db=facility</span><br><span class="line">table=<span class="string">&quot;stockoperlog &quot;</span></span><br><span class="line">time mysqldump -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> \\</span><br><span class="line">  --databases <span class="variable">$db</span> \\</span><br><span class="line">  --complete-insert \\</span><br><span class="line">  --tables <span class="variable">$table</span> \\</span><br><span class="line">  --no-create-info \\</span><br><span class="line">  --skip-add-locks \\</span><br><span class="line">  --skip-add-drop-table \\</span><br><span class="line">  --<span class="built_in">where</span>=<span class="string">&quot;logtime &gt; &#x27;2021-01-01 00:00:00&#x27;&quot;</span> \\</span><br><span class="line">   &gt; stockoperlog_210101_`date +%y%m%d`.sql</span><br></pre></td></tr></table></figure><h3 id="备份表结构"><a href="#备份表结构" class="headerlink" title="备份表结构"></a>备份表结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot \\</span><br><span class="line">  --no-data \\</span><br><span class="line">  --databases account \\</span><br><span class="line">  &gt; /tmp/account_schema.sql</span><br></pre></td></tr></table></figure><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>专门创建一个备份数据库，查询出必要的数据，之后插入到实际使用的表</p><p>使用 table 进行恢复，只对需要的进行恢复</p><p>进行时间点的恢复 前提：</p><ul><li>一个时间点的全备</li><li>对应的 binlog</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 SQL 恢复到指定的数据库</span></span><br><span class="line">mysql -uroot -proot \\</span><br><span class="line">  basic &lt; backup_200604_basic.sql</span><br><span class="line"></span><br><span class="line">mysql -uroot -proot \\</span><br><span class="line">  account &lt; backup_200604_account.sql</span><br></pre></td></tr></table></figure><h2 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h2><blockquote><p>可对数据库进行全备和增量备份，使用 binlog 对数据库进行时间点的… 支持在线的物理备份</p></blockquote><p><strong>配置</strong> 在 my.cnf 中指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xtrabackup]</span><br><span class="line">target_dir &#x3D; &#x2F;data&#x2F;backups&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure><p><strong>基础参数</strong></p><ul><li><code>--print-defaults</code>: 打印程序参数和列表并退出</li><li><code>--target-dir=&lt;path&gt;</code>: 备份到的目标文件夹</li><li><code>--backup</code>: take backup to target-dir</li><li><code>--prepare</code>: 准备备份以在备份上启动 mysql 服务器。</li><li><code>--export</code>:</li><li><code>--print-param</code>:</li><li><code>--rate-limit</code>: 限制备份脚本的吞吐量</li></ul><p><strong>备份过滤的参数：</strong></p><ul><li><code>--tables=name</code> / : 根据正则表达式过滤表名，过滤列表根据</li><li><code>--tables-file=name</code>: 根据文件中的 <code>database.table</code> 进行过滤</li><li><code>--databases=name</code>: 根据数据库列表过滤</li><li><code>--tables-exclude=name</code>: 排除指定的表, 与 <code>--tables</code> 相反，优先级比 <code>--tables</code> 高</li><li><code>--databases-exclude=name</code>: 排除指定的数据库</li></ul><p><strong>压缩备份参数</strong></p><ul><li><code>--compress[=name]</code>: 是否进行压缩备份</li><li><code>--compres</code>s： 进行压缩备份</li><li><code>--compress-threads=N</code>: 指定压缩的线程数</li><li><code>--decompress</code>: 解压缩恢复备份数据</li></ul><p><strong>增量备份参数</strong></p><ul><li><code>--incremental-basedir=&lt;path&gt;</code>： 增量备份基于的全量备份文件夹</li></ul><p><strong>数据库恢复参数</strong></p><ul><li><code>--copy-back</code>: 复制之前所有的文件</li></ul><p><strong>其他参数</strong></p><ul><li><code>--slave-info</code>: 主从复制备份有效</li><li><code>--safe-slave-backup</code>:</li><li><code>–-binlog-info[=name]</code></li></ul><h3 id="全量备份-1"><a href="#全量备份-1" class="headerlink" title="全量备份"></a>全量备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_BACKUP_DIR=/var/<span class="built_in">log</span>/mysql/backups/<span class="variable">$dir_name</span>/Full_$(date +%Y.%m.%d_%H.%M.%S)</span><br><span class="line">mkdir -p <span class="variable">$MYSQL_BACKUP_DIR</span></span><br><span class="line">xtrabackup --backup \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span> \\</span><br><span class="line">  -uroot -proot </span><br><span class="line"></span><br><span class="line">xtrabackup --prepare \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span> \\</span><br><span class="line">  -uroot -proot</span><br></pre></td></tr></table></figure><h3 id="有条件的全量备份"><a href="#有条件的全量备份" class="headerlink" title="有条件的全量备份"></a>有条件的全量备份</h3><p>xtrabackup 当前只能指定到表级别，没法对表的数据进行筛选 若需要对表的内容进行筛选，可考虑使用 <code>mysqldump</code> 进行逻辑备份，配合 <code>xtrbackup</code> 的物理备份实现</p><p><strong>排除指定表进行备份</strong></p><p>可根据实际需要列出需要排除的大表，拼接成正则或是到文件中进行过滤；</p><p>可通过 <code>(.*log.*|.*record.*|.*bak.*|.*\\d+.*)</code> 正则表达式进行排除不相关的表；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. define back info</span></span><br><span class="line">MYSQL_BACKUP_DIR=/var/lib/mysql/<span class="keyword">backup</span></span><br><span class="line">back_up_dir=$MYSQL_BACKUP_DIR/Full_$(<span class="built_in">date</span> +%Y.%m.%d_%H.%M.%S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2 compare back info</span></span><br><span class="line"><span class="comment"># Filter pattern: (.*log.*|.*record.*|.*bak.*|.*\\d+.*)</span></span><br><span class="line">mkdir -p $back_up_dir</span><br><span class="line">table_exclude_names=(</span><br><span class="line">  <span class="string">&quot;account.entitylog&quot;</span></span><br><span class="line">  <span class="string">&quot;account.mqlog&quot;</span></span><br><span class="line">  <span class="string">&quot;basic.interfacelog&quot;</span></span><br><span class="line">  <span class="string">&quot;basic.article_bak&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">join</span>() &#123;</span><br><span class="line">  <span class="keyword">local</span> IFS=<span class="string">&quot;$1&quot;</span></span><br><span class="line">  shift</span><br><span class="line">  echo <span class="string">&quot;$*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">join_str=$(<span class="keyword">join</span> \\| <span class="string">&quot;$&#123;table_exclude_names[@]&#125;&quot;</span>)</span><br><span class="line">exclude_table=<span class="string">&quot;($join_str)&quot;</span></span><br><span class="line">echo <span class="string">&quot;exclude_table: $exclude_table&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 非压缩备份</span></span><br><span class="line"><span class="built_in">time</span> xtrabackup <span class="comment">--backup \\</span></span><br><span class="line">  <span class="comment">--host=127.0.0.1 \\</span></span><br><span class="line">  -uroot -proot \\</span><br><span class="line">  <span class="comment">--tables-exclude=&quot;$exclude_table&quot; \\</span></span><br><span class="line">  <span class="comment">--datadir=/var/lib/mysql/ \\</span></span><br><span class="line">  <span class="comment">--target-dir=$back_up_dir</span></span><br></pre></td></tr></table></figure><p><strong>备份指定的表</strong></p><p>单独备份表的话需要表在独立的表空间，对应 innodb_file_per_table=1</p><h3 id="压缩备份-1"><a href="#压缩备份-1" class="headerlink" title="压缩备份"></a>压缩备份</h3><p>需要使用 <code>qpress</code> 工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 qpress</span></span><br><span class="line">percona-release <span class="built_in">enable</span> tools</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install qpress</span><br><span class="line">MYSQL_BACKUP_DIR=/var/<span class="built_in">log</span>/mysql/backups/<span class="variable">$dir_name</span>/Full_$(date +%Y.%m.%d_%H.%M.%S)</span><br><span class="line">mkdir -p <span class="variable">$MYSQL_BACKUP_DIR</span>  </span><br><span class="line">xtrabackup --backup \\</span><br><span class="line">  --compress  \\</span><br><span class="line">  --compress-threads=4 \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">xtrabackup --decompress \\</span><br><span class="line">  --target-dir=/data/compressed/</span><br><span class="line"></span><br><span class="line">xtrabackup --copy-back \\</span><br><span class="line">  --target-dir=/data/backups/</span><br></pre></td></tr></table></figure><p><strong>数据恢复</strong></p><p>数据目录在恢复前必须为空</p><p>在执行恢复前，MySQL 服务需要关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --copy-back \\</span><br><span class="line">  --target-dir=<span class="variable">$MYSQL_BACKUP_DIR</span> </span><br></pre></td></tr></table></figure><h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><p>增量并压缩备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">datadir=/var/lib/mysql/backup</span><br><span class="line">xtrabackup --user=root \\</span><br><span class="line">  --password=root \\</span><br><span class="line">  --backup \\</span><br><span class="line">  --compress \\</span><br><span class="line">  --compress-threads=4 \\</span><br><span class="line">  --target-dir=<span class="variable">$&#123;datadir&#125;</span>/inc<span class="variable">$&#123;today&#125;</span> \\</span><br><span class="line">  --incremental-basedir=/var/lib/mysql/backup/Full_2020.08.23</span><br></pre></td></tr></table></figure><p>比较偏移的点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat xtrabackup_checkpoints</span><br><span class="line">backup_type = full-backuped</span><br><span class="line">from_lsn = 0</span><br><span class="line">to_lsn = 10820498082</span><br><span class="line">last_lsn = 10820498082</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br><span class="line">flushed_lsn = 10820475795</span><br><span class="line">backup_type = incremental</span><br><span class="line">from_lsn = 10820498082</span><br><span class="line">to_lsn = 10820575291</span><br><span class="line">last_lsn = 10820575291</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br><span class="line">flushed_lsn = 10820572909</span><br></pre></td></tr></table></figure><h3 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h3><p>准备</p><ul><li>可以在任何机器上运行 <code>prepare</code> 命令，无需在原始服务器上, 可复制备份到指定机器上进行恢复</li><li>准备步骤使用此嵌入式 InnoDB 对复制的数据文件执行崩溃恢复</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/data/backups/</span><br></pre></td></tr></table></figure><h3 id="复制与授权"><a href="#复制与授权" class="headerlink" title="复制与授权"></a>复制与授权</h3><p>复制备份文件</p><p>方式一: 使用 xtraback 提供的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/data/backups/</span><br></pre></td></tr></table></figure><p>方式二: 使用 <code>rsync</code> 或 <code>cp</code> 复制备份文件到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -avrP /data/backup/ /var/lib/mysql/</span><br><span class="line"><span class="comment"># 2 cp </span></span><br></pre></td></tr></table></figure><p>授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于数据量大的情况，可以考虑将大表的数据通过 ETL 工具导出到大数据平台进行存储，业务系统中只保留最近 1年的数据。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://www.cnblogs.com/chenmh/p/5300370.html">MySQL mysqldump数据导出详解</a></p><p><a href="https://blog.csdn.net/helloxiaozhe/article/details/77680255">MySql数据库备份与恢复–使用mysqldump 导入与导出方法总结_helloxiaozhe的博客-CSDN博客_mysqldump备份数据库</a></p><p>MySql数据库备份与恢复——使用mysqldump 导入与导出方法总结</p><p><a href="https://www.percona.com/doc/percona-xtrabackup/2.4/index.html">Percona XtraBackup - Documentation</a></p><p>Percona XtraBackup 2.4 官方文档</p><p><a href="https://www.percona.com/doc/percona-xtrabackup/2.4/xtrabackup_bin/partial_backups.html">Partial Backups</a></p><p>Percona 官网部分备份说明文档</p><p><a href="https://cloud.tencent.com/developer/article/1682656">使用innobackupex对数据库进行部分备份(指定表或数据库)</a></p><p>使用innobackupex对数据库进行部分备份(指定表或数据库)</p><p><a href="https://www.runoob.com/mysql/mysql-database-export.html">MySQL 导出数据</a></p><p>MySQL 导出数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;备份概述&quot;&gt;&lt;a href=&quot;#备份概述&quot; class=&quot;headerlink&quot; title=&quot;备份概述&quot;&gt;&lt;/a&gt;备份概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;备份决定了数据库的安全，在主从不一致的情况下删除从库的所有数据，进行数据重新整理。&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-日志</title>
    <link href="http://example.com/2021/04/09/Mysql-%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2021/04/09/Mysql-%E6%97%A5%E5%BF%97/</id>
    <published>2021-04-08T17:06:49.000Z</published>
    <updated>2021-04-08T17:07:47.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><blockquote><p>MySQL 的动态参数，可以随关随停</p></blockquote><h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p>优化策略：</p><ul><li>调优 TOP10, 之后迭代…</li><li>业务扩展，用户流量增加，进一步调优</li></ul><p>慢查询日志的性能剖析工具：汇总一些信息，自动排序</p><p>查看慢日志：</p><p>正常的格式</p><p>explain</p><p>EXPLAIN 关键字模拟优化器执行 SQL 查询语句</p><p><img src="http://img.janhen.com/202103072224361551841270019.png" alt="http://img.janhen.com/202103072224361551841270019.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> </span><br><span class="line">   star, </span><br><span class="line">  evaluator_no </span><br><span class="line"><span class="keyword">from</span> indicator_evaluate </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> evaluator_no <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>id: 代表执行的顺序</li><li>type: 找到数据行的方式, 数据的访问类型，取值为如下<ul><li>all: 全表扫描</li><li>index: ALL 和 INDEX 都读全表，INDEX 从索引读， ALL 从硬盘读</li><li>range： between, in, &gt;, &lt; 等的查询，无需扫全表</li><li>ref：非唯一性索引扫描，返回匹配..</li><li>eq_ref: 唯一性索引扫描，对于每一个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。</li><li>const: 表示通过索引一次就找到了，const 用于比较为 primary key(主键索引)或者是 unique 索引，因为只匹配一行，所以很快，若将主键作为 where 条件，MySQL 就会把该查询作为一个常量</li><li>system ：表中只有一条记录(等同于系统表) 这是 const 特例，平时不会出现。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 最好达到 ref OR range 级别</span><br><span class="line">system&gt;const&gt;eq_ref&gt;</span><br><span class="line">ref&gt;range&gt;</span><br><span class="line">index&gt;all</span><br></pre></td></tr></table></figure><ul><li><p><strong>extra：</strong> Using where, Using index， Using filesort</p><p>最重要的 extra 的取值是前三个 filesort、 using temporary(性能差的sql语句) 、use index(性能好的 sql语句)；</p><p>是查询优化器进行选择索引的一个参数，及排序的规则；extra 中出现下面两项意味着 MySQL 不能使用索引，效率会有很大的影响，需尽早优化</p><ul><li>Using filesort: 外部索引排序，不是从表中按索引次序读取相关内容，可能在内存或磁盘上排序，MySQL 无法利用索引完成的排序。</li><li>Using temporary: 使用临时表，在 order by 和 group by 中常见</li></ul></li><li><p><strong>select_type:</strong> 查询的类型 有以下六种取值</p><ul><li>simplye: 表示简单查询 ，不包含子查询以及 union</li><li>primary: 若查询中包含了任何的子查询，最外层的主查询标识为 primary</li><li>subquery: 标识为子查询</li><li>derived: 派生的，在 from 子查询的结果会被放入为衍生虚表(临时表)</li><li>union: 若第二个 select 出现在 union 之后，则会标记为 union(若 union 包含在 from 子句的子查询中，外层的的 select 标识为 derived)</li><li>union result：从 union 表中获取数据的 select 标识</li></ul></li><li><p><code>key</code>:实际上使用的索引,为 null 表示为索引失效</p></li><li><p>possiable_keys: 理论上可能使用到的索引，若在查询的时候使用了覆盖索引，那么该索引就不会出现在 possible_keys 中，而只会出现在 key 列中。</p></li><li><p>key_len：表示索引在使用的字节数，可以通过该列计算查询中使用的索引的长度，长度越小越好 key_len 显示的值为索引字段的最大可能长度，而非使用长度，及key_len 是根据表定义计算而得，不是通过表内检索出来的。</p></li><li><p>ref: 表示索引的哪一列被使用，如果可能的话是一个常数，哪些列或者常量被用于索引列上的查找。</p></li><li><p>rows: 根据表信息统计，估算出大约要扫描的行数。</p></li></ul><p><strong>优化：</strong></p><p><strong>&amp;手动优化</strong></p><p><strong>① 修改SQL:</strong> 在业务允许的情况下使得语句走对应的索引；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> evaluator_no, course_id <span class="keyword">from</span> evaluator;</span><br></pre></td></tr></table></figure><p><strong>② 添加索引：</strong>对于无法通过修改 SQL 满足业务的情况下，而此 SQL 又进行多次的查询，对其进行添加索引处理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">index</span> idx_name(&lt;<span class="keyword">col</span>&gt;);</span><br></pre></td></tr></table></figure><p><strong>&amp;查询优化器优化</strong></p><p>不使用密集索引，稀疏索引为二级索引不存放对应的全行信息；</p><p>查询的不需要整体信息；</p><p>记住抽样统计，同时查询是否排序、是否使用临时表进行索引的选择；</p><p><img src="http://img.janhen.com/202103072224511551841656997.png" alt="http://img.janhen.com/202103072224511551841656997.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>( <span class="keyword">id</span> ) <span class="keyword">FROM</span> person_info_large;</span><br><span class="line"><span class="comment">-- 测试使用什么索引所以更好</span></span><br><span class="line">&lt;sql&gt; FORCE INDEX(&lt;index&gt;);</span><br></pre></td></tr></table></figure><h3 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h3><blockquote><p>mysql 自带的工具，较为简单</p></blockquote><p>按序显示执行的 SQL 情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --verbose slow-query.log</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 总次数</li><li><code>-t</code>: 时间</li><li><code>l</code>: 锁的时间</li><li><code>r</code>: 总数据行</li><li><code>at</code>,<code>al</code>,<code>ar</code>: 平均数 按照时间排序的前10个查询</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 10 slow-query.log</span><br><span class="line">mysqldumpslow -s c -t 10 slow-query.log</span><br><span class="line">mysqldumpslow -s l -t 10 slow-query.log</span><br><span class="line">mysqldumpslow -s r -t 10 slow-query.log</span><br></pre></td></tr></table></figure><h3 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="pt-query-digest"></a>pt-query-digest</h3><blockquote><p>percona toolkit 中提供</p></blockquote><p>功能增强的慢查询分析工具，具体使用见 <a href="https://www.notion.so/Percona-Toolkit-e9ea157626d24777babdaacf2babd301">这里</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest \\</span><br><span class="line">  --<span class="built_in">type</span> slowlog \\</span><br><span class="line">  slow-query.log</span><br></pre></td></tr></table></figure><p>根据 STDIN 进行分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --query <span class="string">&quot;select * from mysql.user&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置项：</p><ul><li><code>slow_query_log=1</code>： 开启慢查询；</li><li><code>long_query_time=0.2</code>： 设置慢查询的时间阈值，设置为 200 毫秒；</li><li><code>slow_query_log_file</code>：设置慢查询日志文件目录；</li><li><code>log_queries_not_using_indexes=1</code>： 显示没有使用索引的 SQL 语句；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%quer%&#x27;</span>;        <span class="comment">--慢查询日志开启、位置、时长，查询缓冲、</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_queries%&#x27;</span>;   <span class="comment">-- 当前慢查询数-- </span></span><br><span class="line"><span class="keyword">Set</span> slow querySET <span class="keyword">GLOBAL</span> slow_query_log=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time=<span class="number">1</span>;        <span class="comment">-- 当前会话有效, 修改 my.ini 永久</span></span><br></pre></td></tr></table></figure><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>逻辑日志。为归档日志；记录了完整的逻辑记录；属于 Server 层的日志，可作用于任何存储引擎；</p></blockquote><p>包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，主要用于备份恢复、回滚操作等。</p><p>binlog 有三种格式：Statement, Row 和 Mixed.</p><ul><li>Statement: 基于 SQL 语句的复制（statement-based replication, SBR） ： 对一些函数如 now() 在不同主机上执行结果不同会出现不一致的问题</li><li>Row: 基于行的复制（row-based replication, RBR): 不会出现某些特定情况下的存储过程，或 function，以及 trigger 的调用和触发无法被正确复制的问题。<ul><li>基于 Row 的，数据恢复更快</li></ul></li><li>Mixed: 混合模式复制（mixed-based replication, MBR），混合 statement 和物理文件，减少 binlog 的大小</li></ul><p>生成新的 binlog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">logs</span></span><br></pre></td></tr></table></figure><p><strong>生成新的 binlog 的时机</strong></p><ul><li>MySQL 服务器停止或重启时执行；</li><li>使用 <code>flush logs</code> 命令；</li><li>当 binlog 文件大小超过 <code>max_binlog_size</code> 系统变量配置的上限时；</li></ul><p><strong>查看相关</strong> 查看 binblog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">logs</span>;;</span><br></pre></td></tr></table></figure><p>查看 binlog 文件的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">&quot;mysql-bin.000005&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h3><p>为了保证 binlog 和 redo log 的一致性使用，如果不使⽤“两阶段提交”，那么数据库的状态就有可能和⽤它的⽇志恢复出来的库的状态不⼀致；</p><p>分为 prepare 和 commit 两个阶段；</p><p>对于 prepare 状态的事务，参考 binlog，若该事务在 binlog 中存在，则将其提交，不存在，则将其回滚，这样保证主从之间的一致性。</p><p>不只是误操作后需要⽤这个过程来恢复数据。当需要扩容的时候，也就是多搭建⼀些备库来增加系统的读能⼒的时候，常⻅的做法是⽤全量备份加上应⽤ binlog 来实现的，这个“不⼀致”就会导致你的线上出现主从数据库不⼀致的情况。 简单说，redo log 和 binlog 都可以⽤于表示事务的提交状态，⽽两阶段提交就是让这两个状态保持逻辑上的⼀致。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>数据库恢复</strong></p><p>借助 binlog 配合一次全量备份实现指定时间点数据的恢复</p><p>一些参数</p><ul><li><code>--start-position</code>: 开始位置</li><li><code>--stop-porition</code>: 结束位置</li><li><code>--start-datetime</code>: 开始时间</li><li><code>--stop-datetime</code>: 结束时间</li><li><code>--database</code>: 指定数据库</li><li><code>-no-defaults</code>: 处理默认字符集问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysql-bin.000001 | mysql -uroot -proot</span><br><span class="line">mysqlbinlog mysql-bin.000002 | mysql -uroot -proot</span><br><span class="line">.....</span><br><span class="line">mysqlbinlog \\</span><br><span class="line">  --start-datetime=<span class="string">&quot;2005-12-25 11:25:56&quot;</span>\\</span><br><span class="line">  binlog.000003</span><br></pre></td></tr></table></figure><p>多个 binlog 的恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.[0-9]* | mysql -u root -p</span><br></pre></td></tr></table></figure><p>更改一内容再恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.000001 &gt; tmpfile</span><br><span class="line">... edit tmpfile ...</span><br><span class="line">mysql -u root -p &lt; tmpfile</span><br><span class="line">mysqlbinlog --no-defaults \\</span><br><span class="line">  -v --base64-output=DECODE-ROWS \\</span><br><span class="line">  mysql-bin.000009</span><br></pre></td></tr></table></figure><p>指定位置进行重新执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --start-position=27284 \\</span><br><span class="line">   binlog.001002 binlog.001003 binlog.001004</span><br><span class="line">  | mysql --host=host_name -u root -p</span><br></pre></td></tr></table></figure><h3 id="与-redo-log-比较"><a href="#与-redo-log-比较" class="headerlink" title="与 redo log 比较"></a>与 redo log 比较</h3><p>binlog 与 redo log 日志的区别：</p><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使⽤。</li><li>redo log 是物理⽇志，记录的是“在某个数据⻚上做了什么修改”；binlog是逻辑⽇志，记录的是这个语句的原始逻辑，⽐如“给ID=2这⼀⾏的c字段加1”。</li><li>redo log 空间固定会⽤完；binlog是可以追加写⼊的。“追加写”是指binlog ⽂件写到⼀定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。</li></ul><p><a href="https://www.notion.so/63e588ddc94a453397dcb0e8d736c689">日志比较</a></p><h3 id="实时监控-binlog"><a href="#实时监控-binlog" class="headerlink" title="实时监控 binlog"></a><strong>实时监控 binlog</strong></h3><p>适用场景：</p><ul><li>通过实时对 binlog 进行监控分析，将 binlog 中的数据按照业务进行分开，控制拆分的逻辑</li><li>通过实时监控 binlog，根据事件的类型，删除或更改基于数据库的倒排索引，以此来保证索引的有效性</li><li>通过实时对 binlog 进行读取，将数据写入到 Kafka 中，交由流式处理工具(如Flink) 做实时的分析</li></ul><p>实现方案： 通过第三方库操作(阿里的 canal)，因为 mysql 支持通过远程方式下载指定 mysql-server 上的 binlog，从而能够实现借助端口对 MySQL 进行运行情况监控和更改信息的获取。</p><h3 id="binlog-清理"><a href="#binlog-清理" class="headerlink" title="binlog 清理"></a>binlog 清理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除指定日期以前的日志索引中 binlog 日志文件</span></span><br><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">before</span> <span class="string">&#x27;2016-09-01 17:20:00&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除指定日志文件的日志索引中binlog日志文件</span></span><br><span class="line"><span class="comment">-- 将 bin.000022 之前的binlog清掉</span></span><br><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">to</span> <span class="string">&#x27;mysql-bin.000022&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清除master.info文件、relay-log.info文件，以及所有的relay log文件,并重新启用一个新的relaylog文件</span></span><br><span class="line"><span class="comment">-- 使用reset slave之前必须使用stop slave 命令将复制进程停止</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将删除日志索引文件中记录的所有binlog文件，创建一个新的日志文件，起始值从000001开始。不要轻易使用该命令，这个命令通常仅仅用于第一次用于搭建主从关系的时的主库</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>:</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p><strong>配置项</strong></p><ul><li>log-bin：指定 binlog 的文件名</li><li>innodb_flush_log_at_trx_commit：</li><li>expire_logs_days：保留 binlog 的天数</li><li>max_binlog_size： binlog 单个文件的大小，默认 1G，一个事务所产生的所有事件必须记录在同一个 binlog 文件中，所以即使 binlog 文件的大小达到 max_binlog_size 参数指定的大小，也会写入到 binlog 后才能切换。</li></ul><p><strong>配置更改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">log-bin                         &#x3D; mysql-bin</span><br><span class="line">binlog_format                   &#x3D; ROW         # can be mixed, decrease</span><br><span class="line">binlog_row_image                &#x3D; minimal</span><br><span class="line">expire_logs_days                &#x3D; 30</span><br><span class="line">sync_binlog                     &#x3D; 1           # default 0    affect performance， safe to guarantee replication</span><br><span class="line">innodb_flush_log_at_trx_commit  &#x3D; 2           # defalut 1, per second trx flush  2&#x2F;0 &#x3D; perf, 1 &#x3D; ACID</span><br></pre></td></tr></table></figure><p><strong>会话级别更改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># modify</span><br><span class="line">SET SQL_LOG_BIN&#x3D;0  </span><br><span class="line">SET GLOBAL expire_log_days&#x3D;3;</span><br></pre></td></tr></table></figure><h2 id="redolog-物理"><a href="#redolog-物理" class="headerlink" title="redolog (物理)"></a>redolog (物理)</h2><blockquote><p>为物理日志。重做日志。InnoDB 在处理更新语句的时候，只做了写⽇志这⼀个磁盘操作。这个⽇志叫作 redo log，在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</p></blockquote><p>作用：</p><ul><li>确保事务的持久性</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性</li></ul><p>只有 InnoDB 有，其他引擎没有；</p><p>redolog 确保事务的持久性。</p><p>由来： 如果每⼀次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很⾼。</p><p>包含两部分，一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p><h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>**WAL(Write-Ahead Logging)**： 预写日志。先写⽇志，再写磁盘。利⽤ WAL 技术，数据库将随机写转换成了顺序写，⼤⼤提升了数据库的性能。 但是，由此也带来了内存脏⻚的问题。脏⻚会被后台线程⾃动 flush，也会由于数据⻚淘汰⽽触发 flush，⽽刷脏⻚的过程由于会占⽤资源，可能会让更新和查询语句的响应时间⻓⼀些。</p><h3 id="刷新脏页"><a href="#刷新脏页" class="headerlink" title="刷新脏页"></a>刷新脏页</h3><p><strong>Q： MySQL “抖” 了一下的原因</strong></p><p>A：当内存数据⻚跟磁盘数据⻚内容不⼀致的时候，我们称这个内存⻚为“脏⻚”。</p><p>内存数据写⼊到磁盘后，内存和磁盘上的数据⻚的内容就⼀致了，称为“⼲净⻚”。</p><p>平时执⾏很快的更新操作，其实就是在写内存和⽇志，⽽ MySQL 偶尔“抖”⼀下的那个瞬间，可能就是在刷脏⻚(flush)。</p><p>几种可能的原因：</p><p>① InnoDB 的 redo log 写满了。这时候系统会停⽌所有更新操作，把 checkpoint 往前推进，redo log留出 空间可以继续写。</p><p>② 系统内存不⾜。当需要新的内存⻚，⽽内存不够⽤的时候，就要淘汰⼀些数据⻚，空出内存给别的数据⻚使⽤。如果淘汰的是“脏⻚”，就要先将脏⻚写到磁盘。</p><p>③ MySQL 认为系统“空闲”的时候，即使是“⽣意好”的时候，也要⻅缝插针地找时间，只要有机会就刷⼀点“脏⻚”</p><p>④ MySQL正常关闭的情况，这时候，MySQL 会把内存的脏⻚都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p><p>对性能的影响：</p><p>对于 ① 出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。</p><p>对于 ② 这种情况其实是常态。<strong>InnoDB ⽤缓冲池(buffer pool)管理内存，缓冲池中的内存⻚有三种状态</strong>：第⼀种是，还没有使⽤的； 第⼆种是，使⽤了并且是⼲净⻚； 第三种是，使⽤了并且是脏⻚。</p><p>InnoDB 刷脏页的控制策略</p><p>要正确地告诉 InnoDB 所在主机的 IO 能⼒，这样 InnoDB 才能知道需要全⼒刷脏⻚的时候，可以刷多快。</p><p>可能的问题： MySQL 的写⼊速度很慢，TPS 很低，但是数据库主机的 IO 压⼒并不⼤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_io_capacity           # 会告诉 InnoDB 磁盘能⼒,建议设置成磁盘的 IOPS</span><br></pre></td></tr></table></figure><p>如果你来设计策略控制刷脏⻚的速度，会参考哪些因素呢？</p><p>InnoDB 的刷盘速度就是要参考这两个因素：⼀个是脏⻚⽐例，⼀个是 redo log 写盘速度。</p><p>参数 innodb_max_dirty_pages_pct 是脏⻚⽐例上限，默认值是 75%。InnoDB 会根据当前的脏⻚⽐例(假设为M)，算出⼀个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样：  <strong>根据上述算得的F1(M)和F2(N)两个值，取其中较⼤的值记为R，之后引擎就可以按照innodb_io_capacity定义的能⼒乘以R%来控制刷脏⻚的速度。</strong></p><p><img src="http://img.janhen.com/202103072225031553991442351.png" alt="http://img.janhen.com/202103072225031553991442351.png"></p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><ul><li><pre><code>innodb_flush_log_at_trx_commit<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：指定何时将事务日志刷到磁盘，默认为1。</span><br><span class="line"></span><br><span class="line">  - 0： 事务提交时不会将 log buffer 中日志写入到 os buffer，而是每秒写入 os buffer 并调用fsync()</span><br><span class="line">    - 系统崩溃，会丢失 1 秒钟的数据。</span><br><span class="line">  - 1：每次 commit 都会把 redo log 从 redo log buffer 写入到 system，并 fsync 刷新到磁盘文件中。</span><br><span class="line">    - 即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能较差。</span><br><span class="line">  - 2： 每次事务提交时 MySQL 会把日志从 redo log buffer 写入到 system，但只写入到 file system buffer，由系统内部来 fsync 到磁盘文件。</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_buffer_size&#96;: redo 日志的缓冲区，默认为 8M，延迟事务日志写入磁盘</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_files_in_group&#96;： redo 日志的个数，默认为2，命名为 ib_logfile&lt;N&gt;</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_file_size&#96;： 事务日志的大小</span><br><span class="line"></span><br><span class="line">- &#96;innodb_log_group_home_dir&#96;： 事务日志组路径，当前目录表示数据目录</span><br><span class="line"></span><br><span class="line">## undo 日志</span><br><span class="line"></span><br><span class="line">&gt; 属于 InnoDB 存储引擎特有的日志，做事务的处理。</span><br><span class="line"></span><br><span class="line">**提供回滚和多个行版本控制(MVCC)**。</span><br><span class="line"></span><br><span class="line">为逻辑日志，默认存放在共享表空间中，如果配置了 innodb_file_per_table，将会存放在 &lt;table-name&gt;.ibd 中。</span><br><span class="line"></span><br><span class="line">相关的一些问题</span><br><span class="line"></span><br><span class="line">### 配置</span><br><span class="line"></span><br><span class="line">- innodb_max_undo_log_size:</span><br><span class="line">- innodb_undo_tablespaces:</span><br><span class="line">- innodb_undo_log_truncate:</span><br><span class="line">- innodb_purge_rseg_truncate_frequency:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sql</span><br><span class="line">show global variables like &#39;%undo%&#39;;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h3><blockquote><p>中继日志，是复制过程中产生的日志。</p></blockquote><p>relay log 是从库服务器 I/O 线程将主库服务器的二进制日志读取过来记录到从库服务器本地文件，然后从库的 SQL 线程会读取 relay-log 日志的内容并应用到从库服务器上。</p><p><strong>配置</strong></p><ul><li>relay_log：</li><li>max_relay_log_size：</li><li>relay_log_recovery</li></ul><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a><strong>错误日志</strong></h3><p>查找 MySQL 错误日志，查看 MySQL 普通的日志</p><p>通过在 mysql.cnf 中配置错误日志的地址</p><ul><li>log_error：on|文件路径 是否启用错误日志,on表示开启,文件路径表示指定自定义日志路径</li><li>log_warnings： 1|0 是否记录warnings信息到错误日志中</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;log_error&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><ul><li>general_log： on / off</li><li>general_log_file：文件保存地址</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;%genera%&quot;</span>;</span><br><span class="line"><span class="comment">-- 开启</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html">MySQL :: MySQL 8.0 Reference Manual :: 4.6.8 mysqlbinlog - Utility for Processing Binary Log Files</a></p><p>工具 mysqlbinlog 官方文档</p><p>[<a href="https://zhuanlan.zhihu.com/p/58011817">玩转MySQL之八]MySQL日志分类及简介</a></p><p><a href="https://cloud.tencent.com/developer/article/1497297">【MySQL （六） | 详细分析MySQL事务日志redo log】</a></p><p>【MySQL （六） | 详细分析MySQL事务日志redo log】</p><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲_MySQL_数据库-极客时间</a></p><p>极客时间-MySQL实战45讲</p><p><a href="https://www.cnblogs.com/wy123/p/8365234.html">MySQL中的重做日志（redo log），回滚日志（undo log），以及二进制日志（binlog）的简单总结 - MSSQL123 - 博客园</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;慢查询日志&quot;&gt;&lt;a href=&quot;#慢查询日志&quot; class=&quot;headerlink&quot; title=&quot;慢查询日志&quot;&gt;&lt;/a&gt;慢查询日志&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 的动态参数，可以随关随停&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-结构索引与SQL优化</title>
    <link href="http://example.com/2021/04/09/MySQL-%E7%BB%93%E6%9E%84%E7%B4%A2%E5%BC%95%E4%B8%8ESQL%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/04/09/MySQL-%E7%BB%93%E6%9E%84%E7%B4%A2%E5%BC%95%E4%B8%8ESQL%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-08T17:06:14.000Z</published>
    <updated>2021-04-09T09:04:19.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-结构优化"><a href="#MySQL-结构优化" class="headerlink" title="MySQL 结构优化"></a>MySQL 结构优化</h2><p><strong>结构设计</strong></p><ul><li>过分的反范式化为表建立太多的列</li><li>过分的范式化造成太多的表关联</li><li>在 OLTP 环境中使用不恰当的分区表</li><li>使用外键保证数据的完整性</li></ul><p><strong>性能优化顺序</strong></p><ul><li>数据库结构设计和SQL语句</li><li>数据库存储引擎的选择和参数配置</li><li>系统选择及优化</li><li>硬件升级</li></ul><p>知道常用的数据类型，数据库的范式和反范式，各种字段类型占据的大小，更改字段类型是否锁表，如何处理分布式系统下字段的更改。</p><p>1、数据库优化的目的</p><ul><li>减少<strong>数据冗余</strong>，节约数据存储空间</li><li>提高查询效率</li><li>避免数据维护中的异常：<ul><li>插入异常： 必须有什么才能有什么</li><li>更新异常： 如果更改表中的某个实体的单独属性时，需要<strong>对多行进行更新</strong></li><li>删除异常： 如果删除表中的某一实体则会导致其他实体的消失</li></ul></li></ul><p>2、数据库结构设计步骤 (1) 需求分析： (2) 逻辑设计: 确定数据实体之间的逻辑关系，逻辑存储结构 (3) 物理设计： 跟据所使用的数据库特点进行表结构设计 (4) 维护优化： 维护好索引</p><h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><p>1、数据库设计范式 (1) 1NF (2) 2NF： 要求一个表中只具有一个业务主键，符合第二范式的表中<strong>不存在非主键列，只对部分主键的依赖关系</strong> 复合主键 进行表的拆分实现 (3) 3NF： 指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上<strong>消除了非主属性对主键的传递依赖</strong></p><p><strong>范式化优点：</strong> <strong>可以尽量的减少数据冗余；</strong> 范式化的更新操作比反范式化更快； 范式化的表通常比反范式化更小 <strong>范式化缺点：</strong> 对于查询需要对多个表进行关联；更难进行索引优化</p><p>2、反范式化设计 是为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，而<strong>允许存在少量的数据冗余</strong>，反范式化就是<strong>使用空间来换取时间</strong></p><p><strong>反范式化优点：</strong> 可以减少表的关联，可以更好的进行索引优化</p><p><strong>反范式化缺点：</strong> 存在数据冗余及数据维护异常，对数据的修改需要更多的成本</p><h3 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a>字段选择</h3><p>当一个列可以选择多种数据类型时， 考虑顺序： 数字类型 ⇒ 日期 / 二进制类型 ⇒ 字符类型</p><p>对于相同级别的数据类型，应该优先选择占用空间小的数据类型 == 加载的页(16k)</p><p><strong>整数类型</strong></p><p>共五种类型</p><p>int(2) 不影响占用的字节，使用 tinyint 进行存储</p><p>@Q: int(x) x 是什么?</p><p>@A: 11 代表的并不是长度，而是字符的显示宽度,navicat 进行格式化显示了</p><p><strong>实数类型</strong> 共三种类型 FLOAT 4B DOUBLE 8B DECIMAL: 每 4 个字节存 9 个数字，小数点占一个字节</p><p>@Q: DECIMAL（18，9）占用几个字节</p><p>@A: 需要 9 个字节来存储, 表示 9 位整数，9 位小数, 小数点占一个字节， 2*4+1=9</p><p><strong>字符串类型</strong> 常用的两种，还支持 blog, text 类型</p><p>1、varchar 类型 varchar 特点</p><ul><li>varchar 用于存储变长字符串，只占用必要的存储空间列的</li><li>最大长度小于 <strong>255</strong> 则只占用一个额外字节用于记录字符串长度</li><li>列的最大长度大于 255 则要占用两个额外字节用于记录字符串长度</li><li>更改 varchar 小于 255 不会锁表，大于 255 会<strong>锁表</strong></li><li>使用时需要确定 varchar 的长度</li></ul><p>varchar 使用场景：</p><ul><li>字符串列的<strong>最大长度比平均长度</strong>大很多</li><li>字符串列很少被更新</li><li>使用了多字节字符集存储字符串</li></ul><p>2、char 类型</p><p>char 类型的特点：</p><ul><li>CHAR 类型是定长的</li><li>字符串存储在 CHAR 类型的列中会删除末尾的空格</li><li>CHAR 类型的 <strong>最大宽度为255</strong></li></ul><p>char 的适用场景：</p><ul><li>CHAR 类型适合存储所长度近似的值，如 MD5 加密的密码</li><li>CHAR 类型适合存储短字符串，限制 255</li><li>CHAR 类型适合存储经常更新的字符串列，不会锁表，内存占用固定</li></ul><p><strong>日期类型</strong></p><p><a href="https://www.notion.so/ddc0213d5fd7443fb373a18f9a18f7f1">Untitled</a></p><p>共支持四种类型,分别占8B,4B,3B,xB (1) DATATIME 类型 以格式存储日期时间 DATATIME 类型<strong>与时区无关</strong>，占用<strong>8个字节</strong>的存储空间时间范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YYYY-MM-DD HH:MM:SS[.fraction]</span><br><span class="line">datetime=YYYY-MM-DD HH:MM:SS</span><br><span class="line">datetime(6)=YYYY-MM-DD HH:MM:SS.fraction</span><br><span class="line"><span class="comment">-- 支持的范围</span></span><br><span class="line">1000-1-1 0:0:0~9999-12-31 23:59:59</span><br></pre></td></tr></table></figure><p>(2) TIMESTAMP 类型 由格林尼治时间 1970 年 1 月 1 日到当前时间的秒数以]的格式显示 占用 <strong>4个字节</strong> 默认使用 <strong>第一个 timestamp 进行自动更新</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YYYY-MM-DD HH:MM:SS.[L.fraction</span><br></pre></td></tr></table></figure><p>比较 timestamp 类型<strong>显示依赖于所指定的时区</strong> 在行的数据修改时可以<strong>自动修改 timestamp 列的值</strong></p><p>时区比较 存储微秒值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">time_zone</span>=<span class="string">&#x27;+10:00&#x27;</span>;</span><br><span class="line"><span class="comment"># timestamp 与时区相关</span></span><br><span class="line">ALERT TABLE t MODIFY d1 DATETIME(6), MODIFY d2 TIMESTAMP(6);</span><br></pre></td></tr></table></figure><p>(3) Date 类型 为实现 Date，原来使用 int, datetime 存储 占用的字节数比使用字符串、datetime、int 存储要少，使用 date 类型只需要<strong>3个字节</strong> Date 类型还可以利用日期时间函数进行日期之间的计算</p><p>(4) time 类型 time 类型用于存储时间数据</p><p>日期类型使用注意事项</p><ul><li>不要使用字符串类型来存储日期时间数据日期时间类型</li><li>通常比字符串占用的存储空间小日期时间类型在进行查找过滤时可以利用日期来进行对比</li><li>日期时间类型还有着丰富的<strong>处理函数</strong>，可以方便的对时期类型进行日期计算</li><li>使用 Int 存储日期时间不如使用 Timestamp 类型</li></ul><p>使用 int 时间戳保存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">&#x27;2020-01-11 09:53:32&#x27;</span>);  </span><br><span class="line"><span class="keyword">select</span> FROM_UNIXTIME(<span class="number">1578707612</span>);</span><br></pre></td></tr></table></figure><h3 id="Recommand"><a href="#Recommand" class="headerlink" title="Recommand"></a>Recommand</h3><p>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p><p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p><p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p><p><strong>尽量做到冷热数据分离,减小表的宽度</strong> MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）； 更有效的利用缓存，避免读入无用的冷数据； 经常一起使用的列放到一个表中（避免更多的关联操作）。</p><p><strong>尽量控制单表数据量的大小, 建议控制在 500 万以内。</strong></p><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。</p><p>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀。</p><p><strong>日期相关</strong> timestamp 与时区相关，占用 4个字节 datetime, 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前会话时区</span></span><br><span class="line"><span class="keyword">SELECT</span> @@session.time_zone;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前会话时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;Europe/Helsinki&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span> = <span class="string">&quot;+00:00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库全局时区设置</span></span><br><span class="line"><span class="keyword">SELECT</span> @@global.time_zone;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;+8:00&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">time_zone</span> = <span class="string">&#x27;Europe/Helsinki&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>索引是在存储引擎层实现的, 部分存储引擎不支持索引</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h2><p>B+树索引：</p><p>1、特点： B-tree 索引能够加快数据的查询速度 <strong>B-tree 索引更适合进行范围查找，叶子节点指向的是主键</strong></p><p>2、适合使用 B+ 树的索引</p><p>全值匹配 <strong>最左前缀</strong> 匹配<strong>列前缀</strong> 范围匹配 精确匹配 只访问索引，覆盖索引</p><p>3、B+ 树使用限制</p><p>查询优化器判定。。。</p><p>非最左列开始查找，。。。</p><p>不能跳过左边的 Not in 和 &lt;&gt; 无法使用 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引</p><h2 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h2><p>Memory 支持，且为默认的 InnoDB 存储引擎支持<strong>自适应 Hash 索引</strong></p><p>1、特点</p><p>精确匹配使用，只用在等值查询</p><p>所有列，<strong>每一行计算一个Hash码</strong></p><p>2、限制</p><p>需要<strong>两次查找</strong>，先找到行，之后读取值</p><p>无法进行排序 只支持等值查找，不支持索引查找、范围查找</p><p>Hash 冲突可能导致性能问题，不适合选择性差的列</p><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p>1、使用索引的好处：</p><ul><li>减少存储引擎需要扫描的数量，16K 每页，内存中存放更多的索引</li><li>帮助排序，避免使用临时表，索引存储结构为 B 树，按序存储</li><li>将随机 I/O 转化成顺序的 I/O，扫描的行变少</li></ul><p>2、索引带来的损耗：</p><ul><li>写操作成本，需要对应的索引控制</li><li>多个索引会增加查询优化器的选择时间</li></ul><p>3、建立索引的策略：</p><p>安装演示数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://downloads.mysql.com/docs/sakila-db.tar.gztar-zxf&gt; sakila-db.tar.gz</span><br><span class="line">mysql -uroot -p &lt; sakila-schema.sql</span><br><span class="line">mysql-uroot -p &lt; sakila-data.sql</span><br></pre></td></tr></table></figure><h2 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h2><p>1、索引列上不能使用函数或表达式</p><p>2、索引长度有限，针对字符串</p><p>3、通过索引的<strong>选择性</strong>确定前缀索引的长度(字符串)</p><p>4、选取索引列的顺序：</p><ul><li>经常使用的放到列的左边(选择性差的例外)</li><li>选择性高的优先</li><li>宽度小的列优先，I/O 小</li></ul><p>5、覆盖索引直接获取：</p><p>优点： 可以优化缓存，减少磁盘I/O 减少随机I/O，将磁盘I/O改为内存的顺序 I/O 可避免对 Innodb 主键索引的二次查询， 可以避免 MyISAM 表进行系统调用</p><p>缺点： memory 不支持覆盖索引 查询中太多的列。。。 使用双 % 号的 LIKE 查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- using index，覆盖索引使用</span></span><br><span class="line">expalin <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> &lt;mytab&gt; <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>\\G</span><br><span class="line"><span class="comment">-- using where, 非覆盖所以不</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> &lt;mytab&gt; <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>\\G</span><br><span class="line"><span class="comment">-- idx_name name 建立索引查询， using where,using index, 自动增加上主键索引的信息</span></span><br><span class="line"><span class="comment">-- 高版本优化 using indexexplain </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> &lt;mytab&gt; <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;joe&#x27;</span></span><br><span class="line"><span class="comment">-- 1. 表达式剔除:  out_date 为索引列, 查找近一个月内添加的商品</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> productwhere <span class="keyword">to_days</span>(out_date)-<span class="keyword">to_days</span>(<span class="keyword">current_date</span>)&lt;=<span class="number">30</span></span><br><span class="line"><span class="comment">-- 优化后的</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> productwhere out_date &lt;= <span class="keyword">date_add</span>(<span class="keyword">current_date</span>，<span class="built_in">interval</span> <span class="number">30</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="comment">-- 2. 前缀索引长度确定</span></span><br></pre></td></tr></table></figure><h2 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h3><p><strong>优化排序：</strong> 通过排序操作 按照索引顺序扫描数据</p><p>优化的限制：</p><ul><li>索引的列顺序和 Order By 子句的顺序完全一致</li><li>索引中所有列的方向（升序，降序）和 Order by 子句完全一致</li><li>Order by 中的字段全部在关联表中的第一张表中</li></ul><h3 id="仿-Hash-索引优化"><a href="#仿-Hash-索引优化" class="headerlink" title="仿 Hash 索引优化"></a>仿 Hash 索引优化</h3><p><strong>模拟 Hash 索引优化</strong></p><p>(1) 使用流程 新增 title_hash 列 设置值 创建索引</p><p>使用限制</p><p>只能处理键值的全值匹配查找 所使用的Hash函数决定着索引键的大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;mytab&gt; <span class="keyword">add</span> title_hash <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line"><span class="keyword">update</span> &lt;mytab&gt; <span class="keyword">set</span> title_name=<span class="keyword">md5</span>(title);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_title_hash <span class="keyword">on</span> &lt;mhytab&gt;(title_hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- using condition index,...</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> &lt;mytab&gt;</span><br><span class="line"><span class="keyword">where</span> title_hash=<span class="keyword">md5</span>(<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    <span class="keyword">and</span> title=<span class="string">&#x27;sdfsfds&#x27;</span>\\G</span><br></pre></td></tr></table></figure><h3 id="优化锁"><a href="#优化锁" class="headerlink" title="优化锁"></a>优化锁</h3><p><strong>索引优化锁</strong></p><p>避免对表的全部锁定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;ddd&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- session 2, 未使用锁住，使用索引不会锁住</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;eee&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="索引自身问题"><a href="#索引自身问题" class="headerlink" title="索引自身问题"></a>索引自身问题</h3><p><strong>4、删除重复和冗余的索引</strong></p><p>单列的索引类型不同的重复 联合索引的最左匹配原则，形成冗余</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- todo 工具下载</span></span><br><span class="line">pt-duplicate-key-checker h=127.9.0.1</span><br></pre></td></tr></table></figure><p><strong>5、查找未使用的索引</strong></p><p>定期清理 通过 performance_schema,information 数据库查询出信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有数据中对应的表，对应的索引名称，索引使用的次数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(object_schema, <span class="string">&quot;.&quot;</span>, object_name) <span class="keyword">AS</span> TABLE_NAME, </span><br><span class="line">index_name                              <span class="keyword">AS</span> INDEX_NAME,</span><br><span class="line">b.<span class="string">`TABLE_ROWS`</span>                          <span class="keyword">AS</span> TABLE_ROWS</span><br><span class="line"><span class="keyword">FROM</span> performance_schema.table_io_waits_summary_by_index_usage a </span><br><span class="line"><span class="keyword">JOIN</span> information_schema.tables b </span><br><span class="line"><span class="keyword">ON</span> a.<span class="string">`OBJECT_SCHEMA`</span>=b.<span class="string">`TABLE_SCHEMA`</span> <span class="keyword">AND</span> a.<span class="string">`OBJECT_NAME`</span>=b.<span class="string">`TABLE_NAME`</span></span><br><span class="line"><span class="keyword">WHERE</span> index_name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> count_star = <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> object_schema, object_name;</span><br></pre></td></tr></table></figure><p><strong>6、更新索引统计信息及减少索引碎片</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> &lt;mytab&gt;</span><br><span class="line"><span class="comment">-- 可能锁表</span></span><br><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> &lt;mytab&gt;</span><br></pre></td></tr></table></figure><h1 id="SQL-查询优化"><a href="#SQL-查询优化" class="headerlink" title="SQL 查询优化"></a>SQL 查询优化</h1><p>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</p><p>获取慢查询的方式：</p><ul><li>最终用户、测试人员获取存在性能问题的 SQL, 被动，常用</li><li>慢查询日志获取，服务层的日志</li><li>实时获取存在性能问题的 SQL</li></ul><h3 id="SQL-语句执行流程"><a href="#SQL-语句执行流程" class="headerlink" title="SQL 语句执行流程"></a>SQL 语句执行流程</h3><p><strong>查询语句的执行流程</strong></p><p><img src="http://img.janhen.com/202102261610131553910277229.png" alt="http://img.janhen.com/202102261610131553910277229.png"></p><p>优化器的作用：选择索引是优化器的⼯作。⽽优化器选择索引的⽬的，是找到⼀个最优的执⾏⽅案，并⽤最⼩的代价去执⾏语句。在数据库⾥⾯，扫描⾏数是影响执⾏代价的因素之⼀。扫描的⾏数 越少，意味着 访问磁盘数据的次数 越少，消耗的CPU资源越少。 当然，扫描⾏数并不是唯⼀的判断标准，优化器还会结合 是否使⽤临时表、是否排序 等因素进⾏综合判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限校验---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</span><br></pre></td></tr></table></figure><p>Q: MySQL是怎样得到索引的基数的呢？</p><p>MySQL采样统计的⽅法，采样统计的时候，InnoDB 默认会选择 N 个数据⻚，统计这些⻚⾯上的不同值，得到⼀个平均值，然后乘以这个索引的⻚⾯数，就得到了这个索引的基数。 ⽽数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据⾏数超过 1/M 的时候，会⾃动触发重新做⼀次索引统计。</p><p><strong>执行更新语句的流程</strong></p><p><img src="http://img.janhen.com/202103072200261553911424532.png" alt="http://img.janhen.com/202103072200261553911424532.png"></p><p>MySQL可以恢复到半个⽉内任意⼀秒的状态；</p><p>涉及到两个日志文件 redo log 和 binlog；</p><p>两阶段提交，以及 Insert Buffer 插入缓冲</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> T <span class="keyword">SET</span> c=c+<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="number">2</span>;</span><br><span class="line">分析器<span class="comment">----&gt;权限校验----&gt;执行器---&gt;引擎---redo log prepare---&gt;binlog---&gt;redo log commit</span></span><br></pre></td></tr></table></figure><p><strong>SQL 解析及执行计划</strong></p><p>1、SQL 执行过程</p><p>(1) 客户端发送 SQL 请求给服务器</p><p>(2) 服务器检查是否可以在查询缓存中命中该 SQL</p><p>(3) 服务器端进行 SQL 解析，预处理，再由优化器生成对应的执行计划</p><p>(4) 跟据执行计划，调用存储引擎 API 来查询数据将结果返回给客户端</p><p><strong>查询缓存</strong></p><p>查询缓存：</p><p>缓存加锁 对于一个<strong>读写频繁的系统</strong>使用查询缓存很可能会降低查询处理的效率 所以在这种情况下建议大家不要使用查询缓存</p><p>查询缓存的配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type</span><br><span class="line"># 所使用的的大小</span><br><span class="line">query_</span><br><span class="line"># 缓存结果的最大值</span><br><span class="line"># 锁住，是否返回缓存中的数据</span><br><span class="line"># 查询缓存内存块的最小</span><br></pre></td></tr></table></figure><p><strong>查询优化器</strong></p><p><strong>1、可能导致失败的情况：</strong></p><p>(1) 统计信息不准确，如 Innodb 中的总条数为抽样的数据</p><p>(2) 执行计划中的成本估算不等同于实际的执行计划的成本，无法知道顺序读取与随机读取，是否在内存中</p><p>(3) MySQL 基于其成本模型进行。。。</p><p>(4) 从不考虑其他<strong>并发</strong>的查询</p><p>(5) 不会考虑<strong>不受控制的成本</strong>，如存储过程、用户自定义的函数</p><p><strong>2、查询优化器的作用</strong></p><p>(1) 优化 count(), min() 和 max(), B+树的。。。</p><p>(2) 将表达式转换成一个常数，MyISAM中的 Selelct Count(*)</p><ol><li>子查询优化： 转化成关联查询</li><li>提前终止查询：</li><li>对 in() 条件进行优化，对 in 中的数据进行排序，之后通过二分查找方式确定是否满足条件 ### 查询耗时 <strong>1、通过 profile</strong> 高版本已经不建议使用，建议使用方式二</li><li>开启与执行</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> &lt;mytab&gt;</span><br><span class="line"><span class="comment">-- 查看整体信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="comment">-- 查看执行的每个阶段信息</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> &lt;query_id&gt;;</span><br><span class="line"><span class="comment">-- 查看 CPU 的信息</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> &lt;query_id&gt;;</span><br></pre></td></tr></table></figure><ol><li>结果数据</li></ol><p><strong>2、通过 performance_schema(建议)</strong></p><p>在 MySQL5.6 之后建议使用 对数据全局有效 (1) 开启与使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 处理的先决条件，开启 performance_schema</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`setup_instruments`</span></span><br><span class="line"><span class="keyword">SET</span> enabled=<span class="string">&#x27;YES&#x27;</span>,TIMED=<span class="string">&#x27;YES&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">&#x27;stage%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> setup_consumers</span><br><span class="line"><span class="keyword">SET</span> enabled=<span class="string">&#x27;YES&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">&#x27;events%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询使用</span></span><br><span class="line"><span class="keyword">SELECT</span> a.THREAD_ID, SQL_TEXT,c.EVENT_NAME,(c.TIMER_END-c.TIMER_START)/<span class="number">1000000000</span> <span class="keyword">AS</span> <span class="string">&#x27;DURATION(ms)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> events_statements_history_long a </span><br><span class="line"><span class="keyword">JOIN</span> threads b </span><br><span class="line"><span class="keyword">ON</span> a.THREAD_ID=b.THREAD_IDJOIN events_stages_history_long c </span><br><span class="line"><span class="keyword">ON</span> c.THREAD_ID=b.THREAD_ID </span><br><span class="line">  <span class="keyword">AND</span> c.EVENT_ID <span class="keyword">BETWEEN</span> a.EVENT_ID <span class="keyword">AND</span> a.END_EVENT_ID </span><br><span class="line"><span class="keyword">WHERE</span> b.PROCESSLIST_ID=CONNECTION_ID() </span><br><span class="line">  <span class="keyword">AND</span> a.EVENT_NAME=<span class="string">&#x27;statement/sql/select&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.THREAD_ID,c.EVENT_ID</span><br></pre></td></tr></table></figure><ol><li>信息返回 返回各个阶段的耗时 执行的线程ID</li></ol><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>写日志为顺序存储</p><p><strong>慢查询配置</strong></p><ul><li>动态参数,可配合脚本定时开关 slow_query_log</li><li>存放位置。将日志存储与数据存储分开 slow_query_log_file</li><li>查询阈值，秒为单位，建议 0.001 秒 long_query_time</li><li>记录未使用索引的 SQL log_queries_not_using_indexes</li></ul><ol><li>实际使用的SQL</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%quer%&#x27;</span><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file=<span class="string">&#x27;/var/log/mysql/mysql-slow.log&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time=<span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_queries_not_using_indexes=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure><p><strong>2、慢查询记录的内容</strong></p><p>用户</p><p>查询的时间，精确到毫秒</p><p>查询占用的锁时间</p><p>返回的数据行数</p><p>扫描的行数 执行SQL的时间，</p><p>UNIX时间戳</p><p>对应的SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2019-05-30T10:10:02.771744Z</span><br><span class="line"># User@Host: root[root] @ localhost [127.0.0.1]  Id:    44</span><br><span class="line"># Query_time: 0.001503  Lock_time: 0.001002 Rows_sent: 12  Rows_examined: 12</span><br><span class="line">SET timestamp&#x3D;1559211002;</span><br><span class="line">SELECT * FROM exam;</span><br></pre></td></tr></table></figure><p><strong>mysqldumpslow 获取</strong></p><p>通过自带的工具进行筛选输出 (1) <code>-s order（c，t，l，r，at，al，ar）</code>: 指定按哪种排序方式输出结果</p><ul><li>c：总次数</li><li>t：总时间</li><li>1：锁的时间</li><li>r：总数据行</li><li>at，al，ar:t，l，r平均数</li><li><code>t top</code>: 指定取前几条作为结束输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s &lt;r&gt; -t &lt;10&gt; &lt;slow-mysql.log&gt;</span><br></pre></td></tr></table></figure><p><strong>pt-query-digest 获取</strong></p><p>建议使用 还支持对 bin log等日志的进行查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --explain h=127.0.0.1,u=root,p=password mysql-slow.log</span><br></pre></td></tr></table></figure><p>返回结果： 整体的统计信息，total,max,min</p><p>执行计划</p><p><strong>实时获取</strong></p><p>通过 information_schema.proceeslist 表进行查看获取实时数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询出服务器中执行超过 60s 的SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, </span><br><span class="line">    <span class="keyword">user</span>,</span><br><span class="line">    DB, </span><br><span class="line">    command, </span><br><span class="line">     <span class="built_in">time</span>, </span><br><span class="line">    state, </span><br><span class="line">    info</span><br><span class="line"><span class="keyword">FROM</span> information_schema.PROCESSLIST</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">TIME</span> &gt;= <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h2 id="特定-SQL-的优化"><a href="#特定-SQL-的优化" class="headerlink" title="特定 SQL 的优化"></a>特定 SQL 的优化</h2><p><strong>大表的数据修改分批处理：</strong></p><p>1000 万行记录的表中删除/更新 100 万行记录 一次只删除/更新 5000 行记录，暂停几秒</p><p>方式一： 通过存储过程实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$USE `&lt;myDB&gt;`$$DROP PROCEDURE IF EXISTS `p_delete rows`$$CREATE DEFINER=`root`@`127.0.0.1` PROCEDURE `p_delete_rows`()BEGIN   DECLARE v_rows INT；  SET v_rows=1;  WHILE v_roWs &gt;0  DO     -- 根据业务修改下面的语句    DELETE FROM sbtest1 WHERE id&gt;=90000 AND id &lt;=19000 LIMIT 5000;    SELECT ROW_COUNT() INTO v_rows;    -- sleep    SELECT SLEEP(5);  END WHILE;END$$DELIMITER；</span><br></pre></td></tr></table></figure><p>方式二： 程序中执行类似存储过程的逻辑每次获取少量数据，之后执行处理逻辑</p><p><strong>修改大表的表结构</strong></p><p>对表的列的字段类型进行修改，改变字段的宽度会锁表，无法解决主从数据库延迟问题</p><p>方式一： 主从切换</p><p>方式二： 手动创建新表进行迁移，减少主从延迟，操作复杂</p><p>可使用 pt-online-schema-change 工具 完成方式二的复杂逻辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change</span><br><span class="line">--alter=<span class="string">&quot;MODIFY C VARCHAR(150) NOT NULL DEFAULT &#x27;&#x27;&quot;</span></span><br><span class="line">--user=root \\</span><br><span class="line">--password=PassWord D=&lt;mydb&gt;,t=&lt;mytab&gt;</span><br><span class="line">--charset=utf8 \\</span><br><span class="line">--execute</span><br></pre></td></tr></table></figure><p><strong>优化 not in 和 &lt;&gt; 查询(#)</strong></p><p>通过外连接 + NULL 进行处理，即为<strong>将子查询转化成表的连接查询</strong>； 常用的调整手段；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, first_name, last_name, email</span><br><span class="line"><span class="keyword">FROM</span> customerWHERE customer_id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">  (<span class="keyword">SELECT</span> customer_id <span class="keyword">FROM</span> payment)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 Left join 配合 null 的优化</span></span><br><span class="line"><span class="keyword">SELECT</span> a.customer_id,a.first_name,a.last_name,a.email</span><br><span class="line"><span class="keyword">FROM</span> customer a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> payment b </span><br><span class="line"><span class="keyword">ON</span> a.customer_id =b.customer_idWHERE b.customer_id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p><strong>使用汇总表优化查询(#)</strong></p><p>汇总表概述<strong>：</strong> 汇总表就是提前以要统计的数据进行汇总并记录到表中以备后续的查询使用。 汇总表的数据可以使非实时的。</p><p>实际使用汇总表的策略</p><ul><li>使用汇总表记录从该天开始之前的所有统计信息，之后每天进行更新维护；</li><li>查询时借助统计信息表的数据和当天的数据汇总返回；</li><li>汇总表被当做一种缓存，当天数据类似增量信息；</li><li>从原来的表中提取出汇总信息，不会变更原来的表结构，侵入性低，是一种常用的扩展手段。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始的统计SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> product_ <span class="keyword">comment</span> <span class="keyword">WHERE</span> productid=<span class="number">999</span></span><br><span class="line"><span class="comment">-- 创建汇总表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_ comment_cnt(product <span class="keyword">id</span> <span class="built_in">INT</span>,cnt <span class="built_in">INT</span>);</span><br><span class="line"><span class="comment">-- 修改后的 SQL, UNION ALL 确定</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(cnt) <span class="keyword">FROM</span>(</span><br><span class="line"><span class="keyword">SELECT</span> cnt </span><br><span class="line"><span class="keyword">FROM</span> product_comment_cnt </span><br><span class="line"><span class="keyword">WHERE</span> product_id=<span class="number">999</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> product_comment </span><br><span class="line"><span class="keyword">WHERE</span> product_id=<span class="number">999</span><span class="keyword">AND</span> timestr&gt;<span class="built_in">DATE</span>(<span class="keyword">NOW</span>())) a</span><br></pre></td></tr></table></figure><p><strong>只要一行数据时使用 LIMIT 1</strong></p><p>已经知道结果只会有一条结果，加上 LIMIT 1 可以增加性能。MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><p><strong>用 Not Exists 代替 Not In</strong></p><p>Not Exists 允许用户使用相关子查询已排除一个表中能够与另一个表成功连接的所有记录。Not Exists 用到了连接，能够发挥已经建好的索引的作用，而 Not In 不能使用索引。Not In 是最慢的方式，要同每条记录比较，在数据量比较大的查询中不建议使用这种方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> a.mobileid</span><br><span class="line"><span class="keyword">from</span> Log_user a</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> b.mobileid                  </span><br><span class="line"><span class="keyword">from</span> magazineitem b                  </span><br><span class="line"><span class="keyword">where</span> b.mobileid=a.mobileid);</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲_MySQL_数据库-极客时间</a></p><p>MySQL实战45讲</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-结构优化&quot;&gt;&lt;a href=&quot;#MySQL-结构优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL 结构优化&quot;&gt;&lt;/a&gt;MySQL 结构优化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;结构设计&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过分的</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql-索引</title>
    <link href="http://example.com/2021/04/09/MySql-%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/04/09/MySql-%E7%B4%A2%E5%BC%95/</id>
    <published>2021-04-08T17:06:02.000Z</published>
    <updated>2021-04-08T17:09:24.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>删除长期未使用的索引</strong> 不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</p><p><strong>避免定义重复的索引</strong></p><p>借助 pt-duplicate-key-checker 查找，并生成删除重复索引的 SQL 语句</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-duplicate-key-checker -h &lt;host&gt; -u&lt;user&gt; -p&lt;passwd&gt;</span><br></pre></td></tr></table></figure><p><strong>索引好处：</strong></p><ul><li>提高访问速度；</li><li>优化查询；</li><li>将随机 IO 改为顺序 IO</li></ul><p><strong>索引缺点：</strong></p><ul><li>占用空间，索引建立的越多越占用空间；</li><li>更改频繁时，每次修改都需要重建索引；</li></ul><p><strong>索引的适用场景</strong></p><ul><li>选择性较高的场景；</li></ul><p><strong>不适合索引的场景：</strong></p><ul><li>数据规模小的情况；</li><li>选择性较低的列；</li></ul><p><strong>索引的底层实现</strong></p><ol><li>Hash 索引</li></ol><p>适⽤于只有等值查询的场景，⽐如 Memcached 及其他⼀些 NoSQL 引擎。</p><p>(2)) 有序数组</p><p>有序数组在等值查询和范围查询场景中的性能就都⾮常优秀, 有序数组索引只适⽤于静态存储引擎。</p><ol><li>二叉树</li><li>B+ 树</li></ol><h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a><strong>索引的创建</strong></h3><ul><li>index_type： 可选择 BTREE，HASH</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line">    [index_type]</span><br><span class="line">    <span class="keyword">ON</span> tbl_name (key_part,...)</span><br><span class="line">    [index_option]</span><br><span class="line">    [algorithm_option | lock_option] ...</span><br></pre></td></tr></table></figure><p>Functional Key Parts: MySQL8.0+ 支持，不只是列/列特定的前缀，支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  col1 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> (col1, col2(<span class="number">10</span>))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (col1 <span class="built_in">INT</span>, col2 <span class="built_in">INT</span>, <span class="keyword">INDEX</span> func_index ((<span class="keyword">ABS</span>(col1))));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx1 <span class="keyword">ON</span> t1 ((col1 + col2));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx2 <span class="keyword">ON</span> t1 ((col1 + col2), (col1 - col2), col1);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> ((col1 * <span class="number">40</span>) <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p>JSON 格式的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">JSON</span>,</span><br><span class="line">  <span class="keyword">INDEX</span> idx ((<span class="keyword">CAST</span>(<span class="keyword">data</span>-&gt;&gt;<span class="string">&quot;$.name&quot;</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>(<span class="number">30</span>)) <span class="keyword">COLLATE</span> utf8mb4_bin))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;james&quot;, &quot;salary&quot;: 9000 &#125;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;James&quot;, &quot;salary&quot;: 10000 &#125;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;Mary&quot;, &quot;salary&quot;: 12000 &#125;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;&#123; &quot;name&quot;: &quot;Peter&quot;, &quot;salary&quot;: 8000 &#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">data</span>-&gt;&gt;<span class="string">&#x27;$.name&#x27;</span> = <span class="string">&#x27;James&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="索引查看"><a href="#索引查看" class="headerlink" title="索引查看"></a><strong>索引查看</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看指定表的索引</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> &lt;<span class="keyword">table</span>-<span class="keyword">name</span>&gt; <span class="keyword">FROM</span> &lt;<span class="keyword">database</span>-<span class="keyword">name</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定数据库的索引统计</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    TABLE_NAME</span><br><span class="line">    ,INDEX_NAME</span><br><span class="line">    ,SEQ_IN_INDEX</span><br><span class="line">    ,COLUMN_NAME</span><br><span class="line">    ,CARDINALITY</span><br><span class="line">    ,INDEX_TYPE    </span><br><span class="line"><span class="keyword">FROM</span> INFORMATION_SCHEMA.STATISTICS </span><br><span class="line"><span class="keyword">WHERE</span> table_schema = <span class="string">&#x27;DatabaseName&#x27;</span></span><br></pre></td></tr></table></figure><p>重复索引的查看，见 <a href="https://www.notion.so/Percona-Toolkit-e9ea157626d24777babdaacf2babd301">pt-duplicate-key-checker</a></p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>索引分类</p><ul><li>B-Tree: b 树索引</li><li>R-tree: 空间索引</li><li>hash: 散列索引</li><li>full-text: 全文索引</li></ul><h3 id="主键索引-聚集"><a href="#主键索引-聚集" class="headerlink" title="主键索引(聚集)"></a><strong>主键索引(聚集)</strong></h3><p>作为表的主键，可以有包含多个列，该索引是唯一索引，在 InnoDB 存储引擎中为聚集索引。</p><p>主键⻓度越⼩，普通索引的叶⼦节点就越⼩，普通索引占⽤的空间也就越⼩。 所以，从性能和存储空间⽅⾯考量，⾃增主键往往是更合理的选择。</p><p>聚集索引和非聚集索引的区别</p><ul><li>聚集索引在叶子节点存储的是表中的数据</li><li>非聚集索引在叶子节点存储的是主键和索引列</li></ul><p>Q：基于主键索引和普通索引的查询有什么区别？</p><p>A：如果语句是 select * from table where id=8888，只需要搜索 ID 这棵 B+ 树； 如果语句是 select * from table where key=5，需要先搜索 key 索引树，得到 id 的值为 500，再到 ID 索引树搜索⼀次。这个过程称为 回表。 也就是说，基于⾮主键索引的查询需要多扫描⼀棵索引树。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a><strong>普通索引</strong></h3><p>相较于唯一索引，使用了 change buffer</p><p>与唯一索引的相比，这两类索引在查询能⼒上是没差别，主要考虑的是对更新性能的影响。</p><p>Change buffer 使用场景：</p><p>如果所有的更新后⾯，都⻢上伴随着对这个记录的查询，那么应该关闭 change buffer。⽽在其他情况下，change buffer 都能提升更新性能。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a><strong>唯一索引</strong></h3><p>唯⼀索引⽤不上 change buffer 的优化机制，因此如果业务可以接受，从性能⻆度出发建议优先考虑⾮唯⼀索引。</p><p>对于唯⼀索引来说，由于索引定义了唯⼀性，查找到第⼀个满⾜条件的记录后，就会停⽌继续检索。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h3><p>包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引。</p><p>对于频繁的查询优先考虑使用覆盖索引。</p><p>无需二次扫表，直接扫描索引中的 B+ 树即可获取全部数据；</p><p>覆盖索引的好处：</p><ul><li>避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li><li>可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><p>创建的注意事项：</p><ul><li>选取字符串的前多少位作为索引项()；<ul><li>阿里巴巴开发手册规定 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</li></ul></li><li>注意 最左前缀 的使用，以及基于此衍生出来的联合索引组合；</li><li>能够形成覆盖索引，从而避免二次扫表问题。</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><strong>联合索引定义的顺序</strong>： 建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><p><strong>索引列的选取：</strong> 常见索引列建议</p><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a><strong>字符串索引</strong></h2><p>直接创建完整索引，这样可能⽐较占⽤空间；</p><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使⽤覆盖索引</p><p>倒序存储，再创建前缀索引，⽤于绕过字符串本身前缀的区分度不够的问题；</p><p>创建 引，查询性能稳定，有额外的存储和计算消耗，跟第三种⽅式⼀样，都不⽀持 。hash字段索范围扫描</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><strong>前缀索引限定索引的长度</strong></p><p>不指定前缀长度，默认包含整个字符串；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SUser <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx1(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- only prefix</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SUser <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节，所以占⽤的空间会更⼩，这就是使⽤前缀索引的优势。 但可能会增加额外的记录扫描次数。</p><p>如果使⽤的是 index1(即 email 整个字符串的索引结构)，执⾏顺序是这样的：</p><ol><li>从 index1 索引树找到满⾜索引值是 <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的这条记录，取得ID2的值；</li><li>到主键上查到主键值是ID2的⾏，判断email的值是正确的，将这⾏记录加⼊结果集；</li><li>取index1索引树上刚刚查到的位置的下⼀条记录，发现已经不满⾜email=’<a href="mailto:&#122;&#104;&#97;&#110;&#103;&#x73;&#115;&#x78;&#x79;&#x7a;&#64;&#x78;&#120;&#120;&#46;&#x63;&#111;&#x6d;">&#122;&#104;&#97;&#110;&#103;&#x73;&#115;&#x78;&#x79;&#x7a;&#64;&#x78;&#120;&#120;&#46;&#x63;&#111;&#x6d;</a>’的条件了，循环结束。 这个过程中，只需要回主键索引取⼀次数据，所以系统认为只扫描了⼀⾏。</li></ol><p>如果使⽤的是index2(即email(6)索引结构)，执⾏顺序是这样的：</p><p>1 . 从index2索引树找到满⾜索引值是’zhangs’的记录，找到的第⼀个是ID1；</p><p>2 . 到主键上查到主键值是ID1的⾏，判断出email的值不是’<a href="mailto:&#122;&#x68;&#97;&#x6e;&#103;&#115;&#x73;&#120;&#121;&#x7a;&#x40;&#x78;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;">&#122;&#x68;&#97;&#x6e;&#103;&#115;&#x73;&#120;&#121;&#x7a;&#x40;&#x78;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;</a>’，这⾏记录丢弃；</p><p>3 . 取index2上刚刚查到的位置的下⼀条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整⾏然后判断，这次值对了，将这⾏记录加⼊结果集；</p><p>4 . 重复上⼀步，直到在idxe2上取到的值不是’zhangs’时，循环结束。 在这个过程中，要回主键索引取4次数据，也就是扫描了4⾏。 通过这个对⽐，你很容易就可以发现，使⽤前缀索引后，可能会导致查询语句读数据的次数变多。</p><p><strong>使⽤前缀索引，定义好⻓度，就可以做到既节省空间，⼜不⽤额外增加太多的查询成本。</strong></p><p>根据区分度来选择前缀的长度；</p><p>建立索引列的区分度越⾼越好。区分度越⾼，意味着重复的键值越少。可以通过统计索引上有多少个不同的值来判断要使⽤多⻓的前缀。 可以使⽤下⾯这个语句，算出这个列上有多少个不同的值，95% 作为参考；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">4</span>)) <span class="keyword">AS</span> L4,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">5</span>)) <span class="keyword">AS</span> L5,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">6</span>)) <span class="keyword">AS</span> L6,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">7</span>)) <span class="keyword">AS</span> L7,</span><br><span class="line"><span class="keyword">FROM</span> SUser;</span><br></pre></td></tr></table></figure><p><strong>前缀索引对覆盖索引的影响</strong></p><p>如果使⽤ index1(即email整个字符串的索引结构)的话，可以利⽤覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查⼀次。⽽如果使⽤index2(即email(6)索引结构)的话，就不得不回到ID索引再去判断email字段的值。 即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查⼀下，因为系统并不确定前缀索引的定义是否截断了完整信息。 也就是说，使⽤前缀索引就⽤不上覆盖索引对查询性能的优化了，这也是你在选择是否使⽤前缀索引时需要考虑的⼀个因素。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SUser <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_email(eamil(<span class="number">20</span>));</span><br><span class="line"><span class="comment">--SELECT id, name, email FROM SUserWHERE email=&#x27;zhangssxyz@xxx.com&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="区分度不足的处理"><a href="#区分度不足的处理" class="headerlink" title="区分度不足的处理"></a>区分度不足的处理</h3><p><strong>前缀的区分度不够时如何处理</strong></p><p>比如国家的身份证号、电话号码</p><p>方式一： 倒序存储</p><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了⾜够的区分度，先使⽤ count(distinct) ⽅法做验证</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 函数 revere 操作，插入处理</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T(col.., id_card) <span class="keyword">VALUES</span> (xxx, revere(<span class="string">&#x27;input_id_card_string&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询的处理</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;field_list&gt; <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id_card=<span class="keyword">reverse</span>(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p>方式二： 使用 Hash 字段</p><p>在表上再创建⼀个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><p>之后每次插⼊新记录的时候，都同时⽤ crc32() 函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。</p><p>这样，索引的⻓度变成了 4 个字节，⽐原来⼩了很多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 新增加一列，4byte 存放索引 hash 后的值</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ADD</span> id_card_crc <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>, <span class="keyword">ADD</span> <span class="keyword">index</span>(id_card_crc);</span><br><span class="line"><span class="comment">-- 插入逻辑， crc32 hash 值以及原始的值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T(co1..., id_card_crc, id_card) <span class="keyword">VALUES</span> (xxx, <span class="keyword">crc32</span>(<span class="string">&#x27;input_card_string&#x27;</span>), <span class="string">&#x27;input_id_card_string&#x27;</span>);                        </span><br><span class="line"></span><br><span class="line"><span class="comment">-- INDEX can duplication</span></span><br><span class="line"><span class="comment">-- 对应的查询语句，先对 hash 进行查询后对原始字符串查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *  <span class="keyword">FROM</span> t  <span class="keyword">WHERE</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">&#x27;input_id_card_string&#x27;</span>) <span class="keyword">AND</span> id_card=<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>倒序存储和 hash 存储两种方式的比较：</strong></p><p>相同点是，都不⽀持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的⽅式排序的，已经没有办法利⽤索引⽅式查出身份证号码在[ID_X, ID_Y]的所有市⺠了。同样地，hash 字段的⽅式也只能⽀持等值查询。</p><p>它们的区别，主要体现在以下三个⽅⾯：</p><p>① 从占⽤的额外空间来看，倒序存储⽅式在主键索引上，不会消耗额外的存储空间，⽽ hash 字段⽅法需要增加⼀个字段。当然，倒序存储⽅式使⽤ 4 个字节的前缀⻓度应该是不够的，如果再⻓⼀点，这个消耗跟额外这个 hash 字段也差不多抵消了。</p><p>② 在CPU消耗⽅⾯，倒序⽅式每次写和读的时候，都需要额外调⽤⼀次 reverse 函数，⽽ hash 字段的⽅式需要额外调⽤⼀次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更⼩些。</p><p>③ 从查询效率上看，使⽤ has h字段⽅式的查询性能相对更稳定⼀些。因为 crc32 算出来的值虽然有冲突的概率，但是概率⾮常⼩，可以认为每次查询的平均扫描⾏数接近 1。⽽倒序存储⽅式毕竟还是⽤的前缀索引的⽅式，也就是说还是会增加扫描⾏数。</p><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>修改 SQL 语句尽量使其走索引；</p><p>对于查询优化器选择索引错误，通过修改 SQL 引导其进行选择正确的索引，如通过 <code>FORCE INDEX()</code> 来指定使用特定的索引进行查询；</p><p>为查询较多的字段添加索引，可考虑使用覆盖索引；</p><p>要避免编写使索引失效的 SQL 语句；</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><blockquote><p>全值匹配我最爱，最左前缀要遵守； 带头大哥不能死，中间兄弟不能断； 原因： B+ 树的索引结构导致</p></blockquote><p>原因： 复合索引(组合)，先对最左边的字段进行排序，在第一个字段排序的基础上再对后面的字段排序。</p><p>类似 orderby ，只保证第一个字段有序，通常对于第二个字段用不到索引；</p><p>B+ 树这种索引结构，可以利⽤索引的“最左前缀”，来定位记录</p><p>只要满⾜最左前缀，就可以利⽤索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>如何控制索引的顺序：</p><p>如果通过调整顺序，可以少维护⼀个索引，那么这个顺序往往就是需要优先考虑采⽤的。 考虑的原则就是空间了。⽐如上⾯这个市⺠表的情况，name 字段是⽐ age 字段⼤的，那我就建议你创建⼀个(name,age)的联合索引和⼀个(age)的单字段索引</p><p><img src="http://img.janhen.com/202103072220221551846748988.png" alt="http://img.janhen.com/202103072220221551846748988.png"></p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><blockquote><p>索引列上少计算，范围之后全失效； LIKE 百分写最右，覆盖索引不写星； 不等空值还有 OR, 索引失效要少用； VAR 引号不可丢，SQL 高级也不难！</p></blockquote><p><strong>条件字段函数及计算操作</strong></p><p>如果对字段做了函数计算，就⽤不上索引了。</p><p>SQL语句条件⽤的是 where t_modified=‘2018-7-1’ 的话，B+ 树提供的这个快速定位能⼒，来源于同⼀层兄弟节点的有序性。</p><p>显示调用函数，在 t_modified 字段加了 month() 函数操作，导致了全索引扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Query，对索引列使用了函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tradelog <span class="keyword">WHERE</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>按照业务进行修改，使其走索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改索引列中使用的函数成为索引列的范围比较查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tragelog</span><br><span class="line"><span class="keyword">WHERE</span> (t_modified &gt;= <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">AND</span> t_modified&lt;<span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">OR</span> </span><br><span class="line">  (t_modified &gt;= <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">AND</span> t_modified&lt;<span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">OR</span>  </span><br><span class="line">  (t_modified &gt;= <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">AND</span> t_modified&lt;<span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>隐式类型转换</strong></p><p>字符串隐式的转换成数字进行操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid=<span class="number">110717</span>;</span><br><span class="line"><span class="keyword">select</span> “<span class="number">10</span>” &gt; <span class="number">9</span>;     </span><br><span class="line"><span class="comment">-- 1, String ⇒ number</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tradelog <span class="keyword">WHERE</span> <span class="keyword">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="built_in">int</span>)=<span class="number">110717</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改后的 SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tradelog <span class="keyword">WHERE</span> tradeid=<span class="string">&#x27;110717&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>隐式字符编码转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`trade_detail`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`trade_step`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&quot;操作步骤&quot;</span>,</span><br><span class="line"><span class="string">`step_info`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&quot;步骤信息&quot;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- log 和 业务的详情表字符集不同</span></span><br><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l, trade_detail d </span><br><span class="line"><span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>; <span class="comment">/* 语句 Q1 */</span></span><br></pre></td></tr></table></figure><p>两个字符集不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid=$L2.tradeid.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等同于，对列粒度的字符进行编码转换比较</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></table></figure><p>字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做⽐较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做⽐较。</p><p>方案一： 把 trade_detail 表上的 tradeid字 段的字符集也改成 utf8mb4，这样就没有字符集转换的问题了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> trade_detail <span class="keyword">MODIFY</span> tradeid <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">character</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>方案二： 在无法修改字符集的情况下，或者表中的数据很多的情况下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l , trade_detail d </span><br><span class="line"><span class="keyword">where</span> d.tradeid=<span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8) <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>简单的计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> trade_detail <span class="keyword">WHERE</span> trade_step=trade_step + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="索引下堆-5-6"><a href="#索引下堆-5-6" class="headerlink" title="索引下堆(5.6)"></a>索引下堆(5.6)</h3><p>// TODO</p><h2 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h2><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><p><strong>@Q: 为什么要重建索引?</strong></p><p>索引可能因为删除，或者⻚分裂等原因，导致数据⻚有空洞，重建索引的过程会创建⼀个新的索引，把数据按顺序插⼊，这样⻚⾯的利⽤率最⾼，让索引更紧凑、更省空间。</p><p>通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理。</p><p>重建索引 k 的做法是合理的，可以达到省空间的⽬的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执⾏这两个语句的话，第⼀个语句就⽩做了。这两个语句，可以⽤这个语句代替 ： <code>alter table Tengine=InnoDB</code>。</p><p>记录⽇志⽤的表, 会定期删除过早之前的数据。 最后这个表实际内容的⼤⼩ 10G, 索引却有 30G.. 是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放. 只能是重新建表才能重建索引.</p><h3 id="索引选择异常"><a href="#索引选择异常" class="headerlink" title="索引选择异常"></a>索引选择异常</h3><p>@Q: 索引选择异常和处理？ 处理查询优化器选择错误索引？</p><p>查询优化器选择的不是最优的索引情况的处理。</p><p>⼤多数时候优化器都能找到正确的索引，但偶尔还是会碰到我们上⾯举例的这两种情况：原本可以执⾏得很快的SQL语句，执⾏速度却⽐你预期的慢很多</p><p><strong>方式一：采⽤ <code>force index()</code> 强⾏选择⼀个索引</strong></p><p>MySQL 会根据词法解析的结果分析出可能可以使⽤的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少⾏。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执⾏代价。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- FORCE INDEX 的使用</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(a) </span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span> </span><br><span class="line">  <span class="keyword">AND</span> b <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> bLIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但其实使⽤ force index 最主要的问题还是变更的及时性。因为选错索引的情况还是⽐较少出现的，所以开发的时候通常不会先写上 force index。⽽是等到线上出现问题的时候，你才会再去修改 SQL 语句、加上 force index。但是修改之后还要测试和发布，对于⽣产系统来说，这个过程不够敏捷。</p><p><strong>方法二：可以考虑修改语句，引导 MySQL 使⽤期望的索引</strong></p><p>⽐如，在这个例⼦⾥，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p>现在 order by b,a 这种写法，要求按照b,a排序，就意味着使⽤这两个索引都需要排序。因此，扫描⾏数成了影响决策的主要条件，于是此时优化器选了只需要扫描 1000 ⾏的索引 a。 当然，这种修改并不是通⽤的优化⼿段，只是刚好在这个语句⾥⾯有 limit 1，因此如果有满⾜条件的记录， order by b limit 1 和 order by b,a limit 1 都会返回 b 是最⼩的那⼀⾏，逻辑上⼀致，才可以这么做。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(a)</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span></span><br><span class="line">  <span class="keyword">AND</span> b <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> b,a     </span><br><span class="line"><span class="comment">-- modifyLIMIT 1;</span></span><br><span class="line"><span class="comment">-- 另一种引导我们⽤limit 100让优化器意识到，使⽤b索引代价是很⾼的。其实是我们根据数据特征诱导了⼀下优化器，也不具备通⽤性。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> (a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span>) </span><br><span class="line">     <span class="keyword">AND</span> (B <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span>) </span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> b </span><br><span class="line">   <span class="keyword">LIMIT</span> <span class="number">100</span>) <span class="keyword">alias</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>方法三：在有些场景下，可以新建⼀个更合适的索引，来提供给优化器做选择，或删掉误⽤的索引</strong></p><p>这种情况其实⽐较少，尤其是经过 DBA 索引优化过的库，再碰到这个 bug，找到⼀个更合适的索引⼀般⽐较难。 如果我说还有⼀个⽅法是删掉索引 b，你可能会觉得好笑。但实际上我碰到过两次这样的例⼦，最终是 DBA 跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p><h2 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B 树与索引"></a>B 树与索引</h2><p>B+ 树特点：</p><ul><li>关键字分布在整棵树的所有节点。</li><li>任何一个关键字，<strong>出现且只出现在一个节点中</strong>。</li><li>搜索有可能在<strong>非叶子节点</strong>结束。</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ul><p>B+树基本特点</p><ul><li>非叶子节点的子树指针与关键字个数相同。</li><li>非叶子节点的子树指针 P[i]，指向关键字属于 <strong>[k[i],K[i+1])</strong> 的子树（<strong>注意：区间是前闭后开</strong>)。</li><li><strong>为所有叶子节点增加一个链指针</strong>。</li><li><strong>所有关键字都在叶子节点出现</strong>。</li></ul><p><strong>B 树与 B+ 树的区别</strong></p><p>关键字与孩子节点的个数不同；</p><p>B+树的磁盘读写代价更低：B+ 树的内部没有指向关键字具体信息的指针，其内部节点相对 B 树更小，把所有关键字存放在同一块盘中，B+ 树比 B 树所能容纳的关键字数量也越多；</p><p>查询的稳定性： B+ 树所欲数据都存放在叶子节点，B+ 树无论如何都要扫表到叶子节点才能返回数据， 所有关键字查询的路径长度相同；B 树可以中途跳出，查询效率不够稳定；</p><p>B+ 树适合用于遍历和范围的选择，底层叶子节点是双向链表，只需要去遍历叶子节点就可以实现整棵树的遍历；</p><p><strong>MongoDB 的索引为什么选择 B 树，而 MySQL 的索引是 B+树</strong></p><p>MongoDB 非传统的 RDBMS，是以 Json 格式作为存储的 NoSQL，目的就是高性能、高可用、易扩展。摆脱了关系模型，所以范围查询和遍历查询的需求就没那么强烈。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/indexes.html">MySQL :: MySQL 8.0 Reference Manual :: C Indexes</a></p><p>MySQL 的索引官方文档</p><p><a href="https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c">深入理解MySQL索引-InfoQ</a></p><p>深入理解 MySQL 索引</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;删除长期未使用的索引&lt;/strong&gt; 不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务</title>
    <link href="http://example.com/2021/04/09/MySQL-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/04/09/MySQL-%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-04-08T17:04:36.000Z</published>
    <updated>2021-04-08T17:08:37.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>事务是数据库区别于文件系统的一个关键特性。</p></blockquote><p><strong>事务的分类</strong></p><p>① 扁平事务，使用最频繁；</p><p>② 带有保存点的扁平事务；</p><p>③ 链事务，下一个事务将能够看到上一个事务的结果，只能恢复到最近一个的保存点；</p><p>④ 嵌套事务； 任何子事务都在顶层事务提交后才真正的提交；是一棵树状的结构；</p><p>只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源；</p><p>⑤ 分布式事务；需要根据数据所在位置访问网络中的不同节点；保存点在事务内部是递增的；可以借助消息队列实现分布式事务。</p><p>相关的 SQL</p><p>// TODO 关联 Spring 提供的几个事务级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;ios%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ul><li>原子性(Atomic)： 所有操作要么全部成功，要么全部失败</li><li>一致性(Consistency)： 数据从一个一致性状态转移到另一个一致性状态，一致指的是 数据的完整性约束 没有被破坏</li><li>**隔离性(Isolation)**： 并发执行事务时，一个事务应该不影响其他事务的执行</li><li>持久性(Duration)： 对 DB 的修改永久，恢复性能</li></ul><h3 id="事务的实现方式"><a href="#事务的实现方式" class="headerlink" title="事务的实现方式"></a><strong>事务的实现方式</strong></h3><p>实现的原理： InnoDB 中的 undo.log, redo.log 日志文件。</p><p>隔离性： 通过锁实现</p><p>原子性和持久性： 通过 redo 物理日志实现；</p><p>事务的一致性： 通过 undo log 实现；</p><p><strong>redo log</strong></p><p>blog</p><p>可通过参数调节控制 redo log 刷新到磁盘的策略；</p><p>log block： redo log 的块大小与磁盘扇区大小一样都是 512 字节，保证了原子性，不需要 doublewrite 技术；</p><p>为物理日志，恢复速度比逻辑日志快，是幂等的。</p><p>重做日志记录了事务的行为，可以很好地通过其对也进行 “重做” 操作</p><p><strong>undo log</strong></p><ul><li>帮助事务回滚；</li><li>帮助实现 MVCC；</li><li>是实现快照读的一种必要机制；</li><li>存放在数据库内部的一个特殊字段上；</li></ul><p>功能一： 是逻辑日志，将数据库逻辑地恢复到原来的样子；</p><p>功能二： 当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p><p>分类：</p><p>insert undo log</p><p>update undo log</p><p>delete 操作不直接删除记录，而只是将记录标记为已删除。</p><p>undo 信息的数据字典：</p><p>真正删除这行记录的操作其实被 “延时” 了，最终在 purage 操作中完成。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h3><p>第一阶段： 所有参与全局事务的节点都开始准备(PREPARE) ，告诉事务管理器准备好了；</p><p>第二阶段： 事务管理器告诉资源管理器质性 ROLLBACK 还是 COMMIT，分布式事务需要多一次的 PREPARE 操作，待收到所有节点的统一信息后，再进行 COMMIT 或是 ROLLBACK 操作。</p><p>事务相关的 SQL 语句</p><p>一条语句失败并抛出异常，不会导致先前已经执行的语句自动会馆，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- salfpoint </span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一个保存点</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到某个保存点, 此时事务没有结束</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置级别</span></span><br><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> | <span class="keyword">SESSION</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>分布式事务</strong></p><p>XA</p><p>XA 事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。</p><p>Serializable 级别</p><p><strong>长事务</strong></p><p>执行时间较长的事务；</p><p>进行的优化：在 1 亿用户表中，这个操作被封装在一个事务中完成，通过为其转化成小批量的事务进行处理；</p><p>好处一： 便于回滚每完成一个小事务，将完成的结果存放在 batchcontext 表中，表示已完成批量事务的最大账号 ID。 在发生错误时，可以从这个已完成的最大事务 ID 继续进行批量的小事务，重新开启事务的代价就显得比较低。</p><p>好处二： 用户可以知道现在大概已经执行到了哪个阶段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> account_total=account_total+<span class="number">1</span> + (<span class="number">1</span>+interest_rate);</span><br></pre></td></tr></table></figure><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p><strong>更新丢失：</strong></p><p><img src="http://img.janhen.com/202103072221061551851135178.png" alt="http://img.janhen.com/202103072221061551851135178.png"></p><p><strong>Dirty Read</strong></p><p>读取到未提交的数据，之后回滚 ，修改成 <code>READ UNCOMMITTED</code> 隔离级别可以处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><a href="https://www.notion.so/3b7ce6854e864bed8418e6d73783f404">.</a></p><p><strong>不可重复读</strong></p><p>session1 执行事务期间，另一个 session2 事务对session1 读取的数据修改并提交</p><p>将事务隔离级别升级为 REPEATABLE READ 即可处理该问题</p><p><strong>幻读</strong></p><p>侧重于删除和增加</p><p>Transaction A 读取与搜索条件相匹配的若干行， Transaction B 插入或删除行修改 Transaction A 的结果集。</p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插⼊的数据的。因此，幻读在“当前读”下才会出现。</li><li>上⾯session B的修改结果，被session A之后的select语句⽤“当前读”看到，不能称为幻读。幻读仅专指“新插⼊的⾏”。</li></ol><p>幻读有什么问题？ ⾸先是语义上的。session A在T1时刻就声明了，“我要把所有d=5的⾏锁住，不准别的事务进⾏读写操作”。⽽实际上，这个语义被破坏了。 其次，是数据⼀致性的问题。 我们知道，锁的设计是为了保证数据的⼀致性。⽽这个⼀致性，不⽌是数据库内部数据状态在此刻的⼀致性，还包含了数据和⽇志在逻辑上的⼀致性。 原因很简单。在T3时刻，我们给所有⾏加锁的时候，id=1这⼀⾏还不存在，不存在也就加不上锁。 也就是说，即使把所有的记录都加上锁，还是阻⽌不了新插⼊的记录，这也是为什么“幻读”会被单独拿出来解决的原因。 到这⾥，其实我们刚说明完⽂章的标题 ：幻读的定义和幻读有什么问题。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离得越严实，效率就会越低。</p><ol><li>READ UNCOMMITTED: ⼀个事务还没提交时，它做的变更就能被别的事务看到。</li><li>READ COMMIT: ⼀个事务提交之后，它做的变更才会被其他事务看到。</li><li>REPEATABLE READ: ⼀个事务执⾏过程中看到的数据，总是跟这个事务在启动时看到的数据是⼀致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可⻅的。</li><li>SERIALIZABLE: 对于同⼀⾏记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前⼀个事务执⾏完成，才能继续执⾏。主要用于实现 InnoDB 的分布式事务。</li></ol><p><strong>InnoDB 在 REPEATABLE READ 级别下，使用 Next-Key Lock 锁算法，避免幻读的产生。</strong></p><p><a href="https://www.notion.so/5600ccbf25144edaaf0f7827ad50127f">隔离级别与事务问题</a></p><p><strong>事务隔离的实现</strong></p><p>read view 算法</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录⼀条回滚操作。记录上的最新值，通过回滚操作，都可以得到前⼀ 个状态的值。 回滚⽇志什么时候删除呢？</p><p>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要⽤到这些回滚⽇志时，回滚⽇志会被删除。</p><p>什么时候才不需要了呢？</p><p>当系统⾥没有⽐这个回滚⽇志更早的 read-view 的时候。</p><p>为何尽量不使用长事务？</p><p>⻓事务意味着系统⾥⾯会存在很⽼的事务视图。由于这些事务随时可能访问数据库⾥⾯的任何数据，所以这个事务提交之前，数据库⾥⾯它可能⽤到的回滚记录都必须保留，这就会导致⼤量占⽤存储空间。</p><p>除此之外，⻓事务还占⽤锁资源，可能会拖垮库。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>开启事务的方式</strong></p><ul><li>显式启动事务语句： begin 或者 start transaction, 提交 commit，回滚 rollback；</li><li>set autocommit=0： 该命令会把这个线程的⾃动提交关掉。这样只要执⾏⼀个 select 语句，事务就启动，并不会⾃动提交，直到主动执⾏ commit 或 rollback 或断开连接。</li></ul><p>建议使⽤⽅法⼀，如果考虑多⼀次交互问题，可以使⽤ commit work and chain 语法。在 autocommit=1 的情况下⽤ begin 显式启动事务，如果执⾏ commit 则提交事务。如果执⾏ commit work and chain 则提交事务并⾃动启动下⼀个事务。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>InnoDB⾥⾯每个事务有⼀个 唯⼀的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。 ⽽每⾏数据也都是有多个版本的。每次事务更新数据的时候，都会⽣成⼀个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。 也就是说，数据表中的⼀⾏记录，其实可能有多个版本(row)，每个版本有⾃⼰的row trx_id。</p><p><strong>InnoDB利⽤了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能⼒。</strong></p><p>更新数据都是先读后写的，⽽这个读，只能读当前的值，称为“当前读”(currentread)。</p><p>InnoDB的⾏数据有多个版本，每个数据版本有⾃⼰的row trx_id，每个事务或者语句有⾃⼰的⼀致性视图。普通查询语句是⼀致性读，⼀致性读会根据row trx_id和⼀致性视图确定数据版本的可⻅性。</p><ul><li><p>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</p></li><li><p>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</p><p>⽽当前读，总是读取已经提交完成的最新版本。你也可以想⼀下，为什么表结构不⽀持“可重复读”？这是因为表结构没有对应的⾏数据，也没有row trx_id，因此只能遵循当前读的逻辑。</p></li></ul><h2 id="RR-下解决幻读"><a href="#RR-下解决幻读" class="headerlink" title="RR 下解决幻读"></a>RR 下解决幻读</h2><p>表象：快照读(非阻塞读)–伪MVCC 内在：是因为事务对数据加了next-key锁(行锁+gap锁) -gap锁会用在非唯一索引或者不走索引的当前读中</p><p><strong>RC、RR 下的 InnoDB 的非阻塞读实现</strong></p><p>RR 下可能读取到老的版本</p><p>RR 创建快照的时机决定了事务的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session1:</span><br><span class="line">UPDATE ...     -- 1</span><br><span class="line"></span><br><span class="line">session2:</span><br><span class="line">SELECT          --  3</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;    -- 2</span><br></pre></td></tr></table></figure><ol><li>数据行中三个行隐藏参数：</li></ol><p>DB_TRX_ID: 最近一次对本行数据进行修改的数据 ID</p><p>DB_ROW_PTR: 回滚指针， 指向 undo 日志</p><p>DB_ROW_ID: 无主件时隐式的 ID</p><p><strong>(2) undo 日志</strong>： 老版本</p><p>针对 Insert undo log,</p><p>针对 update undo log</p><p><strong>(3) read view</strong>: 可见性算法</p><p><img src="http://img.janhen.com/202103072224031551854704429.png" alt="http://img.janhen.com/202103072224031551854704429.png"></p><p><img src="http://img.janhen.com/202103072224191551854739908.png" alt="http://img.janhen.com/202103072224191551854739908.png"></p><p>MVCC: 读不加锁，读写不冲突，读多写少</p><p>伪 MVCC： 无法多版本共存</p><p><strong>RR 避免 幻读</strong></p><p>产⽣幻读的原因是，⾏锁只能锁住⾏，但是新插⼊记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引⼊新的锁，也就是间隙锁(Gap Lock)。</p><p>但是间隙锁不⼀样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插⼊⼀个记录”这个操作</strong>。间隙锁之间都不存在冲突关系。</p><p><strong>间隙锁和 next-key lock 的引⼊，帮我们解决了幻读的问题，但同时也带来了⼀些“困扰”。</strong></p><p><strong>间隙锁的引⼊，可能会导致同样的语句锁住更⼤的范围，这其实是影响了并发度的。</strong></p><p>⾏锁确实⽐较直观，判断规则也相对简单，间隙锁的引⼊会影响系统的并发度，也增加了锁分析的复杂度，但也有章可循</p><p>next-key 锁</p><p>行锁：</p><p><strong>Gap 锁</strong>： 锁定一个范围，不包含当前</p><p>() GAP 锁出现的时机</p><p>出现的场景： WHERE + INDEX</p><p>where 条件全部命中，不会加 Gap Lock, 只会加 Record Lock</p><p>where 条件部分命中，或全部不命中，加 Gap Lock;</p><p>Gap 锁会用在非唯一索引或者不走 index 的当前读中：</p><ul><li>非唯一索引</li><li>不走索引的当前读，尽量避免</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><blockquote><p>Multiversion concurrency control 多版本并发控制。</p></blockquote><p>并发访问（读或者写）数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li>《MySQL技术内幕：InnoDB存储引擎(第二版)》姜承尧</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;事务是数据库区别于文件系统的一个关键特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;事务的分类&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java-Map类源码</title>
    <link href="http://example.com/2021/04/09/Java-Map%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/04/09/Java-Map%E7%B1%BB%E6%BA%90%E7%A0%81/</id>
    <published>2021-04-08T16:59:34.000Z</published>
    <updated>2021-04-08T17:00:39.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap-JDK7"><a href="#HashMap-JDK7" class="headerlink" title="HashMap(JDK7)"></a>HashMap(JDK7)</h2><p>Hash 表结构几个重要的通用操作， hash 函数、hash 冲突、rehash 及扩容；</p><h3 id="存储结构与初始化"><a href="#存储结构与初始化" class="headerlink" title="存储结构与初始化"></a><strong>存储结构与初始化</strong></h3><p>（1） 结构</p><p>底层结构中为每一个 Node 添加指向 prev, next 的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对，为链表结构，数组每个位置相当于一个桶，桶中存放链表。借助其来处理 Hash 冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>① 无参初始化；</p><p>② Map 传入初始化；</p><p>③ 指定初始化容量；</p><p>④ 执行初始化容量和负载因子；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Obejct, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(x * <span class="number">4</span>/<span class="number">3</span>);    <span class="comment">// loadFactor to prevent grow</span></span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash 函数 | 元素定位</strong></p><p>① 整体的定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>② 具体的 hash 确定</p><p>通过多次移位和异或进行 hash 扰动，使其尽量不依赖于传入的 hashCode 的不均匀性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 根据 hash 确定桶下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度和链表的长度成正比；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、put</strong></p><p>(1) 总体实现流程</p><p>①判断初始化，未初始化则做对应的初始化</p><p>②Null 值特殊处理，Null 无法调用 hashCode()，防止 NullPointerException</p><p>③确定桶下标</p><p>④遍历链表，若重复直接覆盖并返回</p><p>⑤为新加入元素，插入 &lt;K,V&gt;</p><p>⑥根据情况看是否需要扩容处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 对于 NULL 的插入处理</p><p>无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">/*0 bucket*/</span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 处理 Hash 碰撞</p><p>头插法处理；</p><p>在容量阈值达到时，进行 2 倍扩容操作；</p><p>是一种添加之后，再进行扩容的行为，依赖的是上次添加完毕的情况；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、扩容 | rehash</strong></p><p>（1） 影响的变量</p><p>① loadFactor： 负载因子时间上和空间上的一种平衡:</p><ul><li>↑ 查找性能差, 空间利用率高；</li><li>↓ 查找性能高, 空间利用率低；</li></ul><p>② size | threshold： size/capacity 达到负载因子时进行对应的扩容</p><p>③ modCount：用来处理扩容时出现并发访问造成数据不一致，从而 fail-fast</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>（2） 扩容实现</p><p>在负载因子达到给定值的情况下进行扩容；</p><p>扩容为原来数组的两倍；</p><p>需要将原来的 Entry 重新插入到新建的表中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） rehash | 计算桶下标</p><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>根据 hash 值在当前的高位上是否为 0，进行不同的处理。</p><ul><li>为 0： 不需要移动</li><li>为 1： 移动偏移 原来容量对应的桶上；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） JDK7 与 JDK8 中 HashMap 的比较</p><p>① 底层结构上：</p><ul><li>JDK8 采用 数组 + 链表 + 红黑树实现，长度过长转换成红黑树有效防范了 Hash 碰撞攻击；</li><li>将原来的 Entry 改为 Node，表示红黑树节点、链表节点；</li></ul><p>② hash 函数： JDK8 只需要一次移位和异或即可，既能有效处理冲突上还保证了执行效率；</p><p>③ 处理 hash 冲突上： 在为链表时，通过尾插法进行处理，避免出现逆序且链表死循环问题；</p><p>（2） 不安全体现</p><p>扩容时因为头插法而形成环形引用，造成无限循环，CPU 100%；</p><p>put 操作可能造成丢失修改；</p><h2 id="HashMap-JDK8"><a href="#HashMap-JDK8" class="headerlink" title="HashMap(JDK8)"></a>HashMap(JDK8)</h2><h3 id="底层结构与初始化"><a href="#底层结构与初始化" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 整体结构</p><p>① table： 存储节点类型，用于多态扩展</p><p>② loadFactor： 负载因子，控制扩容的时机</p><p>③ modCount： 控制迭代访问， fail-fast</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>（2） 节点与树化</p><p>① 控制树化的时机：</p><ul><li>TREEIFY_THRESHOLD(8)： 链表元素大于该值的时候进行树化</li><li>UNTREEIFY_THRESHOLD(6)： TreeNode 中元素删除到该值时，将结构退化为链表，一般比 TREEIFY_THRESHOLD(8) 小，避免复杂度震荡</li><li>MIN_TREEIFY_CAPACITY(64): 在整个 HashMap 的容量小于该值的时候，即使单个桶中的元素达到 TREEIFY_THRESHOLD(8)，不会进行树化，会直接进行 rehash。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    <span class="comment">/* prevent complexity oscillation */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  <span class="comment">/* prevent resize and treeify conflict */</span></span><br></pre></td></tr></table></figure><p>② 链表节点结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;                  </span><br><span class="line">    <span class="keyword">final</span> K key;                      </span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 红黑树节点结构： 继承 LinkedHashMap.Entry，便于从 tree 回退到 listNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash 函数 | 元素定位</strong></p><p>一次异或一次移位进行 hash 扰动，避免依赖于原来 hashCode 处理键冲突，提高 hash 值的扩散性；</p><p>对于 null 的 KEY，直接使其 hash 值为 0，从而避免 NullPointerException；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><p>执行过程：</p><ul><li>定位到对应的桶看是否有该 KEY</li><li>首个节点为该 KEY，则直接返回</li><li>若为 TreeNode，进行红黑树的查找逻辑</li><li>若为 ListNode 进行链表的迭代遍历查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、put</strong></p><p>（1） 执行流程：</p><p>① 如果 HashMap 未被初始化过，则初始化；</p><p>② 对 Key 求 Hash 值，然后再计算下标；</p><p>③ 如果没有碰撞直接放入桶中；</p><p>④ 如果碰撞了，以链表的方式链接到后面；</p><p>⑤ 如果链表长度超过阀值，就把链表转成红黑树；</p><p>⑥ 如果链表长度低于 6，就把红黑树转回链表；</p><p>⑦ 如果节点已经存在就替换旧值；</p><p>⑧ 如果桶满了（容量 16 *加载因子 0.75 ），就需要 resize（扩容 2 倍后重排）</p><p>（2） 额外功能：</p><ul><li>null 值处理： 直接通过 hash(key) 给 NULL KEY 为 0 的值；</li><li>onlyIfAbsent： 实现 <code>putIfAbsent()</code> 方法逻辑，保留旧的值；</li><li>afterNodeAccess，afterNodeInsertion： hook 钩子函数进行特殊处理，可用于 LinkedHashMap 实现 LRU；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)   <span class="comment">/*  初始情况 */</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)        <span class="comment">/* 插入的桶无元素 */</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                        </span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;                        <span class="comment">/* 第一个位置与插入的重复 */</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)              <span class="comment">/* 是否树化 */</span>       </span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                                   </span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                                         </span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);     <span class="comment">/* 树化 */</span>                            </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))             </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)  <span class="comment">/* 总体的容量扩容 */</span></span><br><span class="line">        resize();                                                                       </span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） Hash 冲突处理</p><p>对于链表的 hash 冲突</p><p>部分 putVal() 方法：</p><p>为了实现树化，需要统计链表中的个数，直接遍历到链表尾部，进行插入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                <span class="comment">// binCount 记录链表中的个数</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                            <span class="comment">/* 迭代到链表尾部 */</span></span><br><span class="line">        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);                      <span class="comment">/* 树化 */</span>                       </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))         </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 扩容 | rehash</strong></p><p>两种可能情况：</p><ul><li>仍然在原来的位置</li><li>在原来的位置上偏移原来的容量</li></ul><p>（1） 链表拆分</p><p>将原来的链表拆成两条链表，低位链表的数据将会到新数组的当前下标位置，高位链表的数据将会到新数组的当前下标+当前数组长度的位置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;   </span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、 树化</strong></p><p>（1） 链表转为红黑树</p><p>在挂接的链表大于 TREEIFY_THRESHOLD 时进行树化逻辑；</p><p>容器整体大于 MIN_TREEIFY_CAPACITY 时才允许树化，否则进行 resize；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;                 </span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) </span><br><span class="line">        resize();   <span class="comment">/* 当前容量太小，直接扩容，防 resize 和 treeify 频繁性能损耗 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 红黑树转变成链表</p><p>在红黑树节点数少于 UNTREEIFY_THRESHOLD(6) 时，进行结构转变；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeNode.split</span></span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index + bit] = hiHead;</span><br><span class="line">        <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">            hiHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-JDK7"><a href="#ConcurrentHashMap-JDK7" class="headerlink" title="ConcurrentHashMap(JDK7)"></a>ConcurrentHashMap(JDK7)</h2><p><img src="http://img.janhen.com/20210130172336image-20201031105854190.png" alt="http://img.janhen.com/20210130172336image-20201031105854190.png"></p><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><h3 id="底层结构与初始化-1"><a href="#底层结构与初始化-1" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 全局结构</p><p>segmentShift | segmentMask： 用于快速定位到 Segment 的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;     <span class="comment">// keep object</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>（2） Segment 结构</p><p>相当于一个带有锁的 HashMap(7)</p><p>① 继承自 <code>ReentrantLock</code> 从而实现并发加分段锁访问；</p><p>② 保存了 count 用于整个容器的统计，以及作为扩容的参考值；</p><p>默认情况下并发级别为 16；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;     <span class="comment">// use for size()</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） HashEntry 结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash &amp; 定位</strong></p><p>先整体进行了多次异或操作，进行 hash 扰动，将每位都用上。</p><p>通过 hash 借助 sementShift 和 segmentMask 来定位到对应的段上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到 Entry，定位 Segment 使用的是元素的 hashcode 通过再散列后得到的值的高位，而定位 HashEntry 直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在 Segment 里散列开了，但是却没有 HashEntry 里散列开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　　 <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);　　 <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><p>无锁获取值实现：</p><p>基于 volatile 来替代锁实现，由 JMM 提供的 happen before 原则保证可见性；</p><p>通过 hash 得出对应的散列值，之后通过 hash 定位到对应的段；</p><p>在桶中再进行 hash 得到对应的桶，只有在读取到 NULL 值时才进行加锁；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Segment 中的总数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashEntry 中的值</span></span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure><p><strong>3、put()</strong></p><p>判断是否需要扩容，不是添加之后进行判断的，在插入前进行判断，避免无效的扩容。</p><p>扩容仅仅是对当前的 Segment 进行扩容，无需对整个容器扩容。</p><p><strong>4、size()</strong></p><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>可能的两步操作：</p><p>① 先尝试通过 <code>RETRIES_BEFORE_LOCK</code>(2) 次借助 segment 中 volatile 保存的 count 相加，基于 <code>modCount</code> 来实现的；</p><p>② 若无法则对整个容器进行加锁统计所有 Segment 的大小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 过多 CAS 转换成对所有 Segment 加锁获取</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） JDK7 与 JDK8 中 ConcurrentHashMap 的比较</p><p>① 底层结构： 链表过长转换成红黑树</p><p>② 同步机制： JDK7 采用分段锁实现，而 JDK8 可以有两种方案</p><ul><li>尝试通过 CAS 来支持更高的并发度；</li><li>在 CAS 失败时通过内置锁 <code>synchronized</code> 锁住链表 | 红黑树的头结点；</li></ul><h2 id="ConcurrentHashMap-JDK8"><a href="#ConcurrentHashMap-JDK8" class="headerlink" title="ConcurrentHashMap(JDK8)"></a>ConcurrentHashMap(JDK8)</h2><p><img src="http://img.janhen.com/20210130172332image-20201031105915401.png" alt="http://img.janhen.com/20210130172332image-20201031105915401.png"></p><p>五十几个内部类，Guava 中的 Cache 基于此实现。</p><p>无法存放 NULL。</p><h3 id="底层结构与初始化-2"><a href="#底层结构与初始化-2" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 底层结构</p><p>① nextTable： 用于并发下的扩容操作</p><p>② transferIndex： 在 rehash 情况下的标记索引</p><p>③ counterCells： 用于并发下获取容量，不精确，与 LongAdder 类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>五种初始化方式：</p><p>前四种同 HashMap 初始化方式；</p><p>⑤ 初始容量、负载因子、并发级别： 含有并发级别控制；</p><p>并发级别基本不用，初始化用于与 initialCapacity 进行比较取最大值；</p><p>与 JDK7 进行兼容的处理逻辑；</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash 函数|定位</strong></p><p>通过传入对象的 hashCode 来进行对应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、put()</strong></p><p>① 判断 Node[] 数组是否初始化，没有则进行初始化操作</p><p>② 通过 hash 定位数组的索引坐标，是否有 Node 节点，如果没有则使用 CAS 进行添加（链表的头节点），添加失败则进入下次循环。</p><p>③ 检查到内部正在扩容，就帮助它一块扩容。</p><p>④ 如果 f != null 则使用 synchronized 锁住 f 元素（链表/红黑二叉树的头元素）</p><p>4.1如果是Node（链表结构）则执行链表的添加操作。</p><p>4.2如果是TreeNode（树型结构）则执行树添加操作。</p><p>⑤ 判断链表长度已经达到临界值 8 (default)节点数超过这个值就需要将链表转换为树结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;          <span class="comment">// may enter this loop many times</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)         <span class="comment">/* P1. not init */</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;      <span class="comment">/* P2. 第一个桶位置为空, CAS添加 */</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)                      <span class="comment">/* P3. 其他线程正在扩容 */</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;                         <span class="comment">/* 发生 hash 碰撞, 处理 listnode OR treenode, 只有此时才加锁, 其他情况都 CAS 循环尝试  */</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;       <span class="comment">/* 使用第一个元素作为锁, 粒度比 Segment 分段锁更加细 */</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;   <span class="comment">/* 链表的计数器 */</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;                    <span class="comment">/* 遍历到链表的结尾，在链表尾部添加节点 */</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;                       <span class="comment">/* 为树形结构的处理 */</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)           <span class="comment">/* 判断是否需要树化, 在方法中还需处理当前是否到达树化的最小容量，否则进行扩容操作 */</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、扩容</strong></p><p>// todo</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><img src="http://img.janhen.com/20210130172343image-20201031105952779.png" alt="http://img.janhen.com/20210130172343image-20201031105952779.png"></p><p>与 JDK7 的 HashMap 基本一致；</p><p>线程安全的同步容器；</p><h3 id="底层结构与初始化-3"><a href="#底层结构与初始化-3" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 底层结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 初始化容量为 11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash | 定位</strong></p><p>直接通过取模实现；</p><p>效率较 HashMap 低；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure><p><strong>2、 扩容 | rehash</strong></p><p>容量为 <code>2*oldCapacity+1</code>；</p><p>初始容量和扩容机制都与 HashMap 不同；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>3、 迭代方式</strong></p><p>通过 <code>Enumerator</code> 实现，而非 Iterator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） 与 HashMap的区别</p><p>① HashTable 设计上基于 Dictionary 实现，线程安全，执行效率低下，而 HashMap 基于 AbstractMap 实现，线程不安全，执行效率比 HashTable 高；</p><p>② NULL 值： HashMap 允许 NULL 值， HashTable 不允许；</p><p>③ 初始化与 hash 定位： HashTable 初始容量为 11，HashMap 初始容量为 16，HashTable 通过 % 的方式进行定位，HashMap 通过移位异或进行定位；</p><p>④ 迭代访问上： 两者实现的迭代不同，一个基于 Iterator，一个基于 Enumerator；</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>默认保持元素插入属性的 Map；</p><p>可先通过 HashMap 来进行统计一些必要的数据，之后通过对 HashMap 的 KEY, VALUE 进行一些排序，将其变为有序的，使用 LinkedHashMap 来将这些顺序串联起来，之后进行对应的逻辑处理；</p><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a><strong>底层结构</strong></h3><p>（1） 全局属性</p><p>① accessOrder： 控制开启访问作为次序，可借助 LinkedHashMap 实现 LRU Cache;</p><p>② head|tail： 控制按照插入 | 访问顺序迭代；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>（2） 节点</p><p>before | after 用于将节点连接起来方便遍历；</p><p>HashMap.TreeNode 扩展此节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;       </span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h3><p>（1） LRU Cache</p><p>通过 HashMap 的 putVal() 中提供的两个 hook 钩子函数实现特有的功能；</p><p>根据 assessOrder 值不同，迭代出不同的结果。为 true，执行 LRU 顺序，访问过后移到链表尾部，头部为最近最久未使用节点； 为 false，执行插入顺序，与 List 语义相同；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;     <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1-2） LinkedHashMap 实现的线程安全的 LRUCache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    cache = <span class="keyword">new</span> LinkedHashMap((<span class="keyword">int</span>) Math.ceil(capacity/DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">223232L</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.size() &gt;= capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.put(key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 借助多态将 HashMap 中的数据按照一定的规则进行排序</p><p>如 HashMap 存放的是词频，可以根据词频进行排序，之后迭代访问时就是词频从高到低的序列；</p><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） 与 HashMap 的区别</p><p>① 设计层面上： LinkedHashMap 是 HashMap 的子类；</p><p>② 底层结构及功能扩展上： LinkedHashMap 节点中添加了 before, after 用于保证顺序；</p><p>③ put 操作： LinkedHashMap 在继承的基础上重写 HashMap 中的 hook(钩子) 方法，在 LinkedHashMap 中向哈希表中插入新 Entry 的同时，还会通过 Entry 的 addBefore 方法将其链入到双向链表中。</p><p>④ get 操作： LinkedHashMap 中重写了 HashMap 中的 get 方法，通过 HashMap 中的 getEntry 方法获取 Entry 对象。 在此基础上，进一步获取指定键对应的值。</p><p>⑤ 在扩容操作上： 虽然 LinkedHashMap 完全继承了 HashMap 的 resize 操作，但是鉴于性能和 LinkedHashMap 自身特点的考量， LinkedHashMap 对其中的重哈希过程(transfer 方法)进行了重写。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>红黑树的实现</p><p>// todo</p><p><strong>X、其他 与 HashMap 的区别</strong></p><p>① 顺序性： TreeMap 可对按照 Key 的自然顺序或是传入的比较器进行排序；</p><p>② 存取效率上： O(1) VS O(logN)；</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>对于 ThreadLocal：</p><ul><li>当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本；</li><li>是一种无锁同步方案；</li><li>是一种用空间换取时间来保证线程安全的方案；</li><li>多线程情况下，对应的子线程的 ThreadLocal 无法获取到父线程的 ThreadLocal，需要第三方工具包支持，可选择 alibaba 的 transmittable-thread-local 包；</li></ul><p><strong>1、底层结构</strong></p><p>（1） 全局结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">Entry[] table;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>（2） Entry</p><p>继承自 WeakReference ，在无活跃线程或栈中持有时，在 GC 时就会被回收；</p><p>节点只保存值，ThreadLocalMap 不是使用链地址法来解决 Hash 冲突；</p><p>多个线程，只设置一个 ThreadLocal 变量，在这个线程中的 ThreadLocal 变量的值始终是只有一个的，即以前的值被覆盖了的。这里是因为 Entry 对象是以该 ThreadLocal 变量的引用为 key 的，所以多次赋值以前的值会被覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;     <span class="comment">/* ThreadLocal as key */</span></span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 定位</p><p>通过此来进行 hash 桶的定位；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure><p>（4） 负载因子</p><blockquote><p>0.66</p></blockquote><p>空间利用率相较于 HashMap 的 0.75 较低，但加快查询；</p><p>同时配合开放地址法来快速定位到空闲的桶；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash()</strong></p><p>没有扰动函数，通过 ThreadLocal 中保存的 threadLocalHashCode 来实现；</p><p>threadLocalHashCode 根据维护的 <code>AtomicInteger nextHashCode</code> 获取；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThreadLocalMap.getEntry</span></span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>2、get()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、set()</strong></p><p>① 先获取到 ThreadLocal 键的 thresholdLocalHashCode ，以此来确定对应的桶下标；</p><p>② 如果在该位置正好与当前进行重合，直接覆盖；</p><p>③ 如果该位置无元素，则将其放入该位置；</p><p>④ 上面两个都不满足的情况下，使用线性探测法不断寻找到对应的满足上述两个条件的位置；</p><p>⑤ 上述都不满足，创建一个节点，并清理一些桶位，之后进行重新 hash ；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail  more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];          <span class="comment">// bucket position</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)   <span class="comment">// add node need to clean some object</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、扩容 | rehash</strong></p><p>（1） rehash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） resize</p><p>扩容为原来的两倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1）与 HashMap 的比较</p><p>① 底层结构：</p><ul><li>ThreadLocalMap 只有数组，HashMap 通过数组 + 链表(Tree) 方式</li><li>节点引用类型： ThreadLocalMap 节点为弱引用，会下一次 GC 被回收</li></ul><p>② hash： 并发下通过 AtomicInteger 实现</p><p>③ hash 冲突处理： ThreadLocalMap 通过线性探测法实现的，HashMap 通过链地址法实现；</p><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a><strong>底层结构</strong></h3><p>（1）节点</p><p>与 Entry 继承 WeakReference，当前 Entry 需要引用队列来进行处理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="comment">// 单独的 Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;    <span class="comment">/* must use reference queue */</span></span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、hash | 定位</strong></p><p>通过四次异或来进行 hash 扰动，使其少依赖于原始的 hashCode()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、put</strong></p><p>NULL 值： 对 NULL 的 KEY 处理机制，将 NULL 作为指向一个对象进行存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li>《Java并发编程的艺术》方腾飞 / 魏鹏 / 程晓明</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashMap-JDK7&quot;&gt;&lt;a href=&quot;#HashMap-JDK7&quot; class=&quot;headerlink&quot; title=&quot;HashMap(JDK7)&quot;&gt;&lt;/a&gt;HashMap(JDK7)&lt;/h2&gt;&lt;p&gt;Hash 表结构几个重要的通用操作， hash 函数、h</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java-集合类源码</title>
    <link href="http://example.com/2021/04/08/Java-%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/04/08/Java-%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/</id>
    <published>2021-04-08T15:18:17.000Z</published>
    <updated>2021-04-08T16:54:15.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>基本性质：</p><ul><li>底层基于数组保存；</li><li>增删慢、随机查询快；</li><li>线程不安全；</li></ul><h3 id="底层结构与初始化"><a href="#底层结构与初始化" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>（2） 加载和初始化</p><p>懒加载形式，在 add() 时进行对应的初始化；</p><p>共支持三种初始化方式：</p><p>① 无参构造： 默认不进行数据的初始化；</p><p>② 给定容量： 程序中通过给定容量来优化；</p><p>③ 通过放入 Collection 接口进行初始化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="comment">// 使用 Guava 创建指定容量的 List</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayListWithCapacity(oldList.size());</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>1、add</strong></p><p>① 默认插入尾部，O(1) 实现；</p><p>② 任意位置插入</p><ul><li>将插入位置后的所有元素右移一位，之后在插入位置赋值；</li><li>插入的开销与插入的位置有关；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);             <span class="comment">/* 右移一位 */</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、remove</strong></p><p>需要调用 System.arraycopy() 将 index + 1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，开销大；</p><p>同 add() 操作，删除与位置紧密相关；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 扩容</strong></p><p>扩容后的大小为 <code>oldN * 1.5 + 1</code>；</p><p>通过 <code>Arrays.copyOf()</code> 复制到新数组中；</p><p>可通过指定初始容量的方式，来减少扩容的次数，减少不必要的开销；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">/* init capacity */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">/* copy to impl. */</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、 迭代访问</strong></p><p>采用快速失败模式实现；</p><p>通过成员变量 <code>modCount</code> 与 expectedModCount 比较实现；</p><p>主要用在序列化获得迭代操作时进行判断，对应抛出 <code>ConcurrentModificationException</code>；</p><p><strong>5、序列化</strong></p><p>只序列化数组中存放值的这些部分。</p><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;     <span class="comment">// not serialize</span></span><br></pre></td></tr></table></figure><p>通过 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;   <span class="comment">/* keep to compare */</span></span><br><span class="line">    s.defaultWriteObject();             <span class="comment">/* only have space */</span></span><br><span class="line"></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;        <span class="comment">/* only write have element */</span></span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;    <span class="comment">/* use for fail-fast */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 list 序列化到指定文件</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p><strong>（1） ArrayList 与 Array 的比较</strong></p><p>① 存储类型： Array 可以存放基本和对象类型， ArrayList 只能存放对象类型；</p><p>② 存放元素的大小： ArrayList 动态可变，Array 不可变;</p><p>③ 其他方法和特性：</p><ul><li>ArrayList 提供 addAll()，removeAll()，iterator() 等方法;</li><li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ul><p><strong>（2）ArrayList 与 LinkedList 的比较</strong></p><p>都是线程不安全的容器，都实现了 List 接口具备 List 的特性。</p><p>① 底层结构： ArrayList 基于索引的数据接口，底层是动态数组实现，LinkedList 以元素列表的形式存储数据，是双向链表实现；</p><p>② 操作性质：</p><ul><li>随机访问： ArrayList 支持随机访问，LinkedList 不支持；</li><li>元素删除： LinkedList 在任意位置添加删除元素更快；</li><li>操作是否与元素位置的影响： 比较插入和删除是否受元素位置影响，ArrayList 插入和删除受元素位置影响，add(e) 默认追加到末尾，在指定位置 i 插入和删除时复杂度为 O(n-i)，而 LinkedList 链表存储，插入和删除不受位置影响；</li></ul><p>③ 内存占用上： LinkedList 存放两个指针，相同数据量下占用更多的空间；</p><p><strong>（3） ArrayList 与 Vector 的比较</strong></p><ul><li>同步性： Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。</li><li>扩容： Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。且 Vector 可以设置增长空间的大小。</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基本性质：</p><ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。</li><li>线程不安全；</li><li>LinkedList 可以用作栈、队列和双向队列。</li></ul><h3 id="底层结构与初始化-1"><a href="#底层结构与初始化-1" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><p>通过记录 first, last, size 便于边界操作（注：用于队列、栈、双端队列）</p><p>队列中每个节点都存放元素，存在初始化情况；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>不支持初始情况下给定对应的容量，即基于链表都为无界队列；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、add</strong></p><p>添加元素, 最后元素与中间元素, 可处理头结点位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)         </span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;               </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);    </span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)             <span class="comment">/* init 处理 */</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、remove</strong></p><p>操作不受指定位置的影响；</p><p>为双向链表中指定节点的删除；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>基本性质：</p><ul><li>底层基于数组保存元素；</li><li>随机查询快，增删慢；</li><li>线程安全；</li><li>Java 中的 Stack 通过继承 Vector 实现的；</li></ul><h3 id="底层结构与初始化-2"><a href="#底层结构与初始化-2" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><p>① elementCount：初始容量为 10，非懒加载实现；</p><p>② capacityIncrement；可以设置每次容量的增长数量；</p><p>③ 无 modCount： 同步容器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] elementData;</span><br><span class="line"><span class="keyword">int</span> elementCount;</span><br><span class="line"><span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>支持 ArrayList 的各种初始化；</p><p>支持设置每次的扩容时的容量增长；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>1、add / get</strong></p><p>对修改底层结构的函数进行加锁同步访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、扩容机制</strong></p><p>默认扩容为 <code>oldN * 2</code>；</p><p>可以通过用户设置的正常数量进行控制扩容大小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?                 <span class="comment">/* 默认扩容 1 倍 */</span></span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p><strong>替代方案</strong></p><p>因为 Vector 通过加锁实现，粒度大效率低。</p><p>（1） 获得对应线程不安全容器的同步容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>（2） 使用并发容器，如 CopyOnWriteArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>基本性质：</p><ul><li>易引起 YongGC, FullGC</li><li>不可用于实时的数据， 写操作复制防止并发修改不一致</li><li>适合读多写少的情景</li><li>读操作无需加锁，写操作加锁</li></ul><p>三个设计思想：</p><ul><li>读写分离</li><li>最终一致性</li><li>新开辟空间，解决并发冲突</li></ul><h3 id="底层结构与初始化-3"><a href="#底层结构与初始化-3" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 结构</p><p>① ReentrantLock： 通过此来实现并发访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>三种初始化方式：</p><p>LinkedList 的初始化方式</p><p>支持泛型数组初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>(1) add</strong></p><p>并发下安全的容器，需要处理并发访问问题、处理复制问题。</p><p>包含 lock 加锁获取与释放：</p><p>① 获取原数组</p><p>② 复制出 len+1 的数组</p><p>③ 为新数组末尾复制</p><p>④ 修改内部数组指向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;           </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();      <span class="comment">/* 获取原数组, volatile 保证可见性 */</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);   <span class="comment">/* 复制数组 */</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) get</strong></p><p>无需加锁直接访问, 在 add 操作的同时可访问旧有的数据 ⇒ 实时性得不到保证 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、迭代方式</strong></p><p>通过安全失败实现，将当前数组放入到 Iterator 实现类中作为快照访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器中保存某个时间点下底层数组的快照，通过 cursor 来进行向前迭代访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="keyword">int</span> cursor;</span><br><span class="line">COWIterator(Object[] elements, <span class="keyword">int</span> initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>（1） 读写分离</p><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响；</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失；</p><p>写操作结束之后需要把原始数组指向新的复制数组；</p><p>（2）适用场景</p><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>（3） 缺陷</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="底层结构与初始化-4"><a href="#底层结构与初始化-4" class="headerlink" title="底层结构与初始化"></a>底层结构与初始化</h3><p>通过一个 HashMap 实现，对应的 Value 为指定的一个 Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><p>1、add</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>基于 LinkedHashMap 实现, HashSet 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>与 HashSet 的区别</strong></p><p>① 底层结构：HashSet 基于 hash 表实现，元素无序， 一些方法 add(), remove(), contains() 复杂度为 O(1)；</p><p>② 有序性： TreeSet 基于红黑树实现，元素有序， add(), remove(), contains() 复杂度为 O(logN)；</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>基本性质：</p><ul><li>有序的优先队列；</li><li>不可以存放 NULL，NULL 无自然顺序；</li><li>非线程安全，入队和出队的时间复杂度为 O(logN)；</li><li>基于堆结构实现，默认情况下为最小堆；</li></ul><h3 id="底层结构与初始化-5"><a href="#底层结构与初始化-5" class="headerlink" title="底层结构与初始化"></a><strong>底层结构与初始化</strong></h3><p>（1） 底层结构</p><p>数组保存的完全二叉树，首元素存放元素值。</p><p>堆顶元素有序，默认情况下为最小堆。</p><p>comparator： 默认自定义比较器优先于存入对象的自然排序进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue; </span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>（2） 初始化</p><p>可指定初始容量与比较器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">PriorityQueue(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator) &#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator);</span><br></pre></td></tr></table></figure><h3 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a><strong>操作</strong></h3><p><strong>（1） offer</strong></p><p>实现：</p><ul><li>先将元素放到完全二叉树的尾节点</li><li>之后不断上浮调整结构使其符合堆特性</li></ul><p>辅助-shiftUp</p><p>上浮函数，用于维护最小堆的结构。</p><p>赋值替换交换优化；</p><p>找出正确位置并放入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2） poll</strong></p><p>弹出当前堆顶元素。</p><p>实现：</p><ul><li>保存堆顶元素；</li><li>将堆顶与最末叶子节点交换，之后通过堆顶下沉实现结构的维护；</li><li>siftDown，下沉函数，最小堆的结构；</li><li>通过赋值来替换掉交换操作；</li><li>找到元素应该放入的正确位置放入；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3） remove</strong></p><p>remove(o) 删除一个对象，为 Collection 中的方法，需要先进行向下调整后进行向上调整；</p><p>实现：</p><ul><li>最末叶子节点赋值到当前删除的位置；</li><li>让原来的最末叶子节点向下调整；</li><li>若结构不合法则向上调整；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];       <span class="comment">/* 最末叶子节点赋值到当前删除的位置 */</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);             <span class="comment">/* 让原来的最末叶子节点向下调整 */</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;      <span class="comment">/* 结构不合法向上调整 */</span></span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4） heapify</strong></p><p>初始传入为 Collection 进行堆化处理，借助原始结构，从中间处向上不断下沉处理，相比较每次插入到最末叶子节点进行向上调整效率更高；</p><p>完全二叉树中间节点位置 size / 2 - 1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="comment">/* 完全二叉树从上层节点不断向下调整实习 */</span></span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、扩容</strong></p><p>小数据量快速 <code>2 * oldCapacity + 2</code> 扩容，容量大于 64 后进行 <code>1.5 * oldCapacity</code> 扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、迭代访问</strong></p><p>通过双向队列 ArrayDeque 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    ArrayDeque&lt;E&gt; forgetMeNot = <span class="keyword">null</span>;</span><br><span class="line">    E lastRetElt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>使用场景</p><ul><li>贪心算法选择局部最优；</li><li>图论中使用进行优化；</li><li>实现哈夫曼树等结构；</li></ul><h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p>基于数组实现的双向队列；</p><p>可使用 Stack 的 API;</p><h3 id="底层结构与初始化-6"><a href="#底层结构与初始化-6" class="headerlink" title="底层结构与初始化"></a>底层结构与初始化</h3><p>(1) 底层结构</p><p>一个数组，两个索引指向队列的头节点和尾部节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>(2) 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>1、sort</strong></p><p><strong>JDK 中的排序都为稳定排序</strong></p><p>算法的执行逻辑：</p><ul><li>小数据量使用 INSERT 排序</li><li>一定规模数据量使用 QUICK 排序</li><li>大数据量使用 MERGE 排序</li><li>并非所有大数据量都是 Merge Sort，在不具备结构性时转换成 Quick Sort；</li></ul><p>（1） 归并排序</p><p>① 小数据量转快速排序</p><p>② 通过分配当前大小进行 merge</p><p>③ 判断排序数组的结构，不具有时使用快速排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];   <span class="comment">/* aux space to merge */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"><span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The array is not highly structured,</span></span><br><span class="line"><span class="comment">        * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 快速排序</p><p>① 小数据量插入排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">boolean</span> leftmost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use insertion sort on tiny arrays</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>② 逻辑实现</p><p>通过双枢纽元分割实现；</p><p>类似 BFPRT 算法中对于枢纽元的选取，将原来期望的复杂度转换成确定的复杂度；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">left part           center part                   right part</span><br><span class="line"> +--------------------------------------------------------------+</span><br><span class="line"> |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line"> +--------------------------------------------------------------+</span><br><span class="line">               ^                          ^       ^</span><br><span class="line">               |                          |       |</span><br><span class="line">              less                        k     great</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">   left part         center part                  right part</span><br><span class="line"> +----------------------------------------------------------+</span><br><span class="line"> | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line"> +----------------------------------------------------------+</span><br><span class="line">              ^                        ^       ^</span><br><span class="line">              |                        |       |</span><br><span class="line">             less                      k     great</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line"> Partitioning degenerates to the traditional <span class="number">3</span>-way</span><br><span class="line"> (or <span class="string">&quot;Dutch National Flag&quot;</span>) schema:</span><br><span class="line"></span><br><span class="line">   left part    center part              right part</span><br><span class="line"> +-------------------------------------------------+</span><br><span class="line"> |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line"> +-------------------------------------------------+</span><br><span class="line">              ^              ^        ^</span><br><span class="line">              |              |        |</span><br><span class="line">             less            k      great</span><br></pre></td></tr></table></figure><p>（3） 插入排序</p><p>为快速排序中的子过程实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Traditional (without sentinel) insertion sort,</span></span><br><span class="line"><span class="comment">        * optimized for server VM, is used in case of</span></span><br><span class="line"><span class="comment">        * the leftmost part.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + <span class="number">1</span>] = ai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Skip the longest ascending sequence.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Every element from adjoining part plays the role</span></span><br><span class="line"><span class="comment">        * of sentinel, therefore this allows us to avoid the</span></span><br><span class="line"><span class="comment">        * left range check on each iteration. Moreover, we use</span></span><br><span class="line"><span class="comment">        * the more optimized algorithm, so called pair insertion</span></span><br><span class="line"><span class="comment">        * sort, which is faster (in the context of Quicksort)</span></span><br><span class="line"><span class="comment">        * than traditional implementation of insertion sort.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">            <span class="keyword">int</span> a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a1 &lt; a2) &#123;</span><br><span class="line">                a2 = a1; a1 = a[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class="line">                a[k + <span class="number">2</span>] = a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            a[++k + <span class="number">1</span>] = a1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class="line">                a[k + <span class="number">1</span>] = a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            a[k + <span class="number">1</span>] = a2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = a[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (last &lt; a[--right]) &#123;</span><br><span class="line">            a[right + <span class="number">1</span>] = a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        a[right + <span class="number">1</span>] = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、binarySearch</strong></p><p>计算 mid <code>mid = (low + high) &gt;&gt;&gt; 1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like public version, but without range checks.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">  <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;       <span class="comment">// </span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Comparable midVal = (Comparable)a[mid];</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、asList / subList</p><p>不推荐使用，返回的 List 修改会有问题。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>1、提供一些容器的空实现：作为容器为空的情况下的返回值，规避空指针问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List EMPTY_LIST = <span class="keyword">new</span> EmptyList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、提供单个元素的集合：</p><p>方便传递方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">singletonList</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SingletonList&lt;&gt;(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3<strong>、sort</strong></p><p>JDK8 中借助 List 中自带的 sort() 函数调用实现；</p><p>4<strong>、binarySearch</strong></p><p>对 List 进行二分搜索</p><p>根据底层是数组还是链表采用不同的处理：</p><p>① 数组： 数组随机访问定位实现</p><p>② 链表： 接着 ListIterator 实现二分查找</p><p>在 binarySearch（）⽅法中，它要判断传⼊的list 是否 RamdomAccess 的实例，如果是，调⽤ indexedBinarySearch() ⽅法，如果不是，那么调⽤ iteratorBinarySearch() ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">    <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、提供将不安全的容器转换为同步容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JDK 中 ArrayList,LinkedList,Vector,CopyOnWriteArrayList,PriorityQueue,ArrayDeque,Collections,Arrays 源码分析比较，关注于集合类型的底层结构、扩容机制、线程安全、复杂度震荡、迭代方式等方面。</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="http://example.com/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/</id>
    <published>2021-03-09T15:23:13.000Z</published>
    <updated>2021-04-09T09:34:16.928Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Notion 做笔记，博客为 Notion 的部分导出。</p><p><a href="https://github.com/Janhen/notes">https://github.com/Janhen/notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 Notion 做笔记，博客为 Notion 的部分导出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Janhen/notes&quot;&gt;https://github.com/Janhen/notes&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hive-基础</title>
    <link href="http://example.com/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-09T14:57:00.000Z</published>
    <updated>2021-04-21T08:45:30.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p><img src="http://img.janhen.com/20210309213549Hive.png" alt="http://img.janhen.com/20210309213549Hive.png"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p><strong>将 SQL 转换成 MapReduce 任务的工具。</strong> 基于 Hadoop 的数据仓库工具，存储和处理海量结构化的数据，可将结构化的数据映射成一张表</p></blockquote><p>FaceBook 开发的海量数据查询工具，基本实现了 <code>SQL-92</code> 标准。</p><p>可以与 Druid, Kudu 进行集成 与 HBase 集成。</p><p><strong>说明</strong></p><p>处理 HDFS 中的海量数据</p><p>通过 SQL 完成计算</p><p>基于 Hadoop 的数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能.</p><p>最适合数据仓库程序</p><p>Hive :</p><ul><li>解释器: AST 抽象语法树</li><li>编译器</li><li>优化器</li><li>执行期</li><li>MetaStore</li></ul><p>Hive 的元数据默认存储在自带的 derby 数据库中 derby: java 开发、但进程、单用户</p><h3 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h3><p>Client： Hive、Beeline、Hue</p><p>元数据库： 存放元数据的地方，数据库、表、分区、列的名称和属性，数据所在位置等信息</p><p>Meta store 元数据服务： 提供统一的服务接口，Client 通过 metastore 访问元数据。三种模式，内嵌、本地、远程模式。</p><p>Hive Driver： 解释器、编译器、优化器、执行器</p><p>HSQL 转化为 MapReduce 的过程</p><p>-&gt; AST 抽象语法树</p><p>-&gt; QB 查询块</p><p>-&gt; OperatorTree 操作树</p><p>-&gt; 优化后的 OperatorTree</p><p>-&gt; MapReduce 树</p><p>-&gt; 优化后的 MapReduce 任务树</p><h3 id="Hive-的优缺点"><a href="#Hive-的优缺点" class="headerlink" title="Hive 的优缺点"></a>Hive 的优缺点</h3><p><strong>Hive 的优点</strong></p><ul><li>学习成本低。Hive 提供了类似 SQL 的查询语言，开发人员能快速上手；</li><li>可处理海量数据。底层执行的是 MapReduce 任务；</li><li>系统可以水平扩展。底层基于 Hadoop； 功能可以扩展。</li><li>扩展性好。Hive 允许用户自定义函数；</li><li>良好的容错性。某个节点发生故障，HQL 仍然可以正常完成；</li><li>统一的元数据管理。元数据包括：有哪些表、表有什么字段、字段是什么类型</li></ul><p><strong>Hive 的缺点</strong></p><ul><li>HQL 表达能力有限；</li><li>迭代计算无法表达；</li><li>Hive 的执行效率不高(基于 MR 的执行引擎)；</li><li>Hive 自动生成的 MapReduce 作业，某些情况下不够智能；</li><li>Hive 的调优困难；</li></ul><h3 id="Hive-架构"><a href="#Hive-架构" class="headerlink" title="Hive 架构"></a>Hive 架构</h3><p><img src="http://img.janhen.com/20210302225729OHxiB9.png" alt="http://img.janhen.com/20210302225729OHxiB9.png"></p><ul><li>CLI: Hive  命令行</li><li>Thrift Server: Hive 可选组件，一个软件框架服务，可通过编程方式访问 Hive</li><li>MetaStore:  元数据存储在 RDBMS 中，元数据包括数据库名、表名和类型、字段名和数据类型、数据所在的位置等</li><li>Driver： 驱动程序<ul><li>解析器： 第三方工具(antlr) 将 HQL 字符串转换成 AST，对 AST 进行语法分析，如字段是否存在、SQL 语义正确性、表的存在</li><li>编译器： 将 AST 编译成逻辑执行计划</li><li>优化器： 对逻辑执行计划进行优化，减少不必要的列、使用分区、进行谓词下推等</li><li>执行器： 将逻辑执行计划转换成可以运行的物理计划</li></ul></li></ul><h3 id="Hive-与-RDBMS-的对比"><a href="#Hive-与-RDBMS-的对比" class="headerlink" title="Hive 与 RDBMS 的对比"></a>Hive 与 RDBMS 的对比</h3><p>Hive 是基于 Hadoop 的数据仓库分析工具，可以将 SQL 转换成 MR 任务运行。</p><ul><li>查询语言， HQL 与 SQL 高度类似，实现了 SQL-92 的标准。</li><li>数据规模，Hive 处理海量数据，RDBMS 只能处理有限的数据集</li><li>执行引擎，Hive 的执行引擎可以是 MR / Tez / Spark / Flink, RDBMS 使用自己的执行引擎</li><li>数据存储，Hive 的数据一般存储在 HDFS 上，RDBMS 通常存储在本地文件系统或者裸设备</li><li>执行速度，Hive 执行速度相对比较慢(MR/数据量)，RDBMS 相对快，Hive 没有索引，默认使用 MapReduce 作为执行引擎，会产生较高的延迟。RDBMS 一般会定义索引，执行延迟较低。</li><li>可扩展性，Hive 方便进行水平扩展，通常 RDBMS 对水平扩展支持不友好。Hive 建立在 Hadoop 上，可扩展性与 Hadoop 的可扩展性是一致的，RDBMS 优于 ACID 语义的严格限制，扩展行有限。</li><li>数据更新，Hive 对数据更新不友好，RDBMS 支持频繁快速的数据更新。</li><li>读时和写时模式，RDBMS 为写时模式，在 load 过程中，提升查询性能，需要预先解析对列简历索引并压缩，Hive 为读时模式，load 较为快</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Hive-与-RDBMS-的对比-1"><a href="#Hive-与-RDBMS-的对比-1" class="headerlink" title="Hive 与 RDBMS 的对比"></a>Hive 与 RDBMS 的对比</h3><p>Hive 是基于 Hadoop 的数据仓库分析工具，  可以将 SQL 转换成 MR 任务运行。</p><ul><li>查询语言类似， HQL, 与 SQL 高度类似，实现了 SQL-92 的标准。</li><li>数据规模，Hive 处理海量数据，RDBMS 只能处理有限的数据集</li><li>执行引擎，Hive 的执行引擎可以是 MR / Tex / Spark / Flink, RDBMS使用自己的执行引擎</li><li>数据存储，Hive 的数据一般存储在 HDFS 上，RDBMS 通常存储在贝蒂文件系统或者裸设备</li><li>执行速度，Hive 执行速度相对比较慢(MR/数据量)，RDBMS 相对快，Hive 没有索引，默认使用 MapReduce 作为执行引擎，会产生较高的延迟。RDBMS 一般会定义索引，执行延迟较低。</li><li>可扩展性，Hive 方便进行水平扩展，通常 RDBMS 对水平扩展支持不友好。Hive 建立在 Hadoop 上，可扩展性与 Hadoop 的可扩展性是一致的，RDBMS 优于 ACID 语义的严格限制，扩展行有限。</li><li>数据更新，Hive 对数据更新不友好，RDBMS 支持频繁快速的数据更新</li></ul><p>Hive 与 RDBMS 对比</p><table><thead><tr><th>Property</th><th>Hive</th><th>RMDBMS</th></tr></thead><tbody><tr><td>查询语言</td><td>HQL</td><td>SQL</td></tr><tr><td>数据存储位置</td><td>HDFS</td><td>Raw Device / 本地文件系统</td></tr><tr><td>数据格式</td><td>用户定义</td><td>系统决定</td></tr><tr><td>数据更新</td><td>不支持</td><td>支持</td></tr><tr><td>索引</td><td>无</td><td>有</td></tr><tr><td>执行引擎</td><td>MapReduce</td><td>Executor</td></tr><tr><td>执行延迟</td><td>高</td><td>低</td></tr><tr><td>可扩展性</td><td>高</td><td>低</td></tr><tr><td>数据规模</td><td>大</td><td>小</td></tr><tr><td>子查询</td><td>只可 from 子句中</td><td>完全支持</td></tr></tbody></table><p>HiveQL 于 SQL 的比较</p><table><thead><tr><th>比较项</th><th>SQL</th><th>HiveQL</th></tr></thead><tbody><tr><td>ANSI SQL 更新</td><td>支持 UPDATEVINSERT\DELETE  。。。</td><td>不完全支持 insert OVERWRITEVINTO TABLE</td></tr><tr><td>事务</td><td>支持</td><td>可支持(分桶、ORCFile 文件格式)</td></tr><tr><td>模式</td><td>写模式</td><td>读模式</td></tr><tr><td>数据保存</td><td>块设备、本地文件系统</td><td>HDFS</td></tr><tr><td>延时</td><td>低</td><td>高</td></tr><tr><td>多表播入</td><td>不支持</td><td>支持</td></tr><tr><td>子查询</td><td>完全支持</td><td>只能用在 From 子句中</td></tr><tr><td>视图</td><td>Updatable</td><td>Read-only</td></tr><tr><td>可扩展性</td><td>低</td><td>高</td></tr><tr><td>数据规模</td><td>小</td><td>大</td></tr></tbody></table><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://github.com/apache/hive">Github-Hive</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual">LanguageManual</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hive&quot;&gt;&lt;a href=&quot;#Hive&quot; class=&quot;headerlink&quot; title=&quot;Hive&quot;&gt;&lt;/a&gt;Hive&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://img.janhen.com/20210309213549Hive.png&quot; alt=&quot;h</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive-优化</title>
    <link href="http://example.com/2021/03/09/Hive-%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/03/09/Hive-%E4%BC%98%E5%8C%96/</id>
    <published>2021-03-09T13:33:13.000Z</published>
    <updated>2021-04-09T09:06:21.334Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>影响 Hive 效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、Job / IO过多、MapReduce 分配不合理等。</p><h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><h3 id="执行引擎选择"><a href="#执行引擎选择" class="headerlink" title="执行引擎选择"></a>执行引擎选择</h3><p>通过参数 hive.execution.engine 控制，可选 MapReduce, Tez, Spark, Flink 作为执行引擎，在离线数仓中，批处理方面主要使用 Spark</p><h3 id="优化器的使用"><a href="#优化器的使用" class="headerlink" title="优化器的使用"></a>优化器的使用</h3><p>在真正执行计算之前，生成和优化逻辑执行计划与物理执行计划。</p><ul><li>Vectorize 矢量化查询执行</li><li>Cost-Based Optimization: CBO 成本优化器</li></ul><p><strong>矢量化查询执行</strong> 要求执行引擎为Tez, 执行通过一次批量执行1024行而不是每行一行来提高扫描，聚合，过滤器和连接等操作的性能, 可一显着缩短查询执行时间。 需要使用 orc 格式存储数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启 </span></span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.enabled = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.reduce.enabled = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>成本优化器</strong> 基于apache Calcite的，Hive的CBO通过查询成本(有analyze收集的统计信息)会生成有效率的执行计划，最终会减少执行的时间和资源的利用</p><p>可定期执行表的分析，分析后数据存放在元数据库中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从 v0.14.0默认</span></span><br><span class="line"><span class="keyword">SET</span> hive.cbo.enable=<span class="literal">true</span>; </span><br><span class="line">true</span><br><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.compute.query.using.stats=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.stats.fetch.column.stats=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认true</span></span><br><span class="line"><span class="keyword">SET</span> hive.stats.fetch.partition.stats=<span class="literal">true</span>; </span><br></pre></td></tr></table></figure><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>Parquet 和 ORC 都是 Apache 旗下的开源列式存储格式。列式存储比起传统的行式存 储更适合批量 OLAP 查询，并且也支持更好的压缩和编码。 选择 Parquet 的原因主要是它支持 Impala 查询引擎，并且对 update、delete 和事务性操作需求很低。</p><p>选择 ORCFile 支持事务操作。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>压缩的配置可以在hive的命令行中或者hive-site.xml文件中进行配置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.compress.intermediate=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>DEFLATE</li><li>GZIP: 扩展名 .gz</li><li>Bzip2: 支持分割, 扩展名 .gz</li><li>LZO：</li><li>LZ4：</li><li>Snappy: 不支持分割</li></ul><p>可在mapred-site.xml, hive-site.xml 配置，命令行配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.intermediate.compression.codec=org.apache.hadoop.io.compress</span><br><span class="line">.SnappyCodec;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.compress.output=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">SET</span> mapreduce.output.fileoutputformat.compress.codec =</span><br><span class="line">org.apache.hadoop.io.compress.SnappyCodc</span><br></pre></td></tr></table></figure><h3 id="分区、分桶表"><a href="#分区、分桶表" class="headerlink" title="分区、分桶表"></a>分区、分桶表</h3><p>设计成分区表可以提升查询的性能，对于一个特定分区的查询，只会加载对应分区路  径的文件数据</p><p>尽量避免层级较深的分区</p><ul><li>日期或时间。如year、month、day或者hour，</li><li>地理位置。如国家、省份、城市</li><li>业务逻辑。如部门、销售区域、客户</li></ul><p>分桶表 分桶表的组织方式是将HDFS上的文件分割成多个文件。 分桶可以加快数据采样，也可以提升join的性能(join的字段是分桶字段)，因为分桶可 以确保某个key对应的数据在一个特定的桶内(文件)，巧妙地选择分桶字段可以大幅 度提升join的性能。</p><p>分桶字段可以选择经常用在过滤操作或者join操作的字段。</p><h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>支持将作业动态地转为本地模式, 当Hive处理的数据量较小时，启动分布式去处理数据会有点浪费。</p><p>一个作业只要满足下面的条件，会启用本地模式</p><ul><li>输入文件的大小小于 <code>hive.exec.mode.local.auto.inputbytes.max</code> 配置的大小</li><li>map 任务的数量小于 <code>hive.exec.mode.local.auto.input.files.max</code> 配置的大小</li><li>reduce 任务的数量是1或者0</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto=<span class="literal">true</span>; <span class="comment">-- 默认 false</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto.inputbytes.max=<span class="number">50000000</span>;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto.input.files.max=<span class="number">5</span>; <span class="comment">-- 默认 4</span></span><br></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>强制不允许用户执行3种有风险的HiveQL语句，一旦执行会直接失败。</p><ul><li>查询分区表时不限定分区列的语句；</li><li>两表 join 产生了笛卡尔积的语句；</li><li>用 order by 来排序，但没有指定 limit 的语句。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DEFAULT strict</span></span><br><span class="line"><span class="keyword">set</span> hive.mapred.mode=nostrict</span><br></pre></td></tr></table></figure><h3 id="JVM-重用"><a href="#JVM-重用" class="headerlink" title="JVM 重用"></a>JVM 重用</h3><p>Hadoop可以重用 JVM，通过共享 JVM 以串行而非并行的方式运行 map 或者 reduce。 避免 JVM 启动进程所耗费的时间会比作业执行的时间还要长。</p><p>JVM的重用<font color="green">适用于同一个作业的 map 和 reduce，对于不同作业的 task 不能够共享 JVM。</font></p><p>开启JVM重用将一直占用使用到的 task 插槽，以便进行重用，直到任务完成后才能释放。</p><p>如果某个“不平衡的”job中有某几个reduce task执行的时间要比其他Reduce task消耗的时间多的多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 代表同一个MR job中顺序执行的5个task重复使用一个JVM，减少启动和关闭的开销</span></span><br><span class="line"><span class="keyword">SET</span> mapreduce.job.jvm.numtasks=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>Hive 将查询转换成一个或多个阶段，MapReduce 阶段、抽样阶段、合并阶段、Limit 阶段..</p><p>默认情况下一次只执行一个阶段，对于特定 Job 有多个阶段，阶段间非完全相互依赖，并行执行，可以缩短 job 的执行时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.parallel=<span class="literal">true</span>; </span><br><span class="line"><span class="comment">-- 默认8</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.parallel.thread.number=<span class="number">16</span>; </span><br></pre></td></tr></table></figure><h3 id="推测执行"><a href="#推测执行" class="headerlink" title="推测执行"></a>推测执行</h3><p>在分布式集群环境下，因为程序Bug、负载不均衡、资源分布不均、网络情况等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务, 这些任务会拖慢作业的整体执行进度。</p><p>Hadoop采用了推测执行机制，它根据一定的规则推测出 “拖后腿” 的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.map.speculative=<span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.reduce.speculative=<span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> hive.mapred.reduce.tasks.speculative.execution=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="合并小文件"><a href="#合并小文件" class="headerlink" title="合并小文件"></a>合并小文件</h3><p>在map执行前合并小文件，减少map数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 缺省参数</span></span><br><span class="line"><span class="keyword">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</span><br></pre></td></tr></table></figure><p>在Map-Reduce的任务结束时合并小文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 map-only 任务结束时合并小文件，默认true</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.mapfiles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 map-reduce 任务结束时合并小文件，默认false</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.mapredfiles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 合并文件的大小，默认256M</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.size.per.task = <span class="number">268435456</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当输出文件的平均大小小于该值时，启动一个独立的 map-reduce 任务进行文件merge</span></span><br><span class="line"><span class="keyword">SET</span> hive.merge.smallfiles.avgsize = <span class="number">16777216</span>;</span><br></pre></td></tr></table></figure><h3 id="Fetch-模式"><a href="#Fetch-模式" class="headerlink" title="Fetch 模式"></a>Fetch 模式</h3><p>Fetch 模式是指 Hive 中对某些情况的查询可以不必使用 MapReduce 计算 在开启 fetch 模式之后，在全局查找、字段查找、limit 查找等都不启动 MapReduce</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Default Value: minimal in Hive 0.10.0 through 0.13.1, </span></span><br><span class="line"><span class="comment">-- more in Hive 0.14.0 and later</span></span><br><span class="line">hive.fetch.task.conversion=more</span><br></pre></td></tr></table></figure><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="列裁剪和分区裁剪"><a href="#列裁剪和分区裁剪" class="headerlink" title="列裁剪和分区裁剪"></a>列裁剪和分区裁剪</h3><p>列裁剪： SELECT 只查需要的列。少用 SELECT * 分区裁剪:  只读取需要的列。在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where 后面，那么就会先全表关联，之后再过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列裁剪优化相关的配置项, default true</span></span><br><span class="line">hive.optimize.cp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 分区裁剪优化, default true</span></span><br><span class="line">hive.optimize.pruner=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h3><p>在 RDBMS 中，如 MySQL 也有 Predicate Pushdown(PPD) 的概念，将 SQL 语句中的 where 谓词逻辑尽可能提前执行，减少下游处理的数据量。</p><p>如下的 SQQ， forum_topic 表过滤的 where 语句卸载子查询内部，而不是外部，Hive 谓词下推逻辑优化器是 PredicatePushDown，该优化器将 OperatorTree 中的 FilterOperator 向上提。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.uid,a.event_type,b.topic_id,b.title</span><br><span class="line"><span class="keyword">from</span> calendar_record_log a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> uid,topic_id,title <span class="keyword">from</span> forum_topic</span><br><span class="line"><span class="keyword">where</span> pt_date = <span class="number">20190224</span> <span class="keyword">and</span> <span class="keyword">length</span>(<span class="keyword">content</span>) &gt;= <span class="number">100</span></span><br><span class="line">) b <span class="keyword">on</span> a.uid = b.uid</span><br><span class="line"><span class="keyword">where</span> a.pt_date = <span class="number">20190224</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment"># 谓词下推优化的配置项, default true</span></span><br><span class="line">hive.optimize.ppd = true</span><br></pre></td></tr></table></figure><h3 id="sort-by-代替-order-by"><a href="#sort-by-代替-order-by" class="headerlink" title="sort by 代替 order by"></a>sort by 代替 order by</h3><p>为了控制 map 端数据分配到 reducer 的 key, 需要配置 distribute by 一起使用，如果不加 distribute by 的话，map 端数据就会随机分配到 reducer。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以UID为key，以上传时间倒序、记录类型倒序输出记录数据</span></span><br><span class="line"><span class="keyword">select</span> uid,upload_time,event_type,record_data</span><br><span class="line"><span class="keyword">from</span> calendar_record_log</span><br><span class="line"><span class="keyword">where</span> pt_date &gt;= <span class="number">20190201</span> <span class="keyword">and</span> pt_date &lt;= <span class="number">20190224</span></span><br><span class="line"><span class="keyword">distribute</span> <span class="keyword">by</span> uid</span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> upload_time <span class="keyword">desc</span>,event_type <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="group-by-代替-count-distinct"><a href="#group-by-代替-count-distinct" class="headerlink" title="group by 代替 count(distinct)"></a>group by 代替 count(distinct)</h3><p>去重计算数据量大时不好处理，数据量大的时候用一个 ReduceTask 来完成，导致整个 Job 很难完成  。 一般 COUNT DISTINCT 使用先 GROUP BY 再 COUNT 的方式替换。使用 group by 替换后， SQL 如下，会启动两个 MR Job，确保启动 Job 开销远小于计算耗时的时候使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> calendar_record_log</span><br><span class="line"><span class="keyword">where</span> pt_date &gt;= <span class="number">20190101</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><h3 id="group-by-配置调整"><a href="#group-by-配置调整" class="headerlink" title="group by 配置调整"></a>group by 配置调整</h3><p>并不是所有的聚合操作都需要在 Reduce 端完成，可现在 Map 端进行部分聚合，最后在 Reduce 端得出最终结果</p><ul><li><code>hive.map.aggr=true</code>: 是否在 Map 端进行聚合</li><li><code>hive.groupby.napaggr.checkinterva=10000</code>: 在 Map 端进行聚合操作的条目数目</li><li><code>hive.groupby.skewindata=true</code>: 有数据倾斜的时候进行负载均衡，默认 false</li></ul><p>当选项设定为 true，生成的查询计划会有两个 MR Job。第一个MR Job中，Map的输出结果会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的Group By Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；第二个MR Job再根据预处理的数据结果按照Group By Key分布到Reduce中（这个过程可以保证相同的Group By Key被分布到同一个Reduce中），最后完成最终的聚合操作。</p><h3 id="join-基础优化"><a href="#join-基础优化" class="headerlink" title="join 基础优化"></a>join 基础优化</h3><p>map join</p><p>分桶 join</p><h3 id="大表-join-大表处理空值或无意义值"><a href="#大表-join-大表处理空值或无意义值" class="headerlink" title="大表 join 大表处理空值或无意义值"></a>大表 join 大表处理空值或无意义值</h3><p>(1) 空 key 过滤 大表 Join 大表时，key 有大量的异常数据，相同的 key 发送到相同的 reducer 上，从而导致内存不够，结果 Join 的时候耗时长，可先通过 SQL 对其进行过滤。</p><p>(2) 空 key 转化 空 Key 转化，key 非异常数据，必须包含在 join 的结果中，可对为空的 key 设置随机值，使数据随机均匀分到不同的 reducer 上，防止数据的倾斜问题 …</p><h3 id="单独处理倾斜-key"><a href="#单独处理倾斜-key" class="headerlink" title="单独处理倾斜 key"></a>单独处理倾斜 key</h3><h3 id="调整-Map-数"><a href="#调整-Map-数" class="headerlink" title="调整 Map 数"></a>调整 Map 数</h3><p>通常情况下，作业通过 Input 目录产生一个/多个 map 任务 input 文件总个数、文件大小，集群设置的文件快大小。</p><p>Q:  是不是map数越多越好？ 答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</p><p>Q:  是不是保证每个map处理接近128m的文件块，就高枕无忧了？ 答案也是不一定。比如有一个127m的文件，正常会用一个 map 去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果 map 处理的逻辑比较复杂，用一个 map 任务去做，肯定也比较耗时。</p><p>增加 Map 的方法：</p><p>调整 maxSize 最大值，使 maxSize 小于 blockSize 增加 map 个数</p><p>// TODO maxSize 对应的配置参数…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))&#x3D;blocksize&#x3D;128M</span><br></pre></td></tr></table></figure><h3 id="调整-Reduce-数"><a href="#调整-Reduce-数" class="headerlink" title="调整 Reduce 数"></a>调整 Reduce 数</h3><p>过多的 reduce 问题</p><ul><li>过多的 reduce， 会过多启动、初始化 reduce 消耗时间和资源</li><li>有多少个 reduce 就会有多少个输出文件，生成很多小文件，如果这些小文件作为下一个任务的输入，会出现小文件过多的问题</li><li><code>hive.exec.reducers.bytes.per.reducer=256000000</code>: 每个 reduce 处理的数据量默认为 256MB</li><li><code>hive.exec.reducers.max=1009</code>: 每个任务最大的 reduce 数，默认 1009</li><li><code>mapreduce.job.reduces</code>： 设置每个 job 的 reduce 个数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置每个 job 的 reduce 个数</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">15</span></span><br></pre></td></tr></table></figure><p>优化小结 Hadoop/Hive 处理数据过程，有几个显著特征：</p><ul><li>不怕数据多，就怕数据倾斜</li><li>对 job 数比较多的作业运行效率相对比较低</li><li>对 sum、count 等聚合操作而言，不存在数据倾斜问题</li><li>count(distinct) 效率较低，数据量大容易出问题</li></ul><p>优化可以从几个方面着手：</p><ul><li>好的模型设计，事半功倍</li><li>解决数据倾斜问题。根据配置和业务进行处理</li><li>减少 job 数</li><li>设置合理的map、reduce task 数</li><li>对小文件进行合并，是行之有效的提高 Hive 效率的方法</li><li>优化把握整体，单一作业的优化不如整体最优</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Hive 自带的序列化与反序列化</p><p><a href="https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe">https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide#DeveloperGuide-HiveSerDe</a></p><p>Hive 参数说明的官方文档：<a href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties">https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties</a></p><p><a href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html">Hive SQL的编译过程</a></p><p><a href="https://mp.weixin.qq.com/s/DfvN7S_00oYw1hqAQDr48g">Hive/HiveSQL常用优化方法全面总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;影响 Hive 效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、Job / IO过多、MapReduce 分配不合理等。&lt;/p&gt;
&lt;h2 id=&quot;架构优化&quot;&gt;&lt;a href=&quot;#架构优化&quot; class=&quot;headerlink&quot; title=&quot;架</summary>
      
    
    
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive 中的函数</title>
    <link href="http://example.com/2021/03/09/Hive-%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/03/09/Hive-%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-09T13:30:52.000Z</published>
    <updated>2021-04-21T08:41:04.808Z</updated>
    
    <content type="html"><![CDATA[<p>函数分类</p><ul><li><p>标准函数： 一列或多列作为参数传入，返回值是一个值的函数</p><p>如 to_date(string timestamp), sqrt(double a)</p></li><li><p>聚合函数： 接收0行、多行的列，返回单一的值</p></li><li><p>表生成函数： 接收 0 、 多个输入，产生多列 、 多行输出 如 explode</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> functions;</span><br><span class="line">desc function upper;</span><br><span class="line">desc function extended upper;</span><br></pre></td></tr></table></figure><h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>基础日期函数：</p><ul><li>current_date:</li><li>current_timestamp：</li><li>year(string date)</li><li>month(string date)</li><li>hour(string date)</li><li>minute(string date)</li><li>second(string date)</li><li><code>datediff(string enddate, string startdate)</code>: 计算时间差</li><li><code>from_unixtime(bigint unixtime[, string format])</code>：转换从 1970-01-01 00:00:00 UTC 开始的秒为日期</li><li><code>date_format(date/timestamp/string ts, string fmt)</code>： 日期、时间戳、字符串类型格式化输出标准时间格式</li><li>to_date(string timestamp)： 字符串转日期，2.1.0- 返回 String 类型，2.1.0+ 返回 date 类型</li><li><code>day(string date)</code> / <code>dayofmonth(date)</code>:  查询当月第几天</li><li><code>weekofyear(string date)</code>: 如weekofyear(“1970-11-01 00:00:00”) = 44, weekofyear(“1970-11-01”) = 44.</li></ul><p>相对日期相关的函数：</p><ul><li><p><code>last_day(string date)</code>：查询月末的最后一天</p></li><li><p><code>date_add(date/timestamp/string startdate, tinyint/smallint/int days)</code>： 增加指定多少天</p></li><li><pre><code>date_sub(date/timestamp/string startdate, tinyint/smallint/int days)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ： 减少指定多少天</span><br><span class="line"></span><br><span class="line">  - date_sub(current_date, dayofmonth(current_date)-1)：当月第一天</span><br><span class="line"></span><br><span class="line">- add_months(string start_date, int num_months, output_date_format)，</span><br><span class="line"></span><br><span class="line">  - add_months(date_sub(current_date, dayofmonth(current_date)-1), 1)： 下月第一天</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  next_day(string start_date, string day_of_week)</span><br></pre></td></tr></table></figure>： 返回第一个日期，该日期晚于 start_date 并命名为day_of_week。- day_of_week 为两个或三个字符，如 &quot;Mo&quot;, &quot;tue&quot;, &quot;FRIDAY&quot;- next_day(&#39;2021-03-26&#39;, &#39;mo&#39;) = 2021-03-29： 指定日期的下一个周一- date_add(next_day(&#39;2021-03-26&#39;, &#39;mo&#39;), -7) = 2021-03-22： 指定日期的上一个周一日期</code></pre></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">current_date</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURRENT_TIMESTAMP</span>();</span><br><span class="line"><span class="comment">-- unix 时间戳转换成日期</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">11111111</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">11111</span>, <span class="string">&#x27;yyyyMMdd&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1111111</span>, <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br><span class="line"><span class="comment">-- 日期转成时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">&#x27;2019-09-15 14:23:00&#x27;</span>);</span><br><span class="line"><span class="comment">-- 时间差, 返回日期相差的天数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2020-04-18&#x27;</span>, <span class="string">&#x27;2019-11-21&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">abs</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-04-18&#x27;</span>, <span class="string">&#x27;2019-11-21&#x27;</span>));</span><br><span class="line"><span class="comment">-- 日期为所处月的第几天</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>);</span><br><span class="line"><span class="comment">-- 日期所处月的最后一天日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">last_day</span>(<span class="keyword">current_date</span>);</span><br><span class="line"><span class="comment">-- 当月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">current_date</span>, <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 下月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> add_months(<span class="keyword">date_sub</span>(<span class="keyword">current_date</span>, <span class="keyword">dayofmonth</span>(<span class="keyword">current_date</span>) - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- must 字符串转换成 date yyyy-MM-dd</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020-01-01 12:12:12&#x27;</span>);</span><br><span class="line"><span class="comment">-- 日期格式化成指定的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="keyword">current_timestamp</span>(), <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="keyword">current_date</span>(), <span class="string">&#x27;yyyyMMdd&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_format</span>(<span class="string">&#x27;2020-06-01&#x27;</span>, <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>常用的日期处理</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 近3天的</span></span><br><span class="line"><span class="comment">-- 近一周的</span></span><br><span class="line">where dt &gt;= date_add(next_day(&#x27;$do_date&#x27;, &#x27;mo&#x27;), -7)</span><br><span class="line">    and dt &lt;= &#x27;$do_date&#x27;</span><br><span class="line"><span class="comment">-- 近一月的</span></span><br><span class="line">where dt &gt;= date_format(&#x27;$do_date&#x27;, &#x27;yyyy-MM-01&#x27;)</span><br><span class="line">    and dt &lt;= &#x27;$do_date&#x27;</span><br></pre></td></tr></table></figure><h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul><li><code>IF .. else</code></li><li><code>case when.. end &lt;column-name&gt;</code>: 多个条件的时候使用</li><li><code>nvl(T value, T default_value)</code>: value 为空的时候返回默认值</li><li><code>COALESCE(T v1, T v2, ...)</code>: 返回参数中第一个非空值</li><li><code>nullif(x, y)</code>:  相等为空，否则为x</li><li>isnull / isnull( a ):</li><li>assert_true(boolean condition): 不满足抛出异常</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试表定义</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> emp</span><br><span class="line">(</span><br><span class="line">    empno    <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;员工号&#x27;</span>,</span><br><span class="line">    ename    <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;员工姓名&#x27;</span>,</span><br><span class="line">    job      <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;工作名称&#x27;</span>,</span><br><span class="line">    mgr      <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    hiredate <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;雇佣日期&#x27;</span>,</span><br><span class="line">    sal      <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;薪水&#x27;</span>,</span><br><span class="line">    comm     <span class="built_in">int</span>,</span><br><span class="line">    deptno   <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">&#x27;部门号&#x27;</span></span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- if (boolean testCondition, T valueTrue, T valueFalseOrNull)</span></span><br><span class="line"><span class="comment">-- 将 emp 表的员工工资等级分类：0-1500、1500-3000、3000以上</span></span><br><span class="line"><span class="keyword">SELECT</span> sal,</span><br><span class="line">       <span class="keyword">if</span>(sal &lt;= <span class="number">1500</span>, <span class="string">&#x27;primary&#x27;</span>, </span><br><span class="line">       <span class="keyword">if</span>(sal &lt;= <span class="number">3000</span>, <span class="string">&#x27;middle&#x27;</span>, <span class="string">&#x27;advanced&#x27;</span>))</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">-- case when 判断</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">CASE</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;accounting&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">20</span> <span class="keyword">THEN</span> <span class="string">&#x27;research&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> deptno = <span class="number">30</span> <span class="keyword">THEN</span> <span class="string">&#x27;sales&#x27;</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="string">&#x27;unknown&#x27;</span> <span class="keyword">END</span> deptname</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">-- 返回参数中的第一个非空值；如果所有值都为 NULL，那么返回NULL</span></span><br><span class="line"><span class="keyword">select</span> sal, <span class="keyword">coalesce</span>(comm, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- null 判断</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> isnotnull(comm);</span><br><span class="line"><span class="comment">-- 空值转换函数 nvl(T value, T default_value)</span></span><br><span class="line"><span class="keyword">select</span> empno,</span><br><span class="line">       ename,</span><br><span class="line">       job,</span><br><span class="line">       mgr,</span><br><span class="line">       hiredate,</span><br><span class="line">       deptno,</span><br><span class="line">       sal + nvl(comm, <span class="number">0</span>) sumsal</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- nullif(x, y) 相等为空，否则为x  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">nullif</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>), <span class="keyword">nullif</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><code>lower</code>：</li><li><code>length</code>:</li><li><code>concat</code> / <code>||</code> ：字符拼接</li><li><code>concat_ws(separator, [string | array(string)]+)</code>: 可指定分隔符进行拼接</li><li><code>substr</code>： 求子串, 指定开始和结束索引</li><li><code>split</code>： <code>.</code> 需要进行正则转义</li><li>instr(string str, string substr)： 返回substr在str中第一次出现的位置</li><li>parse_url(string urlString, string partToExtract [, string keyToExtract])： 从 url 中抽取值，可抽取的值包括 HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.<ul><li>如 parse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;</a>, ‘HOST’) returns ‘<a href="http://facebook.com/">facebook.com</a>‘。</li></ul></li><li>regexp_extract(string subject, string pattern, int index)： 按照正则匹配值<ul><li>如 regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2)， Index 参数为 Java 的 group</li></ul></li><li>regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT):正则替换<ul><li>如 regexp_replace(“foobar”, “oo|ar”, “”) returns ‘fb.’</li></ul></li><li>get_json_object(string json_string, string path)： 从 JSON 字符串中获取特定路径值<ul><li>JSON 路径只能为 [0-9a-z_], 没有大写或特殊字符, keys 不可以以 数字开头</li></ul></li><li>str_to_map(text[, delimiter1, delimiter2])： 返回 map</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子串截取</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">split</span>(<span class="string">&quot;www.janhen.com&quot;</span>, <span class="string">&quot;\\\\.&quot;</span>);</span><br><span class="line"><span class="keyword">select</span> empno || <span class="string">&quot; &quot;</span> || ename idname</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串拼接  指定分割符拼接 concat_ws(separator, [string | array(string)]+)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="built_in">array</span>(<span class="string">&#x27;janhen&#x27;</span>, <span class="string">&#x27;com&#x27;</span>));</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="number">-5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substr</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>get_json_object 获取 JSON 字符串信息</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;store&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;fruit&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;weight&quot;</span>: <span class="number">8</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;apple&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;weight&quot;</span>: <span class="number">9</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pear&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;bicycle&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: <span class="number">19.95</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;amy@only_for_json_udf_test.net&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;owner&quot;</span>: <span class="string">&quot;amy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">-- 获取值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.owner&#x27;) FROM src_json;</span><br><span class="line">amy</span><br><span class="line">-- 获取数组值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.store.fruit\\[0]&#x27;) FROM src_json;</span><br><span class="line">&#123;<span class="attr">&quot;weight&quot;</span>:<span class="number">8</span>,<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line">-- 获取不存在的值</span><br><span class="line">SELECT get_json_object(src_json.json, &#x27;$.non_exist_key&#x27;) FROM src_json;</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li><code>round</code>: round x to d decimal places，可用于控制小数保留几位</li><li><code>ceil</code>:  向上取整</li><li><code>floor</code>:  向下取整。</li><li><code>exp(DOUBLE a)</code>, <code>exp(DECIMAL a)</code>:  指数函数</li><li>log10(DOUBLE a), log10(DECIMAL a)</li><li>log(DOUBLE base, DOUBLE a)</li><li>abs(DOUBLE a)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">314.15926</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">314.15926</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="number">3.1415926</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="number">3.1415926</span>);</span><br></pre></td></tr></table></figure><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul><li><code>size(Map&lt;K.V&gt;)</code> / <code>size(Array&lt;T&gt;)</code>： 返回元素个数</li><li><code>map_keys(Map&lt;K.V&gt;)</code> / <code>map_values(Map&lt;K.V&gt;)</code>: 将 Map 所有的 key、value 进行返回</li><li><code>array_contains(Array&lt;T&gt;, value):</code> 数组中是否包含某个值</li><li><code>sort_array(Array&lt;T&gt;)</code>： 对数组元素进行排序</li><li><code>concat_ws</code>： 将集合通过字符拼接起来</li></ul><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><ul><li>binary(string|binary)： 转换成二进制</li><li>cast(expr as <type>)： 类型转换，无法转换时，返回 NULL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="string">&#x27;23232&#x27;</span> <span class="keyword">AS</span> <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure><blockquote><p>UDTF</p></blockquote><h3 id="聚集函数-UDAF"><a href="#聚集函数-UDAF" class="headerlink" title="聚集函数(UDAF)"></a>聚集函数(UDAF)</h3><ul><li>count / sum / avg / min / max</li><li>collect_set(col): 将制定列聚集为一个 set，自动去重</li><li>collect_list(col)</li><li>ntile(INTEGER x): 将有序分区划分为x个称为存储桶的组，并为该分区中的每一行分配存储桶编号。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按照设备聚合用户，将 set 转换成一个 string 字段保存</span></span><br><span class="line"><span class="keyword">select</span> device_id, </span><br><span class="line">       <span class="keyword">concat_ws</span>(<span class="string">&#x27;|&#x27;</span>, collect_set(uid))</span><br><span class="line"><span class="keyword">from</span> start_log </span><br><span class="line"><span class="keyword">where</span> dt=<span class="string">&#x27;2021-01-01&#x27;</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> device_id;</span><br></pre></td></tr></table></figure><h3 id="表生成函数-UDTF"><a href="#表生成函数-UDTF" class="headerlink" title="表生成函数(UDTF)"></a>表生成函数(UDTF)</h3><blockquote><p>一行输入，多行输出</p></blockquote><p>配合 lateral view 进行使用，解决 UDTF 不能添加额外列的问题。</p><ul><li>explode(ARRAY<T> a)</li><li>explode(MAP&lt;Tkey,Tvalue&gt; m)</li><li>posexplode (array)： 带有原始位置的炸裂函数</li><li>json_tuple(string jsonStr,string k1,…,string kn)</li><li>parse_url_tuple(string urlStr,string p1,…,string pn)</li></ul><p><strong>explode 炸裂数组/Map值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lateral view 常与表生成函数 explode 结合使用，处理上述问题</span></span><br><span class="line"><span class="comment">-- ==&gt;  解决 UDTF 不能添加额外列的问题</span></span><br><span class="line"><span class="comment">-- lateral view udtf(expression) tableALias as  ...</span></span><br><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">&#x27;OK&#x27;</span> cola, <span class="keyword">split</span>(<span class="string">&#x27;www.janhen.com&#x27;</span>, <span class="string">&#x27;\\\\.&#x27;</span>) colb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> cola, colc</span><br><span class="line"><span class="keyword">from</span> t1 <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(colb) t2 <span class="keyword">as</span> colc;</span><br><span class="line">lateral view udtf(expression) tableALias as &lt;col1&gt;, &lt;col2&gt; ...</span><br><span class="line"><span class="comment">-- 炸裂 map 并给定别名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">explode</span>(<span class="keyword">map</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">30</span>)) <span class="keyword">as</span> (<span class="keyword">key</span>,<span class="keyword">value</span>);</span><br><span class="line">key value</span><br><span class="line">A10</span><br><span class="line">B20</span><br><span class="line">C30</span><br><span class="line"><span class="keyword">select</span> posexplode(<span class="built_in">array</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)) <span class="keyword">as</span> (pos,val);</span><br><span class="line">pos val</span><br><span class="line">2C</span><br><span class="line">1B</span><br><span class="line">0A</span><br></pre></td></tr></table></figure><p><strong>json_tuple 获取 JSON 多个值拆开</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.timestamp, b.*</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">log</span> a <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(a.appevent, <span class="string">&#x27;eventid&#x27;</span>, <span class="string">&#x27;eventname&#x27;</span>) b <span class="keyword">as</span> f1, f2;</span><br></pre></td></tr></table></figure><p><strong>parse_url_tuple 获取 URL 中的多个信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.*</span><br><span class="line"><span class="keyword">FROM</span> src <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> parse_url_tuple(fullurl, <span class="string">&#x27;HOST&#x27;</span>, <span class="string">&#x27;PATH&#x27;</span>, <span class="string">&#x27;QUERY&#x27;</span>, <span class="string">&#x27;QUERY:id&#x27;</span>) b <span class="keyword">as</span> host, <span class="keyword">path</span>, <span class="keyword">query</span>, query_id </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>脱敏函数： 对姓名、电话号码进行脱敏，不显示全部内容</p><ul><li>mask(string str[, string upper[, string lower[, string number]]]):<ul><li>如 mask(“abcd-EFGH-8765-4321”, “U”, “l”, “#”) results in llll-UUUU-####-####.</li></ul></li><li>collect_list： 列出该字段的所有值，不去重</li><li>current_user()： 当前用户</li><li>md5(string/binary)</li><li>version()</li></ul><h2 id="窗口与分析函数"><a href="#窗口与分析函数" class="headerlink" title="窗口与分析函数"></a>窗口与分析函数</h2><blockquote><p>和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。数据窗口大小可能会随着行的变化而变化。</p></blockquote><p><strong>窗口函数</strong></p><ul><li>使用之前一般要通过 <code>over()</code> 进行开窗</li><li>针对每一行数据的，若 over 中没有参数，默认是全部的结果集</li></ul><p><strong>partition by 子句</strong></p><ul><li>在 over 窗口中进行分区，对某一列进行分区统计，窗口的大小就是分区的大小</li></ul><p><strong>order by 子句</strong></p><ul><li>对输入的数据进行排序，有 order by 缺少 window 子句，默认窗口为 <code>range between unbounded preceding and current row</code></li></ul><p><strong>over 子句</strong></p><ul><li>后面可指定标准的聚集函数， count, sum, min, max, avg</li><li>使用 PARTITION BY 语句，具有任何原始数据类型的一个或多个分区列</li><li>带有 PARTITION BY 和 ORDER BY 以及任何数据类型的一个或多个分区和/或排序列，<ul><li>带有窗口规格，Windows 可以在 WINDOW 子句中单独定义。</li></ul></li></ul><p><strong>Window 子句</strong></p><p>窗口规范支持以下格式：</p><ul><li>指定 order by 并缺少 window 子句时，window 默认被指定为 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li><li>当同时缺少 order by 和 window 子句时，默认窗口指定为 <code>ROW BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li><li>不支持 Rank 函数， rank、ntile、denseRank、cusmeDis、percentRank，不支持 Lead 和 Lag 函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ROWS | RANGE) BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)</span><br><span class="line">(ROWS | RANGE) BETWEEN CURRENT ROW AND (CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)</span><br><span class="line">(ROWS | RANGE) BETWEEN [num] FOLLOWING AND (UNBOUNDED | [num]) FOLLOWING</span><br></pre></td></tr></table></figure><h3 id="窗口范围"><a href="#窗口范围" class="headerlink" title="窗口范围"></a>窗口范围</h3><ul><li>unbounded preceding: 组内第一行数据</li><li>n preceding: 组内当前行的前n行数据</li><li>current row: 当前行数据</li><li>n following: 组内当前行的后 n 行数据</li><li>unbounded following: 组内最后一行数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工姓名、薪水、部门薪水总和、占部门薪水的百分比</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno) depsalsum,</span><br><span class="line">       <span class="keyword">round</span>(sal / <span class="keyword">sum</span>(sal) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno) * <span class="number">100</span>, <span class="number">2</span>) || <span class="string">&#x27;%&#x27;</span> salofdeptsumpercent</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 等价。组内，第一行 ~ 当前行的和</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 组内，第一行 ~ 最后一行的和</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 组内，按照分区前后两行和当前行的总和，前一行 + 当前行 + 后一行</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       deptno,</span><br><span class="line">       <span class="keyword">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> ename <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span> )</span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h3 id="排名函数"><a href="#排名函数" class="headerlink" title="排名函数"></a>排名函数</h3><ul><li><code>row_number()</code>: 排名顺序增加不会重复</li><li><code>RANK()</code>: 排名相等会在名次中留下空位；如 1、2、2、4、5、…</li><li><code>DENSE_RANK()</code>: 排名相等会在名次中不会留下空位 ；如1、2、2、3、4、…</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t2</span><br><span class="line">(</span><br><span class="line">    cname <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;课程名&#x27;</span>,</span><br><span class="line">    sname <span class="keyword">string</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学生名&#x27;</span>,</span><br><span class="line">    score <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;课程分数&#x27;</span></span><br><span class="line">) <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">-- 求每个班级前3名的学员 </span></span><br><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cname, </span><br><span class="line">           sname, </span><br><span class="line">           score, </span><br><span class="line">           <span class="keyword">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cname <span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">rank</span></span><br><span class="line">    <span class="keyword">FROM</span> t2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> cname, sname, score, <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> tmp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rank</span> &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h3><ul><li><code>lag</code>: 返回当前数据行的上一行数据 常用</li><li><code>lead</code>: 返回当前数据行的下一行数据 常用</li><li><code>first_value</code>: 取分组内排序后，截止到当前行，第一个值</li><li><code>last_value</code>: 分组内排序后，截止到当前行，最后一个值</li><li><code>ntile</code>: 将分组的数据按照顺序切分成n片，返回当前切片值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> userpv (</span><br><span class="line">    cid   <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    ctime <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;时间&#x27;</span>,</span><br><span class="line">    pv    <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;页面访问次数&#x27;</span></span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="comment">-- 上两行数据， 下三行数据</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       lag(pv, <span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime)  lagpv,</span><br><span class="line">       <span class="keyword">lead</span>(pv, <span class="number">3</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime) leadpv</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- first_value 分组排序截止到当前行第一个值 / last_value 分组排序后截止到当前行最后一个值</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       <span class="keyword">first_value</span>(pv) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) firstpv,</span><br><span class="line">       <span class="keyword">last_value</span>(pv) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) lastpv</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- ntile 按照cid进行分组并按照 ctime 排序，将分组内的数据平均分成 2 份</span></span><br><span class="line"><span class="keyword">select</span> cid,</span><br><span class="line">       ctime,</span><br><span class="line">       pv,</span><br><span class="line">       ntile(<span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> ctime) ntile</span><br><span class="line"><span class="keyword">from</span> userpv;</span><br><span class="line"><span class="comment">-- LAG specifying a lag of 3 rows and default value of 0</span></span><br><span class="line"><span class="keyword">SELECT</span> a, </span><br><span class="line">       LAG(a, <span class="number">3</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> b <span class="keyword">ORDER</span> <span class="keyword">BY</span> C)</span><br><span class="line"><span class="keyword">FROM</span> T;</span><br></pre></td></tr></table></figure><h2 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h2><p><strong>临时性添加函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- hive add jar</span></span><br><span class="line">add jar /home/hadoop/udf.jar</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">function</span> myconcat <span class="keyword">as</span> <span class="string">&#x27;con.janhen.hive.udaf.ConcatUDAF&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> FUNCTIONS;</span><br></pre></td></tr></table></figure><p><strong>永久添加到 Hive 中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jar ==&gt; hdfs </span></span><br><span class="line">hdfs dfs -put hiveudf.jar /user/hadoop/jar/</span><br><span class="line">-- 加载函数</span><br><span class="line">create <span class="keyword">function</span> mynvl2 as <span class="string">&#x27;com.janhen.bigdata.hive.nvl&#x27;</span></span><br><span class="line">    using jar <span class="string">&#x27;hdfs:/user/hadoop/jar/hiveudf.jar&#x27;</span>;</span><br><span class="line">show <span class="built_in">functions</span>;</span><br><span class="line">drop <span class="keyword">function</span> mynvl2;</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-Built-inFunctions">Built-in Functions</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics">Windowing and Analytics Functions</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标准函数： 一列或多列作为参数传入，返回值是一个值的函数&lt;/p&gt;
&lt;p&gt;如 to_date(string timestamp), sqrt(double a)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;聚合函数： 接收0行、多行的列，返回单</summary>
      
    
    
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive-HQL</title>
    <link href="http://example.com/2021/03/09/Hive-HQL/"/>
    <id>http://example.com/2021/03/09/Hive-HQL/</id>
    <published>2021-03-09T13:28:56.000Z</published>
    <updated>2021-04-09T09:06:31.713Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>并不是所有的 HQL 都会被 Hive 转换成 MR 作业执行</p><p>HQL 是一种 SQL 方案，支持绝大部分的 SQL-92 标准</p><p>不支持行级别草俎哦、不支持事务</p><p>对于简单不需要聚合的操作，如 <code>SELECT .. FROM xx LIMIT n</code>，直接通过 FetchTask 获取数据</p><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p><strong>装载数据</strong></p><ul><li>LOCAL：<ul><li>LOAD DATA LOCAL …：从本地文件系统加载数据到Hive表中</li><li>LOAD DATA …：从HDFS加载数据到Hive表中</li></ul></li><li>INPATH：加载数据的路径</li><li>OVERWRITE：覆盖表中已有数据；否则表示追加数据</li><li>PARTITION：将数据加载到指定的分区</li></ul><p>一旦该表存在分区，那么在数据在加载时必须加载进入指定分区中，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加载数据并指定分区，HDFS文件，已经被转移</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;/user/hadoop/data&#x27;</span> <span class="keyword">INTO</span> student_info <span class="keyword">PARTITION</span>(province=<span class="string">&#x27;sichuan&#x27;</span>, city=<span class="string">&#x27;chengdu&#x27;</span>);</span><br><span class="line"><span class="comment">-- 加载数据覆盖表中已有数据</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;data/sourceA.txt&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tabA;</span><br><span class="line"><span class="comment">-- 加载数据，覆盖表的数据，到指定的分区</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">&#x27;/user/hadoop/o&#x27;</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test3 <span class="keyword">PARTITION</span> (part = <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">-- 更改表的存储位置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (x = x1, y = y2) <span class="keyword">SET</span> LOCATION <span class="string">&#x27;/user/test/x1/y1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> tabC <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">&#x27;202001&#x27;</span>) <span class="keyword">values</span> (<span class="number">5</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;BJ&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;lishi&#x27;</span>, <span class="string">&#x27;SH&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;TJ&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入查询的结果数据 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> tabC <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">&#x27;202002&#x27;</span>) <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, area <span class="keyword">from</span> tabC <span class="keyword">where</span> <span class="keyword">month</span>=<span class="string">&#x27;202001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>创建表并插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> tabD <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> tabC;</span><br></pre></td></tr></table></figure><p><strong>多表（多分区）插入模式</strong></p><p>一次查询，产生多个不相交的输出</p><p>Hive还有一个很有用的特性，可以通过一次查询，产生多个不相交的输出。</p><p>这样只通过对source表的一次查询，就将符合条件的数据插入test表的各个分区，非常方便</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个查询差生多个不相交的输出</span></span><br><span class="line">FROM source</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">0</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">100</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">100</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">200</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span> (part = <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= <span class="number">200</span> <span class="keyword">AND</span> <span class="keyword">id</span> &lt; <span class="number">300</span></span><br></pre></td></tr></table></figure><p><strong>import 导入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import table student2 partition(month=&#x27;201709&#x27;) from &#x27;/user/hive/warehouse/export/student&#x27;;</span><br></pre></td></tr></table></figure><h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><ul><li>将结果导出到本地</li><li>将查询结果格式化到本地</li><li>将结果导出到 HDFS</li><li>通过 DataX、Sqoop 等工具将结果导出到 HBase、MySQL等其他地方</li></ul><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">change</span> <span class="keyword">column</span> <span class="keyword">id</span> cid <span class="built_in">int</span>;</span><br><span class="line"><span class="comment">-- 增加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">add</span> <span class="keyword">columns</span> (common <span class="keyword">string</span>);</span><br><span class="line"><span class="comment">-- 删除字段：replace columns</span></span><br><span class="line"><span class="comment">-- 在元数据中删除了字段，并没有改动hdfs上的数据文件</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course_common1 <span class="keyword">replace</span> <span class="keyword">columns</span>( <span class="keyword">id</span> <span class="keyword">string</span>, cname <span class="keyword">string</span>, score <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p><img src="http://img.janhen.com/202103030859484G2IXM.png" alt="http://img.janhen.com/202103030859484G2IXM.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dfs -ls /user/hive/warehouse;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exit</span> <span class="keyword">comment</span> <span class="string">&#x27;test comment&#x27;</span> location <span class="string">&#x27;/usr/hive/mydb2.dbe&#x27;</span>;</span><br><span class="line">desc database extended mydb2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连同表一起删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">test</span> <span class="keyword">CASCADE</span>;</span><br><span class="line">DESC EXTENDED student;</span><br><span class="line">DESC FORMATTED student;</span><br><span class="line"><span class="comment">-- 根据其他表创建新的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test.student2 <span class="keyword">LIKE</span> test.student;</span><br></pre></td></tr></table></figure><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><ul><li>CREATE TABLE [IF NOT EXISTS]：创建表</li><li>EXTERNAL： 外部表创建，生产中一般创建的都是外部表，删除表不删除数据</li><li>comment： 表注释</li><li>partition by： 对表中数据进行分区</li><li>clustered by： 建立分桶表</li><li>sorted by： 对表中的一个或多个字段进行排序，较少使用</li><li>存储子句:  可指定 SerDe, 默认没有使用 ROW FORMAT 或者 ROW FORMAT DELIMITED，会默认使用 SerDe。建表时需要为表指定列在指定列的同 时也会指定自定义的 SerDe。<strong>hive使用 Serde 进行行对象的序列与反序列化。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] </span><br><span class="line">[COLLECTION ITEMS TERMINATED BY char] </span><br><span class="line">[MAP KEYS TERMINATED BY char] </span><br><span class="line">[LINES TERMINATED BY char] | </span><br><span class="line">SERDE serde_name </span><br><span class="line">[<span class="keyword">WITH</span> SERDEPROPERTIES (property_name=property_value, </span><br><span class="line">  property_name=property_value, ...)]</span><br></pre></td></tr></table></figure><ul><li>stored as SEQUENCEFILE|TEXTFILE|RCFILE</li><li>LOCATION： 表在 HDFS 上的位置</li><li>TBLPROPERTIES：定义表的属性</li><li>AS： 接查询语句，根据查询结果建表</li><li>LIKE： 复制现有的表结构，不会复制数据</li></ul><h3 id="内外部表"><a href="#内外部表" class="headerlink" title="内外部表"></a>内外部表</h3><p>表的类型有两种，分别是内部表(管理表)、外部 表。</p><ul><li>默认情况下，创建内部表</li><li>删除内部表，表的元数据和数据一起删除</li><li>删除外部表，删除表的定义，数据保留</li><li>生产环境中，多使用外部表</li><li>外部表不能执行 <code>TRUNCATE</code></li></ul><p>表类型转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内部表转外部表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">SET</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;TRUE&#x27;</span>);</span><br><span class="line"><span class="comment">-- 外部表转内部表。EXTERNAL 大写，false 不区分大小</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;FALSE&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><blockquote><p>按照分区字段将表中的数据放置在不同的目录中，提高SQL查询的 性能</p></blockquote><p>Hive没有索引，分区的作用和索引非常类似，可将其看做一种简易索引。对于直接命中分区的查询，Hive不会执行MapReduce作业。</p><p><strong>分区字段不是表中已经存在的数据，可以将分区字段看成伪列。</strong></p><p><strong>分区查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看分区</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> student_info;</span><br></pre></td></tr></table></figure><p><strong>新增分区，加载数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加分区，不加载数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-03&#x27;</span>);</span><br><span class="line"><span class="comment">-- 增加多个分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-05&#x27;</span>) <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-06&#x27;</span>);</span><br><span class="line"><span class="comment">-- 增加分区，加载数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">add</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-07&#x27;</span>) location <span class="string">&#x27;/user/hive/warehouse/mydb.db/t3/dt=2020-06-07&#x27;</span> </span><br><span class="line"><span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-08&#x27;</span>) location <span class="string">&#x27;/user/hive/warehouse/mydb.db/t3/dt=2020-06-08&#x27;</span>;</span><br><span class="line"><span class="comment">-- 单独为外部表的分区键指定值和存储位置：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student _info <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (province = sichuan, city = chengdu) LOCATION <span class="string">&#x27;hdfs://master:9000/student/sichuan/chengdu&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>修改分区的hdfs路径</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-01&#x27;</span>) <span class="keyword">set</span> location <span class="string">&#x27;/user/hive/warehouse/t3/dt=2020-06-03&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>删除分区</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t3 <span class="keyword">drop</span> <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-03&#x27;</span>), <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-06-04&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>动态分区</strong></p><p>Hive 会根据 SELECT 语句中的最后一个查询字段作为动态分区的依据，而不是根据字段名来选择。如果指定了 n 个动态分区的字段，Hive 会将 select 语句中最后 n 个字段作为动态分区的依据。 Hive 默认没有开启动态分区，在执行这条语句前，必须对Hive进行一些参数设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启自动分区</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">PARTITION</span>(<span class="built_in">time</span>) <span class="keyword">SELECT</span> <span class="keyword">id</span>, modify_time <span class="keyword">FROM</span> <span class="keyword">source</span>;</span><br></pre></td></tr></table></figure><h3 id="分桶表"><a href="#分桶表" class="headerlink" title="分桶表"></a>分桶表</h3><blockquote><p>分区不能更细粒度的划分数据，就需要使用分桶 技术将数据划分成更细的粒度。 使用 <code>cluster by &lt;col-name&gt; into &lt;num&gt; buckets</code></p></blockquote><p>分桶的原理</p><ul><li>MR 中： key.hashCode % reduceTask</li><li>Hive 中： 分桶字段.hashCode % 分桶个数</li></ul><p><strong>分桶表创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course( </span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>, </span><br><span class="line">  <span class="keyword">name</span> <span class="keyword">string</span>, </span><br><span class="line">  score <span class="built_in">int</span> ) </span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) <span class="keyword">into</span> <span class="number">3</span> buckets </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;\\t&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>分桶表加载数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通表加载数据 </span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/data/course.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> course_common;</span><br><span class="line"><span class="comment">-- 通过 insert ... select ... 给桶表加载数据 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> course <span class="keyword">select</span> * <span class="keyword">from</span> course_common;</span><br></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>SELECT</p><ul><li>SQL语句对大小写不敏感</li><li>各子句一般要分行</li></ul><h3 id="where-过滤"><a href="#where-过滤" class="headerlink" title="where 过滤"></a>where 过滤</h3><p><strong>正则匹配过滤</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正则匹配，使用 rlike。正则表达式，名字以A或S开头</span></span><br><span class="line"><span class="keyword">select</span> ename, </span><br><span class="line">   salfrom emp</span><br><span class="line"><span class="keyword">where</span> ename <span class="keyword">rlike</span> <span class="string">&#x27;^(A|S).*&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="lateral-view"><a href="#lateral-view" class="headerlink" title="lateral view"></a>lateral view</h3><blockquote><p>lateral view 首先将UDTF应用于基础表的每一行，然后将结果输出行与输入行连接起来以形成具有提供的表别名的虚拟表。</p></blockquote><p>语法</p><ul><li>从 0.12.0 开始列别名可省略，从 UTDF 返回的 StructObjectInspector 的字段名称继承</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateralView: LATERAL VIEW udtf(expression) tableAlias AS columnAlias (&#x27;,&#x27; columnAlias)*</span><br><span class="line">fromClause: FROM baseTable (lateralView)*</span><br></pre></td></tr></table></figure><p><strong>使用案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> pageAds(</span><br><span class="line">  pageid <span class="keyword">string</span>,</span><br><span class="line">  adid_list <span class="built_in">Array</span>&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">);</span><br><span class="line">pageid      adid_list</span><br><span class="line">front_page   [1,2,3]</span><br><span class="line">contact_page [3,4,5]</span><br><span class="line"><span class="comment">-- 页面对应的广告</span></span><br><span class="line"><span class="keyword">SELECT</span> pageid, adid</span><br><span class="line"><span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br><span class="line"><span class="comment">-- 查看特定广告的展示次数</span></span><br><span class="line"><span class="keyword">SELECT</span> adid, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> adcnt</span><br><span class="line"><span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br><span class="line">pageid(string)    adid(int)</span><br><span class="line">&quot;front_page&quot;      1</span><br><span class="line">&quot;front_page&quot;      2</span><br><span class="line">&quot;front_page&quot;      3</span><br><span class="line">&quot;contact_page&quot;    3</span><br><span class="line">&quot;contact_page&quot;    4</span><br><span class="line">&quot;contact_page&quot;    5</span><br><span class="line"></span><br><span class="line">adid    adcnt</span><br><span class="line">1          1</span><br><span class="line">2          1</span><br><span class="line">3          2</span><br><span class="line">4          1</span><br><span class="line">5          1</span><br></pre></td></tr></table></figure><p><strong>多个 lateral view</strong></p><ul><li>from clause 可有多个 lateral view</li><li>后续的 LATERAL VIEWS可以引用 LATERAL VIEW 左侧出现的任何表中的列。</li></ul><h3 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br><span class="line"><span class="comment">-- 左外连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">left</span> <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br><span class="line"><span class="comment">-- 全外连接 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1 <span class="keyword">full</span> <span class="keyword">join</span> u2 <span class="keyword">on</span> u1.id = u2.id;</span><br></pre></td></tr></table></figure><p><strong>多表连接</strong></p><p>Hive 总是按照从左到右的顺序执行，Hive 会对每对 JOIN 连接对象启动一个 MapReduce 任务。</p><p>会首先启动一个 MapReduce job 对表 t 和表 c 进行连接操作；然后再 启动一个 MapReduce job 将第一个 MapReduce job 的输出和表 s 进行连接操作； 然后再继续直到全部操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> techer t </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> score s <span class="keyword">on</span> s.c_id = c.c_id </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> student stu <span class="keyword">on</span> s.s_id = stu.s_id;</span><br></pre></td></tr></table></figure><p><strong>笛卡尔积</strong></p><p>满足下列条件</p><ul><li>没有连接条件</li><li>连接条件无效</li><li>所有表中的所有行互相连接</li></ul><p>Hive 默认不支持笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.strict.checks.cartesian.product=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> u1, u2;</span><br></pre></td></tr></table></figure><h3 id="排序子句"><a href="#排序子句" class="headerlink" title="排序子句"></a>排序子句</h3><p><strong>MR 全局排序</strong></p><ul><li>排序字段需要出现在 select 字段中</li><li>ORDER BY 执行全局排序，只有一个 reduce</li><li>输出规模较大时，耗时高</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多列排序 </span></span><br><span class="line"><span class="keyword">select</span> empno, </span><br><span class="line">       ename, </span><br><span class="line">       job, mgr, </span><br><span class="line"> sal + nvl(comm, <span class="number">0</span>) salcomm, </span><br><span class="line">   deptno </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> deptno, salcomm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>MR 的内部排序(sort by)</strong></p><p>sort by 为每个 reduce 产生排序文件，在 reduce 内部进行排序，得到局部有序的结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置reduce个数</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 按照工资降序查看员工信息 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">sort</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 将查询结果导入到文件中（按照工资降序）。生成两个输出文件，每个文件内部数据按 工资降序排列 </span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/home/hadoop/output/sortsal&#x27;</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">sort</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>MR 分区排序(distribute by)</strong></p><ul><li>将特定的行发送到特定的 reducer 中</li><li>distribute by 要写在 sort by 之前</li><li>可结合 sort by 操作，使分区数据有序</li><li>类似于 MR 中的分区操作</li><li>按照指定的条件将数据分组，常结合 sort by 使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先按 deptno 分区，在分区内按照 sal + comm 排序</span></span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  empno,       </span><br><span class="line">  ename,       </span><br><span class="line">  job,       </span><br><span class="line">  deptno,       </span><br><span class="line">  sal + nvl(comm, <span class="number">0</span>) salcomm</span><br><span class="line"><span class="keyword">FROM</span> emp    </span><br><span class="line"><span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> deptno    </span><br><span class="line"><span class="keyword">SORT</span> <span class="keyword">BY</span> sal comm <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 将数据分到 3 个区中，每个分区都有数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/home/hadoop/output/distBy1&#x27;</span> </span><br><span class="line"><span class="keyword">select</span> empno, </span><br><span class="line"> ename, </span><br><span class="line"> job, </span><br><span class="line"> deptno, </span><br><span class="line"> sal + nvl(comm, <span class="number">0</span>) salcomm </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">distribute</span> <span class="keyword">by</span> deptno </span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> salcomm <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>Cluster By</strong></p><ul><li>distribute by 与 sort by 为同一个字段时，使用 cluster by 简化语法</li><li>只能是升序，不能指定排序规则</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="HQL-与-MR"><a href="#HQL-与-MR" class="headerlink" title="HQL 与 MR"></a>HQL 与 MR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hive SQL </span><br><span class="line">&#x3D;&#x3D;&gt; AST(抽象语法树) </span><br><span class="line">&#x3D;&#x3D;&gt; QB(查询块) </span><br><span class="line">&#x3D;&#x3D;&gt; OperatorTree(操作树) </span><br><span class="line">&#x3D;&#x3D;&gt; 优化后的操作树 </span><br><span class="line">&#x3D;&#x3D;&gt; MapReduce 任务树 </span><br><span class="line">&#x3D;&#x3D;&gt; 优化后的 MapReduce 任务树</span><br></pre></td></tr></table></figure><p>过程描述如下：</p><ul><li>SQL Parser：Antlr定义SQL的语法规则，完成SQL词法，语法解析，将SQL转化为抽象语法树AST Tree；</li><li>Semantic Analyzer：遍历AST Tree，抽象出查询的基本组成单元QueryBlock；</li><li>Logical plan：遍历QueryBlock，翻译为执行操作树OperatorTree；</li><li>Logical plan optimizer: 逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量；</li><li>Physical plan：遍历OperatorTree，翻译为MapReduce任务；</li><li>Logical plan optimizer：物理层优化器进行MapReduce任务的变换，生成最终的执行计划。</li></ul><h3 id="Join-与-MR"><a href="#Join-与-MR" class="headerlink" title="Join 与 MR"></a>Join 与 MR</h3><ul><li>如果其中有一张表为小表，直接使用 map 端 join 的方式（map端加载小表）进行聚合。</li><li>如果两张都是大表，那么采用联合 key，联合 key 的第一个组成部分是 join on 中的公共字段，第二部分是一个 flag，0 代表表 A，1 代表表 B，由此让 Reduce 区分 join 表的信息；在Mapper中同时处理两张表的信息，将 join on 公共字段相同的数据划分到同一个分区中，进而传递到一个 Reduce 中，然后在 Reduce 中实现聚合。</li></ul><p>如果对于每个表在 join 子句中使用相同的列，则 Hive 将多个表上的联接转换为单个map / reduce作业</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.val, b.val, c.val </span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key = b.key1) </span><br><span class="line"><span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key = b.key1)</span><br></pre></td></tr></table></figure><p>对于 join 使用不同的列，</p><ul><li>第一个 map / reduce 作业将 a 与 b 联接在一起，然后将结果与 c 联接到第二个 map / reduce 作业中。</li><li>第一个将 a 与 b 连接起来，并缓冲a的值，同时在减速器中流式传输b的值</li><li>第二个将缓冲第一个连接的结果，同时将c的值通过简化器流式传输</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.val, b.val, c.val </span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key = b.key1) </span><br><span class="line"><span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key = b.key2)</span><br></pre></td></tr></table></figure><p>可指定流式传输的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ STREAMTABLE(a) */</span> a.val, b.val, c.val <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key = b.key1) <span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key = b.key1)</span><br></pre></td></tr></table></figure><p>如果除一个要连接的表之外的所有表都很小，则可以将其作为仅 Map 作业执行。</p><p>无需进行 reduce, 对于 A 的 mapper B 都会完全读取。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MAPJOIN(b) */</span> a.key, a.value</span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.key = b.key;</span><br></pre></td></tr></table></figure><p>Join 相关的配置参数：</p><ul><li>hive.auto.convert.join： 如果可能，在运行时自动将联接转换为mapjoins</li><li>hive.auto.convert.join.noconditionaltask：Hive是否启用基于输入文件大小的有关将公共联接转换为mapjoin的优化。</li><li>hive.auto.convert.join.noconditionaltask.size： 如果hive.auto.convert.join.noconditionaltask关闭，则此参数不起作用。</li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>HQL 的执行过程</p><p>通常情况下NULL参与运算，返回值为 NULL</p><p><strong>NULL&lt;=&gt;NULL 的结果为 true</strong>，一般对 NULL 的比较实用 ISNULL 函数</p><h3 id="Json-数据处理"><a href="#Json-数据处理" class="headerlink" title="Json 数据处理"></a>Json 数据处理</h3><p>Hive 处理 json 数据的方式</p><ul><li>内建的函数 get_json_object</li><li>自定义 UDF 函数</li><li>使用序列化反序列化工具</li></ul><p><strong>方式一:  内建的函数处理</strong></p><p>处理简单的 json 串。</p><ul><li><code>get_json_object(string json_string, string path)</code>: 解析 json 字符串 json_string，返回 path 指定的内容；</li><li><code>json_tuple(jsonStr, k1, k2, ...)</code>: ：参数为一组键k1，k2，…和json字符串，返回值的元组。该方法比  get_json_object 高效，可以在一次调用中输入多个键, 对嵌套结果的解析操作复杂；</li><li><code>explode</code> / <code>lateral view</code>，使用explod将Hive一行中复杂的 array 或 map 结构拆分成多行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> jsont1( </span><br><span class="line">  username <span class="keyword">string</span>, </span><br><span class="line">  age <span class="built_in">int</span>, </span><br><span class="line">  sex <span class="keyword">string</span>, </span><br><span class="line">  <span class="keyword">json</span> <span class="keyword">string</span> </span><br><span class="line">) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/root/lagoudw/data/weibo.json&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> jsont1;</span><br><span class="line"><span class="comment">-- get 单层值 </span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.id&quot;</span>) <span class="keyword">id</span>, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids&quot;</span>) ids, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.total_number&quot;</span>) <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br><span class="line"><span class="comment">-- get 数组</span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.id&quot;</span>) <span class="keyword">id</span>, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[0]&quot;</span>) ids0, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[1]&quot;</span>) ids1, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[2]&quot;</span>) ids2, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.ids[3]&quot;</span>) ids3, </span><br><span class="line">  get_json_object(<span class="keyword">json</span>, <span class="string">&quot;$.total_number&quot;</span>) <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br><span class="line"><span class="comment">-- json_tuple 一次处理多个字段</span></span><br><span class="line"><span class="keyword">select</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ids&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br></pre></td></tr></table></figure><p>含其他字段时，不能直接展开，需要使用 explod 展开</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 拆分 json</span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, ids, <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ids&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, ids, <span class="keyword">num</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拆分 JSON -&gt; 拆分 jsonarray</span></span><br><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span>( <span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, ids, <span class="keyword">num</span></span><br><span class="line">            <span class="keyword">from</span> jsont1 </span><br><span class="line">            <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ids&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, ids, <span class="keyword">num</span> ) </span><br><span class="line"><span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, ids1, <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> tmp </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(<span class="keyword">split</span>(regexp_replace(ids, <span class="string">&quot;\\\\[|\\\\]&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="string">&quot;,&quot;</span>)) t1 <span class="keyword">as</span> ids1;</span><br></pre></td></tr></table></figure><p><strong>方式二: 使用 UDF 处理</strong></p><p>能处理大部分数据，更灵活。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建临时函数</span></span><br><span class="line">add jar /root/lagoudw/jars/bigdata-hive-1.0-SNAPSHOT.jar;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">function</span> json_json_array <span class="keyword">as</span> <span class="string">&quot;com.janhen.bigdata.hive.ParseJsonArray&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username, age, sex, parse_json_array(<span class="keyword">json</span>, <span class="string">&quot;ids&quot;</span>) ids </span><br><span class="line"><span class="keyword">from</span> jsont1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username, age, sex, ids1 </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(parse_json_array(<span class="keyword">json</span>, <span class="string">&quot;ids&quot;</span>)) t1 <span class="keyword">as</span> ids1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username, age, sex, <span class="keyword">id</span>, <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, <span class="keyword">num</span>;</span><br><span class="line"><span class="comment">-- 合并</span></span><br><span class="line"><span class="keyword">select</span> username, age, sex, ids1, <span class="keyword">id</span>, <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">from</span> jsont1 </span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(parse_json_array(<span class="keyword">json</span>, <span class="string">&quot;ids&quot;</span>)) t1 <span class="keyword">as</span> ids1 </span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> json_tuple(<span class="keyword">json</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;total_number&#x27;</span>) t1 <span class="keyword">as</span> <span class="keyword">id</span>, <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p><strong>方式三: 使用SerDe处理</strong></p><p>对象的序列化用途：</p><ul><li>把对象转换成字节序列后保存到文件中</li><li>对象数据的网络传送</li><li>可以在表创建的时候指定 SerDe，之后无需指定分割符之类的信息</li></ul><p>Read : HDFS files =&gt; InputFileFormat =&gt; &lt;key, value&gt; =&gt; Deserializer =&gt; Row object</p><p>Write : Row object =&gt; Seriallizer =&gt; &lt;key, value&gt; =&gt; OutputFileFormat =&gt; HDFS files</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;: 1,&quot;ids&quot;: [101,102,103],&quot;total_number&quot;: 3&#125;</span><br><span class="line">&#123;&quot;id&quot;: 2,&quot;ids&quot;: [201,202,203,204],&quot;total_number&quot;: 4&#125;</span><br><span class="line">&#123;&quot;id&quot;: 3,&quot;ids&quot;: [301,302,303,304,305],&quot;total_number&quot;: 5&#125;</span><br><span class="line">&#123;&quot;id&quot;: 4,&quot;ids&quot;: [401,402,403,304],&quot;total_number&quot;: 5&#125;</span><br><span class="line">&#123;&quot;id&quot;: 5,&quot;ids&quot;: [501,502,503],&quot;total_number&quot;: 3&#125;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> jsont2(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">  ids <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">  total_number <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE <span class="string">&#x27;org.apache.hive.hcatalog.data.JsonSerDe&#x27;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/data/lagoudw/data/json2.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> jsont2;</span><br></pre></td></tr></table></figure><p><strong>JSON 处理方式比较</strong></p><p>1、简单格式的json数据，使用 <code>get_json_object</code>、<code>json_tuple</code> 处理</p><p>2、对于嵌套数据类型，可以使用 UDF</p><p>3、纯 json 串可使用 JsonSerDe 处理更简单</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+LateralView">LanguageManual LateralView</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins">LanguageManual Joins</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;并不是所有的 HQL 都会被 Hive 转换成 MR 作业执行&lt;/p&gt;
&lt;p&gt;HQL 是一种 SQL 方案，支持绝大部分的 SQL-92 标准&lt;/p&gt;
&lt;p&gt;不支持行级别草俎哦、不支持事务&lt;/p&gt;
&lt;p&gt;对于简单不需要聚合的操作，如 &lt;code&gt;S</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Scala集合</title>
    <link href="http://example.com/2021/03/09/Scala%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2021/03/09/Scala%E9%9B%86%E5%90%88/</id>
    <published>2021-03-09T13:26:10.000Z</published>
    <updated>2021-03-09T13:26:56.963Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>集合操作都有可变和不可变两种</p><p>集合的三大类：Seq、Set、Map</p><ul><li>scala.collection.mutable：定义了可变集合的特质和具体实现类</li><li>scala.collection.immutable：定义了不可变集合的特质和具体实现类</li></ul><p>所有的集合都扩展自 Iterable 特质。</p><p><img src="http://img.janhen.com/20210306175511R0KtKd.png" alt="http://img.janhen.com/20210306175511R0KtKd.png"></p><ul><li>String 属于 IndexedSeq</li><li>Queue 队列和 Stack 堆这两个经典的数据结构属于 LinearSeq</li><li>List列表属于 Seq 中的 LinearSeq</li></ul><h2 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h2><p>按照一定顺序排列的元素序列；</p><p>元素的顺序是确定的，每个元素对应一个索引值；</p><p>两个重要的子特质：</p><ul><li>IndexedSeq：提供了快速随机访问元素的功能，它通过索引来查找和定位的</li><li>LinearSeq：提供了访问 head、tail 的功能，它是线型的，有头部和尾部的概念，通过遍历来查找。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List一旦被定义，其值就不能改变。</p><p>有头部和尾部的概念</p><ul><li>head 返回的是列表第一个元素的值</li><li>tail 返回的是除第一个元素外的其它元素构成的新列表</li></ul><p>定义了一个空列表对象Nil，定义为List[Nothing]</p><p>借助 Nil <strong>可将多个元素用操作符 <code>::</code> 添加到列表头部</strong>，常用来初始化列表；</p><p><strong>操作符 <code>:::</code> 用于拼接两个列表；</strong></p><p>使用案例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// :: 操作符表示向集合中添加元素</span></span><br><span class="line">  <span class="keyword">val</span> list1 = <span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">val</span> list2 = <span class="number">5</span> :: <span class="number">6</span> :: <span class="number">7</span> :: <span class="number">8</span> :: <span class="type">Nil</span></span><br><span class="line">  println(<span class="string">s&quot;list1: <span class="subst">$list1</span>&quot;</span>)</span><br><span class="line">  println(<span class="string">s&quot;list2: <span class="subst">$list2</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 ::: 操作符进行了拼接 list</span></span><br><span class="line">  <span class="keyword">val</span> list3 = list1 ::: list2</span><br><span class="line">  println(<span class="string">s&quot;list3: <span class="subst">$list3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">s&quot;list3.head: <span class="subst">$&#123;list3.head&#125;</span>&quot;</span>)</span><br><span class="line">  println(<span class="string">s&quot;list3.last: <span class="subst">$&#123;list3.last&#125;</span>&quot;</span>)</span><br><span class="line">  println(<span class="string">s&quot;list3.init: <span class="subst">$&#123;list3.init&#125;</span>&quot;</span>) <span class="comment">// 返回除最后一个元素之外的其他元素构成的新列表</span></span><br><span class="line">  println(<span class="string">s&quot;list3.tail: <span class="subst">$&#123;list3.tail&#125;</span>&quot;</span>) <span class="comment">// 返回除第一个元系之外的其他元素构成的新列表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> list4 = <span class="type">List</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">  println(<span class="string">s&quot;sorted: <span class="subst">$&#123;quickSort(list4)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> head :: tail =&gt;</span><br><span class="line">      <span class="keyword">val</span> (less, greater) = tail.partition(_ &lt; head)</span><br><span class="line">      quickSort(less) ::: head :: quickSort(greater)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list1: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">list2: <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">list3: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">list3.head: <span class="number">1</span></span><br><span class="line">list3.last: <span class="number">8</span></span><br><span class="line">list3.init: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">list3.tail: <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">sorted: <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraversableLike</span>[+<span class="type">A</span>, +<span class="type">Repr</span>] <span class="keyword">extends</span> <span class="title">Any</span></span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">HasNewBuilder</span>[<span class="type">A</span>, <span class="type">Repr</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">FilterMonadic</span>[<span class="type">A</span>, <span class="type">Repr</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">TraversableOnce</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">GenTraversableLike</span>[<span class="type">A</span>, <span class="type">Repr</span>]</span></span><br><span class="line"><span class="class">                                    <span class="keyword">with</span> <span class="title">Parallelizable</span>[<span class="type">A</span>, <span class="type">ParIterable</span>[<span class="type">A</span>]]</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  self =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Traversable</span>.breaks._</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">partition</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): (<span class="type">Repr</span>, <span class="type">Repr</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> l, r = newBuilder</span><br><span class="line">    <span class="keyword">for</span> (x &lt;- <span class="keyword">this</span>) (<span class="keyword">if</span> (p(x)) l <span class="keyword">else</span> r) += x</span><br><span class="line">    (l.result, r.result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul><li>+=:</li><li>++=:</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> queue1 = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">Int</span>]()</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">queue1 += <span class="number">1</span></span><br><span class="line">queue1 ++= <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dequeue: <span class="type">Int</span> = queue1.dequeue()</span><br><span class="line">println(<span class="string">s&quot;dequeue: <span class="subst">$dequeue</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">queue1.enqueue(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1: <span class="subst">$queue1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">s&quot;queue1.head: <span class="subst">$&#123;queue1.head&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;queue1.last: <span class="subst">$&#123;queue1.last&#125;</span>&quot;</span>)</span><br><span class="line">queue1: <span class="type">Queue</span>()</span><br><span class="line">queue1: <span class="type">Queue</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">dequeue: <span class="number">1</span></span><br><span class="line">queue1: <span class="type">Queue</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">queue1: <span class="type">Queue</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">queue1.head: <span class="number">2</span></span><br><span class="line">queue1.last: <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><code>&amp;</code> / <code>intersect</code>:</li><li><code>++</code> / <code>|</code> / <code>union</code>：</li><li><code>--</code> / <code>&amp;~</code> / <code>diff</code></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">map.keys.foreach(println(_))</span><br><span class="line">map.values.foreach(println)</span><br><span class="line">map.foreach(e =&gt; println(e._1 + <span class="string">&quot; ==&gt; &quot;</span> + e._2))</span><br><span class="line"></span><br><span class="line">println(<span class="string">s&quot;map1(&#x27;b&#x27;): <span class="subst">$&#123;map(&quot;b&quot;)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 访问不存在的 Key 值时，抛出异常</span></span><br><span class="line"><span class="comment">// println(map(&quot;c&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get 方法访问元素，返回一个 Option 对象</span></span><br><span class="line"><span class="keyword">val</span> num: <span class="type">Option</span>[<span class="type">Int</span>] = map.get(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">num <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Key值所对应的Value值，如果键Key不存在，那么就返回指定的默认值</span></span><br><span class="line"><span class="keyword">val</span> num2: <span class="type">Int</span> = map.getOrElse(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>)</span><br><span class="line">println(<span class="string">s&quot;num2: <span class="subst">$num2</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> map3 = scala.collection.mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>)</span><br><span class="line">println(map3)</span><br><span class="line">map3(<span class="string">&quot;a&quot;</span>) = <span class="number">10</span></span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">map3(<span class="string">&quot;c&quot;</span>) = <span class="number">3</span></span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +=添加元素，-=删除元素</span></span><br><span class="line">map3 += (<span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>, <span class="string">&quot;f&quot;</span> -&gt; <span class="number">5</span>)</span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line">map3 -= <span class="string">&quot;d&quot;</span></span><br><span class="line">println(<span class="string">s&quot;map3: <span class="subst">$map3</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key, Value swap</span></span><br><span class="line"><span class="keyword">val</span> kv: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = <span class="keyword">for</span> ((k, v) &lt;- map3) <span class="keyword">yield</span> (v, k)</span><br><span class="line">println(kv)</span><br><span class="line"><span class="comment">// Key, Value swap(R)</span></span><br><span class="line">map3.map(x =&gt; (x._2, x._1)).foreach(println(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉链操作创建Map</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> b = <span class="type">Array</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> c: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = a.zip(b)</span><br><span class="line"><span class="keyword">val</span> d: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = a.zip(b).toMap</span><br><span class="line">println(<span class="string">s&quot;zip: <span class="subst">$&#123;c.toBuffer&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;zip: <span class="subst">$d</span>&quot;</span>)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">a ==&gt; <span class="number">1</span></span><br><span class="line">b ==&gt; <span class="number">2</span></span><br><span class="line">map1(&#x27;b&#x27;): <span class="number">2</span></span><br><span class="line"><span class="type">None</span></span><br><span class="line">num2: <span class="number">0</span></span><br><span class="line"><span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">1</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">10</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">10</span>, c -&gt; <span class="number">3</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, d -&gt; <span class="number">4</span>, a -&gt; <span class="number">10</span>, c -&gt; <span class="number">3</span>, f -&gt; <span class="number">5</span>)</span><br><span class="line">map3: <span class="type">Map</span>(b -&gt; <span class="number">2</span>, a -&gt; <span class="number">10</span>, c -&gt; <span class="number">3</span>, f -&gt; <span class="number">5</span>)</span><br><span class="line"><span class="type">Map</span>(<span class="number">2</span> -&gt; b, <span class="number">5</span> -&gt; f, <span class="number">10</span> -&gt; a, <span class="number">3</span> -&gt; c)</span><br><span class="line">(<span class="number">2</span>,b)</span><br><span class="line">(<span class="number">5</span>,f)</span><br><span class="line">(<span class="number">10</span>,a)</span><br><span class="line">(<span class="number">3</span>,c)</span><br><span class="line">zip: <span class="type">ArrayBuffer</span>((<span class="number">1</span>,a), (<span class="number">2</span>,b), (<span class="number">3</span>,c))</span><br><span class="line">zip: <span class="type">Map</span>(<span class="number">1</span> -&gt; a, <span class="number">2</span> -&gt; b, <span class="number">3</span> -&gt; c)</span><br></pre></td></tr></table></figure><p>操作</p><ul><li>collect： collect通过执行一个并行计算（偏函数），得到一个新的数组对象</li><li>reduce：</li><li><code>sorted</code> / <code>sortwith</code> / <code>sortby</code>：</li></ul><h2 id="与-Java-集合转换"><a href="#与-Java-集合转换" class="headerlink" title="与 Java 集合转换"></a>与 Java 集合转换</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line"><span class="keyword">val</span> list: java.util.<span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).asJava</span><br><span class="line">println(<span class="string">s&quot;java list: <span class="subst">$list</span>&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> buffer: scala.collection.mutable.<span class="type">Buffer</span>[<span class="type">Int</span>] = list.asScala</span><br><span class="line">println(<span class="string">s&quot;scala buffer: <span class="subst">$buffer</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;集合操作都有可变和不可变两种&lt;/p&gt;
&lt;p&gt;集合的三大类：Seq、Set、Map&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scala.collection.mutable：定义了可变集合的特质和具体实现类&lt;/li&gt;
&lt;li&gt;scala.collection.im</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Scala" scheme="http://example.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala语言基础</title>
    <link href="http://example.com/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-09T13:23:27.000Z</published>
    <updated>2021-04-15T02:50:12.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scala-基础"><a href="#Scala-基础" class="headerlink" title="Scala 基础"></a>Scala 基础</h2><p>语言起源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">马丁·奥德斯基（Martin Odersky）是编译器及编程的狂热爱好者。</span><br><span class="line"></span><br><span class="line">主流JVM的Javac编译器就是马丁·奥德斯基编写出来的，JDK5.0、JDK8.0的编译器就是他写的。 </span><br><span class="line">长时间的编程之后，他希望发明一种语言，能够让写程序这样的基础工作变得高效，简单。 </span><br><span class="line">当接触到Java语言后，对Java这门语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到Java中，由此发 明了Scala。</span><br></pre></td></tr></table></figure><p>语言特性：</p><ul><li>OOP</li><li>函数式编程</li><li>静态类型，参考 Haskell、Errlang</li><li>并发性，使用 Actor 作为并发模型，可复用线程</li></ul><p>应用场景：</p><ul><li>Kafka、Spar 等框架底层都是使用 Scala 作为底层源码开发语言</li><li>融合大数据生态，Flink 支持 Scala 开发</li></ul><p><strong>Scala 的 REPL</strong></p><p>REPL 是一个交互式解析器环境，R(read)、E(evaluate) 、P（print）、L（loop） 输入值，交互式解析器会读取输入内容并对它求值，再打印结果，并重复此过程。</p><p>在命令行输入Scala可启动Scala REPL。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li>区分大小写 - Scala语言对大小写敏感</li><li>类名 - 对于所有的类名的第一个字母要大写。</li><li>方法名 - 所有方法名的第一个字母用小写。</li><li>程序文件名 - Scala程序文件的后缀名是 .scala，程序文件的名称可以不与对象名称完全匹配。</li><li>main()方法 - Scala程序从main()方法开始处理</li></ul><h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><ul><li>Int:</li><li>Unit: 无值，用于不返回任何结果的方法的返回类型。</li><li>Null</li><li>Nothing： 在Scala类层级的最低端，它是任何其他类型的子类型</li><li>Any: 是Scala中所有类的超类</li><li>AnyRef: 是Scala中所有引用类的超类</li></ul><p>Scala和Java一样，有8种数值类型 Byte、Short、Int、Long、Float、Double、Char、Boolean 类型；</p><p>Scala 并不刻意的区分基本类型和引用类型。</p><p>每一种数据类型都有对应的Rich类型，如RichInt、RichChar等，为基本类型提供了更多的有用操作。</p><h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p>Scala中，所有的类，包括值类型和引用类型，都最终继承自一个统一的根类型Any。</p><p><img src="http://img.janhen.com/20210306153957XEmR1i.png" alt="http://img.janhen.com/20210306153957XEmR1i.png"></p><ul><li>Null<ul><li>Null是所有引用类型的子类型</li><li>Null类只有一个实例对象null</li><li>null可以赋值给任意引用类型，但是不能赋值给值类型。</li></ul></li><li>Nothing<ul><li>Nothing位于Scala类继承关系的底部，它是其他所有其他类型的子类型</li><li>Nothing对泛型结构有用 。比如，空列表Nil的类型就是List[Nothing]</li><li>Nothing的可以给出非正常终止的信号。比如，使用Nothing处理异常</li></ul></li></ul><p>在Scala中，鼓励使用val。</p><p>简单数据类型可以省略，对于复杂的数据类型建议明确声明；</p><p><strong>操作符</strong></p><p>Scala中的操作符都是方法</p><p><strong>对象相等性</strong></p><p>Scala中，要比较两个基础类型的对象是否相等，可以使用 == 或 !=；</p><p>== 或 != 还可以比较不同类型的两个对象</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串插值器</p><ul><li>s 插值器： 对内嵌的每个表达式求值，对求值结果调用toString</li><li>f 插值器： 除s插值器的功能外，还能进行格式化输出，在变量后用%指定输出格式</li><li>raw 插值器： 按照字符串原样进行输出</li></ul><h2 id="控制结构和函数"><a href="#控制结构和函数" class="headerlink" title="控制结构和函数"></a>控制结构和函数</h2><p><strong>if 表达式</strong></p><p>if 表达式有返回值。</p><p>如果if 和 else 的返回值类型不一样，那么就返回两个返回值类型公共的父类。</p><p><strong>for 表达式</strong></p><p>for (i &lt;- 表达式 / 集合)，让变量 i遍历&lt;-右边的表达式/集合的所有值。</p><p>Scala为for循环提供了很多的特性，这些特性被称之为 for守卫式 或 for推导式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">10</span>) &#123;</span><br><span class="line">println(<span class="string">s&quot;i = <span class="subst">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重循环。条件之间使用分号分隔</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">5</span>; j &lt;- <span class="number">2</span> until <span class="number">5</span>)&#123;</span><br><span class="line">println(i * j )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 守卫语句。</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; j &lt;- <span class="number">1</span> to <span class="number">10</span> <span class="keyword">if</span> i==j)&#123;</span><br><span class="line">  println(<span class="string">s&quot;i * j = <span class="subst">$i</span> * <span class="subst">$j</span> = <span class="subst">$&#123;i * j&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for推导式, yield 接收返回的结果</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用大括号将生成器、守卫、定义包含在其中；并以换行的方式来隔开它们</span></span><br><span class="line"><span class="keyword">for</span> &#123; i &lt;- <span class="number">1</span> to <span class="number">3</span></span><br><span class="line">  from = <span class="number">4</span> - i</span><br><span class="line">  j &lt;- from to <span class="number">3</span> &#125;</span><br><span class="line">  println(<span class="string">s&quot;i = <span class="subst">$i</span>; j = <span class="subst">$j</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>while 表达式</strong></p><p>while语句的本身没有任何返回值类型，即while语句的返回结果是Unit类型的 () 。</p><p>Scala内置控制结构特地去掉了 break 和 continue。</p><p>终止循环的方式：</p><ul><li>使用Boolean类型的控制变量</li><li>使用 return</li><li>使用 breakable和break，需要导入scala.util.control.Breaks包</li></ul><h3 id="懒值"><a href="#懒值" class="headerlink" title="懒值"></a>懒值</h3><p>当 val 被声明为lazy时(var不能声明为lazy)，初始化将被推迟，直到首次对此取值，适用于初始化开销较大的场景。</p><p><strong>惰性求值</strong></p><p>可根据 if 短路求值，避免不必要的 expensive  计算操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(input: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s&quot;evaluate called with <span class="subst">$input</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; expensiveComputation())</span><br><span class="line">    println(<span class="string">&quot;doing work...&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    println(<span class="string">&quot;skipping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evaluate(<span class="number">0</span>)</span><br><span class="line">evaluate(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>通过 scala 的懒加载处理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> perform = expensiveComputation() </span><br><span class="line"><span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; perform) </span><br><span class="line">  println(“doing work…”)</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>导入scala.io.Source后，可引用Source中的方法读取文本文件的内容</p><p>Scala没有内建的对写入文件的支持。要写入文本文件，可使用 java.io.PrintWriter</p><h2 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h2><p>使用ArrayBuffer时，需要导包 import scala.collection.mutable.ArrayBuffer；</p><p><strong>多维数组</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dim = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">dim(<span class="number">1</span>)(<span class="number">1</span>) = <span class="number">11.11</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">2</span>; j &lt;- <span class="number">0</span> to <span class="number">3</span>) &#123;</span><br><span class="line">  print(dim(i)(j) + <span class="string">&quot; &quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">3</span>) println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>元组和操作</strong></p><p>内建了 22 个 Tuple 类</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>在Scala中，类并不用声明为public；</p><ul><li>val修饰的变量（常量），值不能改变，只提供getter方法，没有setter方法；</li><li>var修饰的变量，值可以改变，对外提供getter、setter方法；</li></ul><p><strong>自定义getter和setter方法</strong></p><p>Scala 类中的每一个属性，编译后会有一个私有的字段和相应的getter、setter方法生成。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getter方法</span></span><br><span class="line">println(person age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//setter方法</span></span><br><span class="line">person age_= (<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter方法</span></span><br><span class="line">println(person.age)</span><br></pre></td></tr></table></figure><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>默认情况下，Scala 不遵循 JavaBean 约定，必须要使用 <code>@scala.reflect.BeanProperty</code> 注解来生成满足 JavaBean 约定的 getter 和 setter 方法</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>没有定义构造器，Scala类中会有一个默认的无参构造器；</p><p>的构造器分为两种：主构造器和辅助构造器；</p><p>主构造器的定义与类的定义交织在一起，将主构造器的参数直接放在类名之后。</p><p>当主构造器的参数不用var或val修饰时，参数会生成类的私有val成员。</p><p>Scala中，所有的辅助构造器都必须调用另外一个构造器</p><h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>没有提供Java那样的静态方法或静态字段；</p><p>可以采用object关键字实现单例对象，具备和Java静态方法同样的功能；</p><p>使用object语法结构【object是Scala中的一个关键字】达到静态方法和静态字段的目的；对象本质上可以拥有类的所有特性，除了不能提供构造器参数；</p><p>任何在Java中用单例对象的地方，在Scala中都可以用object实现：</p><ul><li>作为存放工具函数或常量的地方</li><li>高效地共享单个不可变实例</li></ul><p>Scala中的单例对象具有如下特点：</p><ul><li>创建单例对象不需要使用new关键字</li><li>object中只有无参构造器</li><li>主构造代码块只能执行一次，因为它是单例的</li></ul><p><strong>应用程序对象</strong></p><p>可以扩展App特质（trait) 来运行。</p><h3 id="伴生类与伴生对象"><a href="#伴生类与伴生对象" class="headerlink" title="伴生类与伴生对象"></a>伴生类与伴生对象</h3><p>单例对象与某个类具有相同的名称时，它被称为这个类的“伴生对象”；</p><p>类和它的伴生对象必须存在于同一个文件中，而且可以相互访问私有成员（字段和方法）；</p><h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h3><p>object 中的特殊方法</p><ul><li>apply方法通常定义在伴生对象中，目的是通过伴生类的构造函数功能，来实现伴生对象的构造函数功能；</li><li>当遇到类名(参数1,…参数n)时apply方法会被调用；</li><li>在创建伴生对象或伴生类的对象时，通常不会使用new class/class() 的方式，而是<strong>直接使用 class()隐式的调用伴生对象的 apply 方法</strong></li></ul><p><strong>借助 apply 实现工厂设计模式</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">Dog</span> <span class="title">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;woof&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(str: <span class="type">String</span>): <span class="type">Animal</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;dog&quot;</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Dog</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cat = <span class="type">Animal</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">  cat.speak</span><br><span class="line">  <span class="keyword">val</span> dog = <span class="type">Animal</span>(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">  dog.speak</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>override方法重写</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">coding</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;coding...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaProgrammer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, workNo: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Programmer</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">coding</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">super</span>.coding()</span><br><span class="line">    println(<span class="string">&quot;我在写Scala代码。。。&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型检查与转换"><a href="#类型检查与转换" class="headerlink" title="类型检查与转换"></a>类型检查与转换</h3><ul><li>isInstanceOf： 测试某个对象是否属于某个给定的类</li><li>getClass</li><li>classOf</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Person...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Student...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">InstanceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">    <span class="keyword">var</span> student: <span class="type">Student</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    println(student.isInstanceOf[<span class="type">Student</span>])</span><br><span class="line">    <span class="comment">// function check</span></span><br><span class="line">    <span class="keyword">if</span> (person.isInstanceOf[<span class="type">Student</span>]) &#123;</span><br><span class="line">      student = person.asInstanceOf[<span class="type">Student</span>]</span><br><span class="line">      student.say()</span><br><span class="line">    &#125;</span><br><span class="line">    println(student.isInstanceOf[<span class="type">Student</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getClass check</span></span><br><span class="line">    println(person.getClass == classOf[<span class="type">Person</span>])</span><br><span class="line">    println(person.getClass == classOf[<span class="type">Student</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern match check</span></span><br><span class="line">    person <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> s: <span class="type">Student</span> =&gt;</span><br><span class="line">        s.say()</span><br><span class="line">        println(<span class="string">&quot;Student2 type match&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;default...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><p><strong>作为接口使用</strong></p><ul><li>在trait中可以定义抽象方法，与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。</li><li>类可以使用extends关键字继承trait。</li><li>在Scala中没有implement的概念，无论继承类还是trait特质，统一都是extends。</li><li>类继承trait特质后，必须实现其中的抽象方法，实现时可以省略 override 关键字。</li><li>Scala不支持对类进行多继承，但是<strong>支持多重继承trait特质</strong>，使用with关键字即可。</li></ul><p><strong>特质构造顺序</strong></p><ul><li>执行父类的构造器；</li><li>执行trait的构造器，多个trait从左到右依次执行；</li><li>构造trait时会先构造父trait，如果多个trait继承同一个父trait，则父trait只会构造一次；</li><li>所有trait构造完毕之后，子类的构造器才执行</li></ul><h3 id="Ordered和Ordering"><a href="#Ordered和Ordering" class="headerlink" title="Ordered和Ordering"></a>Ordered和Ordering</h3><p>Ordered 特质混入 Java 的 Comparable 接口，它定义了相同类型间的比较方式，但这种内部比较方式是单一的；</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordered</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">A</span>): <span class="type">Int</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">&lt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;  <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">&gt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;  <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;= <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;= <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compareTo</span></span>(that: <span class="type">A</span>): <span class="type">Int</span> = compare(that)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ordering 特质混入 Comparator 接口，提供第三方比较器，可以自定义多种比较方式，在实际开发中也是使用比较多的，灵活解耦合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation</span>.implicitNotFound(msg = <span class="string">&quot;No implicit Ordering defined for $&#123;T&#125;.&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Comparator</span>[<span class="type">T</span>] <span class="keyword">with</span> <span class="title">PartialOrdering</span>[<span class="type">T</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  outer =&gt;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryCompare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="type">Some</span>(compare(x, y))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Int</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &lt;= <span class="number">0</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &gt;= <span class="number">0</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &lt; <span class="number">0</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equiv</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) == <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">if</span> (gteq(x, y)) x <span class="keyword">else</span> y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">if</span> (lteq(x, y)) x <span class="keyword">else</span> y</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reverse</span> </span>= outer</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = outer.compare(y, x)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on</span></span>[<span class="type">U</span>](f: <span class="type">U</span> =&gt; <span class="type">T</span>): <span class="type">Ordering</span>[<span class="type">U</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">U</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">U</span>, y: <span class="type">U</span>) = outer.compare(f(x), f(y))</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ops</span>(<span class="params">lhs: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(rhs: <span class="type">T</span>) = lt(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(rhs: <span class="type">T</span>) = lteq(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(rhs: <span class="type">T</span>) = gt(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(rhs: <span class="type">T</span>) = gteq(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equiv</span></span>(rhs: <span class="type">T</span>) = <span class="type">Ordering</span>.<span class="keyword">this</span>.equiv(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(rhs: <span class="type">T</span>): <span class="type">T</span> = <span class="type">Ordering</span>.<span class="keyword">this</span>.max(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(rhs: <span class="type">T</span>): <span class="type">T</span> = <span class="type">Ordering</span>.<span class="keyword">this</span>.min(lhs, rhs)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">mkOrderingOps</span></span>(lhs: <span class="type">T</span>): <span class="type">Ops</span> = <span class="keyword">new</span> <span class="type">Ops</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Ordering</span> <span class="keyword">extends</span> <span class="title">LowPriorityOrderingImplicits</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]) = ord</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by</span></span>[<span class="type">T</span>, <span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">S</span>]): <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = ord.compare(f(x), f(y))</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.lt(f(x), f(y))</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.gt(f(x), f(y))</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.gteq(f(x), f(y))</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.lteq(f(x), f(y))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用案例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Sorting</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span>(<span class="params">tag: <span class="type">String</span>, score: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Project</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Project</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    tag.compareTo(that.tag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">Project</span>(<span class="string">&quot;hadoop&quot;</span>, <span class="number">40</span>), <span class="type">Project</span>(<span class="string">&quot;flink&quot;</span>, <span class="number">90</span>), <span class="type">Project</span>(<span class="string">&quot;spark&quot;</span>, <span class="number">80</span>), <span class="type">Project</span>(<span class="string">&quot;hive&quot;</span>, <span class="number">60</span>))</span><br><span class="line">    println(list.sorted)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pairs = <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">7</span>, <span class="number">2</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">9</span>, <span class="number">1</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="comment">// Ordering.by[(String,Int,Int),Int](_._2) 从 Tuple3 转到 Int 型，根据 Tuple3 第二个元素进行排序</span></span><br><span class="line">    <span class="type">Sorting</span>.quickSort(pairs)(<span class="type">Ordering</span>.by[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>), <span class="type">Int</span>](_._2))</span><br><span class="line">    println(pairs.toBuffer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配和样例类"><a href="#模式匹配和样例类" class="headerlink" title="模式匹配和样例类"></a>模式匹配和样例类</h2><ul><li>Scala没有Java中的switch case</li><li>Scala的模式匹配可以匹配各种情况，比如变量的类型、集合的元素、有值或无值。</li><li>模式匹配match case中，只要有一个case分支满足并处理了，就不会继续判断下一个case分支了</li></ul><h3 id="守卫式匹配"><a href="#守卫式匹配" class="headerlink" title="守卫式匹配"></a>守卫式匹配</h3><p>可增加 if 条件判断</p><h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><ul><li>可以直接匹配类型，而不是值</li></ul><h3 id="匹配数组、元组、集合"><a href="#匹配数组、元组、集合" class="headerlink" title="匹配数组、元组、集合"></a>匹配数组、元组、集合</h3><h3 id="case-class"><a href="#case-class" class="headerlink" title="case class"></a>case class</h3><p>样例类 默认实现了常用的方法，如 getter/setter, 默认序列化</p><ul><li>主构造器函数结构的参数不需要显示 var/val 修饰，自动使用 val 修饰</li><li>自动定义了伴生对象，提供 apply 方法，无需 new 关键字就可构造出对象</li><li>生成 toString,equals,hashCode,copy 方法</li><li>继承了 Product, Serializable 两个特质</li><li>case class 为多例的， case object 为单例的</li></ul><h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><p>Option通常与模式匹配结合使用，用于判断某个变量是有值还是无值。</p><h2 id="函数与抽象化"><a href="#函数与抽象化" class="headerlink" title="函数与抽象化"></a>函数与抽象化</h2><ul><li>不仅可以定义一个函数然后调用它，还可以写一个未命名的函数字面量，然后可以把它当成一个值传递到其它函数或是赋值给其它变量。</li><li>函数字面量体现了函数式编程的核心理念。字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、函数字面量等。</li><li>函数类型：(输入参数类型列表) =&gt; (输出参数类型列表)只有一个参数时，小括号可省略；函数体中只有1行语句时</li></ul><h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><ul><li>使用 val 定义的是函数(function)，使用 def 定义的是方法(method)。</li><li>Scala 中的方法与 Java 的类似，方法是组成类的一部分</li><li>Scala 中的函数则是一个完整的对象。Scala 中用 22 个特质(从 Function1 到 Function22)抽象出了函数的概念</li><li>Scala 中用 val 语句定义函数，def 语句定义方法</li><li>方法不能作为单独的表达式而存在，而函数可以；</li><li>函数必须要有参数列表，而方法可以没有参数列表；</li><li>方法名是方法调用，而函数名只是代表函数对象本身；</li><li>在需要函数的地方，如果传递一个方法，会自动把方法转换为函数</li><li>一般情况下，不对二者做区分，认为都是函数，<strong>更多的时候使用def定义函数。</strong></li></ul><p><strong>方法转换成函数</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span></span>(x: <span class="type">Int</span>) = x*x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span> </span>= double _</span><br></pre></td></tr></table></figure><p><strong>匿名函数</strong></p><p>函数没有名字就是匿名函数；</p><p>匿名函数，又被称为 Lambda 表达式。</p><p><strong>占位符</strong></p><ul><li>第一个下划线代表第一个参数</li><li>第二个下划线代表第二个参数</li><li>第三个……，如此类推</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote><p>接收一个或多个函数作为输入或输出一个函数。</p></blockquote><p>常用的高阶函数：map、reduce、flatMap、foreach、filter、count。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>闭包是一种函数，是<strong>在其上下文中引用了自由变量的函数</strong>；</p></blockquote><p>闭包引用到函数外面定义的变量，定义这个函数的过程就是将这个自由变量捕获而构成的一个封闭的函数，也可理解为”把函数外部的一个自由变量关闭进来“。</p><p>闭包满足的条件：</p><ul><li>闭包是一个函数</li><li>函数必须要有返回值</li><li>返回值依赖声明在函数外部的一个或多个变量，用 Java 的话说，就是返回值和定义全局变量有关</li></ul><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><blockquote><p>函数编程中，<strong>接收多个参数的函数都可以转化为接收单个参数的函数，</strong>这个转化过程就叫柯里化(Currying)。</p></blockquote><p>柯里化函数拥有多组参数列表，每组参数用小括号括起来。</p><p>Scala 源码中的柯里化</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraversableOnce</span>[+<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">GenTraversableOnce</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  self =&gt;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = foldLeft(z)(op)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">B</span>](z: =&gt;<span class="type">B</span>)(seqop: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>, combop: (<span class="type">B</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = foldLeft(z)(seqop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h3><blockquote><p>部分应用函数（Partial Applied Function）也叫偏应用函数，是指缺少部分（甚至全部）参数的函数</p></blockquote><p>如果一个函数有n个参数, 而为其提供少于n个参数, 那就得到了一个部分应用函数。</p><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><blockquote><p>并不处理所有可能的输入，而只处理那些能与至少一个 case 语句匹配的输入；</p></blockquote><p>偏函数中只能使用 case 语句，整个函数必须用大括号包围。与普通的函数字面量不同，普通的函数字面量可以使用大括号，也可以用小括号；</p><p>Scala中的 Partial Function 是一个 trait。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PartialFunction</span>[-<span class="type">A</span>, +<span class="type">B</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">A</span> =&gt; <span class="type">B</span></span>) </span>&#123; self =&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PartialFunction</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">A</span>): <span class="type">Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>[<span class="type">A1</span> &lt;: <span class="type">A</span>, <span class="type">B1</span> &gt;: <span class="type">B</span>](that: <span class="type">PartialFunction</span>[<span class="type">A1</span>, <span class="type">B1</span>]): <span class="type">PartialFunction</span>[<span class="type">A1</span>, <span class="type">B1</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OrElse</span>[<span class="type">A1</span>, <span class="type">B1</span>] (<span class="keyword">this</span>, that)</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">C</span>](k: <span class="type">B</span> =&gt; <span class="type">C</span>): <span class="type">PartialFunction</span>[<span class="type">A</span>, <span class="type">C</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">AndThen</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>] (<span class="keyword">this</span>, k)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lift</span></span>: <span class="type">A</span> =&gt; <span class="type">Option</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Lifted</span>(<span class="keyword">this</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">applyOrElse</span></span>[<span class="type">A1</span> &lt;: <span class="type">A</span>, <span class="type">B1</span> &gt;: <span class="type">B</span>](x: <span class="type">A1</span>, <span class="keyword">default</span>: <span class="type">A1</span> =&gt; <span class="type">B1</span>): <span class="type">B1</span> =</span><br><span class="line">    <span class="keyword">if</span> (isDefinedAt(x)) apply(x) <span class="keyword">else</span> <span class="keyword">default</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runWith</span></span>[<span class="type">U</span>](action: <span class="type">B</span> =&gt; <span class="type">U</span>): <span class="type">A</span> =&gt; <span class="type">Boolean</span> = &#123; x =&gt;</span><br><span class="line">    <span class="keyword">val</span> z = applyOrElse(x, checkFallback[<span class="type">B</span>])</span><br><span class="line">    <span class="keyword">if</span> (!fallbackOccurred(z)) &#123; action(z); <span class="literal">true</span> &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用案例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 Int 类型的元素加 1</span></span><br><span class="line"><span class="keyword">val</span> partialFunction = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    x.isInstanceOf[<span class="type">Int</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    v1.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">10</span>, <span class="string">&quot;hadoop&quot;</span>, <span class="number">20</span>, <span class="string">&quot;spark&quot;</span>, <span class="number">30</span>, <span class="string">&quot;flink&quot;</span>)</span><br><span class="line">list.collect(partialFunction).foreach(println)</span><br><span class="line"><span class="comment">// simple    </span></span><br><span class="line">list.collect(&#123;<span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span>&#125;).foreach(println)</span><br></pre></td></tr></table></figure><h2 id="隐式机制"><a href="#隐式机制" class="headerlink" title="隐式机制"></a>隐式机制</h2><blockquote><p>根据隐式转换函数的签名，在程序中使用到隐式转换函数接收的参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回，这就是“隐式转换”</p></blockquote><p>隐式转换和隐式参数是Scala中两个非常强大的功能，利用隐式转换和隐式参数，可以提供类库，对类库的使用者隐匿掉具体的细节。</p><p>使用限制</p><ul><li>implicit 关键字只能用来修饰方法、变量、参数</li><li>隐式转换的函数只在当前范围内才有效。如果隐式转换不在当前范围内定义，那么必须通过 import 语句将其导入</li></ul><h3 id="隐式转换函数"><a href="#隐式转换函数" class="headerlink" title="隐式转换函数"></a>隐式转换函数</h3><p>定义的隐式转换函数，只要在编写的程序内引入，就会被Scala自动使用。</p><p>隐式转换函数由Scala自动调用，通常建议将隐式转换函数的名称命名为“one2one”的形式。</p><h3 id="隐式参数和隐式值"><a href="#隐式参数和隐式值" class="headerlink" title="隐式参数和隐式值"></a>隐式参数和隐式值</h3><p>在函数定义的时候，支持在<strong>最后一组参数</strong>中使用 implicit ，表明这是一组隐式参数。</p><p>在调用该函数的时候，可以不用传递隐式参数，而编译器会自动寻找一个implicit 标记过的合适的值作为参数。</p><p>查看范围</p><ul><li>当前作用域内可见的 val 或 var 定义隐式变量</li><li>隐式参数类型的伴生对象内隐式值</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.scala-lang.org/">The Scala Programming Language</a></p><p>Scala 官网</p><p><a href="https://www.scala-lang.org/download/2.11.8.html">Scala 2.11.8</a></p><p>Scala官网下载Scala 2.11.8安装包</p><p><a href="https://mp.weixin.qq.com/s/vGLVmgcjK3jmK6ibYIONew">为什么 Haskell 是我们构建生产软件系统的首选</a></p><p>Haskell</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Scala-基础&quot;&gt;&lt;a href=&quot;#Scala-基础&quot; class=&quot;headerlink&quot; title=&quot;Scala 基础&quot;&gt;&lt;/a&gt;Scala 基础&lt;/h2&gt;&lt;p&gt;语言起源&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Scala" scheme="http://example.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Vagrent</title>
    <link href="http://example.com/2021/03/09/Vagrent/"/>
    <id>http://example.com/2021/03/09/Vagrent/</id>
    <published>2021-03-09T13:17:56.000Z</published>
    <updated>2021-03-09T13:22:08.136Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC] </p><h1 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h1><blockquote><p>快速搭建虚拟机环境，可通过 Vagrantfile 配置文件进行定制，类似 Docker 管理容器。</p></blockquote><p>一些特性：</p><ul><li>多种虚拟器支持，如 VirsualBox(默认)、 Vmware、Docker、Hyper-V</li><li>方便网络配置，支持端口转发，配置私有、公有网络</li><li>方便进行宿主机与虚拟机之间共享文件提供丰富的插件，简化日常使用</li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>Virtual Box</strong></p><p>Oracle 开源的虚拟机软件，跨平台</p><p>在 winows 上无法同时运行 Hyper-V 和 VisualBox，两者都是基于 CPU 等底层硬件的 Hypervisor 机制来实现的，而他们必须独占管理 Hypervisor。通过开启启动项选择是否加载 Hyper-V 服务，实现伪同时运行。</p><p>问题由来： Docker 安装在 win10 上需要开启 Hyper-V，方便进行本地镜像的打包部署，同时需要 VirtualBox 进行模拟集群。</p><p>问题处理：</p><p><a href="https://blog.csdn.net/enweitech/article/details/52180373">解决Win7/8/10系统中的Hyper-V和VMware虚拟机软件共存问题</a></p><p><a href="https://stackoverflow.com/questions/31642333/virtualbox-callee-rc-regdb-e-classnotreg-0x80040154">Virtualbox “Callee RC: REGDB_E_CLASSNOTREG” (0x80040154)?</a></p><p><strong>Hyper-V</strong></p><p>Win10 自带虚拟化工具，实现在 Win10 上运行 Docker 环境，而无需开启 Docker 的远程访问，开启后无法使用其他虚拟器</p><p>对应的 vagrant 设置内存和CPU参数参考文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boxes &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        :name &#x3D;&gt; &quot;docker-kubernetes&quot;,</span><br><span class="line">        :eth1 &#x3D;&gt; &quot;192.168.205.12&quot;,</span><br><span class="line">        :mem &#x3D;&gt; &quot;2048&quot;,</span><br><span class="line">        :cpu &#x3D;&gt; &quot;2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">  config.vm.provider &quot;hyperv&quot; do |v|</span><br><span class="line">    v.ip_address_timeout&#x3D;121</span><br><span class="line">    v.memory&#x3D;opts[:mem]</span><br><span class="line">    v.cpus&#x3D;opts[:cpu]</span><br><span class="line">  end</span><br><span class="line">bcdedit &#x2F;set hypervisorlaunchtype off</span><br><span class="line">bcdedit &#x2F; set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><p><strong>XShell</strong></p><p>SSH 命令工具</p><p>一些特性</p><ul><li>标签化页面管理，方便管理打开的连接</li><li>支持连接目录管理，方便进行多种环境管理</li><li>支持分屏，方便对集群中的主从进行区分</li><li>支持透明图，无需切换窗口查看遗忘的命令</li><li>侧栏显示连接信息，方便集群中配置 IP 地址</li></ul><p><strong>Vagrant 管理</strong></p><p>通过 Vagrantfile 文件设置好一些数值进行控制虚拟机，通过命令管理虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 全局管理</span><br><span class="line">vagrant global-status</span><br><span class="line">vagrant global-status --prune</span><br><span class="line">vagrant destroy &lt;vm_id&gt;</span><br><span class="line">vagrant halt &lt;vm_id&gt; &lt;vm_id2&gt;</span><br><span class="line">vagrant reload &lt;vm_id1&gt; &lt;vm_id2&gt;..</span><br><span class="line">vagrant up &lt;vm_id1&gt; &lt;vm_id2&gt;..</span><br></pre></td></tr></table></figure><p><strong>安装虚拟机环境</strong></p><p>快速安装环境，支持从远程获取对应的 Vagrantfile，之后拉取远程镜像；支持导入本地的 box 作为镜像；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vagrant 命令</span><br><span class="line"># 初始化一个安装 centos&#x2F;7 虚拟机的 Vagrantfile</span><br><span class="line"># 根据目录下的 Vagrantfile 进行启动</span><br><span class="line"># 删除虚拟机</span><br><span class="line"># 查案虚拟机运行状态</span><br><span class="line">vagrant init centos&#x2F;7</span><br><span class="line">vagrant up</span><br><span class="line">vagrant status</span><br></pre></td></tr></table></figure><p><strong>多种虚拟机支持</strong></p><p>支持多种虚拟机，对应的配置memory、Cpu 方式不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 vmware 虚拟机</span><br><span class="line"># 使用 hyper-v，需要管理员权限运行 vagrant，通过 Cmder 默认使用 admin 启动的 powershell 处理</span><br><span class="line">vagrant up --provider&#x3D;vmware_fusion</span><br><span class="line">vagrant up --provider&#x3D;hyperv</span><br></pre></td></tr></table></figure><h2 id="Vagrant-插件"><a href="#Vagrant-插件" class="headerlink" title="Vagrant 插件"></a>Vagrant 插件</h2><p><strong>vagrant-hostmanager</strong></p><p>实现多台虚拟机之间直接通过名称访问，原理为更改 host 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 安装并验证插件</span><br><span class="line">vagrant plugin install vagrant-hostmanager</span><br><span class="line">vagrant plugin list</span><br><span class="line"># 在 Vagrantfile 中修改</span><br><span class="line">config.hostmanager.enabled &#x3D; true</span><br><span class="line">config.hostmanager.manage_guest &#x3D; true</span><br><span class="line">config.hostmanager.manage_host &#x3D; true</span><br><span class="line"># 执行命令，更新虚拟机上的hosts，同时更新主机上的 hosts</span><br><span class="line">vagrant hostmanager</span><br></pre></td></tr></table></figure><p><strong>vagrant-vbguest</strong></p><p>处理 VisualBox 中无法设置共享目录问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant vbguest --status</span><br><span class="line">vagrant vbguest --do install node1</span><br><span class="line"># 配置 vagrantfile</span><br><span class="line">config.vbguest.auto_update&#x3D;false</span><br></pre></td></tr></table></figure><p><strong>vagrant-bindfs</strong></p><p>非使用 visualBox 自带的共享目录，自定义使用文件系统 nfs，性能更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-bindfs</span><br><span class="line"># 。。。</span><br><span class="line">node1. vm. synced_folder &quot;.&#x2F;app&quot;,&quot;&#x2F;mnt&#x2F;app-data&quot;, type:&quot;nfs</span><br><span class="line">node1. bindfs. bind_folder &quot;&#x2F;mnt&#x2F;app-data&quot;,&quot;&#x2F;app&quot;, force_user:&quot;root&quot;, force_group:&quot;root&quot;,o:&quot;nonempty&quot;</span><br><span class="line"># 代理设置插件</span><br><span class="line"># 在Vagrantfile中的config部分添加代理配置, 全部网络都走主机代理</span><br><span class="line">vagrant plugin install vagrant-proxyconf</span><br><span class="line">vim Vagrantfile</span><br><span class="line">  Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">    if Vagrant.has_plugin?(&quot;vagrant-proxyconf&quot;)</span><br><span class="line">      config.proxy.http     &#x3D; &quot;&lt;http:&#x2F;&#x2F;192.168.0.2:3128&#x2F;&gt;&quot;</span><br><span class="line">      config.proxy.https    &#x3D; &quot;&lt;http:&#x2F;&#x2F;192.168.0.2:3128&#x2F;&gt;&quot;</span><br><span class="line">      config.proxy.no_proxy &#x3D; &quot;localhost,127.0.0.1,.example.com&quot;</span><br><span class="line">    end</span><br><span class="line">    # ... other stuff</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line"># 复用虚拟机环境插件安装</span><br><span class="line">vagrant plugin list</span><br><span class="line">vagrant plugin install vagrant-scp</span><br><span class="line">vagrant scp</span><br><span class="line"></span><br><span class="line"># 处理虚拟机安装进行目录文件映射权限问题</span><br><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant plugin list</span><br></pre></td></tr></table></figure><h2 id="Vagrantfile"><a href="#Vagrantfile" class="headerlink" title="Vagrantfile"></a>Vagrantfile</h2><blockquote><p>构建虚拟机的硬件情况，实现控制 CPU、内存、Ip 等资源，同时支持虚拟机启动后执行初始化脚本，实现一些必要工具的安装，如 Docker。</p></blockquote><p>通过配置可实现：</p><ul><li>进行虚拟机目录与本地目录映射</li><li>选择网络</li><li>安装成功后执行特定脚本，直接安装要必要的工具以及 Docker 环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># config.vm.box 配置使用哪个box</span><br><span class="line">config.vm.box &#x3D; &quot;ubuntu16.04_louis&quot;# box ∈ vagrant box list</span><br><span class="line">config.vm.hostname               # 机器应该有的主机名</span><br><span class="line">aa.vm.hostname &#x3D; &quot;aa.test.com&quot;</span><br><span class="line">config.vm.network                # 在机器上配置网络</span><br><span class="line">config.vm.network&quot;forwarded_port&quot;,guest:80,host:8080</span><br><span class="line">aa.vm.network &quot;private_network&quot;, ip: &quot;192.168.55.100&quot;</span><br><span class="line">config.vm.provider               # 配置提供程序特定的配置，用于修改特定于某个 提供程序的设置</span><br><span class="line">config.vm.provision              # 配置置备 在机器上，使软件可以自动安装并创建机器时配置</span><br><span class="line">config.vm.synced_folder          # 配置 机器上的同步文件夹</span><br></pre></td></tr></table></figure><p>配置实例：</p><ul><li>参数注入</li><li>脚本执行，进行必要软件(vim,git…)、必要环境(如pip,java,docker) 的安装</li><li>资源配置，可 CPU、内存…. 等硬件资源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boxes &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        :name &#x3D;&gt; &quot;docker-host&quot;,</span><br><span class="line">        :eth1 &#x3D;&gt; &quot;192.168.205.10&quot;,</span><br><span class="line">        :mem &#x3D;&gt; &quot;1024&quot;,</span><br><span class="line">        :cpu &#x3D;&gt; &quot;1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">boxes.each do |opts|</span><br><span class="line">    config.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">      v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]]</span><br><span class="line">      v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]]</span><br><span class="line">    end</span><br><span class="line">    config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line">    # 从主机特定文件读入脚本执行</span><br><span class="line">    config.vm.provision &quot;shell&quot;, privileged: true, path: &quot;.&#x2F;setup.sh&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>根据需要设置虚拟机网络 IP 地址固定，实现虚拟机中的软件根据名称访问，设置虚拟机可以访问外部的网络。</p><p><strong>端口转发</strong></p><p>将宿主机的端口与虚拟机的端口绑定，从而让外部通过端口可以访问虚拟机</p><p>若 guest_ip 和 host_ip 两项配置为空，则局域网下的所有设备都可以访问该虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(2&quot;) do |config|</span><br><span class="line">config.vm.network</span><br><span class="line">&quot;forwarded_port&quot;(必选) &#x2F;&#x2F;端口转发标示</span><br><span class="line">,guest(必选):       # 虚拟端口</span><br><span class="line">,host(必选):        # 宿主机端口，值必须大于1024</span><br><span class="line">,gust_ip(可选):     # 虚拟机端口绑定虚拟机ip地址</span><br><span class="line">,host_ip(可选):     # 虚拟机端口绑定宿主机端口ip</span><br><span class="line">,protocol(可选):    # 指定通信协议，可以使用tcp&#x2F;udp,默认tcp</span><br><span class="line">,auto_correct(可选): # ture&#x2F;fasle,开机是否自动检测端口冲突</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 实际配置</span><br><span class="line"># 配置2个端口映射，把物理机的8080映射到虚拟机80，物理机的2100映射到虚拟机的22</span><br><span class="line"># host_ip 在主机 IP 较为固定情况下配置使用</span><br><span class="line">config.vm.network :&quot;forwarded_port&quot;, guest: 80, host: 8060,host_ip: &quot;10.2.11.203&quot;</span><br><span class="line">config.vm.network :&quot;forwarded_port&quot;, guest: 22, host: 2100, host_ip: &quot;10.2.11.203&quot;</span><br></pre></td></tr></table></figure><p><strong>私有网络</strong></p><p>虚拟机之间处在同一网段的地址可相互访问，主机可以访问虚拟机，无法通过虚拟机进行团队合作，不与宿主机的 IP 在同一个网段，防止冲突</p><p>配置 vagrant 里面的虚拟机的私有网段的时候，切记不能和企业（公司）内部的 DHCP 分配的 IP 地址在同一网段，否则会发生冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置 Static IP</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.10&quot;</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.55.20&quot;</span><br><span class="line"># 配置通过 DHCP 进行获取 IP，之后执行 &#96;vagrant reload&#96;</span><br><span class="line">config.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;</span><br><span class="line"></span><br><span class="line"># 实际使用</span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.10&quot;,</span><br><span class="line">auto_config: false</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>公有网络</strong></p><p>与宿主机一样的网络配置， vagrant1.3+ 支持设置固定 IP，虚拟机 IP 与主机 IP 处在同一个网段时，实现局域网之间的互通，需要有路由器分配 IP.一般来说开发和测试使用较为封闭的网络模型是比较好的方式，通常不建议 vm 配置有 public_network 的网卡关联</p><p>配置虚拟机自动获取公司内部DHCP服务器分配的IP地址，在局域网任何一台电脑上，都可以ssh到虚拟机，或访问虚拟机上提供的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;192.168.1.120&quot;</span><br><span class="line"></span><br><span class="line"># 配置动态 IP</span><br><span class="line"># 配置共有网络，使用主机上可以访问外网的接口(ipconfig)</span><br><span class="line"># 配置默认网关</span><br><span class="line">config.vm.network &quot;public_network&quot;,bridge: &quot;ens33&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;route add default gw 10.2.11.1&quot;</span><br><span class="line"></span><br><span class="line"># 配置静态 IP</span><br><span class="line"># auto_config：关闭自动配置</span><br><span class="line"># ifconfig enp0s8 10.2.11.196 netmask 255.255.255.0 up: 配置静态ip（这里的ip不能和公司内部的地址冲突）</span><br><span class="line"># route add default gw 10.2.11.1 指定网关（添加默认路由）</span><br><span class="line"># bridge： 绑定接口（物理机哪个接口可以上网）</span><br><span class="line">config.vm.network &quot;public_network&quot;, auto_config: false ,bridge: &quot;ens33&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;ifconfig eth1 10.2.11.196 netmask 255.255.0.0 up&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;alway&quot;,inline: &quot;route add default gw 10.2.11.1&quot;</span><br><span class="line">config.vm.network &quot;public_network&quot;, auto_config: false </span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;always&quot;,inline: &quot;ip addr add 172.17.10.51&#x2F;21 dev eth1&quot; </span><br><span class="line">config.vm.provision &quot;shell&quot;,run: &quot;alway&quot;,inline: &quot;ip route add 172.17.8.0&#x2F;21 via 172.17.0.49&quot;</span><br></pre></td></tr></table></figure><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>配置宿主机中的数据与虚拟机的数据映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># src： 是物理机的目录，相对路径，（相对于项目目录（&#x2F;vagrant&#x2F;ubuntu））</span><br><span class="line"># &#x2F;srv&#x2F;website: 虚拟机的目录，绝对路径，如果没有，会自动创建</span><br><span class="line">config.vm.synced_folder &quot;src&#x2F;&quot;, &quot;&#x2F;srv&#x2F;website&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">config.vm.synced_folder &quot;.&quot;, &quot;&#x2F;vagrant&quot;, disabled: true</span><br><span class="line">config.vm.synced_folder &quot;src&#x2F;&quot;,&quot;&#x2F;srv&#x2F;website&quot;,owner: &quot;root&quot;,group: &quot;root&quot;</span><br></pre></td></tr></table></figure><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote><p>出现的问题以及对应的处理</p></blockquote><p>@Q: 处理本地下载对应镜像慢问题：</p><p>直接下载、设置代理</p><p>执行 <code>vagrant up --provider=hyperv</code>，在控制台找到下载地址，使用本地下载工具下载(代理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 执行下载</span><br><span class="line"># 获取地址重新下载</span><br><span class="line"># 重命名为指定格式</span><br><span class="line">vagrant up --provider&#x3D;hyperv</span><br><span class="line"># 将下载的 .box 添加</span><br><span class="line"># 使用下载的 .box 进行初始化 </span><br><span class="line">vagrant box add centos-7_hyperv hyperv.box</span><br><span class="line">vagrant init centos-7_hyperv</span><br></pre></td></tr></table></figure><p>@Q: 卸载重装 Vagrant 无法删除之前构建的虚拟机</p><p>@Q: 公有网络设置静态 IP 的接口选择问题，无法选择 Wifi、以太网接口?? 待验证 选择不同的连接网卡是否可相互通信？</p><p>选择以太网的桥接可实现内网互通</p><p>@Q: 使用以太网接口指定公司网关显示网络不可达? 公司内网的安全性??</p><p>相当于占用内网的一个 IP</p><p>@Q: 二次使用 vagrantfile 时，报错 chmod: cannot access ‘/etc/systemd/system/docker.service.d/http-proxy.conf’: No such file or directory</p><p>A： 通过 ssh 进入主机，创建该文件 // todo 搜寻更好的处理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</span><br></pre></td></tr></table></figure><p>原因是修改了网络配置(改成桥接)，重新配置 docker 的代理，需要创建文件的方式来配置代理，而默认情况下无权限访问</p><p>@Q: 同步文件夹显示编码问题， ==&gt; Test-Node: Rsyncing folder: /cygdrive/d/develop/Env2/Test-Node/ =&gt; /vagrant D:/ProgramFile/Vagrant/embedded/gems/2.2.5/gems/vagrant-2.2.5/lib/vagrant/util/io.rb:32:in `encode’: “5” from GBK to UTF-8 (Encoding::UndefinedConversionError)</p><p>管理员权限编辑对应的 io.rb 文件，更改 vagrant 源码</p><p><a href="https://github.com/hashicorp/vagrant/issues/9368">https://github.com/hashicorp/vagrant/issues/9368</a></p><h2 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a>Ref：</h2><ul><li><a href="https://www.vagrantup.com/intro/getting-started/providers.html">多种类型虚拟机支持</a></li><li><a href="https://zhuyasen.com/post/vv_evn.html">使用vagrant和vitrualBox搭建虚拟开发环境</a></li><li><a href="https://app.vagrantup.com/boxes/search?provider=hyperv">Box-Search: hyperv</a></li><li><a href="http://blog.lujun9972.win/blog/2018/07/29/vagrant%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html">Vagrant使用指南</a>: 插件、vagrant 代理、对应虚拟机代理</li><li><a href="https://juejin.im/entry/579015868ac247005ffa76ad">windows 下 使用 vagrant 来管理 linux 虚机开发环境</a></li><li><a href="https://superuser.com/questions/1354658/hyperv-static-ip-with-vagrant/1355010">HyperV - Static Ip with Vagrant</a></li><li><a href="https://www.cnblogs.com/hafiz/p/9175484.html">征服诱人的Vagrant！</a></li><li><a href="https://www.kancloud.cn/louis1986/vagrant">Vagrant学习文档</a></li><li><a href="https://blog.hedzr.com/2017/05/02/vagrant-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">VAGRANT 网络配置</a></li><li><a href="https://blog.51cto.com/xslwahaha/1438669">ifconfig命令和ip命令及route命令</a>： 配置公有网络设定 IP、掩码、网关</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC] &lt;/p&gt;
&lt;h1 id=&quot;Vagrant&quot;&gt;&lt;a href=&quot;#Vagrant&quot; class=&quot;headerlink&quot; title=&quot;Vagrant&quot;&gt;&lt;/a&gt;Vagrant&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;快速搭建虚拟机环境，可通过 Vagrantfi</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Flume-数据采集</title>
    <link href="http://example.com/2021/03/09/Flume-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    <id>http://example.com/2021/03/09/Flume-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</id>
    <published>2021-03-09T08:56:07.000Z</published>
    <updated>2021-04-15T02:51:09.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Flume 是 Cloudera 提供的一个分布式、高可靠、高可用的海量日志采集、聚合和传输的系统，基于流式架构，灵活简单。</p><p>实时采集日志的数据采集引擎。</p><p>作用： 实时读取服务器本地磁盘的数据，将数据写入到 HDFS。</p><p>特点</p><ul><li>可与任意存储进程集成，Redis、 Kafka；</li><li>输入的速率大于写入目的存储的速率，会被缓存，减少 HDFS 压力；</li><li>事务基于 channel，两个事务模型（sender + receiver），保证消息被可靠发送</li></ul><p>Flume 是一个专用工具被设计为旨在往 HDFS，HBase 发送数据。它对 HDFS 有特殊的优化，集成了 Hadoop 的安全特性。官方建议数据被多个系统消费，使用 kafka；数据被设计给 Hadoop 使用，使用 Flume。</p><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="http://img.janhen.com/20210130165358image-20201226102711887.png" alt="http://img.janhen.com/20210130165358image-20201226102711887.png"></p><ul><li>Agent： 为一个 JVM 进程，运行在日志手机节点服务器上。</li><li>Source：以处理各种类型、各种格式的日志数据</li><li>Channel：位于Source和Sink之间的缓冲</li><li>Sink：不断地轮询 Channel 中的事件且批量地移除，将其写入到其他系统或另一个 Agent</li><li>Event： ****Flume 数据传输的基本单元，以事件的形式将数据从源发送到目的。<ul><li>Header: 附加的信息，可通过配置文件组的方式对匹配到的目录文件增加 header，可通过拦截器为 Event 增加特定的 header</li><li>Body：事件的实际内容</li></ul></li></ul><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><ul><li>串行模式：</li><li>复制模式： 单 Souce 多 Channel、Sink 模式</li><li>负载均衡模式(单 Source、Channel 多 Sink )： 解决负载均衡和故障转移问题。</li><li>聚合模式： 最常用 传送到一个集中收集日志的 flume，再由此 flume 上传到 hdfs、hive、hbase、消息队列中。</li></ul><p><img src="http://img.janhen.com/20210130165413image-20201226103600691.png" alt="http://img.janhen.com/20210130165413image-20201226103600691.png"></p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="http://img.janhen.com/20210130165418image-20201226103744350.png" alt="http://img.janhen.com/20210130165418image-20201226103744350.png"></p><ol><li>Source 接收事件，交给 Channel 处理器处理事件</li><li>处理器通过拦截器 Interceptor，对事件一些处理,比如压缩解码，正则拦截，时间戳拦截，分类等</li><li>经过拦截器处理过的事件再传给 Channel 选择器，将事件写入相应的 Channel</li><li>最后由 Sink 处理器处理各个 Channel 的事件</li></ol><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p>负责接收数据到 Flume Agent 的组件。可以处理各种类型、各种格式的日志数据</p></blockquote><p>常见的 Source</p><ul><li>directory、http</li><li>kafka source:</li><li>avro source: 监听 Avro 端口来接收外部 avro 客户端的事件流。</li><li>exec source: 可以将命令产生的输出作为 source。如 ping、tail。 可监控实时追加的文件，无法保证数据不丢。<ul><li>tail -f： 文件改名/被删除，追踪停止</li><li>tail -F: 等同于 <code>--follow=name --retry</code> ，根据文件名进行追踪，并保持重试，文件被删除/改名后，若再次创建相同的文件名，会继续追踪</li></ul></li><li>Netcat source: 用来监听一个指定端口，并接收监听到的数据，常用于测试。</li><li>spooling directory source: 将指定的文件加入到“自动搜集”目录中。</li><li>taildir source： 监控指定的多个文件，支持续传。</li></ul><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><blockquote><p>在运行时，可实时对 event 进行修改或丢弃。</p></blockquote><p>拦截器的分类</p><ul><li>时间添加戳拦截器： 生成时间戳到 Eventheader 中</li><li>Host添加拦截器： 生成主机 host/ip 到 Event header 中</li><li>正则表达式过滤拦截器： 使用正则过滤需要的数据</li><li>自定义拦截器： 可解析 Event Body 中的数据，提取到 Event Header 中做特殊处理，如提取日志的事件事件</li></ul><p><strong>时间添加戳拦截器</strong></p><p>向每个 event 的 header 中添加一个时间戳属性进去，key → value = “timestamp” → 当前的毫秒</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1.sources.r1.interceptors = i1 </span><br><span class="line">a1.sources.r1.interceptors.i1.type = timestamp</span><br><span class="line"><span class="comment"># 是否保留Event header中已经存在的同名时间戳，缺省值false</span></span><br><span class="line">a1.sources.r1.interceptors.i1.preserveExisting= <span class="literal">false</span></span><br><span class="line"><span class="comment"># 向event header中添加时间戳键值对的key</span></span><br><span class="line">a1.sources.r1.interceptors.i1.header= time</span><br></pre></td></tr></table></figure><p><strong>Host添加拦截器</strong></p><p>把当前Agent的 hostname 或者 IP 地址写入到 Event 的 header 中</p><ul><li><code>type</code>: host</li><li><code>preserveExisting</code>: header 中存在同名属性是否保留，默认 false</li><li><code>userIp</code>: ip 地址，默认 true, 为 false 时使用 hostname</li><li><code>hostHeader</code>: 默认为 host, Event header 中添加 host 键值对的 key</li></ul><p><strong>正则表达式过滤拦截器</strong></p><p>把 Event 的 body 当做字符串来处理，并用配置的正则表达式来匹配。</p><p><strong>自定义拦截器</strong></p><p>生产环境中常需要自定义拦截器, <code>org.apache.flume.interceptor.Interceptor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Event <span class="title">intercept</span><span class="params">(Event var1)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Event&gt; <span class="title">intercept</span><span class="params">(List&lt;Event&gt; var1)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">    <span class="function">Interceptor <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spooldir-source"><a href="#Spooldir-source" class="headerlink" title="Spooldir source"></a>Spooldir source</h3><blockquote><p>监听一个指定的目录，向指定<strong>目录添加新的文件</strong>，sourcce 可获取到该信息</p></blockquote><p>注意事项</p><ul><li>以追加的方式向已被处理的文件中添加内容，source并不能识别</li><li>复制的 spooldir 目录下的文件不可再打开编辑</li><li>无法监控子目录的文件夹的变动</li><li>被监控文件夹 500ms 扫描一次文件</li><li>适合同步新文件，不适合对实时追加日志文件进行监听并同步</li></ul><h3 id="Taildir-source"><a href="#Taildir-source" class="headerlink" title="Taildir source"></a>Taildir source</h3><blockquote><p>1.7.0 引入，支持断点续传、可监控多目录。相当于 spooldir source + exec source。生产环境中使用较多。</p></blockquote><p>特点：</p><ul><li>支持正则表达式匹配目录中的文件名</li><li>监控日志文件，有文件写入进行收集</li><li>高可靠，agent 重启后不会数据丢失</li><li>不会对跟踪文件有任何处理，不会重命名、删除</li><li>不能读取二进制文件，支持按照行读取文本文件。</li></ul><p><strong>Taildir source 配置</strong></p><ul><li><code>filegroups</code>：文件组，使用空格分隔</li><li><code>filegroups.&lt;filegroupName&gt;</code>： 文件组中指定的绝对路径，可根据正则匹配路径</li><li><code>positionFile</code>： 记录每个拖尾文件的索引节点，绝对路径和最后位置，解决断点续传问题</li><li><code>batchSize</code>： 一次读取并发送到通道的最大行数，默认 100，一般需要更改下</li><li><code>headers.&lt;filegroupName&gt;.&lt;headerKey&gt;</code>： 指定指定文件组的 header key，用于区分不同的文件，放入不同的 header 后，方便在拦截器中根据传入的 headerKey 进行特定的处理</li><li><code>fileHeader</code>： 是否增加一个 header</li><li><code>fileHeaderKey</code>：</li><li><code>hdfs.useLocalTimeStamp</code>： 使用本地时间，而非事件时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1.sources.r1.type &#x3D; TAILDIR </span><br><span class="line">a1.sources.r1.positionFile &#x3D; &#x2F;data&#x2F;janhen&#x2F;conf&#x2F;startlog_position.json </span><br><span class="line">a1.sources.r1.filegroups &#x3D; f1 </span><br><span class="line">a1.sources.r1.filegroups.f1 &#x3D; &#x2F;data&#x2F;janhen&#x2F;logs&#x2F;start&#x2F;.*log</span><br></pre></td></tr></table></figure><p><strong>HDFS sink 配置</strong></p><p>HDFS 文件的滚动方式：</p><ul><li>基于时间:</li><li>基于文件大小: 默认 1024b，生产中调大</li><li>基于 EVENT 数量:</li><li>基于文件空闲时间:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a1.sinks.k1.type = hdfs </span><br><span class="line">a1.sinks.k1.hdfs.path = /user/data/logs/start/%Y-%m-%d/ </span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = startlog.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件滚动方式（文件大小32M）, 默认 1024b, 生产中 &gt;&gt;</span></span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 33554432 </span><br><span class="line"><span class="comment"># 基于时间的数量，默认10</span></span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0 </span><br><span class="line"><span class="comment"># 基于时间的滚动，默认30s</span></span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 0 </span><br><span class="line"><span class="comment"># 基于文件空闲时间</span></span><br><span class="line">a1.sinks.k1.hdfs.idleTimeout = 0 </span><br><span class="line"><span class="comment"># 默认值与 hdfs 副本数一致, 设为1是为了让 Flume 感知不到hdfs的块复制</span></span><br><span class="line">a1.sinks.k1.hdfs.minBlockReplicas = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向hdfs上刷新的event的个数, 默认100 </span></span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地时间 </span></span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>agent 配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">a1.sources=r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># taildir source</span></span><br><span class="line">a1.sources.r1.type = TAILDIR</span><br><span class="line">a1.sources.r1.positionFile = /data/janhen/conf/startlog_position.json</span><br><span class="line">a1.sources.r1.filegroups = f1</span><br><span class="line">a1.sources.r1.filegroups.f1 = /data/janhen/logs/start/.*<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># memorychannel</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 100000</span><br><span class="line">a1.channels.c1.transactionCapacity = 2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># hdfs sink</span></span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = /user/data/logs/start/%Y-%m-%d/</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = startlog.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件滚动方式（文件大小32M）</span></span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 33554432</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 0</span><br><span class="line">a1.sinks.k1.hdfs.idleTimeout = 0</span><br><span class="line">a1.sinks.k1.hdfs.minBlockReplicas = 1</span><br><span class="line"><span class="comment"># 向hdfs上刷新的event的个数</span></span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 1000</span><br><span class="line"><span class="comment"># 使用本地时间</span></span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = <span class="literal">true</span></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p>使用自定义拦截器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flume-ng agent --conf-file /root/janhen/conf/flumelog2hdfs1.conf -name a1 -Dflum e.roog.logger=INFO,console</span><br></pre></td></tr></table></figure><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><blockquote><p>位于 Source 和 Sink 之间的缓冲区，是线程安全的，可同时处理多个 Source 的写入和多个 Sink 的读取，让 Source 与 Sink 可以运行在不同的速率上.</p></blockquote><p>常用的 Channel 类型：</p><ul><li>memory channel: 缓存到内存中，宕机数据丢失</li><li>file channel: 缓存到文件中，宕机数据不丢失，访问速度较慢</li><li><strong>kafka channel</strong>: 缓存到 Kafka 中。兼具 memory, file 的优点，支持扩展。速度快，容量大。</li><li>jdbc channel: 缓存到关系型数据库中</li></ul><p>配置参数：</p><ul><li>type:</li><li>capacity: 存储在 channel 中的最大事件数量，默认为 100，生产环境需要加大</li><li>transactionCapacity：每次事务从 source 到 sink 的最大事件数量，默认为 100</li><li>keep-alive：..</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1.channels = c1</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"><span class="comment"># channel 最大缓存 50W 个事件</span></span><br><span class="line">a1.channels.c1.capacity = 500000</span><br><span class="line"><span class="comment"># 每批 channle 事务处理最大 2W 个事件</span></span><br><span class="line">a1.channels.c1.transactionCapacity = 20000</span><br></pre></td></tr></table></figure><h3 id="Channel-选择器"><a href="#Channel-选择器" class="headerlink" title="Channel 选择器"></a>Channel 选择器</h3><p>确定 source 以何种方式向多个 channel 写， 默认为复制的。</p><p><strong>复制选择器（Replicating Channel Selector)</strong> 可通过 <code>selector.optional</code> 指定哪些 channel 可选，空格分开，失败忽略不会进行实物回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1.sources.r1.selector.type &#x3D; replicatin</span><br></pre></td></tr></table></figure><p><strong>多路复用选择器(Multiplexing Channel Selector)</strong> 按配置进行分发</p><p><strong>自定义选择器</strong> 接口 <code>org.apache.flume.ChannelSelector</code> 的实现类, 实现类以及依赖的jar包在启动时候都必须放入Flume的classpath。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line">a1.sources.r1.selector.type &#x3D; com.janhen.bigdata.flume.MyChannelSelector</span><br></pre></td></tr></table></figure><h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><blockquote><p>Sink 组件用来保存数据，不断轮询 Channel 中的事件并批量的移除。将这些事件批量写入到存储或索引系统、或者被发送到另一个 Flume Agent。</p></blockquote><p>完全事务性的</p><ul><li>HDFS sink： 存储到 HDFS 中，使用较多，Flume 对其有特殊的优化</li><li>Hive sink: Hive 事务写 events</li><li>Kafka sink: 写入到 Kafka 中<ul><li>官方提供的 flume Kafka 插件，自定义了 flume 的 sink，将数据从 channel 中取出，通过 Kafka 的 producer 写入到 Kafka 中，可以自定义分区等。</li></ul></li><li>HBase sink: 写入到 HBase 中</li><li>Logger sink: 信息显示在标准输出上，主要用于测试</li><li>Avro sink: 转换为 Avro events</li></ul><h3 id="HDFS-Sink"><a href="#HDFS-Sink" class="headerlink" title="HDFS Sink"></a>HDFS Sink</h3><p>基本配置：</p><ul><li><code>hdfs.path</code>： 配置 sink 的基础目录</li><li><code>hdfs.filePrefix</code>： 在目录下创建的文件前缀</li><li><code>hdfs.fileSuffix</code>： 在目录下创建的文件后缀</li><li><code>hdfs.useLocalTimeStamp</code>： 是否使用本地时间戳，默认 false</li><li><code>hdfs.round</code>: 时间戳是否四舍五入, 默认 false</li><li><code>hdfs.roundValue</code>： 四舍五入的最高倍数</li><li><code>hdfs.roundUnit</code>: 可选 second, minute, hour，默认为 second</li><li><code>hdfs.threadsPoolSize</code>：</li></ul><p>滚动生成文件配置</p><ul><li><code>hdfs.rollInterval</code>： 基于时间回滚，缺省 30s，0 表示不根据时间进行回滚</li><li><code>hdfs.rollSize</code>： 基于文件大小回滚，缺省 1024byte，0 表示…</li><li><code>hdfs.rollCount</code>： 基于 event 的数量回滚，缺省 10</li><li><code>hdfs.idleTimeout</code>： 基于文件空闲时间回滚，关闭非活动文件超时时间，缺省禁用</li><li><code>hdfs.minBlockReplicas</code>： HDFS 副本数，默认与 HDFS 副本数一致，将参数设置为 1，避免小文件和复制的网络开销</li></ul><p>其他：</p><ul><li>hdfs.batchSize： 向 hdfs 上刷新的 event 个数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a2.sinks.k2.hdfs.path = hdfs://linux121:9000/flume/%Y%m%d/%H%M</span><br><span class="line"><span class="comment"># 上传文件的前缀</span></span><br><span class="line">a2.sinks.k2.hdfs.filePrefix = <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地时间戳</span></span><br><span class="line">a2.sinks.k2.hdfs.useLocalTimeStamp = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 500 个 Event 才 flush 到 HDFS 一次</span></span><br><span class="line">a2.sinks.k2.hdfs.batchSize = 500</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件类型，支持压缩。DataStream 没启用压缩</span></span><br><span class="line">a2.sinks.k2.hdfs.fileType = DataStream</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 分钟滚动一次</span></span><br><span class="line">a2.sinks.k2.hdfs.rollInterval = 60</span><br><span class="line"></span><br><span class="line"><span class="comment"># 128M 滚动一次</span></span><br><span class="line">a2.sinks.k2.hdfs.rollSize = 134217700</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的滚动与 Event 数量无关</span></span><br><span class="line">a2.sinks.k2.hdfs.rollCount = 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># HDFS 最小冗余数</span></span><br><span class="line">a2.sinks.k2.hdfs.minBlockReplicas = 1</span><br></pre></td></tr></table></figure><p><strong>规避小文件、提高写入 HDFS 速度参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a1.sinks.k1.type=hdfs</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp=<span class="literal">true</span></span><br><span class="line">a1.sinks.k1.hdfs.path=hdfs://linux121:9000/flume/events/%Y/%m/%d/ %H/%M</span><br><span class="line">a1.sinks.k1.hdfs.minBlockReplicas=1</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval=3600</span><br><span class="line"><span class="comment"># 文件大小 1G 滚动</span></span><br><span class="line">a1.sinks.k1.hdfs.rollSize=1073741824</span><br><span class="line">a1.sinks.k1.hdfs.rollCount=0</span><br><span class="line">a1.sinks.k1.hdfs.idleTimeout=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向hdfs上刷新的event个数</span></span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 10000</span><br></pre></td></tr></table></figure><h3 id="Sink-组逻辑处理器"><a href="#Sink-组逻辑处理器" class="headerlink" title="Sink 组逻辑处理器"></a>Sink 组逻辑处理器</h3><blockquote><p>把多个 sink 分成一个组， Sink 组逻辑处理器可以对这同一个组里的几个 sink 进行 负载均衡 或者 其中一个sink发生故障后将输出 Event 的任务转移到其他的sink上。默认无 sink 组。</p></blockquote><p><strong>负载均衡</strong> 轮训，随机。。。 退避机制,backoff 设置，失败的 sink 放入黑名单 …</p><p><strong>故障转移</strong> N 中只有一个在工作，其他备用 故障 sink 降级到一个池 设置 sink 组的选择器为 failove 为每一个 sink 设置一个唯一的优先级数值</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="事务机制与可用性"><a href="#事务机制与可用性" class="headerlink" title="事务机制与可用性"></a>事务机制与可用性</h3><blockquote><p>保证数据在 Flume 流动过程中数据不丢失。</p></blockquote><p><strong>1、Put 事务:</strong></p><p>在 Source 到 Channel 之间保证事务</p><p>把一批 Event 放到一个事务中，这批 event 一次性的放入 Channel 中。</p><p>(1) 执行流程：</p><p>事务开始的时候会调用一个 doPut 方法， doPut 方法将一批数据放在 putList 中；</p><ul><li>putList在向 Channel 发送数据之前先检查 Channel 的容量能否放得下，如 果放不下一个都不放，只能 doRollback；</li><li>数据批的大小取决于配置参数 batch size 的值；</li><li>putList 的大小取决于配置 Channel 的参数 transaction capacity 的大 小，该参数大小就体现在putList上；</li></ul><p>数据顺利的放到 putList 之后，接下来可以调用 doCommit 方法，把 putList 中所有的 Event 放到 Channel 中，成功放完之后就清空 putList；</p><p>(2) 事务的回滚(doRollback)：</p><p>doRollback 方法会进行两项操作：将 putList 清空和抛出 ChannelException 异常。source 会捕捉到 doRollback 抛出的异常，然后 source 就将刚才的一批数据重新采集，然后重新开始一个新的事务。</p><p><strong>2、Take 事务:</strong></p><p>Channel 到 Sink 之间保证事务</p><p>把一批 event 组成的事务统一拿出来到 sink 放到 HDFS 上。</p><p>source、sink 的可靠不可控，随着具体使用 Source、Channel、Sink 的类型。</p><p>(1) 执行过程</p><p>doTake 方法会将 channel 中的 event 剪切到 takeList 中。后面接的是HDFS Sink 的话，在把 Channel 中的 event 剪切到 takeList 中的同时也往写入 HDFS 的 IO 缓冲流中放一份 event(数据写入 HDFS 是先写入 IO 缓冲流然后 flush 到 HDFS）；</p><p>当 takeList 中存放了 batch size 数量的 event 之后，就会调用 doCommit 方法， doCommit 方法会做两个操作：</p><ul><li>针对 HDFS Sink，手动调用 IO 流的 flush 方法，将 IO 流缓冲区的数据写入到 HDFS磁盘中；</li><li>清空 takeList 中的数据</li></ul><p>（2） 事务的回滚</p><p>回滚并没有“一半”之说，它只会把整个 takeList 中的数据返回给 channel，然后继续进行数据的读写。这样开启下一个事务的时候容易造成数据重复的问题。</p><h3 id="Flume-执行"><a href="#Flume-执行" class="headerlink" title="Flume 执行"></a>Flume 执行</h3><p>Agent JVM heap 一般为 4G ~ 8G，部署在单独的服务器上。</p><p>全局参数</p><ul><li><code>--conf</code> / <code>-c</code>： 指定配置文件</li><li>-classpath,-C <cp>： 指定 …</li><li><code>--dryrun</code>,-d: 打印命令，实际不执行</li><li><code>-Dproperty=value</code>： 设置 JDK 系统属性<ul><li>flume.root.logger=INFO,console： 调试时候使用，将日志打印到控制台</li><li>org.apache.flume.log.printconfig=true</li><li>org.apache.flume.log.rawdata=true</li></ul></li></ul><p>Agent 参数</p><ul><li><code>—-name</code>: 指定 agent 的名称</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$FLUME_HOME</span>/bin/flume-ng agent --name a1 \\</span><br><span class="line">  --conf-file <span class="variable">$FLUME_HOME</span>/conf/flume-netcat-logger.conf \\</span><br><span class="line">  -Dflume.root.logger=INFO,console</span><br><span class="line"><span class="variable">$FLUME_HOME</span>/bin/flume-ng agent --conf /opt/apps/flume-1.9/conf \\</span><br><span class="line">  --conf-file conf/flume-log2hdfs1.conf \\</span><br><span class="line">  -name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p><strong>指定 JVM 参数运行</strong></p><p><code>$FLUME_HOME/conf/flume-env.sh</code> 中指定运行时的 JVM 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 $FLUME_HOME/conf/flume-env.sh 中指定运行时的 JVM 参数</span></span><br><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">&quot;-Xms4000m -Xmx4000m -Dcom.sun.management.jmxremote&quot;</span></span><br><span class="line"></span><br><span class="line">flume-ng agent --conf /opt/apps/flume-1.9/conf \\</span><br><span class="line">  --conf-file /data/janhen/conf/flume-log2hdfs1.conf \\</span><br><span class="line">  -name a1 -Dflume.roog.logger=INFO,console</span><br></pre></td></tr></table></figure><p><strong>生产环境时候的运行</strong></p><p>nohup，该命令允许用户退出帐户/关闭终端之后继续运行相应的进程</p><ul><li><p>/dev/null，代表linux的空设备文件，所有往这个文件里面写入的内容都会丢 失，俗称黑洞</p></li><li><p>标准输入0，从键盘获得输入 /proc/self/fd/0</p></li><li><p>标准输出1，输出到屏幕（控制台） /proc/self/fd/1</p></li><li><p>错误输出2，输出到屏幕（控制台） /proc/self/fd/2</p></li><li><blockquote><p>/dev/null 标准输出1重定向到 /dev/null 中，此时标准输出不存在，没有任何地方能够找到输出的内容</p></blockquote></li><li><p>2&gt;&amp;1 错误输出将会和标准输出输出到同一个地方</p></li><li><blockquote><p>/dev/null 2&gt;&amp;1 不会输出任何信息到控制台，也不会有任何信息输出到文件</p></blockquote></li></ul><p>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup flume-ng agent --conf /opt/apps/flume-1.9/conf \\</span><br><span class="line">  --conf-file /data/janhen/conf/flume-log2hdfs3.conf \\</span><br><span class="line">  -name a1 -Dflume.root.logger=INFO,LOGFILE &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h3 id="Flume-日志数据采集事项"><a href="#Flume-日志数据采集事项" class="headerlink" title="Flume 日志数据采集事项"></a><strong>Flume 日志数据采集事项</strong></h3><ul><li>使用 taildir source 监控指定的多个目录，可以给不同目录的日志加上不同 header</li><li>在每个目录中可以使用正则匹配多个文件</li><li>使用自定义拦截器，主要功能是从 json 串中获取时间戳，加到 event 的 header 中</li><li>hdfs sink 使用 event header 中的信息写数据（控制写文件的位置）</li><li>hdfs 文件的滚动方式（基于文件大小、基于event数量、基于时间）</li><li>调节 flume jvm 内存的分配</li></ul><h3 id="数据采集优化"><a href="#数据采集优化" class="headerlink" title="数据采集优化"></a>数据采集优化</h3><ul><li>channel 选取 Kafka, 兼具 File Channel 的可靠性与 Memory Channel 的速度</li><li>配置负载均衡</li><li>根据数据采集的业务需求情况，替换成其他的日志采集组件，Logstash, FileBeat</li><li>在 Flume 中过滤数据，剔除掉无用的数据，只收集核心的数据(json)</li></ul><h3 id="Flume-丢包问题"><a href="#Flume-丢包问题" class="headerlink" title="Flume 丢包问题"></a>Flume 丢包问题</h3><p>单机 upd 的 flume source 的配置，100+M/s数据量，10w qps flume就开始大量丢包。</p><p>一般公司在使用 Flume 工作过程中，对业务日志进行监控，如 Flume agent 中有多少条日志，Flume到 Kafka 后有多少条日志等等，如果数据丢失保持在 1% 左右是没有问题的，当数据丢失达到 5% 左右时就必须采取相应措施。</p><h3 id="采集日志"><a href="#采集日志" class="headerlink" title="采集日志"></a>采集日志</h3><p>采集 Nginx 日志，日志格式固定，但是缺少 sessionId</p><p>Log4j 日志，带有 sessionId，与项目联系紧密</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul><li><a href="https://flume.liyifeng.org/">中文flume帮助文档</a></li></ul><p><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html">Flume 1.9.0 User Guide - Apache Flume</a></p><p>Flume 官方用户指南文档</p><p><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#taildir-source">Flume 1.9.0 User Guide - Apache Flume</a></p><p>Flume tailDIR source 官方文档说明</p><p><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#flume-interceptors">Flume 1.9.0 User Guide - Apache Flume</a></p><p>Flume 拦截器官方文档</p><p><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#hdfs-sink">Flume 1.9.0 User Guide - Apache Flume</a></p><p>Flume HDFS sink 文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Flume 是 Cloudera 提供的一个分布式、高可靠、高可用的海量日志采集、聚合和传输的系统，基于流式架构，灵活简单。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="数据采集" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Docker-镜像构建-‘最佳实践’</title>
    <link href="http://example.com/2021/03/09/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/03/09/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-03-09T01:41:21.000Z</published>
    <updated>2021-04-15T02:51:15.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建发布"><a href="#构建发布" class="headerlink" title="构建发布"></a>构建发布</h2><p>一键构建发布</p><p>通过 node 命令合并，maven 插件集成，zsh 终端别名命令定制，Jenkins CICD 操作 Shell 脚本</p><h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a><strong>镜像构建</strong></h3><p>1、构建方式</p><ul><li>Dockerfile 一键构建，构建环境为当前运行环境</li><li>Dockerfile + Builder 容器进行构建，构建环境为 Builder 指定的容器环境</li><li>Jenkins + Agent 配合数据卷容器构建，构建环境为 agent 指定的或是新构建的容器环境</li></ul><p>2、常见构建目标</p><ul><li>中间件镜像构建，对于 redis、rabbitmq、nginx、haproxy、mysql 对外提供服务，需要更改启动方式为非后台启动，在配置中或是命令运行时进行更改处理</li><li>运行环境构建，Centos、Debian、Alpine 操作系统，JRE 、Tomcat、Nginx、Ruby、MySql 程序运行环境</li><li>构建工具构建，Maven、Node、Gradle 等工具镜像构建,保存公司私有仓库的账号密码进行打包发布</li></ul><p>3、镜像构建与 Git 配合</p><p>Docker 提供环境、Git 仓库提供最新的部署脚本，entrypoint 中指定运行特定的脚本(python)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;git_url&gt; -b &lt;branch&gt;</span><br><span class="line">chmod 777 &lt;git_master&gt;&#x2F;docker-entrypoint.sh</span><br><span class="line">docker build -t &lt;&gt; .</span><br><span class="line">docker push &lt;&gt;</span><br></pre></td></tr></table></figure><h3 id="镜像打包"><a href="#镜像打包" class="headerlink" title="镜像打包"></a><strong>镜像打包</strong></h3><p>镜像的 Tag 选择</p><ul><li><code>日期 + &lt;short_commid_id&gt;</code>: 持续交付方式的镜像打包，可保留以往的</li><li><code>&lt;mvn_version&gt;</code>: mvn 版本，不断的覆盖，随模块版本稳定而稳定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0-YYmmddHHMMSS-abddfd</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><p><strong>合并多个 RUN 减少镜像层数</strong></p><p>合并多个 RUN 成一个，因为每次 RUN 都是在原有的镜像上增加一层，可有效减少镜像中的层数</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt-get -y install \</span></span><br><span class="line"><span class="bash">    openjdk-8-jdk ssh vim </span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> target/app.jar /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>选取合适的基础镜像</strong></p><p>使用 alpine 架构的 Linux 一般生成的镜像比较小，根据需要选择可以满足运行条件的最小镜像，自己构建镜像，使用公司内部镜像，借助 Dockerfile 更改部分内容适配需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node:10.16.3-alpin   74M</span><br><span class="line">node:10.16.3         904M</span><br><span class="line">node:10.16.3-stretch</span><br><span class="line">node:10.16.3-bruster</span><br></pre></td></tr></table></figure><p><strong>可重建性</strong></p><p>制作镜像时将源码打包进入镜像中，在镜像提供的环境中进行源码的编译打包，之后运行此种方式配合容器的挂载映射，实现每次运行时的配置都是最新的</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.6</span>-jdk-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pom.xml .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src ./src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -e -B package</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>多阶段构建</strong></p><p>使用某个镜像作为构建环境，之后引用其中的文件，不会将该辅助镜像打包进最后生成的镜像中; 将编译和运行过程分离开，与通过 Jenkins 的 docker agent 进行编译镜像实现类似</p><p>方便控制构建环境的版本，不易出现版本问题</p><p>可以使用配有公司 Maven 私服地址的 Maven 镜像作为编译环境，之后在容器中编译打包，从构建包传递到 JDK 环境的运行包中，执行最终的构建</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jar 的打包和运行</span></span><br><span class="line"><span class="comment"># As Builder 指定构建过程中的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.6</span>-jdk-<span class="number">8</span>-alpine As builder </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app </span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pom.xml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -e -B dependency:resolve </span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src ./src </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -e -B package </span></span><br><span class="line"><span class="comment"># 实际运行的环境</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine </span><br><span class="line"><span class="comment"># 从 Builder 中复制</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/target/app.jar /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br><span class="line"><span class="comment"># Web 项目的打包和运行</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10.16</span>.<span class="number">3</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app/</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ../Doc ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build:docker</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker/nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /usr/src/app/dist  /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="运行参数和动态控制"><a href="#运行参数和动态控制" class="headerlink" title="运行参数和动态控制"></a>运行参数和动态控制</h3><p><strong>COPY 实现自定义配置</strong></p><p>可以实现容器内配置的覆盖，一般配合 WORKDIR 使用</p><p>可以实现相对路径下的文件拷贝到容器中，存在时覆盖原有文件</p><p>可自动实现文件的重命名</p><p>NOTE:</p><ul><li>对于可执行文件，需要进行赋权</li><li>对于配置文件，特定组件需要文件有指定的权限，如 MySQL 的配置文件</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工程文件复制到镜像</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ../devops ./</span></span><br><span class="line"><span class="comment"># 配置覆盖</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker/nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="comment"># 当前目录下文件作为容器中的部分配置</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="comment"># 相对路径下的所有文件拷贝到指定目录，不包含该路径文件夹</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./dist  /usr/share/nginx/html/</span></span><br><span class="line"><span class="comment"># Dockerfile_rabbit3.6</span></span><br><span class="line"><span class="keyword">FROM</span> docker.elastic.co/logstash/logstash:<span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"><span class="comment"># 别名指定</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> logstash.yml /usr/share/logstash/config/logstash.yml</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jvm.options /usr/share/logstash/config/jvm.options</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9600</span></span><br></pre></td></tr></table></figure><p>动态参数和配置</p><p><strong>RUN + echo 实现自定义配置</strong></p><p>通过 RUN 执行 shell 命令，将需要的配置插入到配置文件的尾部，从而覆盖之前编写的配置，实现自定义配置</p><p>只适合使用 key=val 方式的配置文件，对于 json 格式的配置文件无法使用</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.6</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;lower_case_table_names=1&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;max_allowed_packet=100M&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;innodb_log_file_size=500M&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;wait_timeout=57600&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;interactive_timeout=57600&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;transaction_isolation=READ-COMMITTED&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;event_scheduler=1&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;max_connections=500&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;innodb_lock_wait_timeout=500&quot;</span> &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf</span></span><br></pre></td></tr></table></figure><p><strong>COPY + Shell + Sed + ENTRYPOINT 自定义配置</strong></p><p>将带有一定模板值的多个配置文件 COPY 进镜像中，将通过 sed 进行配置替换的脚本 COPY 进镜像，将配置替换脚本作为 ENTRYPOINT;</p><p>即使配置文件对应的应用不支持传入变量值和环境变量也可以通过此种方式使其支持;</p><p>实际使用：</p><ul><li>运行在 Nginx 容器中的 web 项目，动态替换框架打包的 umi 中的配置，实现环境的指定；</li><li>运行在 tomcat 容器中的 war Java 项目，在运行启动后，对应的 war 包的内容被解压开来，更改配置文件的位置，一般是 xx.properties、xxxx.yml，之后重启整个容器应用更改</li></ul><p><strong>ENV 指定实现特定功能</strong></p><p>三种语法</p><p>配合 Python 脚本将传入的环境变量进行解析成 Ansible 连接的信息</p><p>运行时指定环境变量实现动态运行控制</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定路径、版本...</span></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_HOME=/apache-maven-<span class="number">3.3</span>.<span class="number">9</span></span><br><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.6</span>.<span class="number">45</span>-<span class="number">1</span>debian9</span><br><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">8.9</span>.<span class="number">4</span></span><br><span class="line"><span class="comment"># 指定系统环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br><span class="line"><span class="comment"># 指定一组环境变量参数</span></span><br><span class="line"><span class="keyword">ENV</span> ANSIBLE_HOSTS=<span class="string">&quot;test1:127.0.0.1&quot;</span> \</span><br><span class="line">    ANSIBLE_PORT=<span class="string">&quot;22&quot;</span> \</span><br><span class="line">    ANSIBLE_USER=<span class="string">&quot;root&quot;</span> \</span><br><span class="line">    ANSIBLE_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">    ANSIBLE_FILE=<span class="string">&quot;centos_init_test&quot;</span></span><br></pre></td></tr></table></figure><p><strong>多用途构建文件拆分</strong></p><p>通过 Dockerfile、Dockerfile.hub、Dockerfile.dev、<a href="http://dockerfile.in/">Dockerfile.in</a> 增加文件后缀方式区分构建的用途</p><p>通过<code>Dockerfile_&lt;iamge_name&gt;&lt;image_version&gt;_&lt;env&gt;_for_&lt;gole&gt;</code> 指明所属环境版本、目的、特定版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dockerfile  </span><br><span class="line">Dockerfile.hub</span><br><span class="line">Dockerfile.dev</span><br><span class="line">Dockerfile_alpine_3.5</span><br><span class="line">Dockerfile_mysql5.6_v6</span><br><span class="line">Dockerfile_tomcat8539-jre811-for-prod</span><br></pre></td></tr></table></figure><p><strong>配合构建工具实现一键发布</strong></p><p>对于 Maven 项目，通过 docker-maven-plugin 实现自定义选择阶段，只需在命令后增加 <code>docker:build</code>， <code>docker:push</code> 即可，同时可以将阶段绑定到对应 mvn 命令，如 package、deploy</p><p>对于 Node 项目，可以自定义 npm run 命令，在 package.json 中定义好 scripts 指定好某个命令的执行指令，并支持多个命令的合并运行，命令之间顺序任意，以此方便项目的 CI</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;docker-hub:build&quot;: Dockerfile_jenkins_jdk8-maven3.6.1,</span><br><span class="line">&quot;docker:tag&quot;: &quot;docker tag docker.io/project/web&quot;,</span><br><span class="line">&quot;docker-registry:login&quot;:  &quot;docker login -u &lt;user-name&gt; -p&lt;password&gt;&quot;,</span><br><span class="line">&quot;docker:push&quot;: &quot;npm run docker-hub:build &amp;&amp; npm run docker:tag &amp;&amp; npm run docker-registry:login &amp;&amp; docker push &lt;image-name&gt;&quot;,</span><br><span class="line">mvn deploy</span><br><span class="line">mvn clean package docker:push -Pdocker</span><br></pre></td></tr></table></figure><p><strong>ENTRYPOINT + CMD 参数填充</strong></p><p>指定命令参数覆盖 -?，实现指定参数的运行，配合特定运行 jar 包随着 main 类传入参数定制容器的行为</p><p>适合 “一次性命令”，启动的容器目的只是依赖于容器内部的工具执行特定的脚本，方便实现数据库的安装、redis-trib 构建集群便是此种方式</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;setup.jar&quot;</span>] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-?&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>ENTRYPOINT + <a href="http://docker-entrypoint.sh/">docker-entrypoint.sh</a> + 环境变量实现定制化运行</strong></p><p>在 <a href="http://docker-entrypoint.sh/">docker-entrypoint.sh</a> 中指定多种后缀类型的文件执行不同的处理</p><p>通过执行一个初始化脚本，对于 MySQL 环境初始项目需要使用的数据库，并实现权限的分配。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh /opt/app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /opt/app/docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;/opt/app/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>不在其中进行修改文件</strong></p><p>镜像修改会新增一个层，对于修改文件或目录权限，会将文件复制一份</p><p>在 Dockerfile 之前设置好或是通 entrypoint 进行修改</p><p><strong>使用 dockerignore 文件</strong></p><p>执行 docker build 时忽略特定的路径和文件，加速构建过程</p><h3 id="运行时参数指定"><a href="#运行时参数指定" class="headerlink" title="运行时参数指定"></a>运行时参数指定</h3><p><strong>构建阶段动态配置</strong></p><p>常见的编译构建类型</p><ul><li>Docker 镜像的编译构建</li><li>Java 项目的编译构建成对应的 jar 可运行包</li><li>Web 进行编译构建成静态文件</li><li>Android 项目的打包构建</li><li>Flutter 项目的打包构建</li></ul><p>构建过程中的工具 Maven、Gradle、npm。</p><p>Profile： 指定 Maven 的 resource 为不同的目录，仅能够支持配置文件和一些 Maven 插件配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="comment"># 所有的通用配置</span></span><br><span class="line">resource.dev <span class="comment"># 开发配置</span></span><br><span class="line">resource.test <span class="comment"># 测试配置</span></span><br><span class="line">resource.prod <span class="comment"># 生产环境配置</span></span><br><span class="line">resource.docker <span class="comment"># docker ... 可等价于 生产环境</span></span><br></pre></td></tr></table></figure><p>3、Git 的分支控制</p><p>更改分支上的配置内容实现环境的拆分，可以实现非配置文件的更改，直接修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b prod</span><br><span class="line">git checkout -b dev</span><br><span class="line">git checkout -b test</span><br><span class="line">git checkout -b mock</span><br><span class="line">git checkout -b docker</span><br></pre></td></tr></table></figure><p>4、Jenkins 构建变量</p><p>在 Jenkins 中添加条件变量，在每次构建的时候选择需要构建的环境，配合 Shell 脚本将源码中的文件进行替换，实现和 Git 分支控制一样的效果</p><p>如在 WEB-INFO 下的 db.properties，无法通过 上述1、2处理，可以在对应目录下再建一个 db.prod.properties，Jenkins 判断为 prod 环境时，对 db.properties 删除，db.prod.properties 进行重命名即可</p><p><strong>Dockerfile 中的动态配置</strong> 通过 <code>COPY</code>, <code>ADD</code> 将自定义配置放入 image 中</p><p><strong>运行阶段动态配置</strong></p><p>通过 kube 控制 k8s 集群进行运行通过 docker 命令在本机运行通过 ansible 控制机器运行通过 jenkins 的 ssh 工具控制机器运行</p><p>关于运行的环境选择，针对 Java 项目当前已知三种方式进行环境区分： Spring 的 profile，更细致的是 Condition + 各种判断控制，控制较为灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application-dev.properties</span><br><span class="line">application-test.properties</span><br></pre></td></tr></table></figure><p><strong>构建后运行前阶段的动态配置</strong></p><p>1、通过 Docker 的 entrypoint 指定参数拼凑运行的配置或命令 从环境变量中取值，进行环境判断和动态赋值</p><p>2、通过 SpringBoot 的 jar 参数控制 SpringBoot 作为可运行 jar，内部调用一个 sh 脚本控制</p><p>3、通过 volumn 映射配置执行 将指定的配置文件进行映射 将指定的配置文件夹进行映射</p><p>4、镜像中集成 template 更新模板参数，对配置模板渲染生成后重启</p><h3 id="运行后配置"><a href="#运行后配置" class="headerlink" title="运行后配置"></a>运行后配置</h3><p>1、更改配置不重启(重启失效) 一些组件支持在运行过程中更改配置，一般重启后配置失效</p><p>redis 的动态配置</p><ul><li>连接的主服务器</li><li>持久化配置</li><li>..</li></ul><p>mysql 的动态配置</p><ul><li>字符集</li><li>信任function - ..</li></ul><p>2、更改配置重启 适合容器中的配置文件可见，对于使用 jar 包运行的参数拼接可更改对应的 <code>docker-entrypoint.sh</code> 中的 JVM 和 Springboot 配置文件参数实现</p><ul><li>直接在容器中更改配置文件重启</li><li>通过 <code>docker cp</code> 方式将更改好的配置复制到容器中后重启</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/10km/article/details/79046864">docker:mysql启动时自动执行初始建表脚本_10km的专栏-CSDN博客</a></p><p>docker:mysql启动时自动执行初始建表脚本</p><p><a href="https://www.cnblogs.com/han-1034683568/p/6941337.html">https://www.cnblogs.com/han-1034683568/p/6941337.html</a></p><p>让docker中的mysql启动时自动执行sql文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构建发布&quot;&gt;&lt;a href=&quot;#构建发布&quot; class=&quot;headerlink&quot; title=&quot;构建发布&quot;&gt;&lt;/a&gt;构建发布&lt;/h2&gt;&lt;p&gt;一键构建发布&lt;/p&gt;
&lt;p&gt;通过 node 命令合并，maven 插件集成，zsh 终端别名命令定制，Jenkins CIC</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>HBase</title>
    <link href="http://example.com/2021/03/09/HBase/"/>
    <id>http://example.com/2021/03/09/HBase/</id>
    <published>2021-03-08T23:48:46.000Z</published>
    <updated>2021-04-20T03:07:39.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>基于 Google 的 BigTable 论⽂⽽来， 一个高可靠性、高性能、面向列、非关系型、可伸缩、支持海量存储的分布式存储系统。提供超大规模数据集的实时随机读写。</p></blockquote><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="http://img.janhen.com/20210130165638image-20201028233637286.png" alt="http://img.janhen.com/20210130165638image-20201028233637286.png"></p><ul><li>Zookeeper： 实现 HMaster 的⾼可⽤，对 RegionServer 监控，元数据的入口和集群配置的维护。</li><li>HMaster（Master）： 为 HRegionServer 分配 Region<ul><li>分配 region，进行 RegionServer 的负载均衡，失效 Region 的重新分配</li></ul></li><li>HRegionServer（RegionServer）：  处理来自 Client 的读写请求，负责与底层 HDFS 交互，数据存放到 HDFS，处理 Region 变大后的拆分，负责 Storefile 的合并</li><li>Region：多个 Store 构成。一个 Store 对应 Storefile、MemStore 组成。一个 Store 对应 HBase 表的一个列族。<ul><li>MemStore：</li><li>StoreFile(HFile)： 磁盘上保存原属数据的实际物理文件，StoreFile 以 Hfile 的形式存储在 HDFS 中。</li></ul></li><li>Client： 访问 HBase 接口，维护对应的 cache 来加速 HBase 访问，如 cache 的 .META 元数据信息</li><li>HDFS: HDFS 为 Hbase 提供可靠的底层数据存储服务</li><li>MapReduce: MapReduce 为 HBase 提供高性能的计算能力</li></ul><h3 id="HBase-特性"><a href="#HBase-特性" class="headerlink" title="HBase 特性"></a>HBase 特性</h3><p>HBase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。</p><p><strong>必须借助 RowKey 进行大数据量的存取</strong></p><p>特性：</p><ul><li>数据的多版本：HBase 表中的数据有多个版本值，默认情况下是根据版本号去区分，版本号就是插⼊数据的时间戳</li><li>数据类型单⼀：所有的数据在 HBase 中是以字节数组进⾏存储</li><li>HBase 适合海量明细数据的存储，并且后期需要有很好的查询性能（单表超千万、上亿，且并发要求⾼）</li><li>列式存储：根据列族存储，列族在建表的时候必须指定。</li><li>易于扩展：基于上层处理能力(RegionServer) 的扩展，基于存储的扩展(HDFS)。</li><li>列缺失的情况下关系型数据库存在存储空间浪费问题。</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><strong>逻辑存储</strong></p><p>列族： 可稀疏存储。建表时指定。写入文件时以列族存储。</p><p>Region： 表的若干行组成，不能跨 RegionServer。</p><p>Store：</p><p><strong>物理存储</strong></p><p><img src="http://img.janhen.com/20210130165631image-20201028233301935.png" alt="http://img.janhen.com/20210130165631image-20201028233301935.png"></p><ul><li>TimeStamp: 数据的版本。</li><li>Type：</li><li>RowKey： 每行数据的主键。</li><li>Column Family： 列族。</li><li>Cell： 每个版本一个 Cell。</li><li>Region：表的分区。</li></ul><h2 id="Hbase-原理"><a href="#Hbase-原理" class="headerlink" title="Hbase 原理"></a>Hbase 原理</h2><h3 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h3><p><img src="http://img.janhen.com/20210130165643image-20201029082348655.png" alt="http://img.janhen.com/20210130165643image-20201029082348655.png"></p><p>相关组件内容：</p><ul><li>BlockCache： 查询时先到 BlockCache 中找，再到 StoreFile 中读取。从 StoreFile 读取后，将数据写入 BlockCache，之后返回结果给 Client。为读缓存。缓存为 RowKey 级别的。</li><li>MetaCache： Client 为提高查询速度缓存元数据(ZooKeeper 中的数据)。</li><li>MemStore： 每个 Store 持有一个。</li></ul><p>读取数据的过程中 HMaster 未参与。</p><p>HBase 读取流程：</p><p>1）⾸先从 zk 找到 meta 表的 region 位置，然后读取 meta 表中的数据，meta 表中存储了用户表的 region 信息。 2）根据要查询的 namespace、表名和 rowkey 信息。找到写入数据对应的 region 信息 3）找到这个 region 对应的 regionServer，然后发送请求 4）查找对应的 region 5）先从 memstore 查找数据，若不存在，再从 BlockCache 上读取 HBase 上 Regionserver 的内存分为两个部分</p><ul><li>部分作为Memstore，主要⽤用来写；</li><li>另外⼀一部分作为BlockCache，主要⽤用于读数据；</li></ul><p>6）如果 BlockCache 中也没有找到，再到 StoreFile 上进行读取 从 storeFile 中读取到数据之后，不是直接把结果数据返回给 Client，而是把数据先写⼊到B lockCache 中，⽬的是为了加快后续的查询；然后在返回结果给 Client。</p><h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><p><img src="http://img.janhen.com/20210414073929HBase-write.jpg" alt="http://img.janhen.com/20210414073929HBase-write.jpg"></p><p>相关的组件：</p><ul><li>WAL： Write ahead log，预写入日志。</li><li>MemStore： 写缓存。flush 刷盘</li><li>HBase 的写入性能比读取性能好。</li></ul><p>HBase 写入数据流程：</p><p>1）⾸先从 zk 找到 meta 表的 region 位置，然后读取 meta 表中的数据，meta 表中存储了了⽤户表的 region 信息 2）根据 namespace、表名和 rowkey 信息。找到写入数据对应的 region 信息 3）找到这个 region 对应的 regionServer，然后发送请求 4）把数据分别写到 HLog（write ahead log）和 Memstore 各一份 5）Memstore 达到阈值后把数据刷到磁盘，⽣成 storeFile 文件 6）删除 HLog 中的历史数据</p><p>HLog 与 MemStore 各写一份，flush 机制，Compact 机制</p><h3 id="HBase-Flush-机制"><a href="#HBase-Flush-机制" class="headerlink" title="HBase Flush 机制"></a>HBase Flush 机制</h3><p>当 MemStore 的大小超过指定值得时候，需要进行 Flush。</p><p>默认为 100M。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 手动 Flush</span><br><span class="line">flush &lt;table-name&gt;</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><ul><li><code>hbase.hregion.memstore.flush.size</code>： 当 memstore 的⼤小超过这个值的时候，会 flush 到磁盘,默认为 128M</li><li><code>hbase.regionserver.optionalcacheflushinterval</code>： 当 memstore 中的数据时间超过 1 小时，会 flush 到磁盘</li><li><code>hbase.regionserver.global.memstore.size</code>： HregionServer 的全局 memstore 的⼤小，超过该⼤小会触发 flush 到磁盘的操作,默认是堆⼤小的 40%</li></ul><h3 id="HBase-阻塞机制"><a href="#HBase-阻塞机制" class="headerlink" title="HBase 阻塞机制"></a>HBase 阻塞机制</h3><p>触发机制：</p><p>(1) memstore 中数据达到 512MB</p><p>计算公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase.hregion.memstore.flush.size*hbase.hregion.memstore..block.multiplier</span><br></pre></td></tr></table></figure><p>(2) RegionServer 全部 memstore 达到规定值</p><p><strong>配置参数</strong></p><ul><li>hbase.hregion.memstore.flush.size：</li><li>hbase.hregion.memstore.block.multiplier：</li></ul><h3 id="Compact-合并机制"><a href="#Compact-合并机制" class="headerlink" title="Compact 合并机制"></a>Compact 合并机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">major_compact &lt;table-name&gt;</span><br></pre></td></tr></table></figure><p><strong>Minor compact 小合并</strong>：</p><p>多个 HFile(StoreFIle) 合并为一个 HFile。 删除和更新知识做标记，为物理删除，触发频率高。</p><p>触发机制：</p><p>(1) MemStore Flush</p><p>(2) 定期检查线程调用，默认 10s</p><p><strong>Major Compact 大合并</strong></p><p>合并 Store 中所有的 HFile 为一个 HFile。</p><p>会真正移除删除标记的数据。触发频率低。默认 7 天执行。一般手动控制执行，防止业务高峰。</p><p><strong>配置参数</strong></p><ul><li><code>hbase.hstore.compaction.min</code>： 待合并⽂文件数据必须⼤大于等于该值</li><li><code>hbase.hstore.compaction.max</code>： 待合并⽂文件数据必须⼩小于等于该值，默认 10</li><li><code>hbase.hstore.compaction.min.size</code>： ⽂件⼤⼩小于该值的 store file 一定会加入到 minor compaction的store file中</li><li><code>hbase.hstore.compaction.max.size</code>：⽂件⼤⼩⼤于该值的 store file 一定会被 minor compaction 排除，默认值为 LONG.MAX_VALU</li><li><code>hbase.server.thread.wakefrequency</code>： 周期性检查是否需要 compaction 操作，，默认值是 10000 millseconds</li><li><code>hbase.hregion.majorcompaction</code>： 默认值为 7 天进⾏一次⼤合并</li></ul><h3 id="Region-拆分机制"><a href="#Region-拆分机制" class="headerlink" title="Region 拆分机制"></a>Region 拆分机制</h3><p><img src="http://img.janhen.com/20210130165652image-20201102205904080.png" alt="http://img.janhen.com/20210130165652image-20201102205904080.png"></p><p><strong>拆分策略</strong></p><p>(1) ConstantSizeRegionSplitPolicy</p><p>0.94- 默认切分</p><p>(2) IncreasingToUpperBoundRegionSplitPolity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regioncount ^3 * 128M * 2</span><br></pre></td></tr></table></figure><p>(3) SteppingSplitPolity</p><p>2.0 默认的策略。和待分裂 region 所属表在当前 regionserver 上的 region 个数有关</p><p>(4) KeyPrefixRegionSpliPolicy</p><p>(5) DelimitedKeyPrefixRegionSPlitPolicy</p><p>(6) DisabledRegionSplitPolicy</p><p>不启用切分。</p><p><strong>指定策略</strong></p><p>(1) 全局指定</p><p>(2) 通过 Java API 指定策略</p><p>(3) 通过 Hbase SHell 指定策略</p><ul><li><code>hbase.regionserver.region.split.policy</code>： 指定拆分策略，如<code>org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy</code></li></ul><h3 id="Region-合并"><a href="#Region-合并" class="headerlink" title="Region 合并"></a>Region 合并</h3><blockquote><p>仅用于维护的目的。</p></blockquote><p>冷合并：不需要启动 HBase 集群。对 RowKey 进行合并。</p><p>热合并： 在线进行合并。</p><h2 id="Hbase-原理-1"><a href="#Hbase-原理-1" class="headerlink" title="Hbase 原理"></a>Hbase 原理</h2><h3 id="HBase-表的预分区-Region"><a href="#HBase-表的预分区-Region" class="headerlink" title="HBase 表的预分区(Region)"></a>HBase 表的预分区(Region)</h3><p>表被创建时候，默认分配一个 Region 给 Table。此时读写都到同一个 RegionServer 的同一个 Region，无法 Balance。</p><p>预分区的好处：</p><ul><li>增加数据读写效率</li><li>负载均衡，防⽌止数据倾斜</li><li>⽅便集群容灾调度 region</li></ul><h3 id="协处理器"><a href="#协处理器" class="headerlink" title="协处理器"></a>协处理器</h3><blockquote><p>Observer 协处理器，将业务运算代码封装到 Coprocessor 中，并在 RegionServer 上运行，即在数据实际存储位置执行，最后将运算结果返回给 Client。</p></blockquote><p>默认访问 HBase 使用 scan / get 获取数据，对数据进行业务运算，数据量大的情况下，会出现性能问题。</p><p><strong>类似数据库中的触发器和存储过程</strong>、Hadoop 中的 MapReduce、Spring 中的 AOP。</p><ul><li>Observer Coprocessor： 类似触发器，可以在一些事件(Get, Scan) 发生前后执行指定的代码。</li><li>Endpoint Coprocessor： 类似存储过程，在 RegionServer 上直接存储的数据计算。</li></ul><p>(1) OBSERVER</p><p>与触发器类似</p><ul><li>RegionObserver：⽤户可以⽤这种的处理器处理数据修改事件，它们与表的 region 联系紧密。</li><li>MasterObserver：可以被⽤作管理或 DDL 类型的操作，这些是集群级事件。</li><li>WALObserver：提供控制 WAL 的钩⼦函数</li></ul><p>HBase 的一种二级索引通过此种方式实现。</p><p>(2) Endpoint</p><p>类似存储过程，在 RegionServer 中执行代码</p><p>常见用途： 聚合操作。普通操作为全表扫描。</p><p>Endpoint Coprocessor 借助 phoenix 框架容易实现。针对 HBase 数据集进行聚合运算直接使用 SQL 语句。</p><p>初始化表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create &#39;t1&#39;,&#39;info&#39;</span><br><span class="line">create &#39;t2&#39;,&#39;info&#39;</span><br></pre></td></tr></table></figure><p>安装处理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /processor</span><br><span class="line">hdfs dfs -put processor.jar /processor</span><br><span class="line"></span><br><span class="line"><span class="comment"># HBase</span></span><br><span class="line">describe <span class="string">&#x27;t1&#x27;</span></span><br><span class="line">alter <span class="string">&#x27;t1&#x27;</span>,METHOD =&gt; <span class="string">&#x27;table_att&#x27;</span>,<span class="string">&#x27;Coprocessor&#x27;</span>=&gt;<span class="string">&#x27;hdfs://linux121:9000/processor/processor.jar|com.janhen.bigdata.hbase.processor.MyProcessor|1001|&#x27;</span></span><br><span class="line">describe <span class="string">&#x27;t1&#x27;</span></span><br></pre></td></tr></table></figure><p>验证处理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put <span class="string">&#x27;t1&#x27;</span>,<span class="string">&#x27;rk1&#x27;</span>,<span class="string">&#x27;info:name&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span></span><br></pre></td></tr></table></figure><p>卸载处理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> <span class="string">&#x27;t1&#x27;</span></span><br><span class="line">alter <span class="string">&#x27;t1&#x27;</span>,METHOD=&gt;<span class="string">&#x27;table_att_unset&#x27;</span>,NAME=&gt;<span class="string">&#x27;coprocessor$1&#x27;</span></span><br><span class="line"><span class="built_in">enable</span> <span class="string">&#x27;t2&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="RowKey-设计"><a href="#RowKey-设计" class="headerlink" title="RowKey 设计"></a>RowKey 设计</h3><p>RowKey 的设计会直接影响 HBase 的使用效率</p><p>HBase 是<strong>三维有序存储的</strong>，通过 rowkey, column key(column family 和 qualifier) 和 timestamp 这三个维度对 HBase 中的数据进行快速定位。</p><p>HBase 的查询方式</p><ul><li>get 方式，指定 rowkey 获取唯一一条数据</li><li>scan 方式，设置 startRow 和 stopRow 参数进行范围匹配</li><li>全表扫描:  直接扫描整个表中的所有记录</li></ul><p>RowKey 是一个二进制码流(byte[])，最大长度 64Kb，实际一般为 10 - 100 bytes，一般设置为定长的。</p><p><strong>设计良好的数据访问模式可以使集群被充分、均衡的利用。</strong></p><p><strong>基本原则</strong></p><p>(1) 长度原则：</p><p>建议越短越好，不要超过 16 字节。</p><ul><li>HBase 持久化文件 HFile 中按照 KeyValue 存储，RowKey 过长，占用空间内大，影响 HFile 的存储效率。</li><li>MemStore 将缓存部分数据到内存，若 rowkey 字段过长，内存的有效利用率降低，系统不可缓存更多的数据，降低检索效率。</li><li>当前 OS 都为 64 位，内存 8 字节对齐，控制在 16 字节，利用了 OS 的最佳特性。</li></ul><p>(2) 散列原则：</p><p>如果 RowKey 按照时间戳方式递增，不要将时间戳放到二进制码前面，将 RowKey 的高位作为散列字段，由程序随机生成，低位放时间字段，提高数据负载均衡分布到每个 RegionServer，实现负载均衡的机率。</p><p>若没有散列字段，首字段直接是时间信息，所有数据集中在一个 RegionServer 上，在数据检索时负载会集中在个别的 RegionServer 上，造成热点问题，降低查询效率。</p><p>(3) 唯一原则：</p><p>设计时保证唯一性，RowKey 是按照字典顺序排序存储的，设计的时候可利用这个排序的特点，将经常读取的数据存储到一块、最近可能被访问的数据放到一块实现的 HBase 中快速的读写</p><h3 id="表热点"><a href="#表热点" class="headerlink" title="表热点"></a>表热点</h3><blockquote><p>大量的 Client 直接访问集群中的一个或少数几个节点，造成少数region server 的读/写请求过多、负载过大，⽽其他 region server 负载却很小。</p></blockquote><p>造成热点 Region 所在的单个机器超出自身承受能力，引起性能下降甚至 Region 不可用，会影响同一个 RegionServer 上其他的 Region，由于主机无法服务其他 Region 的请求。</p><p><strong>糟糕的 RowKey 是热点的源头</strong></p><p>处理表的热点方案：</p><p>(1) 预分区：避免前期读写都在一个 RegionServer</p><p>(2) 加盐：非密码学上的加盐，而是<em>在 RowKey 前增加一个随机数</em>。操作起来较为复杂。</p><p>(3) 哈希：较为简单。使同⼀一⾏行行永远⽤用⼀一个前缀加盐。</p><p>(4) 反转：反转固定长度或者数字的 RowKey，牺牲了 RowKey 的有序性。一般用字符串进行反转，如手机号的反转、时间戳的反转</p><h3 id="HBase-的二级索引"><a href="#HBase-的二级索引" class="headerlink" title="HBase 的二级索引"></a>HBase 的二级索引</h3><p>本质就是建⽴ hbase 表中列与行键之间的映射关系。</p><p>借助其他的开源</p><p>常见二级索引 Phoenix / solr / es…</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>HBase 底层中使用，判断某个元素是否存在。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://hbase.apache.org/book.html#quickstart">Apache HBase ™ Reference Guide</a></p><p>HBase 文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hbase&quot;&gt;&lt;a href=&quot;#Hbase&quot; class=&quot;headerlink&quot; title=&quot;Hbase&quot;&gt;&lt;/a&gt;Hbase&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="HBase" scheme="http://example.com/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>Guava使用</title>
    <link href="http://example.com/2021/03/09/Guava%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/03/09/Guava%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-08T17:24:34.000Z</published>
    <updated>2021-04-14T01:14:06.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong>Joiner 字符拼接</strong></p><p><strong>1、Joiner | JDK8 Stream</strong> 字符拼接常见操作：</p><ul><li>不带空元素的拼接</li><li>对空元素使用默认值拼接</li><li>写入文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String result=Joiner.on(<span class="string">&quot;#&quot;</span>).join(stringList);</span><br><span class="line">String result =Joiner.on(<span class="string">&quot;#&quot;</span>).userorNull(<span class="string">&quot;DEAULT&quot;</span>).join(stringListwithNull);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StringBuilder builder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder resultBuilder=Joiner.on(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    .useForNull(<span class="string">&quot;DEFAULT&quot;</span>)</span><br><span class="line">    .appendTo(builder, stringListwithNullval);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer</span></span><br><span class="line"><span class="keyword">try</span> (Filewriter writer = <span class="keyword">new</span> Filewriter(<span class="keyword">new</span> File(targetFileName))) &#123;</span><br><span class="line">    Joiner.on(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">        .useForNull(<span class="string">&quot;DEFAULT&quot;</span>)</span><br><span class="line">        .appendTo(writer, stringListwithNullValue);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    fail(<span class="string">&quot;append to the writer occur fetal error.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK8 中的 Join 中的 Stream：跳过 Null 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String result=stringListwithNullValue.stream()</span><br><span class="line">    .filter(item-&gt;item!=<span class="keyword">null</span> &amp;&amp; !item.isEmpty()).collect(joining(<span class="string">&quot;#&quot;</span>));</span><br><span class="line"><span class="comment">// null to defalut</span></span><br><span class="line">String result=stringListwithNullValue.stream()</span><br><span class="line">    .map(item-&gt;item==<span class="keyword">null</span> || item.isEmpty()?<span class="string">&quot;DEFAULT&quot;</span>:item).collect(joining(<span class="string">&quot;#&quot;</span>));</span><br><span class="line"><span class="comment">// function infer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoiningByStreamwithDefaultyalue</span><span class="params">()</span></span>&#123;</span><br><span class="line">string result =stringListwithNullValue.stream()</span><br><span class="line">    .map(<span class="keyword">this</span>::defaultValue)</span><br><span class="line">    .collect(joining(<span class="string">&quot;#&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>2、Map 拼接</strong> 将 Map 的键值按照特定分隔符进行拼接 默认 key 和 val 通过 <code>=</code> 进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,string&gt; stringMap = of(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Guaga&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">assertThat(Joiner.on(<span class="string">&#x27;#&quot;).withKeyValueSeparator(&quot;=&quot;).join(stringMap), equalTo(&quot;Hello=Guava#Java=Scala&quot;));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">try(FileWriter writer=new Filewriter(new File(targetFileNameToMap)))&#123; </span></span><br><span class="line"><span class="string">  Joiner.on(&quot;#&quot;).withKeyValueSeparator(&quot;=&quot;).appendTo(writer, stringMap);</span></span><br><span class="line"><span class="string">  assertThat(Files.isFile().test(new File(targetFileNameToMap)), equalTo(true));</span></span><br><span class="line"><span class="string">&#125; catch (IOException e)&#123;</span></span><br><span class="line"><span class="string">  fail(&quot;append to the writer occur fetal error.&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Splitter 字符分隔</strong></p><p>剔除一些无用的 按照特定分隔符分隔并转化成 List 剔除掉空的字符并转化成 List</p><p>指定分隔符 剔除 Blank 字符 剔除剔除 Empty 字符 收集结果成为 List <strong>1、分隔与忽略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 普通分隔</span></span><br><span class="line">List&lt;String&gt;result=Splitter.on(<span class="string">&quot;|&quot;</span>).splitToList(<span class="string">&quot;hellolworld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2 忽略空串</span></span><br><span class="line">List&lt;string&gt;result=Splitter.on(<span class="string">&quot;|&quot;</span>).omitEmptystrings().splitroList(<span class="string">&quot;hellolworldlll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3 忽略空格并忽略空串</span></span><br><span class="line">result=Splitter.on(<span class="string">&quot;I&quot;</span>).trimResults().omitEmptystrings().splitroList(<span class="string">&quot;hel1o I worldlll&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>2、正则分隔</strong> 使用 <code>onPattern</code> 替代 <code>on</code>, 参数即为正则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1 传入正则表达式进行分隔</span></span><br><span class="line">List&lt;String&gt;result=Splitter.onPattern(<span class="string">&quot;\\\\\\\\l&quot;</span>).trimResults().omitEmptystrings().splitTorist(<span class="string">&quot;hello | worldl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 传入正则Pattern</span></span><br><span class="line">List&lt;string&gt;result =Splitter.on(Pattern.compile(<span class="string">&quot;\\\\l&quot;</span>)).trimResults(). omitEmptystrings().splitToList(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>3、结果分隔</strong> 通过字符长度截取字符串 截取结果中固定的个数，最后的保存剩余所有的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1 分隔固定长度，报文的固定长度截取 aaabbbccc</span></span><br><span class="line">List&lt;string&gt; result = Splitter.fixedtength(<span class="number">4</span>).splitToList(<span class="string">&quot;aaaabbbbccccdddd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 限制返回的结果数，多余的放在最后一个结果中</span></span><br><span class="line">List&lt;String&gt;result=Splitter.on(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .splitToList(<span class="string">&quot;hello# world# java# google# scala&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3 传入正则Pattern, 返回 Map</span></span><br><span class="line">Map&lt;String, String&gt; result = Splitter.on(Pattern.compile(<span class="string">&quot;\\\\\\\\l&quot;</span>))</span><br><span class="line">    .trimResults()</span><br><span class="line">    .omitEmptystrings()</span><br><span class="line">    .withKeyValueSeparator(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    .split(<span class="string">&quot;hello=HELLOl|world=WORLD|||&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>String 其他工具</strong></p><p><strong>1、Strings</strong> 填充字符串 获取公共前缀|后缀 重复指定次数的字符串: 和 python 进行重复类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assertlhat(strings.emptytovull(<span class="string">&quot;&quot;</span>) rnullvalue())</span><br><span class="line">assertThat(Strings.nullToEmpty(<span class="keyword">null</span>), equalro(<span class="string">&quot;&quot;</span>)); </span><br><span class="line">assertThat(strings.nullToEmpty(<span class="string">&quot;hello&quot;</span>), equalTo(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertThat(Strings.commonPrefix(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Hit&quot;</span>), equalTo(<span class="string">&quot;H&quot;</span>));</span><br><span class="line">assertThat(Strings.commonPrefix(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Xit&quot;</span>), equalro(<span class="string">&quot;&quot;</span>));</span><br><span class="line">assertThat(Strings.commonSuffix(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Echo&quot;</span>), equalTo(<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertThat(Strings.repeat(<span class="string">&quot;Alex&quot;</span>,<span class="number">3</span>), equalTo(<span class="string">&quot;AlexAlexAlex&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertlhat(btrings.<span class="number">1</span>sNullormpty(nulL), equallo(<span class="keyword">true</span>))</span><br><span class="line">assertThat(Strings.isNullOrEmpty(<span class="string">&quot;&quot;</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">assertThat(Strings.padstart(<span class="string">&quot;Alex&quot;</span>,<span class="number">3</span>,<span class="string">&#x27;H&#x27;</span>), equalTo(<span class="string">&quot;Alex&quot;</span>));</span><br><span class="line">assertThat(strings.padstart(<span class="string">&quot;Alex&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;H&#x27;</span>), equalTo(<span class="string">&quot;HAlex&quot;</span>));</span><br><span class="line">assertThat(Strings.padEnd(<span class="string">&quot;Alex&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;H&#x27;</span>), equalTo(<span class="string">&quot;AlexH&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>2、CharSet</strong></p><p><strong>3、CharMatcher</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assertThat(CharMatcher. javaDigit(). matches(<span class="string">&#x27;A&#x27;</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">assertThat(CharMatcher. javaDigit(). matches(<span class="string">&#x27;x&#x27;</span>), equalTo(<span class="keyword">false</span>)); </span><br><span class="line">assertrhat(CharMatcher. is(<span class="string">&#x27;A&#x27;</span>).countIn(<span class="string">&quot;Alex sharing the Google Guava to Us&quot;</span>), equalTo(<span class="number">1</span>));</span><br><span class="line">assertThat(CharMatcher. breakingwhitespace().collapseFrom(<span class="string">&quot;hello Guava &quot;</span>,<span class="string">&#x27;*&quot;), equalro(&quot;* hello Guaval&quot;);</span></span><br><span class="line"><span class="string">assertThat(CharMatcher. javaDigit(). or(CharMatcher. whitespace()). removeFrom(&quot;hello 234 world&quot;), equalTo(&quot;helloworld&quot;);</span></span><br><span class="line"><span class="string">asserThat(CharMatcher. javaDigit(). or(CharMatcher. whitespace()). retainFrom(&quot;hello 234 world&quot;), equalro(&quot;234&quot;));</span></span><br></pre></td></tr></table></figure><p><strong>类通用工具</strong></p><p><strong>1、MoreObjects</strong> 1、实战 toString 辅助编写： 支持忽略空值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">tostring</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Moreobjects.tostringHelper(<span class="keyword">this</span>).omitNullValues()</span><br><span class="line">.add(<span class="string">&quot;manufacturer&quot;</span>, <span class="keyword">this</span>.manufacturer)</span><br><span class="line">.add(<span class="string">&quot;version&quot;</span>, <span class="keyword">this</span>.version)</span><br><span class="line">.add(<span class="string">&quot;releaseDate&quot;</span>, <span class="keyword">this</span>.releaseDate).tostring();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、源码 链表结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ToStringHelper</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.holderHead = <span class="keyword">new</span> MoreObjects.ToStringHelper.ValueHolder();</span><br><span class="line">  <span class="keyword">this</span>.holderTail = <span class="keyword">this</span>.holderHead;</span><br><span class="line">  <span class="keyword">this</span>.omitNullValues = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// check and get</span></span><br><span class="line">  <span class="keyword">this</span>.className = (String)Preconditions.checkNotNull(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MoreObjects.ToStringHelper.<span class="function">ValueHolder <span class="title">addHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MoreObjects.ToStringHelper.ValueHolder valueHolder = <span class="keyword">new</span> MoreObjects.ToStringHelper.ValueHolder();</span><br><span class="line">  <span class="keyword">this</span>.holderTail = <span class="keyword">this</span>.holderTail.next = valueHolder;</span><br><span class="line">  <span class="keyword">return</span> valueHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、Objects 深度比较</strong> deepEquals hash: compare(a,b, cmp); requireNonNull template = String.valueOf(template); // null -&gt; “null”</p><p>在 JDK7+ 使用 JDK 提供的 Objects 方法替代</p><p><strong>3、ComparisonChain</strong> 链式的比较规则 JDK8 添加类似的实现在 Comparator 上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Guava <span class="keyword">this</span>, Guava o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Comparisonchain.start()</span><br><span class="line">        .compare(<span class="keyword">this</span>.manufacturer,o.manufacturer)</span><br><span class="line">        .compare(<span class="keyword">this</span>.version,o.version)</span><br><span class="line">        .compare(<span class="keyword">this</span>.releasepate,o.releaseDate).result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、源码 本身为抽象类 类中持有一个实例化的对象 提供该抽象类的一个继承实现类 针对 float,double,int,long,Object 提供比较，针对 Object 提供 classis 和基于 Comparator 的比较</p><p><strong>StopWatch</strong></p><p>工厂方式获取，createStarted() 省去创建之后开启的步骤 可控制返回的时间单位 对象可以来回复用记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;start process the order [&#123;&#125;]&quot;</span>, orderNo);</span><br><span class="line">Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">LOGGER.info(<span class="string">&quot;The orderNo [&#123;&#125;] process successful and elapsed [&#123;&#125;] min.&quot;</span>, orderNo, stopwatch.stop().elapsed(TimeUnit.MINUTES));</span><br></pre></td></tr></table></figure><p><strong>PreConditons</strong></p><p>运行时空判断 判断并可给出 message，默认通过 String 自带的格式化字符串实现 通过方法名空值语义： checkState: 判断状态 checkElementIndex: 判断容器的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preconditions.checkNotNull(list,<span class="string">&quot;The list should not be null and the size must be %s&quot;</span>,<span class="number">2</span>);</span><br><span class="line">Preconditions.checkArgument(type.equals(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">Preconditions.checkState(state.equals(<span class="string">&quot;B&quot;</span>), <span class="string">&quot;The state is illegal.&quot;</span>);</span><br><span class="line">Preconditions.checkElementIndex(<span class="number">10</span>, list.size());</span><br></pre></td></tr></table></figure><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p><strong>FluentIterable</strong></p><p>类似网络中的数据流处理</p><p><strong>1、将其当做链表操作：</strong> 链表的头结点、尾节点获取 两条链表的合并 链表中是否含有满足特定条件的值 链表中是否全部满足特定条件 链表中满足特定条件的第一个值 将链表按照特定的长度进行分割</p><p>从数组中构建链表 从迭代器中构建链表</p><p>链表的循环读取，先连接成环，之后扫描限定个数的节点</p><p>链表元素的转换(transform)，通过 Function 接口实现 链表元素进行转换，单个元素转化后是一个 迭代器，重新进行连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FluentIterable&lt;String&gt; fit = build();</span><br><span class="line"><span class="keyword">boolean</span> result = fit.allMatch(e -&gt; e != <span class="keyword">null</span> &amp;&amp; e.length() &gt;= <span class="number">4</span>);</span><br><span class="line">result = fit.anyMatch(e -&gt; e != <span class="keyword">null</span> &amp;&amp; e.length() == <span class="number">5</span>);</span><br><span class="line">Optional&lt;String&gt; optional = fit.firstMatch(e -&gt; e != <span class="keyword">null</span> &amp;&amp; e.length() == <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>Lists | Sets</strong></p><p><strong>List 构造</strong></p><blockquote><p>通过工厂提供方便的构造方式, 同时语义明确</p></blockquote><p>主要提供三种 List 的构造：</p><p>ArrayList 原始方式 提供根据迭代器构造 提供根据可变数组构造 提供容量构造，包含限定长度、给出期望长度</p><p>LinkedList 构造仅提供两种方式：  底层链表无法指定大小 原始方式 迭代器构造</p><p>CopyOnWriteArrayList： 构造方式同 LinkedList</p><p><strong>Set 构造</strong></p><p>HashSet: 方式和 ArrayList 方式类似</p><p>LinkedHashSet： 方式与 LinkedList 类似 增加限定容量，底层基于数组。。。</p><p>TreeSet： 普通构建，(), (comparator) 传入迭代器</p><p>EnumSet：</p><p><strong>Set 集合性质(&amp;)</strong></p><p>笛卡尔积 组合选取 两个集合不同的部分， difference(set1, set2) 返回在 set1 中的元素而不再 set2 中的元组 交集、并集</p><p><strong>MultiSet</strong></p><p>记录重复元素的个数</p><p><strong>Maps | BiMap | MultiMap</strong></p><p>构造方式</p><p>转换成不可变Map 根据 Set 转变成可变 Map 根据 Map 转换对应的值</p><p>BiMap</p><p>严格的一对一映射，通过接口声明通用的操作</p><p><strong>Table | Range</strong></p><p>ArrayTable TreeBaseTable HashBaseTable ImmutableTable</p><p>表名、列明、列值</p><p><strong>Range</strong></p><p>提供实现了自然排序类的范围： <code>&gt;= &lt;=, [)</code></p><p>范围映射，Key 为一个给定的范围，放入的为泛型 K 的一个 Range，支持按照某个具体的值获取到对应范围端的一个值</p><p><strong>Range | RangeMap | Ording</strong></p><p>Sorted 判断是否已经按照自然排序完成</p><p>给出相反的比较。。。</p><p>Getting Started with Google Guava.pdf</p><p>不可变设计： 提供工厂方式， of 提供构建器方式 CacheBuilder.newBuilder().build() 提供原型方式构建 copyOf</p><p><strong>Range</strong></p><p>存放在其中的元素必须是 Comparable 的</p><p>提供多种符合语义的工厂构造： 根据枚举值确定两端的开闭</p><p><strong>RangeMap</strong></p><p>另一种存在有序性的 Map</p><p><strong>Ording</strong></p><p>支持对 null 的特殊处理，将其放在第一位或者最后一位</p><p>与当前 JDK8 中 Comparator 中的 nullFirst 一致，配合 thenXXX 进行控制比较规则</p><h3 id="Guava-缓存"><a href="#Guava-缓存" class="headerlink" title="Guava 缓存"></a>Guava 缓存</h3><p><strong>原始缓存实现</strong></p><p>1、LinkedHashMap 通过 JDK 自带的实现</p><p>2、LinkedList 借助 LinkedList 实现</p><p>3、通过 SoftReference 实现 容量： 初始容量、最大容量 过期策略： 设置的大小、按照权重、访问、写入、更新、GC 并发等级： 并发使用 KV收集机制： 软引用、弱引用进行 GC</p><p><strong>过期策略(5)</strong></p><p>1、大小 限定缓存的个数，内存大小</p><p>2、LRU 限定大小的情况下，模式通过 LRU 算法进行淘汰</p><p>3、Time(W,R) 在访问命中某个元素多长时间后过期； 在更新某个元素多长时间后过期；</p><p>4、引用生命周期控制(GC) .softValues() .softKeys() 借助 GC 控制何时回收，何时保留</p><p>5、权重 通过为每个缓存的数据设定一定的权重进行控制是否过期 通过实体，给出计算规则： 入参为 key, values，返回的值为对应的权重</p><p><strong>其他特性(4)</strong></p><p>1、不存在的默认值(LoadingCache) 在获取不到的情况下给出的值 类似缓存雪崩情况下的熔断 通过 CacheLoader 抽象类实现： 给类提供根据 Function，Supplier 进行创建的工厂 是 LoadingCache 实现必须要指定的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheLoader&lt;K, V&gt; <span class="title">from</span><span class="params">(Function&lt;K, V&gt; function)</span></span></span><br><span class="line"><span class="function">CacheLoader&lt;Object, V&gt; <span class="title">from</span><span class="params">(Supplier&lt;V&gt; supplier)</span></span></span><br></pre></td></tr></table></figure><p>2、统计功能 .recordStats() 记录缓存的命中率，执行情况</p><p>3、监听缓存移除事件 可设置缓存移除监听器，监听到删除事件进行处理 封装成通知实体控制移除策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;K, V&gt; notification)</span></span>;</span><br></pre></td></tr></table></figure><p>4、灵活的构造方式</p><ul><li>支持根据特定的字符串构造 CacheBuilder： 类似读取配置文件实现缓存</li><li>根据函数式接口构造 CacheLoader</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String spec = <span class="string">&quot;maximumSize=5,recordStats&quot;</span>;</span><br><span class="line">CacheBuilderSpec builderSpec = CacheBuilderSpec.parse(spec);</span><br><span class="line">CacheLoader&lt;String, String&gt; loader = CacheLoader.from(String::toUpperCase);</span><br><span class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.from(builderSpec).build(loader);</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong></p><p>通过 ConcurrentHashMap 实现</p><p>Entry 中各种引用的获得： 有限的几个 每个实现都不同 有一定的规律(存在是否) ⇒  定义Enum, 将所有Enum放入数组中，定义工厂获取方法，按照将boolean作为参数进行掩码控制获得</p><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>消息的 pull 和 push</p><p>进程级别，内部</p><p>Listener 对其进行 subscribe 只能有一个参数：</p><p><strong>实战</strong></p><p>1、多种类型 同种类型的多个订阅方法会被调用</p><p>2、Listener 继承特性 都会被调用</p><p>3、Event继承 都会被调用</p><p>4、异步总线</p><p><strong>设计</strong></p><p>自己实现一个消息总线，实现与 Guava 中 EventBus 类似的功能</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><strong>Monitor</strong></p><p>LockCondition 的一个封装 可替换 synchronized 的实现，语义更加明确，同时更加方便编程</p><p>1、阻塞队列设计 (1) synchronized 方式设计</p><p>(2) Reentrant + Condition 方式设计</p><p>(3) Monitor 方式设计</p><p><strong>限流</strong></p><p>rateLimiter</p><p>Semaphore 通过 Semaphore 进行获取并释放令牌的方式进行控制访问的速率</p><p>令牌桶</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/google/guava/wiki">https://github.com/google/guava/wiki</a></p><p>Github Guava Wiki</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Guava&quot;&gt;&lt;a href=&quot;#Guava&quot; class=&quot;headerlink&quot; title=&quot;Guava&quot;&gt;&lt;/a&gt;Guava&lt;/h2&gt;&lt;h3 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Guava" scheme="http://example.com/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发学习笔记</title>
    <link href="http://example.com/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/12/17/Java-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-17T14:53:30.000Z</published>
    <updated>2020-12-17T14:54:19.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>Java 代码首先会编译成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上进行执行。</p><p>Java中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。</p></blockquote><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>(1) extends Thread</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>(2) Runnable</p><p>(3) Callable</p><p>与 Runnable 相比，Callable 可以有返回值，且可以跑出异常，返回值通过 FutureTask 进行封装。</p><p>(4) ThreadPool</p><p><strong>继承与实现接口的比较</strong></p><p>优先实现接口</p><p>① Thread 只能够通过单继承来实现；</p><p>② Thread 创建开销大，Runnable 创建的开销小；</p><p>③ Runnable 实现解耦； 可以配合线程池使用</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="http://img.janhen.com/20201217224805image-20201217224803962.png" alt="image-20201217224803962" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING, </span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(1) 新建(NEW)</strong></p><p>创建后尚未启动。</p><p>当程序使用   new 关键字  创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。</p><p><strong>(2) 可运行(Runnable)</strong><br>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><p><strong>(3) 阻塞(Blocked)</strong><br>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><p>主要分为三种阻塞方式：</p><p>① 同步阻塞： </p><p>等待获取锁，获取同步锁时该同步锁被别的线程占用，JVM 将线程放入到锁池 (lock pool) 中。</p><p>② 等待阻塞</p><p>执行 o.wait() ，JVM会把该线程放入等待队列(waitting queue)中。</p><p>③ 其他阻塞</p><p>I/O 阻塞： 等待 I/O 操作完成；</p><p>执行 Thread.sleep() ；</p><p>执行 t.join() 方法；</p><p><strong>(4) 无限期等待(Waiting)</strong><br>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片；</p><p>都是交互性质的方法；</p><p>Object.wait()、Thread.join()、LockSupport.part() </p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p><strong>(5) 限期等待(Timed Waiting)</strong></p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p><strong>(6) 死亡(Terminated)</strong></p><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><p><strong>(1) 正常终止</strong></p><p>运行结束，正常终止；</p><p><strong>(2) 退出标志</strong></p><p>定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false.在定义exit时，<strong>使用了一个Java关键字volatile，这个关键字的目的是使exit同步</strong>，也就是说在同一时刻只能由一个线程来修改exit的值。</p><p>volatile 无锁同步的应用场景之一；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;   <span class="comment">// volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) Interrupt 方法结束</strong></p><p>①  阻塞下的结束</p><p>在线程处于阻塞状态下，调用 interrupt() 会抛出 InterrupteException，<u>一定要先捕获InterruptedException异常<strong>之后通过break来跳出循环，才能正常结束run方法</strong></u>。</p><p>死循环中的退出，只有在捕获后进行显示的 break 才能实现；</p><p>② 未阻塞下的结束</p><p>使用 isInterrupted() 判断线程的中断标志来退出循环。当使用 interrupt() 方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">// <span class="doctag">NOTE:</span> after catch exception must break to skip loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) stop 方法终止</strong></p><p>程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后  <u>导致了该线程所持有的所有锁的突然释放(不可控制)</u>  ，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。</p><p><strong>(5) Callable 通过 Future.camcel 来进行终止</strong></p><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><p><strong>(1) InterruptedException</strong></p><p>该线程<u>处于阻塞、限期等待或者无限期等待</u>状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>Thread.sleep()；</p><p>synchronized；</p><p>join()；</p><p><strong>(2) interrupted()</strong></p><p>无限循环不跳出，只有在该循环中执行 sleep() 等会抛出 InterruptedException 操作，</p><p>可通过其返回值来防止无线循环，作为一种退出标志；</p><p>调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><p><strong>(3) Executor 的中断操作</strong></p><p>① 关闭池子操作</p><p>shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>② 关闭指定的线程(Future)</p><p>只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>(1) join</p><p>进行线程之间的流程控制，进行线程通信的一种方式；</p><p>(2) yield()</p><p>让出当前 CPU，之后重新进行竞争；</p><p>(3) sleep()</p><p>不释放锁，在等待一定时间后自动唤醒；</p><p><strong>sleep() 与 wait() 的区别</strong></p><p>想到对应在阻塞队列中、以及延时双删策略中的场景；</p><p>① 设计|定义： sleep() 是 Thread 的静态方法，wait() 是 Object 的成员方法；</p><p>② 锁的占用： sleep() 导致程序暂停执行指定的时间，它的监控状态依然保持着，不释放锁， 而 wait() 释放对象锁，进入等待此对象的等待池中；</p><p>③ 使用范围： sleep() 可以用在任何地方， wait() 只能够用在同步控制方法或同步控制块中使用；</p><p>④ 唤醒方式： sleep() 给定时间内自动唤醒，wait() 需要调用 notify 显视唤醒；</p><p><strong>start() 与 run() 的区别</strong></p><ol><li>start() 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 </li><li> 通过调用 Thread 类的 start() 方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 run ⽅法只是 thread 的⼀个普通 ⽅法调⽤，直接运行。</li><li> 方法 run() 称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li></ol><h2 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h2><img src="http://img.janhen.com/20201217224608image-20201031111430904.png" alt="image-20201031111430904" style="zoom: 33%;" /><p><strong>(1) 进程与线程的比较</strong></p><p>进程是 OS 资源分配的单位，有自己独立的寻址空间；</p><p>线程是 OS 独立运行的单元，其共享同一个进程内的所有数据；</p><p>线程相较于进程更加轻量；</p><p>⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的元空间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈。</p><p><strong>(2) 实现多线程的方式</strong></p><p>Java 中通过将每个线程映射为一个进程实现的；</p><p>线程的实现<br>3种模型:<br>内核线程；<br>用户线程；<br>两者结合。 </p><p><strong>(3) 守护线程</strong></p><p>是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种。</p><p>① 停止执行情况</p><p>专门用于服务其他的线程，如果其他的线程(即用户自定义线程)都执行完毕，连main线程也执行完毕，那么jvm就会退出(即停止运行)——此时，连jvm都停止运行了，守护线程当然也就停止执行了。</p><p>② 优先级</p><p>优先级较低</p><p>③ 设置</p><ul><li><p>通过 setDaemon(true) 在 Thread 未 start() 之前显视设置</p></li><li><p>Daemon 线程产生的新线程也是 Daemon 的</p></li></ul><p>④ 性质</p><p>为 JVM 级别的线程，<u>即使你停止了Web应用，这个线程依旧是活跃的</u>。</p><p><strong>(4) 线程派生的联系</strong></p><p>继承对应的优先级、daemon等属性；</p><p>(5) 并发和并行</p><p>并发： 同⼀时间段，多个任务都在执⾏ (单位时间内不⼀定同时执⾏)； </p><p>并⾏： 单位时间内，多个任务同时执⾏。</p><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>while 循环监测</p><p>线程B是一直执行着while(true) 循环的，直到长度为5才终止执行，显然这种方式是很消耗资源的。所以，就需要一种机制能避免上述的操作又能实现多个线程之间的通信，这就是接下来需要学习的“wait/notify线程间通信”。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p><strong>(1) 进程间的通信方式</strong></p><p>① 管道(pipe)、有名管道(named pipe)</p><p>② 信号量(semophore)</p><p>③ 消息队列(message queue)</p><p>④ 信号(signal)</p><p>⑤ 共享内存(shared memory)</p><p>⑥ 套接字(socket)</p><p><strong>(2) 线程间的通信方式</strong></p><p>1、锁机制：<br>  1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。<br>  1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。<br>  1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。<br>对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br>2、信号量机制：包括无名线程信号量与有名线程信号量<br>3、信号机制：类似于进程间的信号处理。<br>线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的<br>通信机制。</p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><blockquote><p> Object.wait, notify 机制，需要配合 synchronized 一起使用</p></blockquote><p>1、wait()/notify 方法</p><p>(1)wait() 和 notify() 方法要在同步块或同步方法中(synchronized 关键字) 调用，即在调用前，线程也必须获得该对象的对象级别锁。<br>(2)wait方法是释放锁，notify方法是不释放锁的；<br>(3)notify 每次唤醒 wait 等待状态的线程都是随机的，且每次只唤醒一个；<br>(4)notifAll 每次唤醒 wait 等待状态的线程使之重新竞争获取对象锁，优先级最高的那个线程会最先执行；<br>(5)当线程处于 wait() 状态时，调用线程对象的 interrupt() 方法会出现 InterruptedException 异常；</p><p><strong>通过 等待通知模式实现阻塞队列</strong></p><p>(1) 结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">5</span>;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();      <span class="comment">// use for thread communication</span></span><br></pre></td></tr></table></figure><p>(2) 入队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object task)</span> </span>&#123;</span><br><span class="line">    synchronzied(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(task);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        lock.notify();         <span class="comment">// not empty conditon</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obejct oldFront = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait()；</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        oldFront = queue.poll();</span><br><span class="line">        count.getAndDecrment();</span><br><span class="line">        lock.notify();       <span class="comment">// not full condition</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldFront;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong></p><p>(1) MyBatis 中</p><p>在数据库连接这个地方使用<br>到的：<br>org.apache.ibatis.datasource.pooled.PooledDataSource 类中，所以不用花<br>太多的时间去深究。<br>1、获取连接的时候，如果数据库连接池没有空闲的连接，那么当前线程就会进入等<br>待，直到被通知，这个地方就是popConnection()方法</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="*ThreadLocal"></a>*ThreadLocal</h2><blockquote><p>实现每⼀个线程都有⾃⼰的专属本地变量。</p><p>如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。</p></blockquote><p>如果使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本，  副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p><p>(1)概述</p><p>原理： 为每个使用该变量的线程都提供独立的变量副本，从而不会影响到其他线程所对应的副本。</p><p>是一种<u>多线程间并发访问变量的解决方案</u>，不使用锁来保证并发访问，本质是以空间换时间的方式，为每个线程提供变量的独立副本，以保证线程的安全。</p><p>(2) 作用</p><p>ThreadLocal 的作用是<font color="green">提供线程内的局部变量</font> ，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p><p><strong>底层结构</strong></p><img src="http://img.janhen.com/20201217224620394b8da0-ba21-11e8-87f1-559c9b456754.jpg" alt="img" style="zoom:67%;" /><p>一个Thread中只有一个ThreadLocalMap，</p><p>一个ThreadLocalMap中可以有多个ThreadLocal对象，</p><p>其中一个ThreadLocal对象对应一个ThreadLocalMap中一个的Entry实体</p><p>(也就是说：一个Thread可以依附有多个ThreadLocal对象)。</p><p>(1) Thread 中持有的结构</p><p><u>线程局部变量</u>  ，那么理所当然就应该存储在自己的线程对象中</p><p>线程局部变量存储在 Thread 对象的 threadLocals 属性中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) ThreadLocal.ThreadLocalMap</p><p>是实现 ThreadLocal 的原理，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p><p>KEY: 线程对象；</p><p>VALUE: 对应线程的变量副本；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一些操作</strong></p><p>(1) ThreadLocal 4 大 public 方法</p><p>根据当前线程获取到对应的 ThreadLocalMap，借助该 Map 操作实现；</p><p>get()、 set()、 remove()、 withInitial()。</p><p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上， ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与同步机制的比较</strong></p><pre><code>    a.ThreadLocal与同步机制都是为了 &lt;u&gt;解决多线程中相同变量的访问冲突问题&lt;/u&gt;。     b.前者采用以&quot;空间换时间&quot;的方法，后者采用以&quot;时间换空间&quot;的方式 </code></pre><p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal<br>采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后<br>者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p><p><strong>Thread 造成的内存溢出问题</strong></p><p>(1) 与线程池协作引发的内存溢出问题</p><p><u>ThreadLocal变量是维护在Thread内部的</u>，线程不退出，对象的引用就会一直存在。</p><p>当我们使用线程池的时候，就意味着当前线程未必会退出(比如<u>固定大小的线程池，线程总是存在的</u>)。如果这样的话，将一些很大的对象设置到ThreadLocal中(这个很大的对象实际保存在Thread的threadLocals属性中)，这样的话就可能会出现内存溢出的情况。</p><p>一种场景就是说如果使用了线程池并且设置了固定的线程，处理一次业务的时候存放到ThreadLocalMap中一个大对象，处理另一个业务的时候，又一个线程存放到ThreadLocalMap中一个大对象，但是这个线程由于是线程池创建的他会一直存在，不会被销毁，这样的话，以前执行业务的时候存放到ThreadLocalMap中的对象可能不会被再次使用，但是由于线程不会被关闭，因此无法释放Thread 中的ThreadLocalMap对象，造成内存溢出。</p><p>也就是说，ThreadLocal在没有线程池使用的情况下，正常情况下不会存在内存泄露，但是如果使用了线程池的话，就依赖于线程池的实现，如果线程池不销毁线程的话，那么就会存在内存泄露。所以我们在使用线程池的时候，使用ThreadLocal要格外小心！</p><p>(2) 原因</p><p>ThreadLocal内存泄漏的根源是：由于  <u>ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏</u>  ，而不是因为弱引用。</p><p><strong>弱引用与内存泄漏</strong></p><p>弱引用被回收了只是回收了Entry的key引用，但是Entry应该还是存在的吧？</p><p>ThreadLocal的get(),set(),remove() 的时候都会清除线程ThreadLocalMap里所有key为null的value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123; <span class="comment">/** The value associated with this ThreadLocal. */</span> </span><br><span class="line">  Object value;</span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; </span><br><span class="line">    <span class="keyword">super</span>(k); </span><br><span class="line">    value = v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就需要重新认识一下，什么是：<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>，这里的重点是：<strong>只被弱引用关联的对象</strong></p><p>上述过程尽管 GC 执行了垃圾收集，但是弱引用还是可以访问到结果的，也就是没有被回收，这是因为除了一个弱引用 userWeakReference 指向了User实例对象，还有 user 指向 User 的实例对象，只有当user和User实例对象的引用断了的时候，弱引用的对象才会被真正的回收</p><p>并不是所有弱引用的对象都会在第二次GC回收的时候被回收，而是  <u>回收掉只被弱引用关联的对象</u> 。因此，使用弱引用的时候要注意到！希望以后在面试的时候，不要上来张口就说，弱引用在第二次执行GC之后就会被回收！</p><p><strong>应用场景</strong></p><p>(1) 解决数据库连接</p><p>避免方法中总是出现 Connection 参数，每个线程每次使用的都是用一个  Connection；</p><p>(2) MyBatis 中用于 Session 管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">    Session s = (Session) threadSession.get(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">    &#125; <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池"><a href="#线程池" class="headerlink" title="*线程池"></a>*线程池</h1><p>(1) new Thread 弊端：</p><ul><li><p>每次<code>new Thread</code>新建对象，Thread 为大对象，性能差 ；</p></li><li><p>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或 OOM；</p></li><li><p>缺少更多功能，如更多执行、定期执行、线程中断；</p></li></ul><p>(2) 线程池好处</p><p>重用性： 重用存在的线程，减少对象创建、消亡的开销，性能佳 ；</p><p>可控性： 可有效控制最大井发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞 ；</p><p>功能性： 提供定时执行、定期执行、单线程、井发数控制等功能；</p><p><strong>线程池参数</strong></p><ul><li>corePoolSize: &lt;= x</li><li>maximumPoolSize: 最大线程数</li><li>workQueue: 工作队列，为BlockingQueue</li><li>threadFactory: 默认非守护，同优先级，名称</li><li>rejectHandler:  BlockingQueue 满，无空闲的线程池，拒绝cel，默认直接抛出 exception</li><li>keepAliveTime，unit: corePoolSize  –&gt;&gt; maximumPoolSize </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种拒绝策略： ThreadPoolExecutor 类中提供</p><ul><li><p>AbortPolicythrows exception</p></li><li><p>DiscardPolicy： 直接丢弃</p></li><li><p>CallerRunPolicy： 使用调用者 thread 执行</p></li><li><p>DiscardOldestPolicy： 丢弃 BlockingQueue 中最靠前的 task，执行当前 task</p></li></ul><p><strong>方法</strong></p><p>(1) 主要方法</p><p>生命周期及 ExecutorService：</p><p>- execute()</p><p>- submit(): execute + Future</p><p>- shutdown() : handle BlockingQueue in </p><p>- shutdownNow() : BlockingQueue not handler</p><p>(2) 监控方法：</p><ul><li>getTaskCount()：线程池已执行和未执行的任务总数 </li><li>getCompIetedTaskCount()：已完成的任务数量 </li><li>getPoolSize()：线程池当前的线程数量</li><li>getActiveCount()：当前线程池中正在执行任务的线程数量</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>① Executors.newCachedThreadPool </p><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<strong>调用 execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程</strong>。因此，长时间保持空闲的线程池不会使用任何资源。</p><p>② Executors.newFixedThreadPool</p><p><strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</strong>。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务(如果需要)。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><p>③ Executors.newSingleThreadExecutor</p><p>Executors.newSingleThreadExecutor()返回一个线程池(这个线程池只有一个线程)<strong>,这个线程池可以在线程死后(或发生异常时)重新启动一个线程来替代原来的线程继续执行下去</strong>！</p><p>④ Executors.newScheduIedThreadPool </p><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="number">3</span>); scheduledThreadPool.schedule(newRunnable()&#123; <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;延迟三秒&quot;</span>); &#125; &#125;, <span class="number">3</span>, TimeUnit.SECONDS); scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123; <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;延迟1秒后每三秒执行一次&quot;</span>); &#125; &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>⑤ <strong>线程池配置</strong></p><p>CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU + 1IO 密集型任务，参考值可以设置为 2 * NCPU；</p><p>选用基础：</p><p>- 小型应用不适合</p><p>- 线程调度时间开销大</p><p>@@计算密集型与IO密集型</p><p>密集型：  CPU 核 + 1<br>IO 密集： CPU 核数 / (1-阻塞系数)   一般0。8~0.9</p><p>@@如何正确的使用线程池</p><p>设置线程池，比设置界限；</p><p>hook 机制嵌入行为，由 beforeMethod, afterMethod 记录线程执行前和后做日志，异常结果；</p><p>优雅的关闭，hook 机制，推荐使用 JavaBean 创建线程池，在 destoryMethod 里面在销毁时调用 shutdown；</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>(1) 概述</p><p>Java 并发采用的是共享内存模型，线程之间的通信总是隐式执行。</p><p>定义： Java 线程之间的通信由 JMM 控制， <u>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</u>。</p><p>Java内存模型(JMM)解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”</p><ol><li><p>主内存与工作内存<br> 主内存副本拷贝，非对整个obj拷贝。<br> Java借助共享内存实现线程间的通信</p></li><li><p>内存间的交互操作<br> 8中操作, 主内存，保证原子性；<br> 对于long和double的特殊规则(了)<br> 64位</p></li><li><p>对于volatile变量的特殊规则<br> 语义：</p></li></ol><ul><li>可见性, 实现对于其修改立即写回主内存中, 非保证原子性;</li><li>有序性, 禁止指令重排序, 是一种同步机制, 轻量, 与DCL实现安全的单例.  </li></ul><ol start="4"><li>原子性、可见性与有序性<br>volatile：<br>finale: this 引用逃逸(读初始化一般的data)；<br>synchronized: “万能”, 重量, 阻塞</li></ol><p>硬件的效率与一致性:<br>缓存一致性协议</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="*volatile"></a>*volatile</h3><img src="http://img.janhen.com/20201217224645image-20201031124307603.png" alt="image-20201031124307603"  /><p>能够在线程之间保持可见性，能够被 <strong>多线程同时读</strong>，并且保证不会读到过期的值，但 <strong>只能被单线程写</strong>。<br>基于 happens-before 原则，对 volatile 字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile 变量。</p><p>volatile是轻量级的synchronized，他的意思是：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度</p><p>(1) 特性</p><p>a.volatile关键字为域变量的访问提供了一种免锁机制， </p><p>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， </p><p>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 </p><p>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 </p><p><strong>volatile 保证可见性</strong></p><p>有volatile变量修饰的共享变量进行写操作的时候会引发了两件事情：<br>(1)将当前处理器缓存行的数据写回到系统内存；<br>(2)这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效；</p><p>底层实现细节(了)：</p><p>① 发生 volatile  W， JVM 向处理器发送 Lock 前缀的汇编命令，将该变量缓存行写到系统内存；</p><p>② 为了保证写回到的数据被其他线程立即可见，借助  缓存一致性协议  实现，每个处理器 嗅探总线 上传播的数据检查自己是否过期，过期强制从系统内存中把数据读到处理器缓存中。</p><p><img src="http://img.janhen.com/202012172246521553822343527.png" alt="1553822343527"></p><p><strong>volatile 如何禁止指令重排序</strong> </p><p>借助内存屏障和禁止指令重排实现</p><ul><li>对 volatile 变量写操作时，会在<strong>写操作之后</strong>加上一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；</li><li>对 volatile 变量的读操作，会在<strong>读操作之前</strong>加上一条 load 屏障指令，从主内存中读取共享变量。</li></ul><p>使用volatile关键字修饰共享变量可以禁止重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序<br>volatile禁止指令重排序的一些规则：<br>　　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序</p><p>　　2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序</p><p>　　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</p><p>涉及到内存屏障(Memory Barrier)，它是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p><p><strong>一些应用</strong></p><ul><li><p>无锁读取数据： ConcurrencyHashMap 的 get 操作，通过 volatile 替换锁，AQS 中 state 变量；</p></li><li><p>作为终止标识，exit 来进行终止，类似 interrupt 终止；</p></li><li><p>那么在禁止重排序时是一个较好的使用场景，否则我们不需要再使用它，如 DCL 中通过 volatile 修饰；</p></li><li><p>热部署的变量： 通过线程修改之后立即被其他线程可见；</p></li></ul><p>适用场景： </p><p>(1) 对变量的写操作不依赖于当前值(比如 i++)，或者说是单纯的变量赋值(boolean flag = true)。 </p><p>(2)该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>字解决的是多个线程之间访问资源的同步性。</p><p>(1) 一些性质：</p><ul><li>提供原子性，实现同步功能；</li><li>是 JVM 提供的同步工具，使用 lock 和 unlock 字节码指令，保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏；</li><li>与 CAS 比较： 相比于 CAS 可以保证 <strong>一块</strong> 而非一个变量的原子性；</li><li>与 Lock 比较： 相比于 JDK Lock 可以保存 <strong>程序运行信息</strong> ，便于解决死锁和异常；</li></ul><p>(2) 使用的位置：</p><ul><li>code bloker： 显视锁住当前调用对象  synchronized(this)，通过监视器锁实现；</li><li>method: 锁住调用对象，通过访问标识位实现；</li><li>static method: 锁住该类的所有对象；</li><li>class: 显视锁住类对象 synchronized(xxx.class)；</li></ul><p>适用同一个对象调用锁住 obj 的可以实现同步，使其中的一个线程阻塞等待另一个线程执行完毕；不同对象调用时不适用；</p><p><strong>synchronized 保证可见性原理</strong></p><p>通过 javap -v xxx.class 获取字节码指令分析</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><p>JMM 对 synchronized 的规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存；</li><li>线程加锁时，将<em>清空工作内存</em> 中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值(注意，<code>加锁与解锁是同一把锁</code>)；</li></ul><p>本质是对一个对象的监视器(monitor) 进行获取，而这个获取过程是排他的，也就是说同一时刻只有一个线程<br>获取到由 synchronized 所保护对象的监视器。</p><p><strong>(1) 对代码块同步</strong></p><p>monitorenter 和 monitorexit 指令</p><p>Synchronized 每个对象有一个  <u>内置的监视器锁(monitor)</u>  。当 monitor 被占用时就会处于锁定状态，线程执行monitorenter 指令时尝试获取monitor的所有权，过程如下：<br>1、如果 monitor 的进入数为0，则该线程进入 monitor，然后将进入数设置为1，该线程即<br>为 monitor 的所有者。<br>2、如果线程己经占有该 monitor，只是重新进入，则进入monitor 的进入数加1．<br>3．如果其他线程巳经占用了 monitor ,则该线程进入阻塞状态，直到 monitor 的进入数为0，再重新尝试获取monitor的所有权。</p><p><strong>(2) 同步方法</strong></p><p>调用指令将会检查方法的 <code>ACC_SYNCHRONIZED</code> 访问标志是否被设置，如果设置了，  <u>执行线程将先获取 monitor，获取成功之后才能执行方法体</u>  ，方法执行完后再释放 monitor Synchronize和lock都属于同步阻塞。 </p><p><strong>synchronized 其他性质</strong></p><p>(1) 作为锁</p><p>见下部分锁相关</p><p>(2) 原子性</p><p>@Q: CAS 机制与 synchronized 保证原子性的区别？</p><p>① CAS 仅能够保证一个变量的原子性，而 synchronized 可用于方法、类、字段等多处；</p><p>② CAS 通过不断循环重试实现，存在不必要的开销，但是是一种无锁的实现；</p><p>③ CAS 存在 ABA 问题；</p><p>Q: JDK1.6+ 的 synchronized 关键字做了哪些优化?</p><p>对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗 化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：⽆锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈⽽逐渐升级。锁可以升级不可降级，提⾼获得锁和释放锁的效率。</p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p><strong>原子性</strong></p><p>提供了互斥访问，同一时刻只能有一个线程对它进行操作。</p><p>(1) 实现方式：</p><ul><li>锁的同步机制：  synchronized | Lock</li><li>CAS 机制： 包括 AtomicInteger 等原子类</li></ul><p><strong>可见性</strong> </p><p>一个线程对主内存中共享变量的修改，能够及时地被其他线程观察到。</p><p>(1) 不可见的原因： </p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul><p>(2) 实现方式</p><p>volatile 关键字可以保证共享变量的可⻅性。</p><p><strong>有序性：</strong> </p><p>代码在执⾏的过程中的先后顺序。</p><ul><li>Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性，导致代码的执⾏顺 序未必就是编写代码时候的顺序。</li><li>volatile、synchronized、Lock</li></ul><h2 id="happen-before-原则"><a href="#happen-before-原则" class="headerlink" title="*happen-before 原则"></a>*happen-before 原则</h2><ol><li>单一线程原则</li></ol><blockquote><p>Single Thread Rule</p></blockquote><p>一个线程内，程序前面的操作先于后面的操作。也叫程序次序原则。</p><ol start="2"><li>管程锁定原则</li></ol><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock option 先于后面同一个锁的 lock option。</p><ol start="3"><li>volatile 变量规则</li></ol><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先于后面对这个变量的读操作。</p><ol start="4"><li>传递性原则</li></ol><blockquote><p>Transitivity</p></blockquote><p>A –&gt; B, B –&gt; C  ==&gt;&gt; A –&gt; C</p><ol start="5"><li>线程启动规则</li></ol><blockquote><p>Thread Start Rule丶。 入</p></blockquote><p>Thread 对象的 start() 先于此线程的每一个动作</p><ol start="6"><li>线程中断规则</li></ol><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 的调用先于被中断线程的代码检测到中断事件的发生，即 isInterrupt().</p><ol start="7"><li>线程加入规则</li></ol><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先于 join() 方法返回</p><ol start="8"><li>对象终结规则</li></ol><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成(构造函数结束)先于它的 finalize() 方法的开始</p><h2 id="线程同步的实现"><a href="#线程同步的实现" class="headerlink" title="线程同步的实现"></a>线程同步的实现</h2><p>说明： 需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p><p><strong>1、 互斥同步</strong> </p><p>(1) 同步方法 、同步代码块 </p><p>(2) 使用重入锁实现线程同步</p><p>(3) 使用阻塞队列实现线程同步</p><p><strong>2、 非阻塞同步</strong></p><p>主要是 CAS 不断尝试实现</p><p>(1) 使用原子变量实现线程同步</p><p><strong>3、 无同步方案</strong></p><p>(1) 使用局部变量实现线程同步<br>    如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p><p>(2) 使用特殊域变量(volatile)实现线程同步</p><p> 注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 </p><h1 id="锁与锁优化"><a href="#锁与锁优化" class="headerlink" title="锁与锁优化"></a>锁与锁优化</h1><p><strong>线程安全</strong></p><ol><li>Java语言中的线程安全<br>绝对线程安全<br>相对线程安全<br>线程兼容<br>线程对立</li></ol><p><strong>2. 线程安全的实现方法</strong><br><em>1)同步互斥</em><br><strong>Synchronized：</strong>存在挂起、恢复，是<em><u>阻塞</u></em>  实现的，且java线程直接映射到OS原生线程上的，存在用户态到内核态的_<u>转换</u>_，因而性能较差。</p><p><strong>Lock：</strong>可重用锁</p><p>2)非阻塞<br>基于CAS+Loop实现</p><p>3)无同步</p><ul><li>可重入代码</li><li>TLC，线程本地， 是消息队列架构模式</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><strong>乐观锁</strong></p><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是  <u>在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</u>  (比较跟上一次的版本号，如果一样则更新)，如果失败则要重复读-比较-写的操作。 java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，  <u>  比较当前值跟传入值是否一样，一样则更新，否则失败</u>。</p><p><strong>悲观锁</strong></p><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是  <u>Synchronized</u>,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p><h2 id="JVM-锁优化"><a href="#JVM-锁优化" class="headerlink" title="JVM 锁优化"></a>JVM 锁优化</h2><p>锁有四种状态，无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><p>通过 对象头实现</p><p>(1) 原理：</p><p>基于对象头的Mark Word， 23位表示偏向的线程ID</p><p><strong>偏向锁</strong></p><p>偏向锁的目的是在某个线程获得锁之后，<u>消除这个线程锁重入(CAS)的开销</u>，看起来让这个线程得到了偏护</p><p>而偏向锁只需要在置换 ThreadID 的时候依赖一次CAS原子指令</p><p><strong>如果一个线程获得了锁，那么锁就进入了偏向模式。当这个线程再次请求锁时，无需再做任何同步操作</strong></p><p>(1) 设计原因</p><p>为什么会出现这种设计的方式那？这是因为根据HotSpot的作者研究，他发现  <u>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</u>  ，为了让线程获得锁的代价更低而引入了的偏向锁这个概念。</p><p>(2) 锁的升级</p><p>在锁竞争比较激烈的场景，最有可能的情况是每次不同的线程来请求相同的锁，这样的话偏向锁就会失效，倒不如不开启这种模式，幸运的是Java虚拟机提供了参数可以让我们有选择的设置是否开启偏向锁。<br>如果偏向锁失败，虚拟机并不会立即挂起线程，而是使用轻量级锁进行操作。</p><p>(3) 性质：</p><p>线程获取到锁之后，消除这个线程的重入开销；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking</span><br></pre></td></tr></table></figure><p><strong>轻量级锁</strong></p><p>轻量级锁是为了<u>在线程交替执行同步块时提高性能</u>，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><p>如果偏向锁失败，虚拟机并不会立即挂起线程，而是使用轻量级锁进行操作。轻<u>量级锁他只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。</u>  如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先夺到锁，那么当前线程的轻量级锁就会膨胀为重<br>量级锁。</p><p>轻量级锁所适应的场景是 <u>线程交替执行同步块</u> 的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p><p>(1) 说明：</p><p>嵌入在线程栈中的对象<br>使用 Displaced Mark Word 复制对象头到堆栈中，借助CAS实现同步。<br>还是需要进行 CAS , 出现竞争时，会尝试自旋</p><p>(2) 原理：</p><p>绝大部分锁在整个同步周期内都是不存在竞争的</p><p><strong>自旋锁(无锁)</strong></p><p>(1) 原理</p><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>(2) 优缺点</p><p>(3) 时间阈值</p><p>在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是  <u>由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</u>，基本认为一个线程上下文切换的时间是最佳的一个时间。</p><p>(4) 一些实现</p><p>在通过一定的自旋失败后，通常转化为加悲观锁实现，如 ConcurrentHashMap 中对于 put 在尝试 3 次失败后进行转换成对链表头进行加锁；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSpinning</span><br></pre></td></tr></table></figure><p><strong>自适应锁</strong><br>原来默认是10，现在可以实现自适应自旋</p><p>自适应，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><p>如ConcurrentHashMap的tryLock()</p><blockquote><p>-XX:+UseSpinning      1.7默认开启<br>-XX:PreBlockSpin     默认为10，代表</p></blockquote><p><strong>锁消除</strong><br>不存在共享数据竞争，需要对其进行<code>逃逸分析</code>，从而减少不必要的锁。</p><p><strong>锁粗化</strong><br>防止在循环中加锁，进行资源的浪费</p><p><strong>锁的对比</strong></p><h2 id="程序锁优化"><a href="#程序锁优化" class="headerlink" title="程序锁优化"></a>程序锁优化</h2><p><strong>1.减少锁粒度</strong></p><p>将大对象(这个对象可能会被很多线程访问)，拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。</p><p>() 应用</p><p>① 最最典型的减小锁粒度的案例就是ConcurrentHashMap。进而提高并发程度<br>如将 HashMap –&gt; ConcurrentHashMap使用Segment(16)增加并行度。</p><p><strong>2. 减少锁持有时间</strong></p><p>只用在有线程安全要求的程序上加锁</p><p>只在有必要的时候进行同步，这样就明显减少了线程持有锁的时间，从而<br>提高系统的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method1();                             <span class="comment">// cost much time</span></span><br><span class="line">    mutextMethod();   <span class="comment">// 实际需要进行同步的方法</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 锁分离</strong><br>如根据功能进行锁分离<br>(1) 应用</p><p>① ReadWriteLock，即保证了线程安全，又提高了性能。</p><p>在读多写少的情况下，通过 ReentrantReadWriteLock 替换 ReentrantLock，实现对于 Read 的不加锁实现；</p><p>② 读写分离思想可以延伸，  <u>只要操作互不影响，锁就可以分离</u>  。比如LinkedBlockingQueue 从头部取出，从尾部放数据。</p><p>如果使用独占锁的话，则要求两个操作在进行时首先要获取当前队列的锁，那么take<br>和put就不是先真正的并发了，因此，在JDK中正是实现了两种不同的锁，一个<br>是takeLock一个是putLock。</p><p><strong>4. 锁粗化</strong><br>不在循环中加锁，来回加和释放的开销大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第一次加锁</span></span><br><span class="line">    method1();</span><br><span class="line">    &#125;</span><br><span class="line">    method3();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第二次加锁</span></span><br><span class="line">    mutextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    method4();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//第三次加锁</span></span><br><span class="line">    method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第一次和第二次加锁和线程上下文切换的时间超过了method1()、method2()method3()、method4() 的时间.</p><p>改进后的代码的执行时间可能小于上述分别加锁的时间，这就是锁粗化，也是一种锁<br>优化的方式，但是要根据具体的场景；</p><p><strong>5. 锁消除</strong></p><p>锁消除是在  <u>编译器级别的事情</u>。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。</p><p>引发原因：</p><p>① 多数是因为程序员编码不规范引起。</p><p>② 有时这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector<br>和StringBuffer 这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线<br>程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性<br>能。</p><p>**6. JVM 锁优化(volatile, synchronized) **</p><p>见上部分</p><h2 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="*synchronized"></a>*synchronized</h2><p>(1) 作用范围</p><p>(2) 核心组件</p><ol><li><p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p></li><li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p></li><li><p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p></li><li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； </p></li><li><p>Owner：当前已经获取到所资源的线程被称为Owner；</p></li><li><p>!Owner：当前释放锁的线程。</p></li></ol><p>() 底层实现</p><p><img src="http://img.janhen.com/202012172247111553496683656.png" alt="1553496683656"></p><p>是非公平锁，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList；</p><p>每个对象后有个 monitor 对象， <u>加锁就是在竞争 monitor 对象</u> ， 代码块加锁是在前后分别加上monitorenter和monitorexit指令来实现的，方法加锁是通过一个标记位来判断的。</p><p><strong>与 ReentrantLock 对比</strong></p><p>相同点： 都是可重入锁。</p><p>① 底层实现：ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的，为关键字，能够在出现异常时打印出对应的错误堆栈用于分析问题，同时 JVM 对 synchronized 提供了锁升级的优化；</p><p>② 锁的实现方式： ReentrantLock 是同步非阻塞，采用的是乐观并发策略，而 synchronized 是同步阻塞，使用的是悲观并发策略。</p><p>③ 锁的使用的安全性： ReentrantLock 需要显视加锁解锁，可能因为忘记解锁而陷入死锁，而 synchronized 为隐式加锁，不会因为忘记解锁而陷入死锁。</p><p>④ 功能灵活性：</p><ul><li>ReentrantLock 可尝试获取锁；</li><li>RentrantLock 可中断获取锁，提供了⼀种能够中断等待锁的线程的机制，<code>lock.lockInterruptibly()</code> ；</li><li>RentrantLock 能够支持公平锁, synchronized 只能实现非公平锁；</li><li>RentrantLock 可实现选择性通知： synchronizedf 使用 notify / notifyAll 进行通知时，通知的线程由 JVM 选择，ReentrantLock 更加灵活的绑定多个 Condition, 进行选择性通知。</li></ul><p>1 ReentrantLock显示的获得、释放锁，synchronized隐式获得释放锁<br>2 ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>3 ReentrantLock是API级别的，synchronized是JVM级别的<br>4 ReentrantLock可以实现公平锁<br>5 ReentrantLock通过Condition可以绑定多个条件<br>6 底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略<br>7 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。<br>8 synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。<br>9 Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。<br>10 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>11 Lock可以提高多个线程进行读操作的效率，既就是实现读写锁等。</p><p><strong>synchronized 与volatile 的比较</strong></p><p>① 实现与性能：volatile关键字是线程同步的 <u>轻量级</u>实现，所以 <font color="green">volatile性能肯定⽐synchronized关键字要好</font>。 但是 <font color="green">volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块</font>。 synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗 ⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤ synchronized 关键字的场景还是更多⼀些。</p><p>② 阻塞： 多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞</p><p>③ 三特性的： volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。synchronized关键字两者都能 保证。</p><p>④ 使用场景： volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是 多个线程之间访问资源的同步性。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><p>(1) 死锁的四个必要条件：</p><ul><li><p>互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。</p></li><li><p>持有和等待条件： ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</p></li><li><p>不可剥夺条件：线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后 才释放资源。</p></li><li><p>循环等待条件：:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</p></li></ul><p>(2) 避免线程死锁</p><p>① 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p>② 破坏请求与保持条件 ：⼀次性申请所有的资源。</p><p>③ 破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>④ 破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。</p><p><strong>相关问题</strong></p><p>(1) 如何确保N个线程可以访问N个资源同时又不导致死锁？</p><p>① 指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了；</p><p>② 使用带有超时时间的锁；</p><p>③ 通过死锁的检测和恢复机制进行规避；</p><p>(2) 写一个发生死锁的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock1</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;flag1 one level&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;flag 1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;flag2 one level&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;flag 2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock1(<span class="number">1</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLock1(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><p><strong>无锁</strong></p><p>CAS算法的过程是这样：<u>它包含三个参数CAS(V,E,N): V表示要更新的变量，E</u><br><u>表示预期值，N表示新值。仅当V值等于E值时</u>，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。</p><p><strong>可重入锁(递归锁)</strong></p><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</p><p>偏向锁对于偏向的线程没有重入的开销。</p><p><strong>公平锁和非公平锁</strong></p><p>公平锁(Fair)</p><p> 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。</p><p>非公平锁(Nonfair) </p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</p><ol><li>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列 </li><li> Java中的synchronized是非公平锁，ReentrantLock 默认的lock()方法采用的是非公平锁。</li></ol><p><strong>读写锁</strong></p><blockquote><p>读读不互斥，读写互斥，写写互斥</p></blockquote><p>为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 </p><p>(1) 读锁 </p><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p><p>(2) 写锁 </p><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock。</p><p><strong>共享锁和独占锁</strong></p><p>java并发包提供的加锁模式分为独占锁和共享锁。 </p><p>(1) 独占锁</p><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p>(2) 共享锁</p><p> 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p><ol><li>AQS的内部类Node定义了两个常量 SHARED 和 EXCLUSIVE ，他们分别标识 AQS队列中等待线程的锁获取模式。 </li><li> java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</li></ol><p><strong>重量级锁(Mutex Lock)</strong> </p><p>Synchronized是通过对象内部的一个叫做监视器锁(monitor)来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p><p>因此，这种  <u>依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”</u>。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><p><strong>分段锁</strong></p><p>是一种思想ConcurrentHashMap是学习分段锁的最好实践</p><p><strong>活锁</strong></p><p>因为活跃性而引入的问题</p><h1 id="并发中的设计模式"><a href="#并发中的设计模式" class="headerlink" title="并发中的设计模式"></a>并发中的设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证全局唯一，并发情况下使用安全</p><p>见设计模式单例</p><p>7 种单例模式：</p><p>饿汉式；</p><p>双重监测懒汉式；</p><p>线程安全懒汉式；</p><p>静态内部类持有懒汉式；</p><p>枚举式；</p><p>变种的饿汉式；</p><p>变种的懒汉式；</p><h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>Future模式的核心思想：异步调用</p><p>不仅可以在子线程完成后收集其结果，还可以设定子线程的超时时间，避免主任务一直等待。</p><p>() 性质<br>Future模式不会立即返回你需要的数据，但是，他会返回一个契约 ，以后在使用到数据的时候就可以通过这个契约获取到需要的数据。</p><p>在广义的Future模式中，虽然获取数据是一个耗时的操作，但是服务程序不等数据完成就立即返回客户端一个伪造的数据(就是上述说<br>的“契约”)，实现了Future模式的客户端并不急于对其进行处理，而是先去处理其他业<br>务，充分利用了等待的时间，这也是Future模式的核心所在，在完成了其他数据无关的任务之后，最后在使用返回比较慢的Future数据。这样在整个调用的过程中就不会出现长时间的等待，充分利用时间，从而提高系统效率。</p><p>() JDK 中的 Future 模式</p><p>FutureTask实现了 Callable，Future接口，RunnableFuture接口继承了Future和<br>Runnable接口。因为RunnableFuture实现了Runnable接口，因此FutureTask可以提<br>交给Executor进行执行，FutureTask有两个构造方法，如下：</p><p>Runnable 与 Callable 的区别</p><p>(1) Callable规定的方法是call()，Runnable规定的方法是run()；<br>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值得；<br>(3) call()方法可以抛出异常，run()方法不可以；<br>(4) 运行Callable任务可以拿到一个Future对象，Future 表示异步计算的结果</p><p>() 异常</p><p>Future 的 get() 可能会阻塞当前线程的执行，会抛出 InterruptedExcpeiton、ExecutionException，若线程已经取消，抛出 CancellationException，取消由cancel 方法来执行。isDone确定任务是正常完成还是被取消了。</p><p>() 可取消性</p><p>一旦计算完成，就不能再取消计算。如果为了可取消性而使用Future 但又不提供可<br>用的结果，则可以声明Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>使用生产者消费者模式实现的一个例子；<br>模仿分布式爬虫；</p><p>单生产者单消费者</p><p>单生产者多消费者</p><p>多生产者单消费者</p><p>多生产者多消费者</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li>《Java 并发编程的艺术》</li><li>《深入理解Java虚拟机(第二版)》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 代码首先会编译成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="http://example.com/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/12/17/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-17T14:41:19.000Z</published>
    <updated>2021-04-15T02:51:11.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-基础"><a href="#Docker-基础" class="headerlink" title="Docker 基础"></a>Docker 基础</h1><blockquote><p>类似精简的 Linux 环境，含 root 权限、进程空间、用户空间和网络空间，以及运行在其中的应用程序</p></blockquote><p><img src="http://img.janhen.com/1566961968709.png" alt="1566961968709"></p><p>Client： 客户端通过 CLI 命令与 Docker 交互<br>Docker daemon： 宿主机的守护进程，通过 RESTful 接口处理 Client 的命令，连接 Registry 进行镜像的拉取的推送，具体配置见 [Daemon配置](#Daemon 配置)<br>Registry： 保存 image 的地方，实现 image 的维护、复用<br>Image： 静态的镜像，可根据 Image 运行 container<br>Container： 依据 Image 生成的具体的容器，实际运行的程序</p><p>Docker 底层实现原理：</p><ul><li>Namespaces：做隔离pid，net，ipc，mnt，uts</li><li>Control groups(cgroups)：做资源限制</li><li>Union file systems: Container和image的分层，分层文件系统</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><blockquote><p>一个特殊的文件系统，提供容器运行时所需的程序，同时包含一些为运行时准备的配置参数，无法更改</p></blockquote><p><strong>镜像的获取</strong></p><ul><li>根据 Dockerfile 构建镜像，配合 sh 脚本实现一些定制的初始化和参数判断逻辑，可重建</li><li>根据容器构建镜像，在只读镜像上操作可写容器重新打包成镜像，Docker 无状态，volume 不会打包进镜像，较少使用</li><li>从远程 Registry 拉取镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程 registry 拉取</span></span><br><span class="line">docker commit wonderful_mendeleev janhen/centos-vim-gcc:1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 Dockerfile 构建</span></span><br><span class="line">docker build -t janhen/myimage:1.0 .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器创建</span></span><br><span class="line">docker pull &lt;registry_host&gt;/&lt;username OR project_name&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span><br></pre></td></tr></table></figure><p><strong>镜像 tag</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> image 的查、交互</span></span><br><span class="line">docker images</span><br><span class="line">docker history &lt;image_id&gt;</span><br><span class="line">docker tag &lt;image_old_name&gt; &lt;image_new_name&gt;</span><br></pre></td></tr></table></figure><p><strong>镜像清理</strong></p><p>处理同一个版本多次覆盖，默认查找顺序为 Local -&gt; Registry 的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   删除指定的 image</span></span><br><span class="line">docker rmi &lt;image_id OR image_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">   强制删除指定|全部 image</span></span><br><span class="line">docker rmi -f $(docker images)</span><br><span class="line"><span class="meta">#</span><span class="bash">   删除 &lt;none&gt; 的镜像(<span class="comment">#)</span></span></span><br><span class="line">docker rmi $(docker images -f &quot;dangling=true&quot; -q)</span><br><span class="line">docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27; | xargs docker rmi</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote><p> 是镜像运行时的实体，构建在镜像上，可对容器进行写操作</p></blockquote><p><strong>Container 的启动并运行</strong></p><p>单机上使用最多，控制部署时候的各种参数，包含网络、存储、密码、变量…</p><p>常用的启动指定：</p><ul><li><p>指定网络，根据需要选择端口转发、单机桥接网络、多机网络、主机网络</p></li><li><p>指定文件映射，将程序中的配置文件、数据文件隔离出来，避免应容器销毁而丢失</p></li><li><p>指定命令，内部运行的程序自带的命令，如 Redis 中的命令控制持久化方式…</p></li><li><p>指定变量，通过命令方式、环境变量方式指定，让运行容器更加定制化</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --name: 按照特定名称启动，作为容器标识</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -d: 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -i: 交互式运行容器，打开STDIN，用于控制台交互 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -t: 终端方式交互, 通过 bash、shell... 进行命令式交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -p: 映射宿主机与容器的端口号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --network=&lt;value&gt;: 指定网络连接类(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -v: 进行宿主机文件与容器文件的映射(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --&lt;param&gt;=&lt;value&gt;: 进行特定参数指定，传入中的参数，在容器中的文件处可引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -e: 指定环境变量, 对应镜像提供，与 Dockerfile 中指定的 ENV 等同，可进入容器使用 env 查看(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --privileged=<span class="literal">true</span>: 给容器扩展的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --rm: 在容器终止运行后自动删除容器文件，避免磁盘浪费，常用于测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --restart=&lt;strategy&gt;: 重启策略，与 --rm 参数冲突，提供多种策略</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --entrypoint: 覆盖默认镜像的 ENTRYPOINT</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --link: 添加链接到另一个 container, 不建议使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   -w: 指定工作目录，等价于 Dockerfile 中的 WORKDIR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动过后执行一段 Shell 脚本, 用于测试环境类镜像使用</span></span><br><span class="line">docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以命令行方式进入容器，查看镜像具体情况</span></span><br><span class="line">docker run -it --entrypoint bash openjdk:7-jre </span><br><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile 中环境变量配合运行指定 JVM 运行参数、运行端口，参数名仿照 spring-boot maven 插件</span></span><br><span class="line">docker run -d -p 7070:7070 -e JVM_OPTS=&quot;-Xms1024m -Xmx2048m&quot; -e PROGRAM_ARGS=&quot;--server.port=7070&quot; com.blinkfox/web-demo:1.0.0</span><br><span class="line">docker run -e &quot;JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=5005,server=y,suspend=n&quot; -p 8080:8080 -p 5005:5005 -t springio/gs-spring-boot-docker</span><br><span class="line">docker run -d --name test1 \</span><br><span class="line">  -e MYENV=AAAA \ </span><br><span class="line">  busybox /bin/sh -c &quot;while true;do sleep 3600;done&quot;</span><br></pre></td></tr></table></figure><p><strong>容器的信息查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器整体信息查询</span></span><br><span class="line">docker info</span><br><span class="line">docker info | grep &quot;Docker Root Dir&quot;</span><br><span class="line">docker ps [(-a)|(-aq)]?</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置信息</span></span><br><span class="line">docker inspect &lt;container&gt;</span><br><span class="line">docker inspect -f &#123;&#123;xx.yy&#125;&#125; &lt;container&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 交互，调试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   日志，  -f ： follow <span class="built_in">log</span> output，持续实时显示日志，   -t:......</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   命令交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在容器中执行特定命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志查看</span></span><br><span class="line">docker logs &lt;contain_id OR container_name&gt;</span><br><span class="line">docker logs -f &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内部执行</span></span><br><span class="line">docker exec -it &lt;container_id&gt; bash</span><br><span class="line">docker exec &lt;container_id&gt; ip a</span><br><span class="line">docker exec -it &lt;container_id OR container_name&gt; env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行信息</span></span><br><span class="line">docker stat &lt;container&gt;</span><br></pre></td></tr></table></figure><p><strong>容器基础命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的启、停</span></span><br><span class="line">docker container start|stop|restart &lt;container_id OR contaienr_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入导出</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   导出容器成指定的 tar 包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   容器快照文件导入为*镜像*</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   URL/目录导入</span></span><br><span class="line">docker export 7691a814370e &gt; ubuntu.tar</span><br><span class="line">cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><p><strong>容器的清理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除|强制删除指定的容器</span></span><br><span class="line">docker container rm &lt;container_id OR container_name&gt;</span><br><span class="line">docker contaienr rm -f &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已停止运行的容器(<span class="comment">#)</span></span></span><br><span class="line">docker rm $(docker ps -f &quot;status=exited&quot; -q)</span><br></pre></td></tr></table></figure><p><strong>Container 交互</strong></p><blockquote><p>容器内部可执行的命令，特定目录存储的配置内容，可以通过 CLI 的监控命令</p></blockquote><p>支持更改 /etc/hosts， /etc/hostname，/etc/resolv.conf ，只针对运行时，临时的更改</p><p>几种交互方式：</p><ul><li><p>运行时直接进入交互、运行时直接执行命令交互，包含对文件的操作、内部命令执行</p></li><li><p>运行后按特定终端进入交互、运行后按特定命令交互，同上</p></li><li><p>日志交互，logs，支持最后几行、最近的时间点、实时显示</p></li><li><p>基本情况，inspect，返回运行情况 JSON 字符串，可通过 Go  Templete 获取特定情况</p></li><li><p>运行的资源情况，stats，实时显示 CPU、内存、网络、磁盘情况</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器内部</span></span><br><span class="line">docker exec -it -u root jenkins sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行特定命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   创建之后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在已运行的容器中执行命令</span></span><br><span class="line">docker run -it --rm ubuntu:18.04  ip a</span><br><span class="line">docker run -it --rm ubuntu:18.04 --hostname=test.com --dns=172.16.3.3 ip a</span><br><span class="line">docker run -it --rm ubuntu:18.04  cat /etc/resolv.conf</span><br><span class="line">docker exec -it gitlab cat /etc/resolv.conf</span><br><span class="line">docker exec -it gitlab cat /etc/hostname</span><br><span class="line">docker exec -it gitlab cat /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内部执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看挂载情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看定义的环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 dns 情况, 与在宿主机上的 /etc/docker/daemon.json 上配置 dns 类似?</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看容器IP地址配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看路由情况</span></span><br><span class="line">mount</span><br><span class="line">env</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">ip addr show eth0</span><br><span class="line">ip route</span><br><span class="line"><span class="meta">#</span><span class="bash"> logs 查看</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   特定时间偏移, 特定时间段</span></span><br><span class="line">docker logs -f -t --since=40m --tail=10 jenkins</span><br><span class="line">docker logs -t --since=&quot;2019-08-01T13:23:37&quot; --until &quot;2018-08-31T12:23:37&quot; jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> inpect 查看</span></span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; 1f1f4c1f931a</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">stat</span> 查看</span></span><br><span class="line">docker stats &lt;container_id OR container_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝文件，作为 Dockerfile 中 COPY 的...</span></span><br><span class="line">docker cp &lt;host_machine file OR dir&gt; &lt;container_name&gt;:&lt;container_dir&gt;</span><br></pre></td></tr></table></figure><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><blockquote><p>Docker 的私有仓库，实现容器的复用共享</p></blockquote><p>发布镜像到 Registry 的方式：</p><ul><li><p>发布镜像到仓库</p><p>  直接将本地已经构建好的镜像发布到仓库中</p></li><li><p>根据指定 Dockerfile 由 Docker hub 进行构建形成镜像</p><p>自动在 git 发生变化的时候拉取数据进行构建重新发布到仓库上，自动构建发布，CICD</p><p>保证镜像的可再生性</p></li></ul><p>私有 Registry 搭建：</p><p>官方提供的 registry</p><p>Vmware 开源的 harbor，见 <a href="./B-%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%8E%AF%E5%A2%83.md#harbor">工具与环境</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录 docker hub 账号和密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送镜像到 docker hub</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker hub 关联 github or bitbucket</span></span><br><span class="line">docker login 172.17.11.29:5111 -u admin -p Harbor12345</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名镜像的名称(tag)</span></span><br><span class="line">docker push 172.17.11.29:5111/centos-vim-gcc:1.0.0</span><br><span class="line">docker tag janhen/centos-vim-gcc:1.0.0 172.17.11.29:5111/study-docker/centos-vim-gcc:1.0.0</span><br><span class="line">docker push 172.17.11.29:5111/study-docker/centos-vim-gcc:1.0.0</span><br></pre></td></tr></table></figure><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><blockquote><p>进行容器之间的访问，包含单机上的访问，多台机器之间的访问； 含端口映射、容器互联</p><p>关联文档:  <a href="https://yeasy.gitbooks.io/docker_practice/network/">使用网络</a>  |  <a href="https://yeasy.gitbooks.io/docker_practice/advanced_network/">高级网络配置</a></p></blockquote><p><strong>Linux 上网络访问</strong></p><blockquote><p> Linux 网络命名空间，进行网络的隔离</p></blockquote><p>Veth pair： 进行网络命名空间的连接，实现两个 net namspce 连接通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网络命名空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给命名空间分配 ip 地址, 默认情况下只有 mac 地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动接口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接双方使其网络互通</span></span><br><span class="line">ip netns list</span><br><span class="line">ip netns delete test1</span><br><span class="line">ip netns exec test2 ip link</span><br><span class="line">ip netns exec testl ip link set dev veth-testl up</span><br><span class="line">ip netns exec testz ip link set dev veth-test2 up</span><br></pre></td></tr></table></figure><h3 id="Docker-网络访问"><a href="#Docker-网络访问" class="headerlink" title="Docker 网络访问"></a>Docker 网络访问</h3><blockquote><p>通过link 方式实现容器之间的访问，直接通过名称而非 IP，适用于单台机器</p></blockquote><p><img src="http://img.janhen.com/1566531692115.png" alt="1566531692115"></p><p>一个容器对应一个网络空间</p><p>类似局域网连接，通过中间的交换机实现两个容器之间的通信， docker0 的内网指定默认为 172.17.0/16，自定义为 172.17.18.0/16…</p><p>访问外部网络，需要经过 NAT 转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络， bridge 网络</span></span><br><span class="line">docker network ls</span><br><span class="line">sudo docker network inspect &lt;network_id OR network_name&gt;</span><br><span class="line">ip a</span><br><span class="line">yum install bridge-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示系统当前桥接</span></span><br><span class="line">brctl show</span><br><span class="line">ip a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建指定类型的网络</span></span><br><span class="line">docker network create -d bridge net-my</span><br></pre></td></tr></table></figure><p><strong>Docker link 网络连接</strong></p><blockquote><p>通过命名 Docker 进行相连，类似网络命名空间中的 Veth pair，目前不推荐使用</p><p>命令格式： –link <container_name OR container_id>:<alias></p><p>替代方案： docker-compose.yml 中使用 depends_on，使用 overlay 网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 类似给 net-test2 添加 DNS 记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   link 方向性; 使用少</span></span><br><span class="line">docker run -d --name net-test2 \</span><br><span class="line">  --link net-test1 busybox \</span><br><span class="line">  /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker exec -it net-test2 /bin/sh</span><br><span class="line">  ip a </span><br><span class="line">  ping net-test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 指定网络类型， bridge|overlay</span></span><br><span class="line">docker network create -d bridge net-my</span><br><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line">docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --link &lt;name&gt; 支持通过名称访问容器 </span></span><br><span class="line">docker run -d --name flask-redis \</span><br><span class="line">  -p 5000:5000 \</span><br><span class="line">  --link redis \</span><br><span class="line">  -e REDIS_HOST=redis \</span><br><span class="line">  janhen/flask-redis </span><br><span class="line">docker run -d --name test1 \</span><br><span class="line">  -e PENG=testt1 \</span><br><span class="line">  busybox </span><br><span class="line">docker run -d --name test2 \ </span><br><span class="line">  -e PENG=testest \</span><br><span class="line">  busybox  \</span><br><span class="line">  /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br></pre></td></tr></table></figure><p><strong>自定义网络连接</strong></p><blockquote><p>避免使用 –link 进行容器之间网络的连接</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockernetwork create -d bridge net-demo</span><br></pre></td></tr></table></figure><h3 id="Docker-单机网络"><a href="#Docker-单机网络" class="headerlink" title="Docker 单机网络"></a>Docker 单机网络</h3><p><strong>Docker bridge 网络</strong></p><blockquote><p>可以创建自己的桥接网络，进行区分，docker-compose 默认管理的容器共享同一个 bridge 网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建自己的桥接网络</span></span><br><span class="line">docker network create -d bridge my-bridge</span><br><span class="line">docker network ls</span><br><span class="line">brctl show</span><br><span class="line">docker run -d \</span><br><span class="line">  -- name net-test3 \</span><br><span class="line">  --network my-bridge busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker network connect mybridge net-test2</span><br></pre></td></tr></table></figure><p>bridge 性能一般，对性能要求较高，可使用个 SR-IOV 网卡嵌入容器内。</p><p><strong>Docker host 和 none网络</strong></p><blockquote><p>none 网络： 不会有网络信息，孤立的网络，用来做私有的工具，如保存密码??，使用场景少</p><p>host 网络：无网络信息，与主机共享网络命名空间，存在端口冲突问题</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx </span><br></pre></td></tr></table></figure><h3 id="Docker-多机网络"><a href="#Docker-多机网络" class="headerlink" title="Docker 多机网络"></a>Docker 多机网络</h3><blockquote><p>实现多个不同机器之间的容器进行通信</p></blockquote><h4 id="Overlay-网络"><a href="#Overlay-网络" class="headerlink" title="Overlay 网络"></a>Overlay 网络</h4><blockquote><p>依赖一个分布式存储，保存对应的 IP，防止网络(172.18.0.0/16)、容器名称等的冲突</p></blockquote><p>实现 Docker 的多机网络，见 [Internel 访问](#Internel 访问)</p><p>两台机器之间可以相互通信，为了实现不同容器之间的通信需要借助第三方的分布式存储</p><p>使用etcd 建立的 cluster 中容器名称不允许重复、Ip 地址不允许重复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络，实现多态主机之间的同步创建 overlay 网络</span></span><br><span class="line">docker network ls</span><br><span class="line">docker netword create -d overlay net-overlay-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络情况，子网范围，容器情况</span></span><br><span class="line">docker network inspect net-overlay-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器指定到 overlay 网络</span></span><br><span class="line">docker run -d --name node1-test1 \</span><br><span class="line">  --net net-overlay-demo \</span><br><span class="line">  busybox sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker run -d --name node2-test1 \</span><br><span class="line">  --net net-overlay-demo \</span><br><span class="line">  busybox sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点上容器的地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 cluster 中网络的情况</span></span><br><span class="line">docker exec node1-test1 ip a</span><br><span class="line">docker exec node2-test1 ip a</span><br><span class="line">docker network inspect net-overlay-demo</span><br></pre></td></tr></table></figure><h4 id="Etcd-分布式存储"><a href="#Etcd-分布式存储" class="headerlink" title="Etcd 分布式存储"></a><strong>Etcd 分布式存储</strong></h4><blockquote><p>存储分布式系统中的 key-val，开源免费，保证 overlay 网络中分配的容器与容器对应的IP地址在整个网络中唯一</p><p>关联： <a href="https://github.com/etcd-io/etcd">GitHub</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在对应的两台机器上安装 etcd，容器安装/binary 安装</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过命令指定好集群启动</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证 cluster 的运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 etcd 文件夹执行健康检查，两台机器同时执行</span></span><br><span class="line">./etcdctl cluster-health</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭 Docker 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 etcd 作为分布式存储启动 docker， 手动启动 dockerd 守护进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 \</span><br><span class="line">  -H unix://var/run/docker.sock \</span><br><span class="line">  --cluster-store=etcd://192.168.xx.xx:2379 \</span><br><span class="line">  --cluster-advertise=192.168.xx.xx:2375 &amp;  </span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="Docker-持久化"><a href="#Docker-持久化" class="headerlink" title="Docker 持久化"></a>Docker 持久化</h2><blockquote><p>将容器与数据存储隔离开，如 Mysql 运行程序与数据保存位置</p></blockquote><p><img src="http://img.janhen.com/202012172237411566571502370.png" alt="1566571502370"></p><p>两种持久化的方式：</p><ul><li><p>本地 FS 的 Volumn</p></li><li><p>基于 plugin 的 Volume， 如 NAS</p></li></ul><p>本机上三种持久化实现, -mount 选项选择数据卷：</p><ul><li><p>bind :挂载在 Linux FS 中任意位置</p></li><li><p>volume：统一挂载在 daemon 设置的 docker 目录下，默认为 <code>/var/lib/docker/volumes/&lt;unique_str_id OR volume_name&gt;</code></p></li><li><p>tmpfs： 只挂载在内存中，易丢失</p></li></ul><p>使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker volume create -d local test</span><br><span class="line">docker volume inspect &lt;contaienr&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理</span></span><br><span class="line">docker volume prune &lt;&gt;</span><br><span class="line">docker volume rm &lt;&gt;</span><br><span class="line">docker run -d --mount type=bind, source=/data, destination=/redis/data xxxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定 :ro 容器无法对挂载数据卷内的数据进行修改</span></span><br><span class="line">docker run -d -v /webapp:/opt/webapp:ro</span><br></pre></td></tr></table></figure><p><strong>数据卷容器</strong></p><p>实现多个容器操作数据，任意容器修改都可被其他容器看到</p><p>–volumes-from 参数所挂载的数据卷容器无需处在运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --volumes-from dbdata xxx</span><br></pre></td></tr></table></figure><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><blockquote><p>通过 Dockerfile 中的 Volumn 控制，在宿主机上 docker 文件下建立目录存放文件</p></blockquote><p>建议 -v 参数指定在 docker 目录下 volume 的名称，默认为 <code>/var/lib/docker/volumes/&lt;-v_name OR long_str&gt;</code></p><p>针对官方镜像，到 Docker Hub 上查看对应的 volume 挂载目录位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 volume，查看所有|指定|删除volume</span></span><br><span class="line">docker volume create volume1</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect volume1</span><br><span class="line">docker volume rm volume2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行-&gt;删除-&gt;验证</span></span><br><span class="line">docker run -d -v mysql1:/var/lib/mysql  \</span><br><span class="line">  --name mysql1  \</span><br><span class="line">  -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql </span><br><span class="line">docker rm -f  mysql1 mysql2</span><br><span class="line">docker run -d -v mysql1:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql </span><br><span class="line">docker exec -it mysql2 /bin/bash</span><br><span class="line">  mysql -u root</span><br><span class="line">  show databases;</span><br></pre></td></tr></table></figure><h3 id="Bind-Mouting"><a href="#Bind-Mouting" class="headerlink" title="Bind Mouting"></a>Bind Mouting</h3><blockquote><p>指定容器目录与宿主机目录绑定，宿主机文件更改影响到容器中的运行</p></blockquote><p>可以实现本台电脑  –&gt;  虚拟机  –&gt;  容器三者的目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v: &lt;宿主机目录&gt;:&lt;容器目录&gt; 进行一一映射</span></span><br><span class="line">docker run -d -v $(pwd):/usr/share/nginx/html -p 80:80 --name web janhen/my-nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 Docker 作为本地开发环境</span></span><br><span class="line">docker run -d -p 80:5000  --name flask janhen/flask-skeleton </span><br></pre></td></tr></table></figure><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><blockquote><p>用于生成 Docker Image 的文件，一般只用于 <code>docker build -t janhen/xx:99 .</code> 命令执行使用 </p><p>关联： <a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html#dockerfile-%E6%8C%87%E4%BB%A4">Dockerfile 指令</a></p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>Dockerfile 的基本语法</strong></p><blockquote><p>FROM,WORKDIR,ENV,COPY,ADD</p><p>RUN,CMD,ENTRYPOINT</p><p>VOLUME,EXPOSE</p></blockquote><ul><li><p><code>FROM</code>： 根据特定的镜像制作，从头制作、 根据指定环境制作、某个镜像作为构建阶段使用</p></li><li><p><code>RUN </code>： 运行命令脚本, 可以通过此安装一些环境并对环境进行配置，如安装 Node 环境，每运行一个命令增加一层 ==&gt;  建议将多个命令合并成一个命令使用</p></li><li><p><code>WORKDIR</code>： 设定当前工作目录, 类似 cd 改变目录, 没有目录自动创建(#)<br>  直接通过绝对路径定位<br>  通过绝对路径+相对路径定位目录</p></li><li><p><code>ADD and COPY</code>： 将本地文件添加到 docker image 中,常 配合 WORKDIR 使用</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> LABEL 镜像的 metadata，帮助信息</span></span><br><span class="line">LABEL maintainer=&quot;janhen &lt;ipaam414@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">RUN yum update &amp;&amp; yum install -y vim \</span><br><span class="line">  python-dev</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y perl \</span><br><span class="line">    pwgen --no-install-recommends &amp;&amp; rm -rf \  </span><br><span class="line">    /var/lib/apt/lists/*</span><br><span class="line">RUN /bin/bash -c &#x27;source $HOME/.bashrc;echo $HOME&#x27;</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">WORKDIR /test</span><br><span class="line">WORKDIR demo</span><br><span class="line">RUN pwd</span><br><span class="line"></span><br><span class="line">ADD hello /</span><br><span class="line">ADD test.tar.gz /</span><br><span class="line">WORKDIR /root</span><br><span class="line">ADD hello test/</span><br><span class="line">COPY hello test/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENV 设定环境变量, 建议使用</span></span><br><span class="line">ENV MYSQL_VERSION 5.6</span><br><span class="line">RUN apt-get install -y mysql-server = &quot;$&#123;MYSQL_VERSION&#125;&quot; \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动后默认执行的命令和参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   docker run 指定其他命令, CMD 被忽略</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   定义多个 CMD，只运行最后一个</span></span><br><span class="line">docker run [image]                # CMD 会被执行</span><br><span class="line">docker run -it [image] /bin/bash  # CMD 不会执行</span><br><span class="line">CMD [&quot;mongod&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENTRYPOINT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动时运行的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器以应用程序/服务的形式运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   不会被忽略, 一定会执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   最佳实践: 通过 shell 脚本作为 entrypoint </span></span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin/     # 添加到容器中</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]           # 指定入口脚本</span><br><span class="line">EXPOSE 27017</span><br><span class="line">ENTRYPOINT [&quot;scripts/dev.sh&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行宿主机与容器中文件的映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射容器中的 /tmp 到宿主机上，默认在 /var/lib/docker/volumes/&lt;long_id OR name&gt; 下建立对应的映射</span></span><br><span class="line">VOLUME /tmp</span><br></pre></td></tr></table></figure><p><strong>命令格式</strong></p><blockquote><p>不同的命令执行写法，以及对应的区别</p></blockquote><p>Shell 格式, 默认通过 shell 执行</p><p>Exec 格式,   ENTRYPOINT [“/bin/bash”, “-c”, “echo”, “hello $name”]</p><p>针对 Exec 无法映射变量问题的处理： 通过命令方式编写语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV name Docker</span><br><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;hello $name&quot;]</span><br></pre></td></tr></table></figure><p><strong>命令区别</strong></p><p>1、RUN、CMD和ENTRYPOINT命令区别</p><p>RUN 运行在 image 的构建阶段执行，执行结果会被打包进 image 文件</p><p>CMD 在容器启动后执行，可用于在容器内启动某个服务、进程，只可使用一次，与 run 中年执行命令冲突</p><p>ENTRYPOINT 在容器启动后执行，出现多行不会忽略，一定执行，通常配合 COPY 到容器中的 sh 脚本使用</p><p>2、COPY 与 ADD 命令区别</p><p>ADD 可以获取网络资源，可以直接解压缩</p><p><strong>注意事项</strong></p><p>1、CMD 的最后一次有效性</p><p>官方镜像中大多最后运行 CMD，方便覆盖实现定制化的参数的启动</p><p>2、目录</p><p>COPY . /app 与 COPY . /app/ 映射不同</p><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><blockquote><p>多容器管理，通过 yml 配置管理容器之间的依赖关系，底层 python 编写，前身为开源的 Fig 项目。主要用于本地开发使用。</p><p>关联文档：<a href="https://yeasy.gitbooks.io/docker_practice/compose/compose_file.html">Compose 模板文件</a> | <a href="https://docs.docker.com/compose/compose-file">Doc</a></p></blockquote><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><blockquote><p>docker-compose 的启动、停止、交互</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> compose 后台启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并查看日志</span></span><br><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose -f &lt;compose_name&gt; up -d </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止并删除 容器、网络、volumes</span></span><br><span class="line">docker-compose stop &lt;service&gt;</span><br><span class="line">docker-compose down &lt;service&gt;</span><br><span class="line">docker-compose build</span><br><span class="line"><span class="meta">#</span><span class="bash"> compose 查看运行情况，状态、端口情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 compose 中定义容器使用的 images</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose images</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 compose 中的 service</span></span><br><span class="line">docker-compose exec mysql bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展</span></span><br><span class="line">docker-compose scale &lt;service_name&gt;=&lt;count&gt;</span><br></pre></td></tr></table></figure><p><strong>service 的扩展</strong></p><blockquote><p> 实现水平扩展，负载均衡，在不存在端口冲突的情况下通过 haproxy 进行负载均衡，在 Docker Swarm 运行时可直接通过 deploy 中的参数指定复制扩展的个数</p></blockquote><p>通过 docker-compose scale 命令进行扩展</p><p>处理 scale 中端口映射重复问题</p><p>在 docker-compose 中增加 dockercloud/haproxy 进行负载均衡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动时指定扩展</span></span><br><span class="line">docker-compose up --scale web=3 -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行后进行扩展</span></span><br><span class="line">docker-compose scale web=4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证扩展情况</span></span><br><span class="line">docker-compose ps</span><br><span class="line">for i in `seq 10`; do curl 127.0.0.1:8080; done</span><br></pre></td></tr></table></figure><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><blockquote><p>对应 docker-compose.yml 文件的语法</p></blockquote><p>三大实体：</p><ul><li><p>service: 服务</p></li><li><p>networks: 网络指定，指定网络类型，一般为 bridge、overlay，根据需要指定多个网络，进行一定的隔离</p></li><li><p>volumes: 进行数据卷的映射</p></li></ul><hr><p>image 获取方式： 通过 image 获取本地的或是拉取远程的，或者通过 build 进行构建，传入 Dockerfile 的目录以及对应的 Dockerfile 名称</p><p>ports: 进行宿主端口与容器端口的映射</p><p>depends_on: 解决容器的依赖，启动先后问题</p><p>links: 服务之间的依赖关系，在容器内部可以直接使用依赖服务名称对应的 IP 地址，不建议使用</p><p>deploy: 进行部署，控制集群中的各种情况，用于 Docker swarm，version 3 支持</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 特定片段参考</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置网络, 可多个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> frontend, backend 前后端设置</span></span><br><span class="line">networks:</span><br><span class="line">  - frontend</span><br><span class="line">  - backend</span><br><span class="line"><span class="meta">#</span><span class="bash"> 端口设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接引号设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 宿主机与容器端口映射</span></span><br><span class="line">ports:</span><br><span class="line">  - &quot;6379&quot;</span><br><span class="line">ports:</span><br><span class="line">  - 5000:80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 依赖</span></span><br><span class="line">depends_on:</span><br><span class="line">  - mysql</span><br></pre></td></tr></table></figure><h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><blockquote><p>Docker 自带的服务编排框架，大多数都由其中的 Manager 做管理，较难定制，不适合太多节点的部署</p></blockquote><p>Docker Swarm 特点：</p><p>符合传统IT的管理模式</p><p>平台本身集成性好，可当成云管平台使用</p><p>内置太多不易进行定制化，不好 Debug，不易干预</p><p><strong>不提供存储选项</strong>：Docker Swarm不提供将容器连接到存储的无障碍方式，其数据量需要在主机和手动配置上进行大量即兴创作</p><p><strong>监控不良</strong>：Docker Swarm提供有关容器的基本信息，如果您正在寻找基本的监控解决方案，那么Stats命令就足够了。如果您正在寻找高级监控，那么Docker Swarm永远不是一个选择。虽然有像CAdvisor这样的第三方工具可以提供更多监控，但使用Docker本身实时收集有关容器的更多数据是不可行的。</p><h2 id="Swarm-架构"><a href="#Swarm-架构" class="headerlink" title="Swarm 架构"></a>Swarm 架构</h2><p><img src="http://img.janhen.com/202012172238091566634422450.png" alt="1566634422450"></p><p><a href="http://thesecretlivesofdata.com/raft/">Raft</a> consensus group： 进行控制分布式场景下的协商:  内置的分布式的存储数据库，通过 Raft 协议进行同步，包含 Leader 选举、Log 复制</p><p>Internel distributed state store： 分布式存储数据库，功能如保证分布式场景下 Ip 等唯一，类似 etcd</p><p>Manager: 可以保存 Raft 关联的文件，用于 Secret 实现</p><p>Worker: 主要运行容器，通过 Gossip network 进行通信，保证分布式下的一致性</p><p>Gossip network： 各个 Worker 之间同步实现的协议</p><p>扩展：</p><p>  Service: 通过 swam manager 进行控制，具体 service 部署到哪个 node 上</p><p>  Replicas： 一个 Service 对应多个 Replicas，用于扩展</p><h2 id="集群搭建管理"><a href="#集群搭建管理" class="headerlink" title="集群搭建管理"></a>集群搭建管理</h2><blockquote><p>让几台服务器搭建成一个 Swarm Cluster</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 Manager Node</span></span><br><span class="line">docker swarm init --advertise-addr=192.169.xx.xx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 Worker Node 加入到特定的 Manager Node</span></span><br><span class="line">docker swarm join --token xxxfsdfsdf &lt;ip&gt;:&lt;port&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前 Node 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点查看</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点降级</span></span><br><span class="line">docker node ls  </span><br><span class="line">docker node inspect &lt;node_name&gt;</span><br><span class="line">docker node demote &lt;node_name&gt;</span><br><span class="line">docker node ps</span><br></pre></td></tr></table></figure><h2 id="Swarm管理"><a href="#Swarm管理" class="headerlink" title="Swarm管理"></a>Swarm管理</h2><p><strong>Swarm Services 管理</strong></p><blockquote><p>单个 Service 的管理，一个 Service 可扩展到多个 cluster node 上的 Container 运行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建容器，运行位置有 mananger 进行控制运行在哪个节点上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似 docker run 命令，在本地创建 container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 service 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   MODE: replicated</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   REPLICAS: 1/1 支持水平扩展，类似 docker compose 中的 scale</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看具体的 service 情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   运行在哪个节点上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展servie，通过复制的方式(<span class="comment">#) </span></span></span><br><span class="line">docker service create --name demo busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps demo</span><br><span class="line">docker service scale demo=5</span><br><span class="line">docker service ps demo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 本机查看 docker 容器运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除某个正在运行中的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群自动恢复，确保一定数目的 scale 扩展有效，系统稳定运行时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示节点中容器运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除服务，对应的集群节点容器删除</span></span><br><span class="line">docker ps</span><br><span class="line">docker rm -f e64432</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps demo</span><br><span class="line">docker service rm demo</span><br></pre></td></tr></table></figure><h2 id="RoutingMesh"><a href="#RoutingMesh" class="headerlink" title="RoutingMesh"></a>RoutingMesh</h2><blockquote><p>Swarm 网络通信原理，管理集群服务间的通信，访问集群中任何一个节点特定端口都会被重定向到实际运行服务的节点上</p></blockquote><p><img src="http://img.janhen.com/202012172238131566634990023.png" alt="1566634990023"></p><p>DNS 服务发现，单机情况下可以通过 service 的名称进行相互访问，多机情况下通过 swarm 进行相互访问</p><p>VIP： 非真实机器的IP地址，避免多个IP地址变化问题，造成系统运行不稳定，一个 service 对应一个</p><p>LVS： 根据虚拟 IP 找出容器中的具体的 IP 地址</p><p>两种体现：</p><ul><li>Internel：容器之间通过 overlay 网络访问</li><li>Ingress ：服务绑定接口的情况，此服务通过任意 Swarm 节点对应接口访问</li></ul><h3 id="Internel-访问"><a href="#Internel-访问" class="headerlink" title="Internel 访问"></a>Internel 访问</h3><blockquote><p>容器间实现相互访问，通过 overlay 网络实现，实现 service 与 service 之间的通信</p></blockquote><p><img src="http://img.janhen.com/202012172238171568514162156.png" alt="1568514162156"></p><p>whoami 镜像： 提供 web 服务，访问 8000 端口，返回 container 的 hostname</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 whoami 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   端口映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   网络指定</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有 service </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 whoami 服务运行位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 到对应机器上验证</span></span><br><span class="line">docker network create -d overlay net-demo</span><br><span class="line">docker service create -d \</span><br><span class="line">  --name whoami \</span><br><span class="line">  -p 8000:8000 \</span><br><span class="line">  --network net-demo jwilder/whoami</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps whoami</span><br><span class="line">docker ps</span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 busybox 的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   连接到同一个 overlay 网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有服务，当前 busybox service 是否启动完成</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务 client 服务具体位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入对应的机器查看对应运行的 container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   10.0.0.7 IP 地址，为虚拟 IP， 将 whoiam 通过 scale 扩展</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 scale 进行扩展 whoami </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 whoami 位置，并进入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入对应 client contaienr 中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   连接 whoami </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查询 dns，只有一个虚拟IP 10.0.0.7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 whoami 查看网络地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 whoami(另一) 查看网络地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 client</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 task.whoami，返回对应的多个节点，为真实的 IP 地址（<span class="comment">#）</span></span></span><br><span class="line">docker service create -d \</span><br><span class="line">  --name client \</span><br><span class="line">  --network net-demo busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps client</span><br><span class="line">docker ps</span><br><span class="line">docerer exec -it &lt;container_id&gt; sh</span><br><span class="line">  ping whoami    </span><br><span class="line">docker service scale whoami=2    </span><br><span class="line">docker service ps whoami</span><br><span class="line">docker service ps client</span><br><span class="line">docker exec -it &lt;container_client_id&gt; sh </span><br><span class="line">  ping whoami </span><br><span class="line">  nslookup whoami</span><br><span class="line">docker exec 5b79 ip a</span><br><span class="line">docker execdf9 ip a</span><br><span class="line">docerk exec -it &lt;container_client_id&gt; sh</span><br><span class="line">  nslookup task.whoami</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展 whoami 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查案 client 对应的 task.whoami，显示三个对应的(whoami)IP 地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   ==&gt; 虚拟IP: 不会随 service 的扩展而变化, 包括增加、减少、机器之间的迁移不会变化(<span class="comment">#)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问多次服务 whoami，相应的对应机器上的容器会因为负载均衡而不同，通过 LVS 实现</span></span><br><span class="line">docker service scale whoami=3</span><br><span class="line">docker service ps whoami</span><br><span class="line">---</span><br><span class="line">  nslookup task.whoami</span><br><span class="line">  wget whoami:8000</span><br><span class="line">  more index.html</span><br><span class="line">  rm -rf index.html</span><br><span class="line">  wget whoami:8000</span><br></pre></td></tr></table></figure><p>两种体现：</p><p>Internal: 容器键通过 overlay 网络(VIP)访问</p><p>Ingress: 服务绑定接口, 通过任意 swarm 节点的接口访问’</p><p>DNS + VIP + iptables + LVS 实现的过程图：</p><p>// todo 具体 Swarm 网络中数据的流动情况</p><p>小结： 容器之间连接到 overlay 网络进行通信，service 之间的通信通过  VIP + LVS 实现</p><h3 id="Ingress-负载均衡"><a href="#Ingress-负载均衡" class="headerlink" title="Ingress 负载均衡"></a>Ingress 负载均衡</h3><blockquote><p>绑定端口实现的容器之间的访问，通过 <node_ip>:<service_port> 直接访问服务</p><p>作用体现：集群中的 Node 对应的端口提供相同的服务，即使 Node 本地无服务也支持访问</p></blockquote><p>Ingress Network 的数据包走向图</p><p><img src="http://img.janhen.com/202012172238261568515008492.png" alt="1568515008492"></p><p>在  IPTables + IPVS 发往目的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常看网络桥接情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看机器的网络命令空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 ingress_sbox 网络命名空间</span></span><br><span class="line">iptables</span><br><span class="line">brctl show</span><br><span class="line">sudo ls /var/run/docker/netns</span><br><span class="line">sudo nsenter --net=/var/run/docker/netns/ingress_sbox</span><br><span class="line">ip a</span><br><span class="line">iptables -nL -t mangle</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 LVS 管理工具</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 LVS 情况，展示可选的服务 IP 地址，展示机器的 weight, </span></span><br><span class="line">yum install ipvsadm</span><br><span class="line">sudo nsenter --net=/var/run/docker/netns/ingress_sbox</span><br><span class="line">iptables -nL -t mangle</span><br><span class="line">ipvsadm -l</span><br></pre></td></tr></table></figure><h2 id="Docker-Stack-部署"><a href="#Docker-Stack-部署" class="headerlink" title="Docker Stack 部署"></a>Docker Stack 部署</h2><blockquote><p>进行多服务部署，可以使用 docker-compose.yml ，只能用于 swarm cluster，无法用于其他的服务编排框架</p></blockquote><p>docker-compose.yml 文件更改</p><p>compose file version 3: 增加 <a href="https://docs.docker.com/compose/compose-file/#deploy">deploy</a> 命令，具体参数如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy</span></span><br><span class="line"><span class="comment">#   endpoint_mode: vip 模式(默认), dnsrr 模式 循环访问(少用)</span></span><br><span class="line"><span class="comment">#   labels: 帮助描述信息</span></span><br><span class="line"><span class="comment">#   mode: global, replicated， global 全局唯一, 无法通过 scale 横向扩展，一般外部服务使用此种方式，如 mysql,nginx,redis等； replicated 默认，可通过复制来进行扩展</span></span><br><span class="line"><span class="comment">#   placement:   </span></span><br><span class="line"><span class="comment">#     constraint: </span></span><br><span class="line"><span class="comment">#       - node.role == manager # 限制部署到 manager 节点上</span></span><br><span class="line"><span class="comment">#     preferences: 优先喜好</span></span><br><span class="line"><span class="comment">#       -</span></span><br><span class="line"><span class="comment">#   replicas: 在 mod 是 replicated 的时候定义初始化时候需要的 replicas</span></span><br><span class="line"><span class="comment">#   resources: 进行资源的限制</span></span><br><span class="line"><span class="comment">#     limits:</span></span><br><span class="line"><span class="comment">#       cpus: &#x27;0.50&#x27;  # CPU 使用限制</span></span><br><span class="line"><span class="comment">#       memeory: 50M  # 内存使用限制</span></span><br><span class="line"><span class="comment">#     reservations:   # 优先保留，最小的情况</span></span><br><span class="line"><span class="comment">#       cpus: &#x27;0.25&#x27;</span></span><br><span class="line"><span class="comment">#       memory: 20M</span></span><br><span class="line"><span class="comment">#   restart_policy:         # 容器宕机后的处理</span></span><br><span class="line"><span class="comment">#     conditon: on-failure  # 什么情况下重启</span></span><br><span class="line"><span class="comment">#     delay: 5s             # 延迟</span></span><br><span class="line"><span class="comment">#     max_attempts: 3       # 最大重试次数</span></span><br><span class="line"><span class="comment">#     window: 120s</span></span><br><span class="line"><span class="comment">#   update_config:          # service 更新的配置</span></span><br><span class="line"><span class="comment">#     parallelism: 2</span></span><br><span class="line"><span class="comment">#     delay: 10s</span></span><br><span class="line"><span class="comment">#     order: stop-first</span></span><br></pre></td></tr></table></figure><p>部署的过程：</p><p>更改单机的 docker-compose.yml 为对应 cluster 部署(deploy)</p><p>按条件执行命令： 如下</p><p>验证： 通过访问任意一个 cluster 中的地址即可访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 整个 application 定义为一个 stack 为 wordpress</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   可通过 -c=docker-compose.yml 进行简化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   mysql: 限制只运行一个，只能运行在 manager 节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 stack 查看服务情况</span></span><br><span class="line">docker stack deploy wordpress --compose-file=docker-compose.yml</span><br><span class="line">docker stack ls</span><br><span class="line">docker stack ps wordpress</span><br><span class="line">docker stack services wordpress</span><br><span class="line">docker stack rm wordpress</span><br></pre></td></tr></table></figure><h2 id="Docker-Secret-管理"><a href="#Docker-Secret-管理" class="headerlink" title="Docker Secret 管理"></a>Docker Secret 管理</h2><blockquote><p>对一些密码进行管理， 处理 docker-compose.yml 中存储密码不安全问题，借助内部分布式存储数据库控制，只作用于 Docker Swarm</p><p>关联： <a href="https://docs.docker.com/engine/reference/commandline/secret/">Doc-CLI</a></p></blockquote><p><img src="http://img.janhen.com/202012172238471566631044524.png" alt="1566631044524"></p><p>Secret 类型： username password， SSH key, TLS 认证，不想让人看到的数据</p><p>生产环境至少要两个 Manager，分布式存储的天然加密环境</p><p>Secret 的管理：</p><p>将 Secret 存储在 Manager 中的分布式存储中的 Raft Database</p><p>Secret 给某个 service 指派</p><p><strong>Service 基本使用</strong></p><p>Secret 的创建方式：文件方式、输入方式。</p><p>存放在容器中的 <code>/run/secrets/&lt;secret_file_name&gt;</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按文件方式进行创建</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件，保证安全性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 secret</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 借助管道按照输入方式创建 secret</span></span><br><span class="line">vim password</span><br><span class="line">docker secret create my-file-pw password</span><br><span class="line">rm -rf password</span><br><span class="line">docker secret ls</span><br><span class="line">echo &quot;mypassword&quot; | docker secret create my-input-pw</span><br><span class="line">docker secret rm my-input-pw</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 swarm service 创建过程中指定 secret 进行使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器查看指定目录，找到 manager 通过 Raft Database 保存的 secret</span></span><br><span class="line">docker service create -d --name client \</span><br><span class="line">  --secret my-file-pw busybox \</span><br><span class="line">  sh -c &quot;while true; do sleep 3600; done&quot;</span><br><span class="line">docker service ls </span><br><span class="line">docker service ps client</span><br><span class="line">docker ps</span><br><span class="line">docker exec -it &lt;client_container_id&gt; sh</span><br><span class="line">  cd /run/secrets/</span><br><span class="line">  ls</span><br><span class="line">  cat my-file-pw # 原文</span><br><span class="line"><span class="meta">#</span><span class="bash"> 实际使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建 service 的时候指定好 secret，并在环境变量中指定在容器中的位置</span></span><br><span class="line">docker service create -d --name db \</span><br><span class="line">  --secret my-file-pw \ </span><br><span class="line">  -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-file-pw mysql</span><br><span class="line">docker service ps db</span><br><span class="line">--</span><br><span class="line">docker exec -it &lt;db_container_id&gt; sh</span><br><span class="line">ls /run/secrets</span><br><span class="line">cat /run/secrets/my-file-pw</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><strong>在 Stack 中的使用</strong></p><p>在服务配置下增加 secrets，指定对应的 Secret</p><p>对应的密码参数使用指定的 secrets 在容器中的位置</p><p>可以连通创建 secret 一起使用，不建议</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 简化 --compose-file </span></span><br><span class="line"><span class="comment"># 查看服务是否全部启动完成</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stack</span> <span class="string">deploy</span> <span class="string">wordpress</span> <span class="string">\</span></span><br><span class="line">  <span class="string">-c=docker-compose.yml</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stack</span> <span class="string">services</span> <span class="string">wordpress</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Service-更新"><a href="#Docker-Service-更新" class="headerlink" title="Docker Service 更新"></a>Docker Service 更新</h2><blockquote><p>在运行过程中对 service 依赖的镜像进行升级，实现升级过程中不会中断原来的服务</p></blockquote><h3 id="单-Service-更新"><a href="#单-Service-更新" class="headerlink" title="单 Service 更新"></a>单 Service 更新</h3><p>进行 service 的更新，不会暂停运行的项目</p><p>@Q: 存在一段时间有 1.0和2.0并存的情况，如何处理??</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 overlay 网络，启动服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待服务启动完毕</span></span><br><span class="line">docker network create -d overlay net-demo</span><br><span class="line">docker network ls</span><br><span class="line">docker service create -d --name web \</span><br><span class="line">  --publish 8080:5000 \</span><br><span class="line">  --network net-demo</span><br><span class="line">  janhen/python-flask-demo:1.0.0</span><br><span class="line">docker service ps web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查服务运行情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写测试脚本方便验证</span></span><br><span class="line">docker service scale web=2</span><br><span class="line">docker service ps web</span><br><span class="line">curl 127.0.0.1:8080</span><br><span class="line">sh -c &quot;while true; do curl 127.0.0.1:8080&amp;&amp;sleep 1; done&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新镜像，一般通过 Dockerfile 进行构建，指定对应更新的版本，发布到私有 registry</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行环境拉取镜像，执行更新命令</span></span><br><span class="line">docker service update --image janehn/python-plask-demo:2.0.0 web</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新镜像并设置参数, 覆盖 docker-compose.yml</span></span><br><span class="line">docker service update --image westos.org/game2048 \</span><br><span class="line">  --update-parallelism 10 \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><h3 id="端口更新"><a href="#端口更新" class="headerlink" title="端口更新"></a>端口更新</h3><blockquote><p> 对 service 与宿主机的端口映射进行更改</p></blockquote><p>删除掉原来的端口映射，无法做到更新时业务不中断，通过 VIP + 端口实现原理导致的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service update --publish-rm 8080:500 \</span><br><span class="line">  --publish-add 8088:5000 web</span><br></pre></td></tr></table></figure><h3 id="Stack-更新"><a href="#Stack-更新" class="headerlink" title="Stack 更新"></a>Stack 更新</h3><blockquote><p>更改 Swarm Cluster 中多个容器中对于镜像、网络、部署配置的更新，关联 <service>.deploy.update_config 下的配置</p></blockquote><p>可更改 docker-compose.yml 中 deploy 下的 update_config 控制更新时的细节，允许几个 scale 进行更新，延迟信息。。。</p><p>第一次通过 deploy 进行启动进行了多 service 的部署</p><p>第二次通过 deploy 部署时，自动检测到 docker-compose.yml 的变化，进行更新    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy wordpress --compose-file docker-compose.yml </span><br></pre></td></tr></table></figure><h2 id="Docker-Swarm-监控"><a href="#Docker-Swarm-监控" class="headerlink" title="Docker Swarm 监控"></a>Docker Swarm 监控</h2><blockquote><p>实现对 Docker Swarm Cluster 中运行节点上容器的监控</p></blockquote><h3 id="CAdvisor-InfluxDB-Grafana"><a href="#CAdvisor-InfluxDB-Grafana" class="headerlink" title="CAdvisor+InfluxDB+Grafana"></a>CAdvisor+InfluxDB+Grafana</h3><blockquote><p>docker swarm集群的监控方案，开源免费</p><p>cAdvisor：数据收集模块，需要部署在集群中的每一个节点上，当然前提条件是节点接受task。</p><p>InfluxDB：数据存储模块</p><p>Grafana：数据展示模块</p></blockquote><p><strong>Docker Universal Control Plane(UCP)</strong></p><blockquote><p>docker原厂的可视化集群管理GUI，企业级的，只支持docker EE</p></blockquote><p><strong>portainer</strong></p><blockquote><p>在集群中部署portainer的service，只能被调度给manager角色的节点</p><p>关联： <a href="https://www.portainer.io/">Web</a></p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Daemon-配置"><a href="#Daemon-配置" class="headerlink" title="Daemon 配置"></a>Daemon 配置</h2><blockquote><p>对容器的 dockerd 守护线程进行配置</p><p>关联： <a href="https://docs.docker.com/config/daemon/">Configure the daemon</a></p></blockquote><p><strong>dameon.json</strong> </p><p>配置文件编写：</p><p>源镜像地址配置</p><p>私有源非 Https 配置</p><p>Debug 模式开启</p><p><code>/etc/docker/daemon.json</code></p><p>ip: 永久绑定到某个固定的 IP 地址</p><p>bridge： 将 Docker 默认桥接到创建的网桥上</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://reg-mirror.qiniu.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.17.11.29:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;172.17.11.29:5111&quot;</span>,</span><br><span class="line">    <span class="string">&quot;192.168.205.23:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;192.168.205.23:5111&quot;</span>,</span><br><span class="line">     <span class="string">&quot;172.17.10.150:80&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span>: <span class="string">&quot;bridge-my&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更改后使其生效</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service</span><br><span class="line">sudo systemctl status docker -l</span><br><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><p><strong>设置运行时目录，存储驱动</strong></p><p><strong>设置 Http/Https 代理</strong></p><p>加快拉取国外访问、处理国内制作镜像无法访问国外资源问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加配置</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"></span><br><span class="line">[Service]    </span><br><span class="line">Environment=&quot;HTTP_PROXY=https://172.17.10.18:5720/&quot; &quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置生效</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置</span></span><br><span class="line">rm -f /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure><p> <a href="https://docs.docker.com/engine/admin/systemd/#/http-proxy">Docker systemd http-proxy</a> </p><h2 id="监控与管理"><a href="#监控与管理" class="headerlink" title="监控与管理"></a>监控与管理</h2><blockquote><p>人工进行容器的管理、<strong>监控</strong>、资源调整、<strong>故障排除</strong>，包括日志查看、容器实时运行情况、资源重分配，在无法使用或没有监控方案情况下使用</p></blockquote><p><strong>dockerd 支持</strong></p><blockquote><p>在发生故障后，通过设置 Docker 守护线程的一些参数方便调试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启守护线程的 debug 模式，给出更多的信息提示</span></span><br><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.169.9.2:2376</span><br></pre></td></tr></table></figure><p><strong>容器的运行日志查看</strong></p><p>使用 Go 模板尽心格式化日志输出</p><p>可使用日志驱动程序插件，企业版支持统一格式查看远程的日志，默认双重日志</p><p><a href="https://docs.docker.com/config/formatting/">Format command and log output</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $&#123;CID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个镜像对应的全部容器</span></span><br><span class="line">docker container ls | grep &lt;image&gt; | awk &#x27;&#123;print $1&#125;</span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&#x27; &lt;CONTAINER&gt;</span><br><span class="line">docker logs -f &lt;container_id&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 Go 的模板语法进行格式化展示数据</span></span><br><span class="line">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>容器日志</strong></p><blockquote><p>在 daemon 中的日志配置，根据实际需要进行优化，可选择日志插件</p></blockquote><p>指定容器日志最大大小                20M</p><p>最大的文件个数                            5</p><p>压缩，                                           开</p><p><strong>容器的运行情况</strong></p><blockquote><p>通过 stats 实时查看容器的资源信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实时查看容器统计信息，CPU、内存、网络、磁盘</span></span><br><span class="line">docker stats 13b9203f9f0b d42877298134 44fb90cd2f2c</span><br><span class="line">docker container stats --format &quot;table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>容器的资源分配</strong></p><blockquote><p>容器使用多少宿主机的资源，可以通过 docker-compose.yml 中设置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过参数限定容器访问内存、CPU</span></span><br><span class="line">docker run --help | grep cpu </span><br><span class="line">docker run --help | grep memory</span><br></pre></td></tr></table></figure><p><strong>容器可用性</strong></p><p>容器支持重启，可以通过 <code>--restart</code> 指定重启策略，保证可用性</p><p><strong>容器网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有网络</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络映射</span></span><br><span class="line">docker port nostalgic_morse 5000</span><br></pre></td></tr></table></figure><p><strong>.dockerignore</strong> </p><p>针对非 SpringBoot 项目，如前端项目需要忽略一些文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p><strong>默认的重要文件：</strong></p><p>/var/run/docker.sock</p><p>/var/lib/docker/volumes/<volume_name OR long_uuid></p><h2 id="Docker-卸载"><a href="#Docker-卸载" class="headerlink" title="Docker 卸载"></a><strong>Docker 卸载</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止并删除容器</span></span><br><span class="line">docker rm -f `docker ps -aq`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除安装</span></span><br><span class="line">yum list installed|grep docker</span><br><span class="line"> yum -y remove docker-ce.x86_64</span><br><span class="line"> yum -y remove docker-ce-cli.x86_64</span><br><span class="line"> yum -y remove containerd.io.x86_64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有镜像、Volume删除</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除 docker-compose</span></span><br><span class="line"> rm -rf /var/lib/docker</span><br><span class="line"> rm -rf /hdapp</span><br><span class="line"> rm -rf /etc/docker</span><br><span class="line"> rm -f /usr/local/bin/docker-compose</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 测试卸载情况</span></span><br><span class="line"> yum list installed|grep docker</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除 docker0 网卡</span></span><br><span class="line"> yum install bridge-utils</span><br><span class="line"> ip link set dev docker0 down</span><br><span class="line"> brctl delbr docker0</span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><a href="https://jiajially.gitbooks.io/dockerguide/content/dockerIND.html">Docker-guide</a>: 中文的 GitBook</p><p><a href="https://github.com/docker-library/docs">官方镜像示例</a>： Docker Hub 中一些镜像的开源示例</p><p><a href="https://labs.play-with-docker.com/p/blga8164315g00e59gs0">play-with-docker</a> ： 方便环境搭建， 保存 docker 4h，在网站上创建多个网络，进行互通访问</p><p><a href="https://zhuanlan.zhihu.com/p/53260098">10分钟看懂Docker和K8S</a>： 快速入门</p><p><a href="https://zhuyasen.com/post/docker_note.html">docker学习笔记</a>： 他人博客笔记</p><p><a href="https://yeasy.gitbooks.io/docker_practice/">Docker – 从入门到实践</a></p><p><a href="https://yeasy.gitbooks.io/docker_practice/appendix/debug.html">如何调试 Docker</a>： 总结调试方法</p><p><a href="https://www.jianshu.com/p/21d66ca6115e">关于对docker run –link的理解</a>： Docker 桥接网络理解</p><p><a href="https://yeasy.gitbooks.io/docker_practice/advanced_network/e">工具和示例</a>： Docker 相关工具</p><p><a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html#dockerfile-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">Dockerfile 最佳实践</a>： 编写 Dockerfile 的一些建议 </p><p><a href="https://blog.51cto.com/12227558/2096290">CentOS7.4—构建LVS+Keepalived高可用群集</a>： LVS </p><p><a href="https://www.centos.bz/2018/02/docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/">docker镜像操作</a>： 容器制作、本地导入、镜像导出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-基础&quot;&gt;&lt;a href=&quot;#Docker-基础&quot; class=&quot;headerlink&quot; title=&quot;Docker 基础&quot;&gt;&lt;/a&gt;Docker 基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;类似精简的 Linux 环境，含 root 权限、进程空间</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Arthas</title>
    <link href="http://example.com/2020/12/17/Arthas/"/>
    <id>http://example.com/2020/12/17/Arthas/</id>
    <published>2020-12-17T13:10:57.000Z</published>
    <updated>2021-04-09T09:34:39.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p><code>Arthas</code> 是Alibaba开源的Java诊断工具。</p><p><a href="https://github.com/alibaba/arthas">Github</a></p></blockquote><p>当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ol><h2 id="JVM-信息"><a href="#JVM-信息" class="headerlink" title="JVM 信息"></a>JVM 信息</h2><p>JVM 相关命令的</p><p>1.dashboard -&gt; </p><ol start="2"><li>thread -&gt; </li></ol><p>3.jvm -&gt; </p><p>4.sysprop -&gt; 查看和修改JVM的系统属性  </p><p>5.getstatic -&gt; 查看类的静态属性  </p><h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><blockquote><p>当前系统的实时数据面板  </p><p>线程、内存、运行信息 </p></blockquote><img src="http://img.janhen.com/image-20201217211858202.png" alt="image-20201217211858202" style="zoom: 50%;" /><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><blockquote><p>当前JVM 线程堆栈信息  </p></blockquote><ul><li>-b:  找出持有锁的</li><li>-n:  根据 cpu 使用排序</li><li>-i:  指定时间间隔</li><li>–state <value>: 过滤线程状态</li></ul><p>使用最繁忙的 5个线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -i 2000 -n 5</span><br></pre></td></tr></table></figure><p>查看指定线程堆栈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &lt;id&gt;</span><br></pre></td></tr></table></figure><p>查看特定状态的线程: RUNNABLE, TIMED_WAITING, WAITING, BLOCKED..</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread -i 2000 --state TIMED_WAITING</span><br><span class="line">thread -i 2000 --state RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><blockquote><p>查看当前JVM 的信息  </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> RUNTIME                                                                                                                            </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME                          8@e57d77f3ad01                                                                               </span><br><span class="line"> JVM-START-TIME                        2020-12-10 19:38:01                                                                          </span><br><span class="line"> MANAGEMENT-SPEC-VERSION               1.2                                                                                          </span><br><span class="line"> SPEC-NAME                             Java Virtual Machine Specification                                                           </span><br><span class="line"> SPEC-VENDOR                           Oracle Corporation                                                                           </span><br><span class="line"> SPEC-VERSION                          1.8                                                                                          </span><br><span class="line"> VM-NAME                               Java HotSpot(TM) 64-Bit Server VM                                                            </span><br><span class="line"> VM-VENDOR                             Oracle Corporation                                                                           </span><br><span class="line"> VM-VERSION                            25.11-b03                                                                                    </span><br><span class="line"> INPUT-ARGUMENTS                       -Xmx4096M                                                                                    </span><br><span class="line">                                       -Xms4096M                                                                                    </span><br><span class="line">                                       -Xmn1536M                                                                                                                                                     </span><br><span class="line">       ...                                                                   </span><br><span class="line">                                                                                                                                    </span><br><span class="line"> CLASS-PATH                            ...                                                             </span><br><span class="line"> BOOT-CLASS-PATH                       ...                               </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING                                                                                                                      </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT                    34980                                                                                        </span><br><span class="line"> TOTAL-LOADED-CLASS-COUNT              46897                                                                                        </span><br><span class="line"> UNLOADED-CLASS-COUNT                  11917                                                                                        </span><br><span class="line"> IS-VERBOSE                            false                                                                                        </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION                                                                                                                        </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> NAME                                  HotSpot 64-Bit Tiered Compilers                                                              </span><br><span class="line"> TOTAL-COMPILE-TIME                    549939(ms)                                                                                   </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS                                                                                                                 </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> ParNew                                5889/191768(ms)                                                                              </span><br><span class="line"> [count/time]                                                                                                                       </span><br><span class="line"> ConcurrentMarkSweep                   18/12942(ms)                                                                                 </span><br><span class="line"> [count/time]                                                                                                                       </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager                      Code Cache                                                                                   </span><br><span class="line">                                                                                                                                    </span><br><span class="line">...                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY                                                                                                                             </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE                     4133945344(3.85 GiB)/4294967296(4.00 GiB)/4133945344(3.85 GiB)/289171584(275.78 MiB)         </span><br><span class="line"> [committed/init/max/used]                                                                                                          </span><br><span class="line"> NO-HEAP-MEMORY-USAGE                  398196736(379.75 MiB)/2555904(2.44 MiB)/1862270976(1.73 GiB)/340835576(325.05 MiB)           </span><br><span class="line"> [committed/init/max/used]                                                                                                          </span><br><span class="line"> PENDING-FINALIZE-COUNT                0                                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM                                                                                                                   </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OS                                    Linux                                                                                        </span><br><span class="line"> ARCH                                  amd64                                                                                        </span><br><span class="line"> PROCESSORS-COUNT                      6                                                                                            </span><br><span class="line"> LOAD-AVERAGE                          0.35                                                                                         </span><br><span class="line"> VERSION                               3.10.0-957.el7.x86_64                                                                        </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> THREAD                                                                                                                             </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                                 99                                                                                           </span><br><span class="line"> DAEMON-COUNT                          75                                                                                           </span><br><span class="line"> PEAK-COUNT                            99                                                                                           </span><br><span class="line"> STARTED-COUNT                         70889                                                                                        </span><br><span class="line"> DEADLOCK-COUNT                        0                                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> FILE-DESCRIPTOR                                                                                                                    </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MAX-FILE-DESCRIPTOR-COUNT             1048576                                                                                      </span><br><span class="line"> OPEN-FILE-DESCRIPTOR-COUNT            298                                                                                          </span><br><span class="line">Affect(row-cnt:0) cost in 19 ms.</span><br></pre></td></tr></table></figure><h3 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h3><blockquote><p>查看当前JVM的系统属性(<code>System Property</code>)</p></blockquote><p>查看日志匹配，方便进行日志的收集<br>查看日志文件位置，方便日志的查看<br>查看执行的参数，SpringBoot 之后拼接的参数，方便定位自定义参数的实际指定情况<br>查看 JVM 运行的时区，方便处理日志的时间问题<br>查看运行时的版本，方便查看已知的 JDK bug 修复情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysprop FILE_LOG_PATTERN</span><br><span class="line">sysprop CONSOLE_LOG_PATTER</span><br><span class="line">sysprop LOG_FILE</span><br><span class="line">sysprop sun.java.command</span><br><span class="line">sysprop user.timezone</span><br><span class="line">sysprop java.runtime.version</span><br></pre></td></tr></table></figure><h3 id="getstatic"><a href="#getstatic" class="headerlink" title="getstatic"></a>getstatic</h3><blockquote><p> 查看类的静态属性 , 推荐直接使用 <code>ognl</code> 命令  </p></blockquote><ul><li>-c: 类加载器的 hash id</li><li>-E: 开启正则表达式匹配，默认通配符匹配  <ul><li><code>&lt;class-pattern&gt; </code>                 Class name pattern, use either ‘.’ or ‘/‘ as separator            </li><li><code>&lt;field-pattern&gt;</code>                  Field name pattern                                                </li><li><code>&lt;express&gt;</code>                        the content you want to watch, written by ognl </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic com.janhen.SapConstants JOB_RUNNING_INTERVAL</span><br><span class="line">field: JOB_RUNNING_INTERVAL</span><br><span class="line">@Integer[2]</span><br><span class="line">Affect(row-cnt:1) cost in 331 ms.</span><br><span class="line"></span><br><span class="line"><span class="meta">[arthas@8]$</span><span class="bash"> getstatic com.janhen.SapConstants ALCNTC_INTERFACE_NO</span></span><br><span class="line">field: ALCNTC_INTERFACE_NO</span><br><span class="line">@String[MD038]</span><br><span class="line">Affect(row-cnt:1) cost in 33 ms.</span><br></pre></td></tr></table></figure><p>查看私有的静态变量  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic org.springframework.amqp.rabbit.connection.CachingConnectionFactory DEFAULT_CHANNEL_CACHE_SIZE</span><br></pre></td></tr></table></figure><p>查看集合信息  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic org.springframework.amqp.rabbit.connection.CachingConnectionFactory txStarts</span><br></pre></td></tr></table></figure><p>指定的 classloader 加载的类查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getstatic -c 73ad2d6 io.netty.channel.nio.NioEventLoop logger &#x27;getClass().getName()&#x27;</span><br><span class="line">field: logger</span><br></pre></td></tr></table></figure><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><blockquote><p>查看JVM已加载的类信息</p><p>各个字段的类型，以及访问标识符  </p><p>父类信息、接口信息、类加载器信息、加载的来源文件</p></blockquote><p>search-class  </p><ul><li><p>-d, –details:  Display the details of class        </p></li><li><p>-f, –field: Display all the member variables<br> <class-pattern>                  Class name pattern, use either ‘.’ or ‘/‘ as separato  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -df org.springframework.amqp.rabbit.connection.CachingConnectionFactory*</span><br></pre></td></tr></table></figure></li></ul><h3 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h3><blockquote><p>查看已加载类的方法信息</p><p>声明的类、 构造器、注解、参数、异常、类加载器</p></blockquote><ul><li><p> -c, –classloader <value>        The hash code of the special class’s classLoader                    </p></li><li><p>-d, –details                    Display the details of method<br><code>&lt;class-pattern&gt;</code>                  Class name pattern, use either ‘.’ or ‘/‘ as separator<br><code>&lt;method-pattern&gt;</code>                 Method name pattern   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d org.springframework.amqp.rabbit.connection.CachingConnectionFactory</span><br></pre></td></tr></table></figure><p>查看具体的方法信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d org.springframework.amqp.rabbit.connection.CachingConnectionFactory toString</span><br></pre></td></tr></table></figure></li></ul><h3 id="classloader"><a href="#classloader" class="headerlink" title="classloader"></a>classloader</h3><blockquote><p>查看classloader的继承树，urls，类加载信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> classloader</span><br><span class="line"> name                                                        numberOfInstances  loadedCountTotal    </span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader      1                  15617               </span><br><span class="line"> java.net.URLClassLoader                                     1060               5560                </span><br><span class="line"> BootstrapClassLoader                                        1                  4535                </span><br><span class="line"> java.net.FactoryURLClassLoader                              2                  1666                </span><br><span class="line"> sun.reflect.DelegatingClassLoader                           1406               1406                </span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader                   1                  1116                </span><br><span class="line"> sun.misc.Launcher$AppClassLoader                            1                  47                  </span><br><span class="line"> com.alibaba.fastjson.util.ASMClassLoader                    1                  13                  </span><br><span class="line"> sun.misc.Launcher$ExtClassLoader                            1                  10                  </span><br><span class="line"> org.apache.cxf.common.util.ASMHelper$TypeHelperClassLoader  1                  6                   </span><br><span class="line">Affect(row-cnt:10) cost in 330 ms.</span><br></pre></td></tr></table></figure><h3 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h3><blockquote><p>载入外部 .class，直接修改线上的代码，不能恢复  </p></blockquote><ul><li>-c, –classloader <value>                       classLoader hashcode<br><classfilePaths>                                .class file paths  </li></ul><h3 id="ognl"><a href="#ognl" class="headerlink" title="*ognl"></a>*ognl</h3><blockquote><p>执行ognl表达式， ognl命令实际上包含了getstatic的功能</p></blockquote><p><strong>查看Spring的配置</strong></p><ul><li>-c, –classLoader <value>                     The hash code of the special class’s classLoader, default classLoader is SystemClassLoader. </li></ul><p>查看 Spring 中运行时指定属性的值，先找到持有 ApplicationContext 的类对应的类加载器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc -df com.janhen.SpringContextUtil | grep classLoaderHash</span><br><span class="line">ognl -c b1bc7ed &#x27;#spCtx=@com.janhen.SpringContextUtil@context,#spCtx.getEnvironment().getProperty(&quot;spring.redis.sentinel.nodes&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><strong>设置静态属性值</strong></p><p>一般由配置中心修改，防止 setstatic 不知道什么时候因为什么修改的<br>应该无法更改 final 的静态变量  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;#field=@demo.MathGame@class.getDeclaredField(&quot;random&quot;), #field.setAccessible(true), #field.set(null,null)&#x27;</span><br></pre></td></tr></table></figure><p>替换方式实现：  可以写一个新的类，里面设置 static field的值。然后用 classloader 命令把这个新的类 load到JVM里再执行。   </p><p>上传class到服务器上 redefine </p><p><a href="https://github.com/WangJi92/arthas-idea-plugin/issues/1">https://github.com/WangJi92/arthas-idea-plugin/issues/1</a>  </p><h3 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h3><blockquote><p>记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p></blockquote><p><code>-n &lt;count&gt;</code>: 指定次数, 通过 -n 参数指定需要记录的次数，当达到记录次数时 Arthas 会主动中断tt命令的记录过程，避免人工操作无法停止的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.amqp.rabbit.connection.CachingConnectionFactory toString</span><br></pre></td></tr></table></figure><h2 id="监控与执行"><a href="#监控与执行" class="headerlink" title="监控与执行"></a>监控与执行</h2><p>获取运行时的方法信息、返回信息、执行过程的耗时<br>通过字节码增强技术实现，使用完成之后需要执行shutdown 或者 将增强过的类执行reset 命令。  </p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p> -c, –cycle <value>                             The monitor interval (in seconds), 60 seconds by default<br>  <class-pattern>                                 Path and classname of Pattern Matching<br> <method-pattern>                                Method of Pattern Matching  </p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><blockquote><p>查看方法参数</p></blockquote><ul><li><p>-n, –limits <value>                            Threshold of execution times     </p></li><li><p>-b, –before                                    Watch before invocation  </p></li><li><p>-x, –expand <value>                            Expand level of object (1 by default)  </p></li></ul><p>查看入参对象(Object)以及返回对象(Set)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch com.janhen.ConsumingRtnProcessor getBinAlreadyExistContainerBarcodes &quot;&#123;params, returnObj&#125;&quot; -b -x 2</span><br><span class="line">watch com.janhen.ConsumingRtnProcessor verifyContainer &quot;&#123;params, returnObj&#125;&quot; -b</span><br><span class="line">watch -E .*ConsumingRtnProcessor verify|verifyContainer &quot;&#123;params, returnObj&#125;&quot; -b -x 3</span><br><span class="line">watch -E .*ConsumingRtnProcessor verify|verifyBin|verifyContainer &quot;&#123;params,returnObj&#125;&quot; -b -x 3</span><br><span class="line">watch -E .*ReceiveBillDao update &quot;&#123;params,returnObj&#125;&quot; -b -x 3</span><br><span class="line">watch com.janhen.StockServiceImpl query  &quot;&#123;params,target&#125;&quot; -x 3  </span><br></pre></td></tr></table></figure><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><blockquote><p>跟踪方法耗时</p></blockquote><p>跟踪方法的耗时情况，包含各个阶段的  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace com.janhen.OrderBillServiceImpl getByBillNumber|query</span><br></pre></td></tr></table></figure><p>匹配特定类的所有方法  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -E .*OrderServiceImpl .*</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -E com.janhen.OrderServiceImpl query</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Configure logging drivers<br><a href="https://docs.docker.com/config/containers/logging/configure/">https://docs.docker.com/config/containers/logging/configure/</a>  </p><p>Java线上诊断神器Arthas-2<br><a href="https://kamzhuyuqing.github.io/2018/12/20/Java%E7%BA%BF%E4%B8%8A%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8Arthas-2/">https://kamzhuyuqing.github.io/2018/12/20/Java%E7%BA%BF%E4%B8%8A%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8Arthas-2/</a>  </p><p>技术征文 | 那些年，我用 Arthas 排查过的问题<br><a href="https://mp.weixin.qq.com/s/gJ4ZVvFBuiXbirjTxjwGeQ">https://mp.weixin.qq.com/s/gJ4ZVvFBuiXbirjTxjwGeQ</a>  </p><p>是否可以考虑支持setstatic<br><a href="https://github.com/alibaba/arthas/issues/641">https://github.com/alibaba/arthas/issues/641</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Arthas&lt;/code&gt; 是Alibaba开源的Java诊断工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Percona-Toolkit-数据库工具</title>
    <link href="http://example.com/2020/12/17/Percona-Toolkit/"/>
    <id>http://example.com/2020/12/17/Percona-Toolkit/</id>
    <published>2020-12-17T11:20:54.000Z</published>
    <updated>2021-04-09T09:07:06.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>perl 语言编写, 不同的 linux 发行版不同的安装</p></blockquote><p><strong>DSN 语法</strong></p><ul><li>h: host</li><li>P: 端口</li><li>u: 用户</li><li>p: 密码</li><li>S: mysql_socket  </li><li>D: 数据库</li><li>A: charset  </li><li>t: table</li><li>F:   mysql_read_default_file  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h&#x3D;172.17.10.233,P&#x3D;3306,u&#x3D;root,p&#x3D;root,D&#x3D;testdb3,t&#x3D;testtable1</span><br></pre></td></tr></table></figure><p><strong>分类</strong></p><p>这些工具主要包括开发、性能、配置、监控、复制、系统、实用六大类</p><p align="center">PT 工具分类</p><table><thead><tr><th>工具类别</th><th>工具命令</th><th>工具作用</th><th>备注</th></tr></thead><tbody><tr><td>开发类</td><td>pt-duplicate-key-checker</td><td>列出并删除重复的索引和外键</td><td>优化使用，实用</td></tr><tr><td></td><td>pt-online-schema-change</td><td>在线修改表结构</td><td></td></tr><tr><td></td><td>pt-query-advisor</td><td>分析查询语句，并给出建议，有bug</td><td>已废弃</td></tr><tr><td></td><td>pt-show-grants</td><td>规范化和打印权限</td><td>分析使用</td></tr><tr><td></td><td>pt-upgrade</td><td>在多个服务器上执行查询，并比较不同</td><td></td></tr><tr><td>性能类</td><td>pt-index-usage</td><td>分析日志中索引使用情况，并出报告</td><td>索引查看，实用</td></tr><tr><td></td><td>pt-pmp</td><td>为查询结果跟踪，并汇总跟踪结果</td><td></td></tr><tr><td></td><td>pt-visual-explain</td><td>格式化执行计划</td><td></td></tr><tr><td></td><td>pt-table-usage</td><td>分析日志中查询并分析表使用情况</td><td>pt 2.2新增命令</td></tr><tr><td>配置类</td><td>pt-config-diff</td><td>比较配置文件和参数</td><td></td></tr><tr><td></td><td><strong>pt-mysql-summary</strong></td><td>对mysql配置和status进行汇总</td><td>整体信息，实用</td></tr><tr><td></td><td>pt-variable-advisor</td><td>分析参数，并提出建议</td><td></td></tr><tr><td>监控类</td><td>pt-deadlock-logger</td><td>提取和记录mysql死锁信息</td><td>死锁信息，实用</td></tr><tr><td></td><td>pt-fk-error-logger</td><td>提取和记录外键信息</td><td>pt-deadlock-logger</td></tr><tr><td></td><td>pt-mext</td><td>并行查看status样本信息</td><td></td></tr><tr><td></td><td><strong>pt-query-digest</strong></td><td>分析查询日志，并产生报告</td><td>常用命令</td></tr><tr><td></td><td>pt-trend</td><td>按照时间段读取slow日志信息</td><td>已废弃</td></tr><tr><td>复制类</td><td>pt-heartbeat</td><td>监控mysql复制延迟</td><td></td></tr><tr><td></td><td>pt-slave-delay</td><td>设定从落后主的时间</td><td></td></tr><tr><td></td><td>pt-slave-find</td><td>查找和打印所有mysql复制层级关系</td><td></td></tr><tr><td></td><td>pt-slave-restart</td><td>监控salve错误，并尝试重启salve</td><td></td></tr><tr><td></td><td><strong>pt-table-checksum</strong></td><td>校验主从复制一致性</td><td>实用</td></tr><tr><td></td><td><strong>pt-table-sync</strong></td><td>高效同步表数据</td><td>实用</td></tr><tr><td>系统类</td><td>pt-diskstats</td><td>查看系统磁盘状态</td><td></td></tr><tr><td></td><td>pt-fifo-split</td><td>模拟切割文件并输出</td><td></td></tr><tr><td></td><td>pt-summary</td><td>收集和显示系统概况</td><td></td></tr><tr><td></td><td>pt-stalk</td><td>出现问题时，收集诊断数据</td><td></td></tr><tr><td></td><td>pt-sift</td><td>浏览由pt-stalk创建的文件</td><td>pt 2.2新增命令</td></tr><tr><td></td><td>pt-ioprofile</td><td>查询进程IO并打印一个IO活动表</td><td>pt 2.2新增命令</td></tr><tr><td>实用类</td><td>pt-archiver</td><td>将表数据归档到另一个表或文件中</td><td></td></tr><tr><td></td><td>pt-find</td><td>查找表并执行命令</td><td></td></tr><tr><td></td><td>pt-kill</td><td>Kill掉符合条件的sql</td><td>常用命令</td></tr><tr><td></td><td>pt-align</td><td>对齐其他工具的输出</td><td>pt 2.2新增命令</td></tr><tr><td></td><td>pt-fingerprint</td><td>将查询转成密文</td><td>pt 2.2新增命令</td></tr></tbody></table><h1 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h1><h2 id="pt-summary"><a href="#pt-summary" class="headerlink" title="pt-summary"></a>pt-summary</h2><blockquote><p>可查看挂载情况、网络情况、进程情况  </p></blockquote><ul><li>–sleep:  通过 vmstat 收集的 sleep 时间, 默认 5  </li><li>–summarize-mounts:  挂载的文件系统、磁盘使用, 默认 TRUE  </li><li>–summarize-network:  网络收集、配置, 默认 TRUE   </li><li>–summarize-processes:  top process vmstat 输出, 默认 TRUE   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-summary</span><br></pre></td></tr></table></figure><h2 id="pt-mysql-summary"><a href="#pt-mysql-summary" class="headerlink" title="pt-mysql-summary"></a>pt-mysql-summary</h2><blockquote><p>精细地对 mysql 的配置和 sataus 信息进行汇总, 优先执行<br>各种类型字段在对应数据库中的数量<br>btree 在对应 db 中的数量<br>连接的 host </p><p>当前连接情况, Process list<br>主从连接情况  </p></blockquote><ul><li>–all-databases: 默认 false  </li><li>–databases:  查看指定的数据库  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有数据库</span></span><br><span class="line">pt-mysql-summary \</span><br><span class="line">  --host=127.0.0.1 --port=3306 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --all-databases</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指令数据库</span></span><br><span class="line">pt-mysql-summary \</span><br><span class="line">  --host=127.0.0.1 --port=3306 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --databases testdb</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">状态统计:</span><br><span class="line">Aborted_clients:  取消的连接</span><br><span class="line">Com_change_db:  更改 db 命令?</span><br><span class="line">Com_commit:  事务提交的个数</span><br><span class="line">Com_insert:  插入语句</span><br><span class="line">Com_select:  查询语句</span><br><span class="line">Com_show_engine_status:  查看存储引擎情况</span><br><span class="line">Com_show_table_status: 查看表状态</span><br><span class="line">Com_show_variables:  查看变量</span><br><span class="line">Connections:  连接数</span><br><span class="line">Created_tmp_disk_tables: 创建的临时表</span><br><span class="line">Handler_commit</span><br><span class="line">Handler_rollback</span><br><span class="line">Handler_update</span><br><span class="line">Handler_write</span><br><span class="line">Innodb_buffer_pool_bytes_data:  缓存池数据</span><br><span class="line">Innodb_row_lock_time:  行锁的时间</span><br><span class="line">Innodb_row_lock_waits:  锁等待</span><br><span class="line">Innodb_rows_deleted</span><br><span class="line">Innodb_rows_inserted</span><br><span class="line">Select_full_join:   全表连接</span><br><span class="line">Select_full_range_join:  范围连接</span><br><span class="line">Sort_rows: 排序的行</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pt-mysql-summary \</span><br><span class="line">  --host=127.0.0.1 --port=3306 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --databases testdb1,testdb2</span><br><span class="line"><span class="meta">#</span><span class="bash"> Note Processlist, Schema, InnoDB, Binary Logging</span></span><br><span class="line"> Server_id: 315</span><br><span class="line"> Master_id: 391</span><br><span class="line"> Slave_UUID: 7f80892a-650a-11ea-bb0f-0242ac110002</span><br><span class="line">                  Version | 5.6.47-log MySQL Community Server (GPL)</span><br><span class="line">                  Started | 2020-07-01 19:35 (up 43+14:06:36)</span><br><span class="line">                Databases | 9</span><br><span class="line">                  Datadir | /var/lib/mysql/</span><br><span class="line">                Processes | 60 connected, 4 running</span><br><span class="line">              Replication | Is not a slave, has 1 slaves connected</span><br><span class="line"><span class="meta">#</span><span class="bash"> Processlist <span class="comment">################################################</span></span></span><br><span class="line"></span><br><span class="line">  Command                        COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  Binlog Dump                           1       1      8000      8000</span><br><span class="line">  Daemon                                1       1     20000     20000</span><br><span class="line">  Query                                 1       1         0         0</span><br><span class="line">  Sleep                                60       0     22500      3500</span><br><span class="line"></span><br><span class="line">  User                           COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  event_scheduler                       1       1     20000     20000</span><br><span class="line">  user1                                45       1         0         0</span><br><span class="line">  user2                                 1       1      8000      8000</span><br><span class="line">  user3                                15       0         0         0</span><br><span class="line"></span><br><span class="line">  Host                           COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  127.0.0.1                             1       1         0         0</span><br><span class="line">  172.17.0.1                            2       0         0         0</span><br><span class="line">  192.168.199.116                       1       1      8000      8000</span><br><span class="line">...</span><br><span class="line">  localhost                             1       1     20000     20000</span><br><span class="line"></span><br><span class="line">  db                             COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">  NULL                                  3       3     30000     20000</span><br><span class="line">  testdb1                           6       0         0         0</span><br><span class="line">  testdb2                            10       0         0         0</span><br><span class="line">  testdb3                         15       0         0         0</span><br><span class="line">  testdb4                          30       0         0         0</span><br><span class="line">  testdb5                            1       0         0         0</span><br><span class="line"></span><br><span class="line">  State                          COUNT(*) Working SUM(Time) MAX(Time)</span><br><span class="line">  ------------------------------ -------- ------- --------- ---------</span><br><span class="line">                                       60       0         0         0</span><br><span class="line">  Master has sent all binlog to         1       1      8000      8000</span><br><span class="line">  Waiting for next activation           1       1     20000     20000</span><br><span class="line">  init                                  1       1         0         0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Schema <span class="comment">#####################################################</span></span></span><br><span class="line"></span><br><span class="line">  Database     Tables Views SPs Trigs Funcs   FKs Partn</span><br><span class="line">  testdb1      35                           4</span><br><span class="line">  testdb3    223     1                     4</span><br><span class="line"></span><br><span class="line">  Database     InnoDB</span><br><span class="line">  testdb1      35</span><br><span class="line">  testdb3    223</span><br><span class="line"></span><br><span class="line">  Database     BTREE</span><br><span class="line">  testdb1    112</span><br><span class="line">  testdb3   653</span><br><span class="line"></span><br><span class="line">                 v   d   b   s   t   i   c   d   d   t</span><br><span class="line">                 a   a   i   m   e   n   h   e   a   i</span><br><span class="line">                 r   t   g   a   x   t   a   c   t   n</span><br><span class="line">                 c   e   i   l   t       r   i   e   y</span><br><span class="line">                 h   t   n   l               m       i</span><br><span class="line">                 a   i   t   i               a       n</span><br><span class="line">                 r   m       n               l       t</span><br><span class="line">                     e       t</span><br><span class="line">  Database     === === === === === === === === === ===</span><br><span class="line">  testdb1  209  34  13   3   4  17   5</span><br><span class="line">  testdb3 3482 283  88   1   2 132  37 433  73   4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> InnoDB <span class="comment">#####################################################</span></span></span><br><span class="line">                  Version | 5.6.47</span><br><span class="line">         Buffer Pool Size | 18.0G</span><br><span class="line">         Buffer Pool Fill | 100%</span><br><span class="line">        Buffer Pool Dirty | 0%</span><br><span class="line">           File Per Table | ON</span><br><span class="line">                Page Size | 16k</span><br><span class="line">            Log File Size | 2 * 500.0M = 1000.0M</span><br><span class="line">          Log Buffer Size | 8M</span><br><span class="line">             Flush Method |</span><br><span class="line">      Flush Log At Commit | 2</span><br><span class="line">               XA Support | ON</span><br><span class="line">                Checksums | ON</span><br><span class="line">              Doublewrite | ON</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Binary Logging <span class="comment">#############################################</span></span></span><br><span class="line">                  Binlogs | 15</span><br><span class="line">               Zero-Sized | 0</span><br><span class="line">               Total Size | 14.2G</span><br><span class="line">            binlog_format | ROW</span><br><span class="line">         expire_logs_days | 7</span><br><span class="line">              sync_binlog | 0</span><br><span class="line">                server_id | 391</span><br><span class="line">             binlog_do_db |</span><br><span class="line">         binlog_ignore_db |</span><br></pre></td></tr></table></figure><h2 id="pt-deadlock-logger"><a href="#pt-deadlock-logger" class="headerlink" title="pt-deadlock-logger"></a>pt-deadlock-logger</h2><blockquote><p>死锁检测, 收集和保存 mysql 上最近的死锁信息，可以直接打印死锁信息和存储死锁信息到数据库中，死锁信息包括发生死锁的服务器、最近发生死锁的时间、死锁线程 id、死锁的事务 id、发生死锁时事务执行了多长时间等信息。</p></blockquote><ul><li>–columns=A: 控制输出的列  </li><li>–daemonize:  后台运行  </li><li>–log=s:    后台运行将输出到处到指定文件  </li><li>–tab:   使用 tab 进行分割</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-deadlock-logger \</span><br><span class="line">  --h 127.0.0.1 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  --tab</span><br></pre></td></tr></table></figure><h2 id="pt-duplicate-key-checker"><a href="#pt-duplicate-key-checker" class="headerlink" title="pt-duplicate-key-checker"></a>pt-duplicate-key-checker</h2><blockquote><p>找出重复的索引和外键，并生成删除重复索引的 SQL 语句   </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-duplicate-key-checker \</span><br><span class="line">  -h 127.0.0.1 \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  -d testdb3,testdb1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># ########################################################################</span><br><span class="line"># testdb3.testtable1                                             </span><br><span class="line"># ########################################################################</span><br><span class="line"></span><br><span class="line"># idx_testtable1_06 is a left-prefix of id_testtable1_unique_01</span><br><span class="line"># Key definitions:</span><br><span class="line">#   KEY &#96;idx_testtable1_06&#96; (&#96;dcUuid&#96;)</span><br><span class="line">#   UNIQUE KEY &#96;id_testtable1_unique_01&#96; (&#96;dcUuid&#96;,&#96;billNumber&#96;),</span><br><span class="line"># Column types:</span><br><span class="line">#         &#96;dcuuid&#96; varchar(38) not null comment &#39;配送中心uuid&#39;</span><br><span class="line">#         &#96;billnumber&#96; varchar(30) not null comment &#39;单号&#39;</span><br><span class="line"># To remove this duplicate index, execute:</span><br><span class="line">ALTER TABLE &#96;testdb3&#96;.&#96;testtable1&#96; DROP INDEX &#96;idx_testtable1_06&#96;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># ########################################################################</span><br><span class="line"># Summary of indexes                                                      </span><br><span class="line"># ########################################################################</span><br><span class="line"></span><br><span class="line"># Size Duplicate Indexes   30832348</span><br><span class="line"># Total Duplicate Indexes  23</span><br><span class="line"># Total Indexes            707</span><br></pre></td></tr></table></figure><h2 id="pt-show-grants"><a href="#pt-show-grants" class="headerlink" title="pt-show-grants"></a>pt-show-grants</h2><blockquote><p>查看授权情况  </p></blockquote><ul><li>–flush: 刷新权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show all grants</span></span><br><span class="line">pt-show-grants \</span><br><span class="line"> -h 127.0.0.1 -P3306 \</span><br><span class="line"> -u root -p $MYSQL_ROOT_PASSWORD</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show database grants</span></span><br><span class="line">pt-show-grants \</span><br><span class="line">  -u root -p root \</span><br><span class="line">  -D testdb4</span><br></pre></td></tr></table></figure><p><strong>pt-variable-advisor</strong>  </p><blockquote><p>分析 mysql 的参数变量，并对可能存在的问题提出建议</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pt-variable-advisor --h 172.17.10.233 --u root --p root </span><br><span class="line">pt-variable-advisor --h localhost --u root --p root \</span><br><span class="line">  --source-of-variables /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">  </span><br><span class="line">pt-variable-advisor \</span><br><span class="line">  h=172.17.10.233,P=3306,u=root,p=root, \</span><br><span class="line">  S=/var/run/mysqld/mysqld.sock \</span><br><span class="line">  --source-of-variables=mysql</span><br></pre></td></tr></table></figure><h2 id="pt-table-checksum"><a href="#pt-table-checksum" class="headerlink" title="pt-table-checksum"></a>pt-table-checksum</h2><blockquote><p>校验 MySQL 主从复制的完整性，存在锁表问题。</p></blockquote><p>参数：  </p><ul><li><p>–databases=：指定需要被检查的数据库，多个则用逗号隔开  </p></li><li><p>–tables=：指定需要被检查的表，多个用逗号隔开  </p></li><li><p>-h=127.0.0.1 ：Master的地址  </p></li><li><p>-u=xiaoml：用户名  </p></li><li><p>-p=123456：密码  </p></li><li><p>-P=3306：端口  </p></li><li><p>–tables-regex=s：  表正则匹配  </p></li><li><p>–ignore-tables-regex=s： 忽略的表</p></li><li><p>–replicate=s:  将校验结果保存到表中 <code>percona.checksums</code>  </p></li><li><p>–replicate-database=s:  指定数据库复制校验  </p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum -u root -p root \</span><br><span class="line">  --databases testdb5 \</span><br><span class="line">  --tables=QRTZ_TRIGGERS</span><br></pre></td></tr></table></figure><p>使用依赖： 需要一个既能登录主库，也能登录从库，而且还能同步数据库的账号  </p><p>生产环境使用 pt-table-checksum 检查MySQL数据一致性<br><a href="https://segmentfault.com/a/1190000004309169">https://segmentfault.com/a/1190000004309169</a>  </p><p><strong>pt-diskstats</strong>  </p><blockquote><p>为 GUN/LINUX 打印磁盘 io 统计信息,可以分析从远程机器收集的数据    </p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="pt-index-usage"><a href="#pt-index-usage" class="headerlink" title="pt-index-usage"></a>pt-index-usage</h2><blockquote><p>从 log 文件中读取查询语句，并用 explain 分析他们是如何利用索引。 完成分析之后会生成一份关于索引没有被查询使用过的报告。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-index-usage /var/lib/mysql/slow.log \</span><br><span class="line">  --h localhost --u root --p 123456 \</span><br><span class="line">  -d testdb3 \</span><br><span class="line">  --no-report --create-save-results-database</span><br></pre></td></tr></table></figure><h2 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="*pt-query-digest"></a>*pt-query-digest</h2><blockquote><p>分析查询执行日志，并产生一个查询报告，为 MySQL、PostgreSQL、 memcached 过滤、重放或者转换语句。<br><a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html">pt-query-digest</a></p></blockquote><ul><li><p><code>--database=s</code>:   连接的数据库, 非分析的数据库</p></li><li><p><code>--limit=A</code>:  限制输出的百分比/数量， (default 95%:20)</p></li><li><p><code>--report-all</code>：  所有的查询输出  </p></li><li><p><code>--ignore-attributes=a:</code>  忽略收集的属性   </p></li><li><p><code>--timeline:</code>   展示时间线的事件  </p></li><li><p><code>--review type</code>: DSN   保存查询结果供之后 review, 默认数据库和表为 <code>percona_schema.query_review</code>    </p></li><li><p><code>--report-histogram</code>=s:   属性的直方图，默认为 Query_time   </p></li><li><p><code>--type</code> tcpdump: 类型, 分析多种不同类型的日志  </p><ul><li>binlog: 分析 binlog</li><li>genlog: </li><li>slowlog: 分析慢查询</li><li>tcpdump: </li></ul></li><li><p><code>--order-by</code>: 默认根据查询时间排序， Query_time:sum ，<code>attribute:aggregate</code> 参数的语法  </p><ul><li>sum       Sum/total attribute value</li><li>min       Minimum attribute value</li><li>max       Maximum attribute value</li><li>cnt       Frequency/count of the query</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按照总耗时排序</span></span><br><span class="line">--order-by Query_time:sum </span><br></pre></td></tr></table></figure><ul><li><code>--since=s</code>: 过滤开始时间  </li><li><code>--until=s</code>  过滤结束时间  </li><li><code>--limit=A</code>:  限制输出的百分比/数量， (default 95%:20)  </li><li><code>--filter</code>:  过滤指定的事件, 不同的扫描条件    </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤语句 select：</span></span><br><span class="line">--filter &#x27;$event-&gt;&#123;arg&#125; =~ m/^select/i&#x27;，</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤指定用户：</span></span><br><span class="line">--filter &#x27;($event-&gt;&#123;user&#125; || &quot;&quot;) =~ m/^dba/i&#x27; ，</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤全表扫描：</span></span><br><span class="line">--filter &#x27;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤指定数据库</span></span><br><span class="line">--filter &#x27;$event-&gt;&#123;db&#125; &amp;&amp; $event-&gt;&#123;db&#125; =~ /testdb3/ &amp;&amp; $event-&gt;&#123;user&#125; =~ /root/&#x27; </span><br></pre></td></tr></table></figure><p><strong>使用案例</strong><br>分析所有慢查询日志  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-advisor /var/lib/mysql/slow-query.log</span><br></pre></td></tr></table></figure><p>指定的查询分析  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --query &quot;select * from mysql.user&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest \</span><br><span class="line"> -h127.0.0.1 -P3306 \</span><br><span class="line"> -uroot -proot \</span><br><span class="line"> --since &#x27;2020-07-25 00:00:00&#x27; \</span><br><span class="line"> --until &#x27;2020-07-26 00:00:00&#x27; \</span><br><span class="line"> --limit 20 \</span><br><span class="line"> /var/lib/mysql/mysql-slow.log.200725</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pt-query-digest \</span><br><span class="line"> -uroot -pimws \</span><br><span class="line"> --since &#x27;2020-07-25 00:00:00&#x27; \</span><br><span class="line"> --until &#x27;2020-07-26 00:00:00&#x27; \</span><br><span class="line"> --order-by Query_time:cnt \</span><br><span class="line"> --limit 20 \</span><br><span class="line"> /var/lib/mysql/mysql-slow.log.200725 \</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> slow-analyse-2.log</span></span><br></pre></td></tr></table></figure><h1 id="更改相关"><a href="#更改相关" class="headerlink" title="更改相关"></a>更改相关</h1><h2 id="pt-online-schema-change"><a href="#pt-online-schema-change" class="headerlink" title="*pt-online-schema-change"></a>*pt-online-schema-change</h2><blockquote><p>在线更改表结构，适用于大表结构的更改  </p></blockquote><ul><li><p><code>--host</code>: 连接mysql的地址</p></li><li><p><code>-P=3306</code>: 连接mysql的端口号</p></li><li><p><code>--user</code>: 连接mysql的用户名</p></li><li><p><code>--password</code>: 连接mysql的密码</p></li><li><p><code>--database=s / D</code>: 连接mysql的库名</p></li><li><p><code>t</code>:  连接mysql的表名</p></li><li><p><code>--alter</code>: 修改表结构的语句</p></li><li><p><code>--charset=utf8</code>: 使用utf8编码，避免中文乱码</p></li><li><p><code>--no-version-check:</code> 不检查版本，在阿里云服务器中一般加入此参数，否则会报错</p></li><li><p><code>--execute</code>:  执行修改表结构</p></li><li><p><code>--new-table-name=s</code>:  新创建的表，默认为 <code>&lt;old-table-name&gt;_new</code></p></li><li><p><code>--dry-run</code>:  常见并更改表, 不会创建触发器、复制数据..</p></li><li><p><code>--print</code>:  打印 SQL 执行语句  </p></li><li><p><code>--statistics</code>：  打印内部计数器的统计信息</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert_sql=&quot;ADD COLUMN addColumn varchar(30) DEFAULT &#x27;QTY&#x27; COMMENT &#x27;增加列备注&#x27;,ADD COLUMN addColumn2 varchar(30) DEFAULT 0 COMMENT &#x27;增加列2备注&#x27;,CHANGE COLUMN modColumn varchar(100)&quot;</span><br><span class="line">pt-online-schema-change \</span><br><span class="line">  --user=root --password=root --host=127.0.0.1 \</span><br><span class="line">  --alter  &quot;$alert_sql&quot; \</span><br><span class="line">  D=testdb3,t=testtable1 \</span><br><span class="line">  --print --dry-run</span><br></pre></td></tr></table></figure><h2 id="pt-heartbeat"><a href="#pt-heartbeat" class="headerlink" title="-pt-heartbeat"></a>-pt-heartbeat</h2><blockquote><p>监控 mysql 复制延迟，测量复制落后主 mysql 或者主 PostgreSQL 多少时间，可以使用这个脚本去更新主或者监控复制</p></blockquote><p>通过 <code>show slave status\G</code> 命令中的 <code>Seconds_Behind_Master</code> 值来判断主从延迟并不靠谱。</p><p>原理：<code>pt-heartbeat</code> 通过真实的复制数据来确认 mysql 和 postgresql 复制延迟，避免了对复制机制的依赖，能得出准确的落后复制时间。</p><p>包含两部分：</p><p>第一部分在主上 <code>pt-heartbeat</code> 的 <code>--update</code> 线程会在指定的时间间隔更新一个时间戳，</p><p>第二部分是 <code>pt-heartbeat</code> 的 <code>--monitor</code> 线程或者 <code>--check</code> 线程连接到从上检查复制的心跳记录（前面更新的时间戳），并和当前系统时间进行比较，得出时间的差异。</p><p>可以手工创建 heartbeat 表或者添加 –create-table 参数。</p><ul><li>-D / –database=s: 指定数据库, 必须的参数</li><li>–update, –monitor, –check: 互斥参数</li><li>–daemonize, –check: 互斥参数</li><li>–config: 指定配置文件的位置， key 必须为全称</li><li>–create-table： 创建heartbeat表如果该表不存在，该表由–database和–table参数来确认</li><li>–file： 将最新的–monitor信息输出到文件中，新的信息会覆盖旧的信息，通常和–daemonize参数一起使用</li><li>–frames：  统计的时间窗口，默认为1m,5m,15m</li><li>-master-server-id： 指定master的server_id，在检测从的延迟时，必须指定该参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建 heartbeat 表, 保存主从执行情况</span></span><br><span class="line">master_server_id=$(</span><br><span class="line"> mysql -uroot -proot \</span><br><span class="line">   -e &quot;SHOW VARIABLES LIKE &#x27;server_id&#x27;\G&quot; \</span><br><span class="line">   | grep Value \</span><br><span class="line">   | sed -n -e &#x27;s/^.*: //p&#x27;</span><br><span class="line">)</span><br><span class="line">slave_server=192.168.199.116</span><br><span class="line"></span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --create-table \</span><br><span class="line">  --update </span><br><span class="line"></span><br><span class="line">mysql -uroot -proot -e &quot;SELECT * FROM testdb3.heartbeat &quot;;</span><br><span class="line"></span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --update &amp;</span><br></pre></td></tr></table></figure><p>查看主从延迟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -h $slave_server \</span><br><span class="line">--monitor \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --print-master-server-id</span><br><span class="line">pt-heartbeat \</span><br><span class="line">  -u root -proot \</span><br><span class="line">  -D testdb3 \</span><br><span class="line">  --master-server-id=$master_server_id \</span><br><span class="line">  --check</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">实时延迟，1分钟延迟，5分钟延迟，15分钟延迟</span></span><br><span class="line">0.00s [  0.00s,  0.00s,  0.00s ] 391</span><br><span class="line">0.00s [  0.00s,  0.00s,  0.00s ] 391</span><br></pre></td></tr></table></figure><p>守护线程方式执行， 2s 执行一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pt-heartbeat \</span><br><span class="line"> -u root -proot \</span><br><span class="line"> -D testdb3 \</span><br><span class="line"> --master-server-id=$master_server_id \</span><br><span class="line"> --update --daemonize --interval=2</span><br><span class="line"></span><br><span class="line">pt-heartbeat --stop</span><br></pre></td></tr></table></figure><p>监控从库并输出日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pt-heartbeat \</span><br><span class="line"> -u root -proot \</span><br><span class="line"> -D testdb3 \</span><br><span class="line"> --master-server-id=$master_server_id \</span><br><span class="line"> --monitor --print-master-server-id \</span><br><span class="line"> --daemonize --interval=2 \</span><br><span class="line"> --log=/var/lib/mysql/slave-lag.log</span><br></pre></td></tr></table></figure><p>使用pt-heartbeat监控主从复制延迟<br><a href="https://cloud.tencent.com/developer/article/1183713">https://cloud.tencent.com/developer/article/1183713</a><br>pt-heartbeat<br><a href="https://www.cnblogs.com/ivictor/p/5901853.html">https://www.cnblogs.com/ivictor/p/5901853.html</a></p><h2 id="pt-table-sync"><a href="#pt-table-sync" class="headerlink" title="-pt-table-sync"></a>-<strong>pt-table-sync</strong></h2><blockquote><p>主从过程中不同步的表进行同步, 解决主从数据不一致的问题。</p></blockquote><p>注意事项：<br>使用 <code>--dry-run</code> 和 <code>--print</code> 选项总是先测试同步。  </p><p>无法同步表结构，和索引等对象，只能同步数据  </p><p>使用该工具来解决主从数据不一致的问题，也可以用来对两个不在一个主从拓扑实例，进行数据 sync  </p><ul><li><p>–[no]check-slave: 检查目标服务器是否是从数据库，默认为 Yes    </p></li><li><p>–sync-to-master and/or –replicate:  只有当需要sync的表都有唯一键(主键或唯一索引)，才能使用–sync-to-master and/or –replicate。(没有唯一键，则只能在desitination上直接修改，而指定–sync-to-master and/or –replicate时只能在主库上修改)，如果sync主从时没有指定–replicate或者–sync-to-master则所有修改都在从库上执行(不论表上是否有唯一键)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看数据不一致</span></span><br><span class="line">pt-table-sync --print  \</span><br><span class="line">  h=127.0.0.1,P=3306,u=root,p=root h=127.0.0.1,P=3307 \</span><br><span class="line">  --database=testdb5 --tables=testtable1  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复</span></span><br><span class="line">pt-table-sync --execute \</span><br><span class="line">h=127.0.0.1,P=3306,u=root,p=root h=127.0.0.1,P=3307 \</span><br><span class="line">--database=testdb5 --tables=testtable2</span><br></pre></td></tr></table></figure><h2 id="pt-archiver"><a href="#pt-archiver" class="headerlink" title="pt-archiver"></a>pt-archiver</h2><blockquote><p>将 mysql 数据库中表的记录归档到另外一个表或者文件，也可以直接进行记录的删除操作</p></blockquote><p>只是归档旧的数据，不会对线上数据的 OLTP 查询造成太大影响，可以将数据插入另外一台服务器的其他表中，也可以写入到一个文件中，方便使用 <code>load data infile</code> 命令导入数据。还可以用来执行 delete 操作, <font color="green">默认的会删除源中的数据</font>。使用的时候请注意  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> create table</span></span><br><span class="line">mysql -uroot -proot \</span><br><span class="line">  -e &quot;CREATE TABLE IF NOT EXISTS testdb4.bak_mis_wm_testtable1 LIKE testdb4.mis_wm_testtable1&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> archive data to bak table and file</span></span><br><span class="line">pt-archiver \</span><br><span class="line">  --source h=172.17.10.233,u=root,p=root,D=testdb4,t=mis_wm_testtable1 \</span><br><span class="line">  --dest h=172.17.10.233,u=root,p=root,D=testdb4,t=bak_mis_wm_testtable1 \</span><br><span class="line">  --file &#x27;/var/lib/mysql/%Y-%m-%d-%D.%t&#x27; \</span><br><span class="line">  --where &quot;dispatchState = &#x27;FINISHED&#x27;&quot; \</span><br><span class="line">  --limit 1000 --commit-each</span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><a href="https://www.cnblogs.com/chenpingzhao/p/4850420.html">percona-toolkit工具的使用</a><br>Percona-Toolkit 示例说明<br><a href="https://blog.csdn.net/kk185800961/article/details/85016523">https://blog.csdn.net/kk185800961/article/details/85016523</a>  </p><p>pt-query-digest（percona toolkit）小解<br><a href="https://www.cnblogs.com/shengdimaya/p/7063204.html">https://www.cnblogs.com/shengdimaya/p/7063204.html</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;perl 语言编写, 不同的 linux 发行版不同的安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/12/17/Blog/"/>
    <id>http://example.com/2020/12/17/Blog/</id>
    <published>2020-12-17T01:14:13.711Z</published>
    <updated>2020-12-17T01:14:13.711Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="http://example.com/2020/11/10/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2020/11/10/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-11-10T14:27:31.000Z</published>
    <updated>2020-12-30T00:37:27.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="命令设计"><a href="#命令设计" class="headerlink" title="命令设计"></a>命令设计</h3><p>Postel 原则： 宽进严出<br>尽可能自由宽松接受输入格式，并输出格式良好的严谨输出格式。<br>宽进减少了过滤器在面对非预期输入时出错的可能性，以及特定情况下崩溃的可能性。<br>严出提高过滤器被其他程序用作输入的可能性。</p><p>命令的风格</p><ul><li>POSIX</li><li>GNU</li><li>MS-DOS   </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> POSIX 集中短参数</span></span><br><span class="line">tar -c -f xx.tar xx.txt yy.txt</span><br><span class="line">tar -cfxx.tar xx.txt yy.txt</span><br></pre></td></tr></table></figure><p>命令的参数:</p><ul><li>可用选项  </li><li>选项参数: key=val  </li><li>子命令: 分割子命令显示不同的信息</li><li>密码参数: 防止根据 <code>history</code> 获取出用户密码</li><li>位置参数: 多个值按序解析 </li><li>支持多种类型的参数: 如发布的日志，传入文件名称自动解析文件内容作为参数，传入字符串  </li><li>支持自定义参数的解析:  可提供自定义的转换器，将参数映射成一个枚举项，指定的类对象</li><li>参数类型: <code>File</code>, <code>Date</code>, <code>URL</code>, <code>Pattern</code>..  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show interval and count </span></span><br><span class="line">vmstat 1 10</span><br></pre></td></tr></table></figure><h3 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h3><ul><li><p>–usage:  给定短的使用消息  </p></li><li><p><code>-verbose</code>: 显示 Debug 日志  </p></li><li><p><code>-v</code> / <code>-vvv</code>: 的个数越多显示的日志越详细, 如 ansible 执行时通过 -vvv 显示运行时候的详细信息</p></li><li><p><code>-V</code>/<code>--version</code>: 显示版本信息  </p></li><li><p>-a:<br>所有项，与 <code>--all</code> 同名的选项<br>添加（append), 与 tar 中一样</p></li><li><p>-b<br>缓冲区(buffer) 大小/block 的大小， du、df、tar 中使用<br>批处理（batch）禁用提示/设置通过属性接受文件的输入</p></li><li><p>-c<br>命令（带参数），如 sh、python<br>检查（check) 不带参数，检查命令/配置是否正确</p></li><li><p>-d<br>调试（debug)，带或不带参数，设置调试信息级别<br>删除(delete)<br>目录（directory)</p></li><li><p>-D<br>定义(define) 带参数</p></li><li><p>-e<br>执行(execute) (带参数)<br>编辑(edit)，如 crontab<br>排除(exclude)</p></li><li><p>-f<br>文件(file)(带参数)<br>强制(force), 如 git push -f xxx、ssh</p></li><li><p>-h<br>表头（header)<br>帮助(help)</p></li><li><p>-i<br>初始化<br>交互执行，如 <code>docker exec -it &lt;container-name&gt; bash</code></p></li><li><p>-I<br>包含</p></li><li><p>-k: 保留，禁止资源的常规删除</p></li><li><p>-l:<br>列表<br>加载：<br>登陆： ssh 等要求网络身份</p></li></ul><p>常用的命令缩写:<br>-h: 主机<br>-P: 端口<br>-u: 用户<br>-p: 密码<br>-t: 测试配置文件<br>-c: 指定配置文件地址  </p><p>常用的子命令<br><code>start</code>:<br><code>stop</code>:<br><code>restart</code>:<br><code>reload</code>:  </p><h3 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h3><p><strong>fzf</strong></p><blockquote><p>模糊搜索工具</p><p>配置 Ctrl + R 快捷键自动根据 history 中的数据搜索</p></blockquote><img src="http://img.janhen.com/image-20201129000402250.png" alt="image-20201129000402250" style="zoom: 33%;" /><p><strong>the_silver_searcher</strong></p><blockquote><p><a href="https://github.com/ggreer/the_silver_searcher">GitHub</a></p></blockquote><p>替代 grep 的 Linux 工具，类似于ack的代码搜索工具，但速度更快。</p><p>可通过 <code>.gitignore</code>、 <code>.hgignore</code> 、<code>.ignore</code> 忽略指定文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install the_silver_searcher</span><br></pre></td></tr></table></figure><p><strong>navi</strong></p><blockquote><p><a href="https://github.com/denisidoro/navi">Github</a></p><p>命令行和应用程序启动器的交互式备忘单工具。</p></blockquote><p>基于 fzf 对命令进行搜索, 可按照特定的标签进行组织命令，支持通过 <code>&lt;name&gt;</code> 指定参数</p><img src="http://img.janhen.com/image-20201128235948928.png" alt="image-20201128235948928" style="zoom:33%;" /><p><strong>nohup</strong></p><blockquote><p>允许用户退出帐户/关闭终端之后继续运行相应的进程</p></blockquote><ul><li>/dev/null，代表linux的空设备文件，所有往这个文件里面写入的内容都会丢 失，俗称黑洞 </li><li>标准输入0，从键盘获得输入 /proc/self/fd/0 </li><li>标准输出1，输出到屏幕（控制台） /proc/self/fd/1 </li><li>错误输出2，输出到屏幕（控制台） /proc/self/fd/2</li><li><code>&gt;/dev/null </code> 标准输出1重定向到 /dev/null 中，此时标准输出不存在，没有任 何地方能够找到输出的内容 2&gt;&amp;1 错误输出将会和标准输出输出到同一个地方</li><li><code>&gt;/dev/null 2&gt;&amp;1</code> 不会输出任何信息到控制台，也不会有任何信息输出到文件中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup flume-ng agent --conf /opt/apps/flume-1.9/conf \</span><br><span class="line">  --conf-file /data/lagoudw/conf/flume-log2hdfs3.conf \</span><br><span class="line">  -name a1 \</span><br><span class="line">  -Dflume.root.logger=INFO,LOGFILE &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><strong>lrzsz</strong></p><blockquote><p>文件的上传和下载工具，只支持文件，不支持文件夹，配合 tar 命令使用，配合 SSH 连接使用</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择本地文件上传到服务器</span></span><br><span class="line">rz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 从服务器下载文件到本地</span></span><br><span class="line">sz &lt;file&gt;</span><br></pre></td></tr></table></figure><p><strong>ipvsadm</strong></p><blockquote><p>LVS 管理工具</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查案负载情况</span></span><br><span class="line">ipvsadm -l</span><br></pre></td></tr></table></figure><p><strong>zsh</strong></p><blockquote><p>辅助命令编写，带有提示</p></blockquote><p>可进行 alias 指定, 主题选择，插件选择</p><p><strong>sort</strong> </p><p>用于排序。</p><ul><li>-f ：忽略大小写  </li><li>-b ：忽略最前面的空格  </li><li>-M ：以月份的名字来排序，例如 JAN，DEC  </li><li>-n ：使用数字  </li><li>-r ：反向排序  </li><li>-u ：相当于 unique，重复的内容只出现一次  </li><li>-t ：分隔符，默认为 tab  </li><li>-k ：指定排序的区间  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sm * | sort -nr | head -n 10 </span><br></pre></td></tr></table></figure><p><strong>uniq</strong> </p><p>可以将重复的数据只取一个。  </p><ul><li>-i ：忽略大小写</li><li>-c ：进行计数</li></ul><p>当前目录下的磁盘情况</p><p><strong>tee</strong><br>输出重定向会将输出内容重定向到文件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee [-a] &lt;file&gt;</span><br></pre></td></tr></table></figure><p><strong>paste</strong></p><p>字符转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paste [-d] file1 file2</span><br><span class="line">-d ：分隔符，默认为 tab</span><br></pre></td></tr></table></figure><p><strong>rsync</strong></p><blockquote><p>远程同步工具</p><p>速度快、避免复制相同内容和支持符号链接。</p><p>rsync只对差异文件做更新。scp是把所有文件都复制过去。</p></blockquote><ul><li><code>-r</code></li><li><code>-v</code>: 显示复制过程</li><li><code>-l</code>: 复制符号链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y rsync</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -rvl /opt/module root@linux123:/opt/</span><br></pre></td></tr></table></figure><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p><strong>cat</strong>  </p><ul><li><code>-n</code>: 显示文本的行号  </li><li><code>-T, --show-tabs</code>:  使用 <code>^I</code> 标示 Tab 字符      </li><li><code>-E, --show-ends </code>:  显示 <code>$</code> 作为每行的末尾<br>Ctrl + D 终止输入    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; SampleTextFile.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>File</strong></p><p>显示文件字符集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file -i test_info.sh</span><br></pre></td></tr></table></figure><p><strong>iconv:</strong><br>文本字符集转换   </p><ul><li>-f, –from-code=NAME:  来源字符集编码  </li><li>-t, –to-code=NAME： 目的字符集编码  </li><li>-o, –output=FILE：  输出文件名  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f ISO-8859-1 -t UTF-8 in.txt &gt; out.txt</span><br></pre></td></tr></table></figure><h3 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h3><p>RedHat 类系统信息查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure><p><strong>系统相关</strong></p><blockquote><p>系统服务相关，包括查看状态、停止运行、重新加载、开机自启</p><p>主机域名映射，实现 hosts </p><p>环境变量控制，实现增加环境变量</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统应用状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止系统应用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载系统应用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将系统应用开机自启</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看失败的系统应用</span></span><br><span class="line">systemctl status redis_6379</span><br><span class="line">systemctl status docker</span><br><span class="line">systemctl stop redis_6379</span><br><span class="line">systemctl reload docker.service</span><br><span class="line">systemctl enable docker.service</span><br><span class="line">systemctl --failed</span><br></pre></td></tr></table></figure><p><strong>系统基本信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统总信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统的位数, 配合下载 URL 使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统内核版本</span></span><br><span class="line">uname -a</span><br><span class="line">uname -m</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><strong>CPU 情况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看物理CPU个数</span></span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看每个物理CPU中core的个数(即核数)</span></span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看逻辑CPU的个数</span></span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看CPU信息（型号）</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure><p>CPU 整体信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><p>各个 CPU 的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL</span><br></pre></td></tr></table></figure><p>连续的 CPU 情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1 300</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看僵尸进程</span></span><br><span class="line">ps -al | gawk &#x27;&#123;print $2,$4&#125;&#x27; | grep Z</span><br></pre></td></tr></table></figure><p>查看进程实际使用的内存情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e -o &#x27;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&#x27; |  sort -nrk5</span><br></pre></td></tr></table></figure><p><strong>运行负载情况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">top -p 3306</span><br></pre></td></tr></table></figure><p><strong>内存使用情况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看内存使用百分比</span></span><br><span class="line">free | sed -n &#x27;2p&#x27; | gawk &#x27;x = int(( $3 / $2 ) * 100) &#123;print x&#125;&#x27; | sed &#x27;s/$/%/&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 释放内存</span></span><br><span class="line">echo 1 &gt;/proc/sys/vm/drop_caches</span><br><span class="line">echo 2 &gt;/proc/sys/vm/drop_caches</span><br><span class="line">echo 3 &gt;/proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><p><strong>磁盘占用情况</strong></p><p>可以作为部署时候的参考</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line">df -sh *</span><br></pre></td></tr></table></figure><p><strong>文件句柄数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>查看端口使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss -nelp | grep 22</span><br><span class="line">netstat -lntp | grep 22</span><br></pre></td></tr></table></figure><p>查看IP 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Show all interface ip addr</span></span><br><span class="line">ifconfig | grep -Eo &#x27;inet (addr:)?([0-9]*\.)&#123;3&#125;[0-9]*&#x27; | grep -Eo &#x27;([0-9]*\.)&#123;3&#125;[0-9]*&#x27; | grep -v &#x27;127.0.0.1&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Specified interface</span></span><br><span class="line">ifconfig eno1 | grep -Eo &#x27;inet (addr:)?([0-9]*\.)&#123;3&#125;[0-9]*&#x27; | grep -Eo &#x27;([0-9]*\.)&#123;3&#125;[0-9]*&#x27;</span><br><span class="line">ifconfig eth0 | grep -Eo &#x27;inet (addr:)?([0-9]*\.)&#123;3&#125;[0-9]*&#x27; | grep -Eo &#x27;([0-9]*\.)&#123;3&#125;[0-9]*&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接指定端口 </span></span><br><span class="line">telnet IP PORT  </span><br><span class="line"><span class="meta">#</span><span class="bash"> dns 解析相关</span></span><br><span class="line">nslookup sina.com    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 从主机到互联网另一端的主机走的什么路径  </span></span><br><span class="line">traceroute sina.com  </span><br><span class="line"></span><br><span class="line">sar  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 网络状况分析跟踪  </span></span><br><span class="line">tcpdump</span><br></pre></td></tr></table></figure><p>Tcp 端口监听情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -lntp | grep &lt;port&gt;</span><br><span class="line">ps -ef | grep &lt;port&gt;</span><br><span class="line">lsof -i tcp:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>Tcp 状态连接统计  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | awk &#x27;/^tcp/ &#123;++s[$NF]&#125; END &#123;for(a in s) print a,s[a]&#125;&#x27; </span><br></pre></td></tr></table></figure><p>bridge-utils： yum install bridge-utils</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 本地系统的转发支持，  0,1 语义..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开启转发</span></span><br><span class="line">sysctl net.ipv4.ip_forward</span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables 关联命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   查看 NAT 的端口映射， 显示伪装地址，端口映射情况</span></span><br><span class="line">iptables -t nat -nL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 bridge 情况</span></span><br><span class="line">brctl show</span><br><span class="line"><span class="meta">#</span><span class="bash"> 网络运行情况</span></span><br><span class="line">netstat -anop</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看本机网卡</span></span><br><span class="line">nmcli d</span><br></pre></td></tr></table></figure><p><strong>网卡配置</strong></p><p>打开文件**/etc/sysconfig/network**来修改主机名和DNS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</span><br><span class="line"></span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DNS1=172.17.0.211</span><br><span class="line">DNS2=172.17.0.221</span><br><span class="line">IPADDR=172.17.10.137    # 更改</span><br><span class="line">NETMASK=255.255.240.0</span><br><span class="line">GATEWAY=172.17.0.49</span><br><span class="line"></span><br><span class="line">systemctl restart network</span><br><span class="line">ping 8.8.8.8</span><br><span class="line">ping 172.17.0.49</span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure><p><strong>域名主机名配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hostname</span><br><span class="line">hostnamectl </span><br><span class="line">hostnamectl set-hostname cnode</span><br><span class="line">echo &quot;172.17.10.153 cnode1&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p><strong>防火墙相关</strong></p><blockquote><p>线上服务器必须使用，当前为 Centos7 自带防火墙，局域网一般可以关闭</p><p>开启、关闭防火墙，基本信息查看</p><p>开放或关闭某个|一个数据段的端口，</p><p>开放或关闭某个|多个服务</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止并关闭开机启动防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动防火墙</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有zone</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看特定区域，不指定默认为 public</span></span><br><span class="line">firewall-cmd --version</span><br><span class="line">firewall-cmd --state</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line">firewall-cmd --get-zones</span><br><span class="line">firewall-cmd --get-default-zone</span><br><span class="line">firewall-cmd --list-zone</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">firewall-cmd --zone=pulic</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看开放的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启需要的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看开放端口验证</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个端口</span></span><br><span class="line">firewall-cmd --list-port</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=3306/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=22/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-port</span><br><span class="line">firewall-cmd --query-port=22/tcp</span><br><span class="line">firewall-cmd --add-port=22/tcp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看开放的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除某个|某段的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证开放端口情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙</span></span><br><span class="line">firewall-cmd --list-port</span><br><span class="line">firewall-cmd --permanent --remove-port=2000-20002/tcp </span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-port</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启|关闭某个服务</span></span><br><span class="line">firewall-cmd --add-service ftp --permanent</span><br><span class="line">firewall-cmd --remove-service --permanent</span><br><span class="line">firewall-cmd --zone=public --list-services</span><br></pre></td></tr></table></figure><p><strong>iptables 相关</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对于请求 8082 端口的全部丢弃掉</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 8082 -j DROP</span><br></pre></td></tr></table></figure><p><strong>net-tools</strong></p><blockquote><p>常用的网络工具</p></blockquote><p>可以使用 Linux 旧有支持的命令，以及扩展的网络工具</p><p>route： 如 <code>route -n</code> 命令，等价于现在自带的 <code>ip -r</code> 命令</p><p>netstat： 常用的网络工具</p><p>ifconfig： 废弃命令，在 Linux 上使用 <code>ip address</code> 代替，简写成 <code>ip a</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加默认网关模板以及对应的实例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证设置网关的结果</span></span><br><span class="line">route add default gw &#123;IP-ADDRESS&#125; &#123;INTERFACE-NAME&#125;</span><br><span class="line">route add default gw 192.168.2.254 eth0</span><br><span class="line">route -n</span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux 自带命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置默认网关</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证执行情况</span></span><br><span class="line">ip route add default via 192.168.1.254</span><br><span class="line">ip r</span><br></pre></td></tr></table></figure><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>查看指定目录下文件的大小，排序并只显示TOP10</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh * | sort -hr | head -n 10</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo find /var/lib/docker/containers -name *.log</span><br><span class="line"></span><br><span class="line">sudo du -d1 -h /var/lib/docker/containers | sort -h</span><br><span class="line">sudo du -d1 -h /var/lib/docker | sort -h</span><br><span class="line"></span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27; iwms-openapi</span><br></pre></td></tr></table></figure><p>磁盘挂载</p><ul><li><code>du -sh *</code>: 查看目录占用的空间情况</li><li><code>df -h</code>：查看磁盘占用情况</li><li><code>df -T</code>：查看所有磁盘的文件系统类型(type)</li><li><code>fdisk -l</code>：查看所有被系统识别的磁盘</li><li><code>mount -t type device dir</code>：挂载device到dir</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式化分区</span></span><br><span class="line">mkfs -t ext4 /dev/vdb1</span><br></pre></td></tr></table></figure><ul><li>mkfs -t ext4 /dev/vdb1:  格式化分区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">umount /data   ##卸载data目录下分区</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分区的UUID</span></span><br><span class="line">ls -l  /dev/disk/by-uuid/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自动挂载</span></span><br><span class="line">vim /etc/fstab </span><br><span class="line">  /dev/sdb    /data    ext4    defaults    0 0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看硬盘以及分区情况</span></span><br><span class="line">lsblk</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比如要扩充 /var</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建好文件系统后 新建临时挂载点 storage</span></span><br><span class="line">mkdir /storage</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将/dev/sdb1挂载到/storage下</span></span><br><span class="line">mount /dev/sdb1  /storage</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝/var下的所有内容到新的硬盘</span></span><br><span class="line">cp -pdr /var /storage</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或在/var 目录下执行：find . -depth -<span class="built_in">print</span> | cpio - pldvm /temp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前/var目录下的内容</span></span><br><span class="line">rm -rf /var/*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新挂载硬盘到/var目录</span></span><br><span class="line">umount /dev/sdb1</span><br><span class="line">mount /dev/sdb1 /var</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过程中若提示磁盘忙，使用fuser找出将正在使用磁盘的程序并结束掉；</span></span><br><span class="line">fuser -m -v /var</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">partprobe /dev/sda</span><br><span class="line">partx -a /dev/sdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证情况</span></span><br></pre></td></tr></table></figure><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><p>删除后，存放的数据不删除  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln –snf  /var/www/test1   /var/test  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 意不要在后面加 ”/”</span></span><br><span class="line">rm –rf &lt;软链接名称&gt;</span><br><span class="line">ln –snf  &lt;新的源文件或目录&gt; &lt;目标文件或目录&gt;</span><br></pre></td></tr></table></figure><h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><blockquote><p>重要的配置文件位置</p></blockquote><p><strong>用户相关</strong></p><ul><li><p>/etc/passwd： 用户列表文件，是否是系统用户，是否可以登录</p></li><li><p>/etc/group：    用户组列表文件</p></li><li><p>/etc/sudoers: 可以有 sudo 权限的配置</p></li><li><p>/etc/profile： 环境变量配置</p></li><li><p>/etc/hosts：   host 文件位置</p></li><li><p>/etc/hostnames: 主机名</p></li><li><p>/etc/sysconfig/network-scripts/ifcfg-ensxx: 网卡设置</p></li><li><p>/etc/yum.repos.d/xxx.repo： 软件安装源</p></li><li><p>/var/logs： 日志存放位置</p></li></ul><p><strong>执行路径</strong></p><p>/usr/local/bin、/usr/bin、/usr/local/sbin、/usr/sbin</p><p>/home/<user_name>/bin: 可执行路径，常通过 ln -s … 的方式使全局可用</p><p><strong>文件操作</strong></p><p>基本操作， ls、touch、mkdir、cd、rm、cp、mv、pwd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 复制、移动、重命名</span></span><br><span class="line">cp -r /user/newTest /test </span><br><span class="line">mv /test/newTest /usr </span><br><span class="line">mv aaa bbb</span><br><span class="line">rm -rf /user/newTst</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件的查看</span></span><br><span class="line">cat -n /etc/passwd </span><br><span class="line">tail /etc/passwd</span><br><span class="line">tail -3 /etc/passwd</span><br><span class="line">tail -f nohup.out</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件压缩与解压</span></span><br><span class="line">tar -cvf &lt;zip_name&gt; &lt;folder_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制并重命名</span></span><br><span class="line">copy -a nginx_playbooks wordpress_playbooks</span><br></pre></td></tr></table></figure><p><strong>文件上传下载</strong></p><blockquote><p>文件下载： wget、curl</p><p>文件上传： scp</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp </span><br></pre></td></tr></table></figure><p><strong>tar 命令</strong></p><ul><li>-z, –gzip, –gunzip, –ungzip   通过 gzip 过滤归档  </li><li>-c, –create: 创建一个新归档</li><li>-v, –verbose: 详细地列出处理的文件  </li><li>-f, –file=ARCHIVE: 使用归档文件或 ARCHIVE 设备  </li><li>-C, –directory=DIR: 改变至目录 DIR  </li><li>-x, –extract, –get: 从归档中解出文件  </li><li>-j, –bzip2 :  通过 bzip2 过滤归档  </li><li>-t, –list: 列出归档内容</li></ul><p>打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf /mydata/etc.tar /etc</span><br></pre></td></tr></table></figure><p>  打包并压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /mydata/etc.tar.gz /etc</span><br></pre></td></tr></table></figure><p>用bzip2压缩文件夹/etc到文件/etc.tar.bz2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf /mydata/etc.tar.bz2 /etc</span><br></pre></td></tr></table></figure><p>解压缩到指定目录  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf etc.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure><p>找出指定时间范围内的日志文件，打包传输  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*04-29*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*04-28*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*04-30*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*04-31*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*05-01*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*05-02*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*05-03*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*05-04*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">find . -name &quot;*05-05*&quot; -exec cp &#123;&#125; 200428_200505 \;</span><br><span class="line">tar -zcvf 200428_200505.tar.gz 200428_200505/</span><br></pre></td></tr></table></figure><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li>-maxdepth levels  </li><li>-atime n File was last accessed n*24 hours ago.   </li><li><em>-mtime n File’s  data  was  last  modified  n</em>24  hours ago.  </li><li>-size n[cwbkMG]    </li><li>-type c File is of type c  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找出指定目录下文件的个数  </span></span><br><span class="line">find DIR_NAME -type f | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找出 /opt 目录下大于 800 M 的文件</span></span><br><span class="line">find /opt -type f -size +800M -print0 | xargs -0 du -h | sort -nr  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到文件并移到 opt 目录  </span></span><br><span class="line">find / -name &quot;*tower*&quot; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找出系统中占用容量最大的前 12 个目录  </span></span><br><span class="line">du -hm --max-depth=2 | sort -nr | head -12</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录搜索lin开头的文件，然后用其搜索后的结果集，再执行ls -l的命令（这个命令可变，其他命令也可以），其中 -<span class="built_in">exec</span> 和 &#123;&#125; \; 都是固定格式  </span></span><br><span class="line">find . -name &quot;lin*&quot; -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><code>-v</code>: 过滤掉</p><p><code>-i</code>: 忽略大小写</p><p><code>-n</code>: 打印行号</p><p><code>-H, --with-filename</code>: 打印文件名</p><p><code>-r</code>: 递归处理  </p><p><code>-d, --directories=ACTION</code>: 目录处理策略, <code>read</code>,<code>recurse</code>,<code>skip</code></p><p><code>-c</code>/<code>--count</code>: 打印匹配的数量</p><p><code>-w</code>: 匹配整个词</p><p><code>-x</code>: 整行</p><p>查看指定进程并过滤掉 grep 自身</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep namenode | grep -v grep</span><br></pre></td></tr></table></figure><p>正则匹配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;python|PYTHON&quot; file</span><br><span class="line">grep -E &quot;python|PYTHON&quot; file</span><br><span class="line">grep -F &quot;py.*&quot; file</span><br></pre></td></tr></table></figure><p>打印匹配行的前后5行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -5 &#x27;parttern&#x27; INPUT_FILE </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep Full gclogs/fanruan.gc.log.2020-07-26</span><br><span class="line">grep -n Full gclogs/fanruan.gc.log.2020-07-26</span><br></pre></td></tr></table></figure><p>搜索指定字符，并显示匹配到的行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n man /etc/man_db.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3:# This file is used by the man-db package to configure the man and cat paths.</span><br><span class="line">4:# It is also used to provide a manpath for those without one by examining</span><br><span class="line">5:# their PATH environment variable. For details see the manpath(5) man page.</span><br></pre></td></tr></table></figure><p>查看单个/多个文件某字符出现的次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep Full gclogs/* | wc -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> count</span></span><br><span class="line">grep -c processor /proc/cpuinfo</span><br><span class="line"><span class="meta">#</span><span class="bash"> Show filename:count</span></span><br><span class="line">grep -c Full gclogs/*</span><br><span class="line">gclogs/fanruan.gc.log:1</span><br><span class="line">gclogs/fanruan.gc.log.2020-07-17:434</span><br><span class="line">gclogs/fanruan.gc.log.2020-07-18:1</span><br><span class="line">gclogs/fanruan.gc.log.2020-07-19:3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看某个配置文件，排除掉里面以 # 开头的注释内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;^[^#]&#x27; /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure><p>查看某个配置文件，排除掉里面以 # 开头和 ; 开头的注释内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;^[^#;]&#x27; /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><blockquote><p> 轻量级流编辑器，一般用来处理文本类文件<br> 非交互式的编辑器, 它不会修改文件，除非使用 shell 重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上<br> sed -i 会实际写入  </p></blockquote><ul><li>  p 参数表示打印，一般配合 -n（安静模式）进行使用</li></ul><ul><li><p>c. 替换</p></li><li><p>s： 搜索并替换</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示网络接口的 Ip 地址  </span></span><br><span class="line">ifconfig eth0 |grep &#x27;inet&#x27; |sed &#x27;s/^.*inet//g&#x27; |sed &#x27;s/netmask.*$//g&#x27; |sed -n &#x27;1p&#x27;</span><br><span class="line">192.168.199.183  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示第 7 ~ 10 行内容</span></span><br><span class="line">sed -n &#x27;7,10p&#x27; /opt/log4j2.properties</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将文件中每一行以 <span class="comment"># 开头的都替换掉空字符并展示</span></span></span><br><span class="line">sed &#x27;s/^#*//g&#x27; /opt/log4j2.properties</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 1 ~ 4 行内容替换成 GitNavi.com</span></span><br><span class="line">cat -n /opt/log4j2.properties |sed &#x27;1,4c GitNavi.com</span><br></pre></td></tr></table></figure><h3 id="日期和日历"><a href="#日期和日历" class="headerlink" title="日期和日历"></a>日期和日历</h3><ul><li><p><code>date +%Y</code>:  显示当前年份</p></li><li><p><code>date +%m</code>: 显示当前⽉份</p></li><li><p><code>date +%d</code>: 显示当前是哪⼀天</p></li><li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> : 按照指定格式显示</p></li><li><p><code>date -d &#39;1 days ago&#39;</code>: 显示前⼀天⽇期</p></li><li><p><code>date -d yesterday +&quot;%Y-%m-%d&quot;</code>: 同上</p></li><li><p><code>date -d next-day +&quot;%Y-%m-%d&quot;</code>: 显示明天⽇期</p></li><li><p><code>date -d &#39;next monday&#39;</code>: 显示下周⼀时间</p></li><li><p><code>date -s 字符串时间</code>: 设置系统时间</p></li></ul><p>cal<br>查看日历。<br><code>cal -3</code>: 查看当前，上个，下个月的日历<br><code>cal 2020</code>: 查看指令年份的</p><h3 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h3><ul><li>open files: 可打开的文件限制  </li><li>file size: 可创建单个文件的最大大小?  </li><li>max memory size: 最大可用的内存大小  </li><li>stack size:  最大可使用的栈大小  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 59459</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 59459</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><ul><li><code>-</code>代表⽂件</li></ul><ul><li><p><code>d</code> 代表⽬录</p></li><li><p><code>c</code> 字符流，</p></li><li><p><code>s</code> socket</p></li><li><p><code>p</code> 管道</p></li><li><p><code>l</code> 链接⽂档(link ﬁle)</p></li><li><p><code>b</code> 设备⽂件</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [⽂件或⽬录] [mode=421 ] [⽂件或⽬录]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变⽂件或者⽬录的所有者</span></span><br><span class="line">chown [最终⽤户] [⽂件或⽬录] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变⽂件或者⽬录的所属组</span></span><br><span class="line">chgrp [最终⽤户组] [⽂件或⽬录] </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useradd &lt;user-name&gt;</span><br><span class="line">passwd &lt;user-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换⽤户，只能获得⽤户的执⾏权限，不能获得环境变量</span></span><br><span class="line">su &lt;user-name&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到⽤户并获得该⽤户的环境变量及执⾏权限</span></span><br><span class="line">su - &lt;user-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除⽤户但保存⽤户主⽬录</span></span><br><span class="line">userdel &lt;user-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ⽤户和⽤户主⽬录，都删除</span></span><br><span class="line">userdel -r ⽤户名 </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 让用户支持权限命令</span></span><br><span class="line">visudo</span><br><span class="line"><span class="meta">%</span><span class="bash">vagrant ALL=(ALL)   ALL</span></span><br></pre></td></tr></table></figure><p>/etc/sudoers</p><p>Allow root to run any commands anywhere </p><p>root ALL=(ALL) ALL </p><p>hadoop ALL=(ALL) ALL</p><p>cat /etc/passwd 查看创建了哪些⽤户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usermod -g &lt;⽤户组&gt; &lt;⽤户名&gt;</span><br><span class="line">groupadd &lt;组名&gt; &lt;代表⽬录&gt;</span><br><span class="line">groupdel &lt;组名&gt;</span><br><span class="line">groupmod -n &lt;新组名&gt; &lt;⽼组名&gt;</span><br><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul><li>《UNIX 编程艺术》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;命令设计&quot;&gt;&lt;a href=&quot;#命令设计&quot; class=&quot;headerlink&quot; title=&quot;命令设计&quot;&gt;&lt;/a&gt;命令设计&lt;/h</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用服务</title>
    <link href="http://example.com/2020/11/10/Linux-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2020/11/10/Linux-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-11-10T13:21:25.000Z</published>
    <updated>2020-12-17T12:09:03.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><blockquote><p>默认安装好客户端，对于海外的服务器进行转发有时连接效果较好</p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置文件存放在 <code>~/.ssh/config</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><p>端口更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Port=1022</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果 60s 内没用任何数据,将会自动断开。</span></span><br><span class="line">vim /etc/ssh/ssh_config</span><br><span class="line"><span class="meta">#</span><span class="bash">添加</span></span><br><span class="line">ServerAliveInterval 60</span><br><span class="line">ServerAliveCountMax 3</span><br></pre></td></tr></table></figure><p>禁止密码登陆，可避密码泄漏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁用root账户登录(非必要)</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否允许用户自行使用成对的密钥系统进行登入行为</span></span><br><span class="line">RSAAuthentication yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否让 sshd 去检查用户home目录的权限数据</span></span><br><span class="line">StrictModes no</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止密码登录</span></span><br><span class="line">PasswordAuthentication no </span><br></pre></td></tr></table></figure><p><strong>SSH 免密码密钥认证</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将公钥传递给远程 root </span></span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub root@linux121</span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub root@linux122</span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub root@linux123</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定端口传递</span></span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub -oPort=6000 root@127.0.0.1</span><br></pre></td></tr></table></figure><p><strong>SSH 文件传输</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 SSH 复制远程服务器指定文件到本地</span></span><br><span class="line">scp root@linux121:/root/frp_0.13.0_linux_amd64.tar.gz frp.tar.gz</span><br></pre></td></tr></table></figure><p><strong>SSH 连接执行命令</strong></p><p>连接上指定的机器，同时执行指定的命令，封装 zookeeper 集群的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;start zookeeper server...&quot;</span><br><span class="line"><span class="meta">if(($</span><span class="bash"><span class="comment">#==0));</span></span></span><br><span class="line">then echo &quot;no params&quot;;</span><br><span class="line">exit;</span><br><span class="line">fi</span><br><span class="line">hosts=&quot;linux121 linux122 linux123&quot;</span><br><span class="line"></span><br><span class="line">for host in $hosts</span><br><span class="line">do ssh $host &quot;source /etc/profile; $1&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h2><blockquote><p>Linux 自带的定时调度服务</p></blockquote><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p><strong>查看用户的定时任务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前用户的定时任务</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定用户的定时任务</span></span><br><span class="line">crontab -u &lt;username&gt; -l</span><br></pre></td></tr></table></figure><p><strong>按照时间查看定时任务</strong></p><p>查看每日的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /etc/cron.daily/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x.  2 root root 4096 Sep 14 15:16 .</span><br><span class="line">drwxr-xr-x. 76 root root 4096 Nov 10 21:15 ..</span><br><span class="line">-rwx------.  1 root root  219 Apr  1  2020 logrotate</span><br><span class="line">-rwxr-xr-x.  1 root root  618 Oct 30  2018 man-db.cron</span><br></pre></td></tr></table></figure><p>查看每小时的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /etc/cron.hourly/</span><br></pre></td></tr></table></figure><p>查看每周的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /etc/cron.weekly/</span><br></pre></td></tr></table></figure><p>查看每月的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /etc/cron.monthly/</span><br></pre></td></tr></table></figure><p><strong>查看 <code>/etc/crontab</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /etc/crontab</span><br></pre></td></tr></table></figure><p><strong>查看任务执行日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/cron</span><br></pre></td></tr></table></figure><h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------- minute (0 - 59)</span><br><span class="line">|  +------------- hour (0 - 23)</span><br><span class="line">|  |  +---------- day of month (1 - 31)</span><br><span class="line">|  |  |  +------- month (1 - 12)</span><br><span class="line">|  |  |  |  +---- day of week (0 - 6) (Sunday&#x3D;0 or 7)</span><br><span class="line">|  |  |  |  |</span><br><span class="line">*  *  *  *  *  command to be executed</span><br></pre></td></tr></table></figure><p>定时删除日志</p><p>每天凌晨2点删除 <code>/usr/apps/logs</code> 目录下7天前包含 log 的日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * &#x2F;usr&#x2F;bin&#x2F;find &#x2F;usr&#x2F;apps&#x2F;logs&#x2F; -type f -mtime +7 -name &quot;*log*&quot; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="journal"><a href="#journal" class="headerlink" title="journal"></a>journal</h2><blockquote><p>日志查看服务</p></blockquote><p>Linux 日志分类</p><ul><li><p>内核及系统日志： 日志数据由系统服务 syslog 统一管理</p></li><li><p>用户日志：这种日志数据用于记录 Linux 系统用户登录及退出系统的相关信息</p></li><li><p>程序日志：有些应用程序运会选择自己来独立管理一份日志文件, 通过配置日志格式和回滚策略</p></li></ul><p>Linux 中常用日志文件</p><ul><li><p>/var/log/cron： 与定时任务相关的日志信息</p></li><li><p>/var/log/maillog： 与邮件相关的日志信息</p></li><li><p>/var/log/secure： 与安全相关的日志信息, 可基于此日志过滤攻击的 IP</p></li><li><p>/var/log/boot.log： 守护进程启动和停止相关的日志消息</p></li><li><p><code>/var/log/messages</code> / <code>/var/log/syslog</code>：  存储所有的全局系统活动数据,包括启动、IO错误、网络错误、程序故障等 /varlog/dmesg：记录Linux系统在引导过程中的各种事件信息</p></li><li><p>/var/log/lastlog：最近几次成功登录事件和最后一次不成功登录事件</p></li><li><p>/var/log/wtmp：记录每个用户登录、注销及系统启动和停机事件</p></li><li><p>/var/log/rpmpkgs： RPM软件包日志</p></li><li><p>/var/log/kern： 存储内核的错误和警告数据，用于排除与定制内核相关的故障</p></li><li><p>/var/log/btmp： 记录错误的登陆尝试</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -f -n 1000</span><br></pre></td></tr></table></figure><h2 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h2><blockquote><p>日志回滚服务</p></blockquote><p>/etc/logrotate.d/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tree &#x2F;etc&#x2F;logrotate.d</span><br><span class="line">&#x2F;etc&#x2F;logrotate.d</span><br><span class="line">├── bootlog</span><br><span class="line">├── chrony</span><br><span class="line">├── ppp</span><br><span class="line">├── subscription-manager</span><br><span class="line">├── syslog</span><br><span class="line">├── vsftpd</span><br><span class="line">├── wpa_supplicant</span><br><span class="line">└── yum</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>配合 cron 实现日志的分割压缩处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logrotate /etc/logrotate.d/nginx</span><br><span class="line">logrotate -d /etc/logrotate.d/nginx</span><br><span class="line">logrotate -vf /etc/logrotate.d/nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/access_log &#123;</span><br><span class="line">    rotate 7</span><br><span class="line">    size 5k</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y-%m-%d</span><br><span class="line">    missingok</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        test -r /var/run/nginx.pid &amp;&amp; kill -USR1 `cat /var/run/nginx.pid`</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://serverfault.com/questions/427144/how-to-limit-nginx-access-log-file-size-and-compress">How to limit nginx access log file size and compress?</a></p><h2 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h2><p>防火墙状态查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iptables -nvL  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放指定的端口</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 9000 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暴露docker swarm需要的端口，如果不使用docker swarm不需要打开端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 2377 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 7946 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p udp --dport 7946 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 4789 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p udp --dport 4789 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="ntpd"><a href="#ntpd" class="headerlink" title="ntpd"></a>ntpd</h2><blockquote><p>时间同步工具</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install ntp</span><br><span class="line">ntpdate time.pool.aliyun.com</span><br><span class="line">systemctl enable ntpd</span><br></pre></td></tr></table></figure><p>三台机器时钟同步</p><p>时间同步的⽅式：在集群中找⼀台机器，作为时间服务器。 通过⽹络连接外⽹进⾏时钟同步, 此台机器需要保证能连上外⽹。</p><p>集群中其他机器与这台机器定时的同步时间，每隔一段时间(⼗分钟)同步⼀次时间。</p><p>1.时间服务器配置（必须root⽤户）</p><p>第⼀步:确定是否安装了ntpd的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntpd</span><br></pre></td></tr></table></figure><p>启动ntpd的服务 service ntpd start 设置ntpd的服务开机启动 chkconfig ntpd on</p><p>第⼀步:确定是否安装了ntpd的服务 rpm -qa | grep ntpd</p><p>第⼆步:编辑/etc/ntp.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">编辑第⼀台机器的/etc/ntp.conf</span><br><span class="line">vim /etc/ntp.conf </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在⽂件中添加如下内容 </span></span><br><span class="line">restrict 192.168.80.0 mask 255.255.255.0 nomodify</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释⼀下四⾏内容 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 0.centos.pool.ntp.org </span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 1.centos.pool.ntp.org </span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 2.centos.pool.ntp.org </span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 3.centos.pool.ntp.org </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 去掉以下内容的注释，如果没有这两⾏注释，那就⾃⼰添加上 </span></span><br><span class="line">server 127.127.1.0 # local clock </span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br></pre></td></tr></table></figure><p>配置以下内容，保证BIOS与系统时间同步添加⼀⾏内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconﬁg/ntpd</span><br><span class="line">SYNC_HWLOCK=yes</span><br></pre></td></tr></table></figure><p>第三步：</p><p>重新启动ntpd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service ntpd status</span><br><span class="line">service ntpd start</span><br></pre></td></tr></table></figure><p>使NTP服务可以在系统引导的时候⾃动启动 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig ntpd on</span><br></pre></td></tr></table></figure><p>2.其他机器配置（必须root⽤户）</p><p>第⼀步：在其他机器配置10分钟与时间服务器同步⼀次</p><p>crontab -e 编写脚本 另外两台机器与192.168.80.121进⾏时钟同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/10 * * * * /usr/sbin/ntpdate 192.168.80.121</span><br></pre></td></tr></table></figure><p>第⼆步：修改任意机器时间, 进行验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2020-12-31 11:11:11&quot;</span><br></pre></td></tr></table></figure><p>第三步：⼗分钟后查看机器是否与时间服务器同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;默认安装好客户端，对于海外的服务器进行转发有时连接效果较好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hive 安装</title>
    <link href="http://example.com/2020/11/10/Hive-%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2020/11/10/Hive-%E5%AE%89%E8%A3%85/</id>
    <published>2020-11-09T17:34:47.000Z</published>
    <updated>2021-04-13T00:36:06.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><strong>安装MySQL 数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># 安装 Docker</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># 安装 MySQL、配置 MYSQL</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">mysql_volume_root&#x3D;&#x2F;opt&#x2F;janhen&#x2F;software&#x2F;mysql</span><br><span class="line"></span><br><span class="line">mysql_container_name&#x3D;Mysql_linux121</span><br><span class="line">docker rm -f mysql_container_name</span><br><span class="line">docker run -d --name mysql_container_name \</span><br><span class="line">  --privileged \</span><br><span class="line">  --restart&#x3D;always \</span><br><span class="line">  -v $mysql_volume_root&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">  -v $mysql_volume_root&#x2F;conf&#x2F;mysqld.cnf:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf \</span><br><span class="line">  -v $mysql_volume_root&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD&#x3D;hadoop123janhen \</span><br><span class="line">  mysql:5.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker exec -it $mysql_container_name \</span><br><span class="line">  mysql -uroot -p hadoop123janhen \</span><br><span class="line">  -e &quot;SET GLOBAL validate_password_policy&#x3D;0&quot;</span><br><span class="line"></span><br><span class="line">CREATE user &#39;hive&#39;@&#39;%&#39; IDENTIFIED BY &#39;youpassword&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;hive&#39;@&#39;%&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">mysql -uhive -p Hive123Hadoop</span><br></pre></td></tr></table></figure><p><strong>复制 MySQL 驱动</strong></p><p>复制 mysql-connector-java-5.1.46.jar 拷贝到 <code>$HIVE_HOME/lib</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># 安装 Hive、配置 Hive</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># 配置环境变量</span><br><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">#.</span><br><span class="line">#├── bin</span><br><span class="line">#│   ├── beeline</span><br><span class="line">#│   ├── hive</span><br><span class="line">#│   ├── hive-config.sh</span><br><span class="line">#│   ├── hiveserver2</span><br><span class="line">#│   └── schematool</span><br><span class="line">        ...</span><br><span class="line">#├── conf</span><br><span class="line">#│   ├── hive-default.xml.template</span><br><span class="line">#│   ├── hive-env.sh.template</span><br><span class="line">#│   ├── hive-site-local.xml</span><br><span class="line">          ...</span><br><span class="line">#├── hcatalog</span><br><span class="line">#│   ├── bin</span><br><span class="line">#│   ├── etc</span><br><span class="line">         ...</span><br><span class="line">#├── lib36</span><br><span class="line">+fd</span><br><span class="line">#│   ├── asm-3.1.jar</span><br><span class="line">#│   ├── avro-1.7.7.jar</span><br><span class="line">#│   ├── derby-10.10.2.0.jar</span><br><span class="line">#│   ├── druid-common-0.9.2.jar</span><br><span class="line">#│   ├── findbugs-annotations-1.3.9-1.jar</span><br><span class="line">#│   ├── hbase-annotations-1.1.1.jar</span><br><span class="line">#│   ├── hbase-hadoop2-compat-1.1.1.jar</span><br><span class="line">#│   ├── hbase-hadoop2-compat-1.1.1-tests.jar</span><br><span class="line">#│   ├── hbase-hadoop-compat-1.1.1.jar</span><br><span class="line">#│   ├── hive-beeline-2.3.7.jar</span><br><span class="line">#│   ├── hive-exec-2.3.7.jar</span><br><span class="line">#│   ├── hive-hcatalog-core-2.3.7.jar</span><br><span class="line">#│   ├── hive-hplsql-2.3.7.jar</span><br><span class="line">#│   ├── hive-jdbc-2.3.7.jar</span><br><span class="line">#│   ├── mysql-metadata-storage-0.9.2.jar</span><br><span class="line">#│   ├── netty-3.6.2.Final.jar</span><br><span class="line">#│   ├── snappy-java-1.0.5.jar</span><br><span class="line">#│   └── zookeeper-3.4.6.jar</span><br><span class="line">#│   └── ...</span><br><span class="line">#└── scripts</span><br><span class="line">#    └── ...</span><br></pre></td></tr></table></figure><p><strong>配置环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">export HIVE_HOME=/opt/janhen/servers/hive-2.3.7</span><br><span class="line">export PATH=$PATH:$HIVE_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="配置本地元数据管理"><a href="#配置本地元数据管理" class="headerlink" title="配置本地元数据管理"></a><strong>配置本地元数据管理</strong></h3><p><code>$HIVE_HOME/conf/hive-site.xml</code></p><p>当启动一个hive 服务时，其内部会启动一个metastore服务。Hive根据 hive.metastore.uris 参数值来判断，如果为空，则为本地模式。</p><p>缺点：每启动一次hive服务，都内置启动了一个metastore；在hive-site.xml中暴露 的数据库的连接信息；</p><p>优点：配置较简单，本地模式下hive的配置中指定mysql的相关信息即可。</p><p><font color="green"><u>在xml文件中 <code>&amp;amp;</code> 表示 &amp;</u></font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hive元数据的存储位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://linux121:3306/hivemetadata?createDatabaseIfNotExist=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定驱动程序 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接数据库的用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接数据库的口令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>youpassword<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据默认的存储位置(HDFS) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在命令行中，显示当前操作的数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在命令行中，显示数据的表头 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 操作小规模数据时，使用本地模式，提高效率 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.mode.local.auto<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对数据进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure><h3 id="配置远程元数据管理"><a href="#配置远程元数据管理" class="headerlink" title="配置远程元数据管理"></a><strong>配置远程元数据管理</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 metastore 服务管理元数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>thrift://linux121:9083,thrift://linux123:9083<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.client.socket.timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3600<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据默认的存储位置(HDFS) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在命令行中，显示当前操作的数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在命令行中，显示数据的表头 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 操作小规模数据时，使用本地模式，提高效率 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.mode.local.auto<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a><strong>配置日志</strong></h3><p>Hive的log默认存放在 /tmp/root 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi $HIVE_HOME/conf/hive-log4j2.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加配置</span></span><br><span class="line">property.hive.log.dir = /opt/janhen/hive-2.3.7/logs</span><br></pre></td></tr></table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a><strong>配置参数</strong></h3><p>配置方式</p><ul><li>用户自定义配置文件(hive-site.xml)</li><li>启动hive时指定参数(-hiveconf)</li><li>hive命令行指定参数(set)</li></ul><p>配置的优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set ---&gt; -hiveconf ---&gt; hive-site.xml ---&gt; hive-default.xml</span><br></pre></td></tr></table></figure><p>启动时指定参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动时指定参数</span></span><br><span class="line">hive -hiveconf hive.exec.mode.local.auto=true</span><br></pre></td></tr></table></figure><p>命令执行时更改</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看全部参数 </span></span><br><span class="line">hive&gt; set;</span><br><span class="line">hive&gt; set hive.exec.mode.local.auto;</span><br></pre></td></tr></table></figure><h3 id="启动与验证"><a href="#启动与验证" class="headerlink" title="启动与验证"></a>启动与验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 Hive Metastore</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line">cd $HIVE_HOME/bin</span><br><span class="line">nohup hive --service metastore &amp;</span><br><span class="line">lsof -i:9083</span><br><span class="line">tail -f -n 500 nohup.out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 HiveServer2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line">nohup hiveserver2 &amp;</span><br><span class="line">lsof -i:10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 浏览器验证</span></span><br><span class="line">http://linux123:10002/</span><br></pre></td></tr></table></figure><p><strong>初始化元数据 - MySql</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure><p><strong>连接 Hive</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive</span><br><span class="line">hive&gt; show functions;</span><br></pre></td></tr></table></figure><p>下载网址：<a href="http://archive.apache.org/dist/hive/">http://archive.apache.org/dist/hive/</a></p><p>文档网址：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual">https://cwiki.apache.org/confluence/display/Hive/LanguageManual</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;软件安装&quot;&gt;&lt;a href=&quot;#软件安装&quot; class=&quot;headerlink&quot; title=&quot;软件安装&quot;&gt;&lt;/a&gt;软件安装&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;安装MySQL 数据库&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop 集群环境搭建</title>
    <link href="http://example.com/2020/11/10/Hadoop-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2020/11/10/Hadoop-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-11-09T17:23:23.000Z</published>
    <updated>2020-11-10T15:07:55.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>集群规划</strong></p><table><thead><tr><th>框架</th><th>linux121</th><th>linux122</th><th>linux123</th></tr></thead><tbody><tr><td>HDFS</td><td>NameNode、DataNode</td><td>DataNode</td><td>SecondaryNameNode、DataNode</td></tr><tr><td>YARN</td><td>NodeManager</td><td>NodeManager</td><td>NodeManager、ResourceManager</td></tr></tbody></table><p><strong>安装 JDK</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/java</span><br><span class="line">wget http://download.janhen.com/tools/jdk-8u251-linux-x64.tar.gz</span><br><span class="line">tar -zxvf jdk-8u251-linux-x64.tar.gz -C /usr/local/java</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_251</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p><strong>SSH 免密登陆</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/.ssh </span><br><span class="line">chmod 700 /root/.ssh</span><br><span class="line"></span><br><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -P &quot;&quot;</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line">scp authorized_keys linux122:/root/.ssh/</span><br><span class="line">scp authorized_keys linux123:/root/.ssh/</span><br></pre></td></tr></table></figure><p><strong>本地域名配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx linux121</span><br><span class="line">xxx linux122</span><br><span class="line">xxx linux123</span><br></pre></td></tr></table></figure><p>准备安装的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;opt&#x2F;janhen&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 防火墙关闭</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line">vi /etc/selinux/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 软件安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line">mkdir -p /opt/janhen/</span><br><span class="line">cd /opt/janhen</span><br><span class="line">wget https://archive.apache.org/dist/hadoop/common/hadoop-2.9.2/hadoop-2.9.2.tar.gz</span><br><span class="line">tar -zxvf hadoop-2.9.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 环境变量配置</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_251</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME=/opt/janhen/hadoop-2.9.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java</span><br><span class="line">java -version</span><br><span class="line">hadoop version</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> JDK路径明确配置给HDFS</span></span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/hadoop-env.sh</span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/core-site.xml</span><br><span class="line"></span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/hdfs-site.xml</span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/mapred-env.sh</span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/mapred-site.xml</span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/yarn-env.sh</span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/yarn-site.xml</span><br><span class="line">vi $HADOOP_HOME/etc/hadoop/slaves</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改权限</span></span><br><span class="line">chown -R root:root $HADOOP_HOME</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line">hadoop namenode -format</span><br><span class="line">hadoop_tmp_dir=/home/hadoop/data/tmp</span><br><span class="line">metadata_file=fsimage_0000000000000000000</span><br><span class="line">cd $hadoop_tmp_dir/dfs/name/current</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动NameNode</span></span><br><span class="line">hadoop-daemon.sh stop namenode</span><br><span class="line">hadoop-daemon.sh start namenode</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动DataNode</span></span><br><span class="line">hadoop-daemon.sh start datanode</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 yarn</span></span><br><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 yarn 从即诶单</span></span><br><span class="line">yarn-daemon.sh start nodemanager</span><br><span class="line"></span><br><span class="line">jps | grep NameNode</span><br><span class="line">jps | grep DataNode</span><br><span class="line">jps | grep ResourceManager</span><br><span class="line">jps | grep NodeManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试集群</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ================================================</span></span><br><span class="line">hdfs dfs -mkdir -p /test/input</span><br><span class="line"></span><br><span class="line">cat &gt; /root/test.txt &lt;&lt;EOF</span><br><span class="line">hello hdfs ...</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上传linxu文件到Hdfs</span></span><br><span class="line">hdfs dfs -put /root/test.txt /test/input</span><br><span class="line">hdfs dfs -get /test/input/test.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------测试词频统计执行--------</span></span><br><span class="line">cat &gt; /root/wc.txt &lt;&lt;EOF</span><br><span class="line">hadoop mapreduce yarn</span><br><span class="line">hdfs hadoop mapreduce</span><br><span class="line">mapreduce yarn spark</span><br><span class="line">flink hql</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">hdfs dfs -ls /</span><br><span class="line">hdfs dfs -du /</span><br><span class="line">hdfs dfs -mkdir /wcinput</span><br><span class="line">hdfs dfs -put /root/wc.txt /wcinput</span><br><span class="line">hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar wordcount /wcinput /wcoutput</span><br><span class="line">hdfs dfs -cat /wcoutput/part-r-00000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------日志收集--------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动历史服务器</span></span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br><span class="line">jps | grep JobHistoryServer</span><br><span class="line"></span><br><span class="line">curl http://linux121:19888/jobhistory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------日志配置--------</span></span><br><span class="line">yarn-daemon.sh stop resourcemanager</span><br><span class="line">yarn-daemon.sh stop nodemanager</span><br><span class="line">mr-jobhistory-daemon.sh stop historyserver</span><br><span class="line"></span><br><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line">yarn-daemon.sh stop resourcemanager</span><br><span class="line">yarn-daemon.sh start nodemanager</span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">19888,9000,50090,50010,6379,9092,8088,8080</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证地址</span></span><br><span class="line">jobhistory</span><br><span class="line">linux121:19888</span><br></pre></td></tr></table></figure><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://archive.apache.org/dist/hadoop/common/hadoop-2.9.2/">Hadoop 安装包地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;集群规划&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Hadoop" scheme="http://example.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组类问题</title>
    <link href="http://example.com/2020/11/10/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/10/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-09T17:03:57.000Z</published>
    <updated>2020-11-09T17:07:11.087Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数组旋转 k 位</strong></p><p><a href="https://leetcode.com/problems/rotate-array/">189. Rotate Array</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    k = k % n;                     <span class="comment">// prevent unnecessary rotate</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, n-k-<span class="number">1</span>);</span><br><span class="line">    reverse(nums, n-k, n-<span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;数组旋转 k 位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-array/&quot;&gt;189. Rotate Array&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二分查找及变种</title>
    <link href="http://example.com/2020/11/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2020/11/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-11-09T16:56:19.000Z</published>
    <updated>2021-04-13T00:32:22.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>（1） 算法</p><p>（2） 复杂度</p><p>O(logN)</p><p>（3）性质</p><ul><li><p>适用于处理 ceil、floor 等操作；</p></li><li><p>配合索引相当于是实现了跳表结构；</p></li></ul><p><strong>1、 普通二分查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、 带有重复元素的二分查找-最先&amp;最后</strong></p><p>（1） 查找含有重复元素的数组集合中元素第一次出现的位置</p><p>在相等的情况下，进行判断决定是否进行缩小范围或找到对应的值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == aim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] != nums[mid])  <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; aim) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 查找含有重复元素的数组集合中元素最后一次出现的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid] != nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; key) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 二分查找-大于&amp;小于</strong></p><p>（1） 查找小于等于给定元素的最小元素在数组中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchFloor</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length-<span class="number">1</span> || nums[mid+<span class="number">1</span>] &gt; key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 查找大于等于给定元素的最小元素在数组中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchCeil</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] &lt; key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、 带偏移的二分查找</strong></p><p>用于旋转数组的查找，偏移后数据有序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchOffset</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> realMid = (mid + offset) % nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[realMid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; key) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;p&gt;（1） 算法&lt;/p&gt;
&lt;p&gt;（2） 复杂度&lt;/p&gt;
&lt;p&gt;O(logN)&lt;/p&gt;
&lt;p&gt;（3）性质&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础排序及变种</title>
    <link href="http://example.com/2020/11/10/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2020/11/10/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-09T16:51:39.000Z</published>
    <updated>2021-04-19T15:04:00.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本的排序算法，以及变种</p></blockquote><p><a href="https://www.notion.so/f0d201fbc4234aa292d96bca0100661d">排序比较</a></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>（1） 算法:</p><p>选择数组中最小的元素, 将它与数组的第一个元素交换, 之后开始次小元元素… （2） 复杂度</p><p>比较: N²/2, 交换: N 最坏: O(n²)</p><p>最好: O(n²)，</p><p>平均: O(n²)</p><p>（3） 性质:</p><ul><li>运行时间与输入无关；</li><li>不稳定；</li><li>原地排序；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>（1） 算法: 从左到右不断交换相邻逆序的元素, 经过一次循环确定最后一个元素到达最右侧 存在传入数组已经有序的情况</p><p>（2） 复杂度分析: 最坏: O(n²) 最好: O(n), 集合有序, 需要进行一次冒泡 平均: O(n²)</p><p>（3） 性质：</p><ul><li>元素交换的次数为固定值, 原始数据的逆序度 需要三次赋值操作；</li><li>稳定；</li><li>原地排序；</li></ul><p><strong>1、基础冒泡</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --)  <span class="comment">// insure N-1~1 position, 0 must in correct position</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序性优化"><a href="#有序性优化" class="headerlink" title="有序性优化"></a><strong>有序性优化</strong></h3><p>对于已经有序的数据，不进行元素交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasSorted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !hasSorted; i --) &#123;  <span class="comment">// except bad condtion</span></span><br><span class="line">        hasSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;    <span class="comment">// when equal not modify original order</span></span><br><span class="line">                hasSorted = <span class="keyword">false</span>;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>（1）算法: 将数组分为两部分，将后部分元素逐一与前部分元素比较，如果前部分元素比 array[i] 小，就将前部分元素往后移动。当没有比 array[i] 小的元素，即是合理位置，在此位置插入 array[i]。</p><p>（2） 复杂度分析</p><p>最坏: O(n²), 数组逆序, 需要 N²/2 比较 N²/2 交换</p><p>最好: O(n), 正序, 需要 N-1 比较 0 次交换 平均: O(n^2) N²/4 比较 N²/4 交换</p><p>（3） 性质:</p><ul><li>复杂度取决于数组的初始顺序， 移动次数为逆序对的数量；</li><li>稳定；</li><li>原地排序；</li></ul><p><strong>基础插入排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortB</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j --)</span><br><span class="line">            swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值优化"><a href="#赋值优化" class="headerlink" title="赋值优化"></a><strong>赋值优化</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[i], j;   <span class="comment">// e current element, j should put position</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e &lt; arr[j-<span class="number">1</span>])</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表实现插入排序"><a href="#链表实现插入排序" class="headerlink" title="链表实现插入排序"></a><strong>链表实现插入排序</strong></h3><p><a href="https://leetcode.com/problems/insertion-sort-list/">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode first = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode cur = head;  <span class="comment">//the node will be inserted</span></span><br><span class="line">  ListNode pre = first; <span class="comment">//insert node between pre and pre.next</span></span><br><span class="line">  ListNode next = <span class="keyword">null</span>; <span class="comment">//the next node will be inserted</span></span><br><span class="line">  <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    next = cur.next;</span><br><span class="line">    <span class="comment">//find the right place to insert</span></span><br><span class="line">    <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val) &#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//insert between pre and pre.next</span></span><br><span class="line">    cur.next = pre.next;</span><br><span class="line">    pre.next = cur;</span><br><span class="line">    pre = first;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="http://img.janhen.com/20210130164857image-20201122224138741.png" alt="http://img.janhen.com/20210130164857image-20201122224138741.png"></p><p>希尔排序可视轨迹</p><p>（1） 算法：使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p>（2） 复杂度分析： 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。</p><p>（3） 性质：</p><ul><li>交换不相邻元素，将逆序数量减少大于1；</li><li>基于原来的插入排序；</li><li>不稳定；</li><li>原地排序；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i += h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h; j -= h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j-h]) swap(arr, j, j - h);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>（1） 思想: 分治, 分区</p><p>（2） 复杂度: 由每次选取的分割点控制 最好: 每次分割点都为中间的元素， O(logN) 最坏: 每次分割点都为最后元素 O(n²)</p><p>（3） 性质:</p><ul><li>每趟排序就有一个元素排在了最终的位置上，第n趟结束，<strong>至少</strong>有n个元素已经排在了最终的位置上；</li><li>非稳定</li><li>原地排序</li></ul><p>（4） 归并 VS 快排: 归并由下到上, 先处理子问题之后合并，快排由上到下, 先进行分区然后处理子问题；</p><p>归并非原地排序，需要辅助空间，快排通过原地分区函数实现原地排序；</p><p>归并排序为稳定的排序，保留原来相同值的顺序；</p><p>（5） 优化: 三数取中法 随机选取法</p><p><strong>随机取枢纽元</strong></p><p>小数据集使用插入排序；</p><p>随机选择枢纽元比较；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        insertSort(arr, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = partition(arr, lo, hi);</span><br><span class="line">    quickSort(arr, lo, j - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, j +<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速选择；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    swap(arr,lo,lo +(<span class="keyword">int</span>) Math.random() * (hi-lo+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[++ i] &lt; pivot) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[-- j] &gt; pivot) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, j, lo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三路快排优化"><a href="#三路快排优化" class="headerlink" title="三路快排优化"></a><strong>三路快排优化</strong></h3><p><img src="http://img.janhen.com/20210130164902image-20201122224436315.png" alt="http://img.janhen.com/20210130164902image-20201122224436315.png"></p><p>三向切分快排可视轨迹</p><p>对重复元素较多的情形优化；</p><p>函数返回重复元素第一次和最后一次出现位置；</p><p>类似荷兰国旗问题的处理；</p><p>相关： <a href="https://leetcode.com/problems/sort-colors/description/">75. Sort Colors</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo,<span class="keyword">int</span> hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo - <span class="number">1</span>, gt = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;              <span class="comment">// 各个区间的语义</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] == pivot) </span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            swap(arr, i ++, ++ lt);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            swap(arr, i, -- gt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;lt+<span class="number">1</span>, gt-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数取中值确定枢纽元优化"><a href="#三数取中值确定枢纽元优化" class="headerlink" title="三数取中值确定枢纽元优化"></a><strong>三数取中值确定枢纽元优化</strong></h3><p>枢纽元的选取上进行优化；</p><p>选取边界和中间数将三处进行排序，选择中间元素作为枢纽元，并放入 [hi-1] 位置；</p><p>之后 [lo], [hi] 可以作为快排内循环的哨兵；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort three element AND put hi-1 position</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">medianOf3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[lo] &gt; arr[mid]) swap(arr, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (arr[lo] &gt; arr[hi]) swap(arr, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[hi]) swap(arr, mid, hi);</span><br><span class="line">    swap(arr, mid, hi - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[hi - <span class="number">1</span>];        <span class="comment">// pivot is mid value, and position is hi-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> pivot)</span> </span>&#123;  <span class="comment">// pivot original position hi - 1</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++ i] &lt; pivot);   <span class="comment">// <span class="doctag">NOTE:</span> [hi-1] as sentinel</span></span><br><span class="line">        <span class="keyword">while</span> (arr[-- j] &gt; pivot);   <span class="comment">// [lo] as sentinel</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, hi - <span class="number">1</span>);  <span class="comment">// put pivot as correct position</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt;= INSERTITION_SORT_THRESHOLD) &#123;</span><br><span class="line">        insertSort(arr, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> median = medianOf3(arr, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = partition(arr, lo, hi, median);</span><br><span class="line">    quickSort(arr, lo, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr,i +<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>（1） 算法</p><p>（2） 复杂度</p><p>大部分为 O(NlogN)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T(n) = 2T(n/2) + n = 2(2T(n/4) + n/2) + n </span><br><span class="line">     = 4T(n/4) + 2n = 4(2T(n/8) + n/4) + 2n </span><br><span class="line">     = 8T(n/8) + 3n = 8(2T(n/16) + n/8) + 3n </span><br><span class="line">     = 16T(n/16) + 4n …… = 2^k  T(n/2^k) + k * n</span><br></pre></td></tr></table></figure><p>（3） 性质</p><ul><li>大数据量情况下出现无法分配空间情况；</li><li>稳定的排序；</li><li>非原地排序；</li></ul><p><strong>基础归并排序</strong></p><p><img src="http://img.janhen.com/20210130164907image-20201122224009106.png" alt="http://img.janhen.com/20210130164907image-20201122224009106.png"></p><p>自顶向下归并排序可视轨迹</p><p>① 对排序的两个子数组 [lo,mid], [mid+1, hi]，在 [mid] &gt;= [mid+1] 数组整体有序情况下跳过合并；</p><p>② 分配当前两个数组对应的数组空间作为辅助；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; INSERTITION_SORT_THRESHOLD) &#123;</span><br><span class="line">        insertSort(arr, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, lo, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])    loopArrQueue</span><br><span class="line">    merge(arr, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[hi - lo + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; aux.length; k ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) aux[k] = arr[j ++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) aux[k] = arr[i ++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; arr[j]) aux[k] = arr[i ++];</span><br><span class="line">        <span class="keyword">else</span> aux[k] = arr[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; aux.length; k ++) </span><br><span class="line">       arr[k + lo] = aux[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a><strong>自底向上的归并排序</strong></h3><p><img src="http://img.janhen.com/20210130164913image-20201122223815424.png" alt="http://img.janhen.com/20210130164913image-20201122223815424.png"></p><p>自底向上的归并排序可视轨迹</p><p>考虑处理两种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P1  __ __ | __ __ | __ __ | _       i + sz &lt; arr.length to control</span><br><span class="line">P2  __ __ | __ __ | __ __ | __ _    min&#123;i + sz + sz - 1, arr.length - 1&#125; to control</span><br></pre></td></tr></table></figure><p>sz 为两个子数组的区间大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N;  sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; N; i += sz + sz) &#123;  loopArrQueue</span><br><span class="line">            merge(arr, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, N-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用链表进行归并排序"><a href="#使用链表进行归并排序" class="headerlink" title="使用链表进行归并排序"></a><strong>使用链表进行归并排序</strong></h3><p>执行过程：</p><p>① 找出中间节点，分割链表；</p><p>② 对分割的链表分别进行归并排序；</p><p>③ 将链表合并；</p><p>相关： <a href="https://leetcode.com/problems/sort-list/">leetcode</a> | <a href="https://leetcode-cn.com/problems/sort-list/">leetcode-cn</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. find mid node and cut two list</span></span><br><span class="line">  ListNode preMid = preMidNode(head);</span><br><span class="line">  ListNode mid = preMid.next;</span><br><span class="line">  preMid.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 2. handle two sub problem</span></span><br><span class="line">  ListNode l1 = sortList(head);</span><br><span class="line">  ListNode l2 = sortList(mid);</span><br><span class="line">  <span class="comment">// 3. merge result</span></span><br><span class="line">  <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">preMidNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  ListNode pre = <span class="keyword">null</span>, fast = head, slow = head;</span><br><span class="line">  <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = merge(l1.next, l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    l2.next = merge(l1, l2.next);</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并-k-个已经排序的链表"><a href="#合并-k-个已经排序的链表" class="headerlink" title="合并 k 个已经排序的链表"></a><strong>合并 k 个已经排序的链表</strong></h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">leetcode-cn</a> | <a href="https://leetcode.com/problems/merge-k-sorted-lists/">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mergeSortList(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSortList</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">      <span class="keyword">return</span> lists[lo];  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    ListNode left = mergeSortList(lists, lo, mid);</span><br><span class="line">    ListNode right = mergeSortList(lists, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">return</span> merge(left, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并两个排序的链表</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      l1.next = merge(l1.next, l2);</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l2.next = merge(l1, l2.next);</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="http://img.janhen.com/20210130164926image-20201122225020506.png" alt="http://img.janhen.com/20210130164926image-20201122225020506.png"></p><p>堆排序可视轨迹</p><p>（1） 算法</p><p>（2） 复杂度</p><p>O(logN)</p><p>（3） 性质</p><ul><li>无法利用到现代处理器的缓存局部性原理，一般不使用；</li><li>不稳定；</li><li>原地排序，适用于嵌入式系统中内存小的情况；</li></ul><p><strong>基础堆排序</strong></p><p>先通过向堆中不断插入元素，向上调整形成堆结构；</p><p>之后不断删除堆顶元素实现排序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i ++)</span><br><span class="line">        heapify(arr, i);                            <span class="comment">// heapInsert</span></span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;                              <span class="comment">// heapify: delete and adjust heap structure</span></span><br><span class="line">        swap(arr, -- N, <span class="number">0</span>);</span><br><span class="line">        sink(arr, N, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[k] &gt; arr[(k - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, k, (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        k = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">            j ++;</span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt;= arr[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a><strong>算法优化</strong></h3><p>与 java.util.ProrityQueue 中实现逻辑相同</p><p>① 通过 sink 向下调整进行优化；</p><p>② 下沉操作中使用赋值替代交换，常数级优化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (N - <span class="number">2</span>)  / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)      <span class="comment">// build heap</span></span><br><span class="line">        sink(arr, i, N);</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;                   <span class="comment">// delete max ⇔ put into last position</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, -- N);</span><br><span class="line">        sink(arr, <span class="number">0</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = arr[k];</span><br><span class="line">    <span class="keyword">while</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">    j = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= arr[j])  <span class="keyword">break</span>;</span><br><span class="line">        arr[k] = arr[j];</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[k] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并-k-个已经排序的链表-1"><a href="#合并-k-个已经排序的链表-1" class="headerlink" title="合并 k 个已经排序的链表"></a><strong>合并 k 个已经排序的链表</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化加载所有链表的头节点</span></span><br><span class="line">  PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, Comparator.comparingInt(l -&gt; l.val));   <span class="comment">// list like each data flow</span></span><br><span class="line">  <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pq.offer(list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较每条链表当前的头节点</span></span><br><span class="line">  ListNode first = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">  ListNode cur = first;</span><br><span class="line">  <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">    cur.next = pq.poll();</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pq.offer(cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基本的排序算法，以及变种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/f0d201fbc4234aa292d96bca0100661d&quot;&gt;排序比较&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;选择排序</summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
