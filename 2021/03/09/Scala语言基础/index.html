<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Scala语言基础 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Scala 基础语言起源 12345马丁·奥德斯基（Martin Odersky）是编译器及编程的狂热爱好者。主流JVM的Javac编译器就是马丁·奥德斯基编写出来的，JDK5.0、JDK8.0的编译器就是他写的。 长时间的编程之后，他希望发明一种语言，能够让写程序这样的基础工作变得高效，简单。 当接触到Java语言后，对Java这门语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala语言基础">
<meta property="og:url" content="http://example.com/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Scala 基础语言起源 12345马丁·奥德斯基（Martin Odersky）是编译器及编程的狂热爱好者。主流JVM的Javac编译器就是马丁·奥德斯基编写出来的，JDK5.0、JDK8.0的编译器就是他写的。 长时间的编程之后，他希望发明一种语言，能够让写程序这样的基础工作变得高效，简单。 当接触到Java语言后，对Java这门语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到Jav">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://img.janhen.com/20210306153957XEmR1i.png">
<meta property="article:published_time" content="2021-03-09T13:23:27.000Z">
<meta property="article:modified_time" content="2021-03-09T13:25:24.549Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Scala">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.janhen.com/20210306153957XEmR1i.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Scala语言基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-03-09T13:23:27.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Scala语言基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Scala-基础"><a href="#Scala-基础" class="headerlink" title="Scala 基础"></a>Scala 基础</h2><p>语言起源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">马丁·奥德斯基（Martin Odersky）是编译器及编程的狂热爱好者。</span><br><span class="line"></span><br><span class="line">主流JVM的Javac编译器就是马丁·奥德斯基编写出来的，JDK5.0、JDK8.0的编译器就是他写的。 </span><br><span class="line">长时间的编程之后，他希望发明一种语言，能够让写程序这样的基础工作变得高效，简单。 </span><br><span class="line">当接触到Java语言后，对Java这门语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到Java中，由此发 明了Scala。</span><br></pre></td></tr></table></figure>

<p>语言特性：</p>
<ul>
<li>OOP</li>
<li>函数式编程</li>
<li>静态类型，参考 Haskell、Errlang</li>
<li>并发性，使用 Actor 作为并发模型，可复用线程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>Kafka、Spar 等框架底层都是使用 Scala 作为底层源码开发语言</li>
<li>融合大数据生态，Flink 支持 Scala 开发</li>
</ul>
<p><strong>Scala 的 REPL</strong></p>
<p>REPL 是一个交互式解析器环境，R(read)、E(evaluate) 、P（print）、L（loop） 输入值，交互式解析器会读取输入内容并对它求值，再打印结果，并重复此过程。</p>
<p>在命令行输入Scala可启动Scala REPL。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul>
<li>区分大小写 - Scala语言对大小写敏感</li>
<li>类名 - 对于所有的类名的第一个字母要大写。</li>
<li>方法名 - 所有方法名的第一个字母用小写。</li>
<li>程序文件名 - Scala程序文件的后缀名是 .scala，程序文件的名称可以不与对象名称完全匹配。</li>
<li>main()方法 - Scala程序从main()方法开始处理</li>
</ul>
<h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><ul>
<li>Int:</li>
<li>Unit: 无值，用于不返回任何结果的方法的返回类型。</li>
<li>Null</li>
<li>Nothing： 在Scala类层级的最低端，它是任何其他类型的子类型</li>
<li>Any: 是Scala中所有类的超类</li>
<li>AnyRef: 是Scala中所有引用类的超类</li>
</ul>
<p>Scala和Java一样，有8种数值类型 Byte、Short、Int、Long、Float、Double、Char、Boolean 类型；</p>
<p>Scala 并不刻意的区分基本类型和引用类型。</p>
<p>每一种数据类型都有对应的Rich类型，如RichInt、RichChar等，为基本类型提供了更多的有用操作。</p>
<h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p>Scala中，所有的类，包括值类型和引用类型，都最终继承自一个统一的根类型Any。</p>
<p><img src="http://img.janhen.com/20210306153957XEmR1i.png" alt="http://img.janhen.com/20210306153957XEmR1i.png"></p>
<ul>
<li>Null<ul>
<li>Null是所有引用类型的子类型</li>
<li>Null类只有一个实例对象null</li>
<li>null可以赋值给任意引用类型，但是不能赋值给值类型。</li>
</ul>
</li>
<li>Nothing<ul>
<li>Nothing位于Scala类继承关系的底部，它是其他所有其他类型的子类型</li>
<li>Nothing对泛型结构有用 。比如，空列表Nil的类型就是List[Nothing]</li>
<li>Nothing的可以给出非正常终止的信号。比如，使用Nothing处理异常</li>
</ul>
</li>
</ul>
<p>在Scala中，鼓励使用val。</p>
<p>简单数据类型可以省略，对于复杂的数据类型建议明确声明；</p>
<p><strong>操作符</strong></p>
<p>Scala中的操作符都是方法</p>
<p><strong>对象相等性</strong></p>
<p>Scala中，要比较两个基础类型的对象是否相等，可以使用 == 或 !=；</p>
<p>== 或 != 还可以比较不同类型的两个对象</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串插值器</p>
<ul>
<li>s 插值器： 对内嵌的每个表达式求值，对求值结果调用toString</li>
<li>f 插值器： 除s插值器的功能外，还能进行格式化输出，在变量后用%指定输出格式</li>
<li>raw 插值器： 按照字符串原样进行输出</li>
</ul>
<h2 id="控制结构和函数"><a href="#控制结构和函数" class="headerlink" title="控制结构和函数"></a>控制结构和函数</h2><p><strong>if 表达式</strong></p>
<p>if 表达式有返回值。</p>
<p>如果if 和 else 的返回值类型不一样，那么就返回两个返回值类型公共的父类。</p>
<p><strong>for 表达式</strong></p>
<p>for (i &lt;- 表达式 / 集合)，让变量 i遍历&lt;-右边的表达式/集合的所有值。</p>
<p>Scala为for循环提供了很多的特性，这些特性被称之为 for守卫式 或 for推导式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">10</span>) &#123;</span><br><span class="line">	println(<span class="string">s&quot;i = <span class="subst">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重循环。条件之间使用分号分隔</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">5</span>; j &lt;- <span class="number">2</span> until <span class="number">5</span>)&#123;</span><br><span class="line">	println(i * j )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 守卫语句。</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; j &lt;- <span class="number">1</span> to <span class="number">10</span> <span class="keyword">if</span> i==j)&#123;</span><br><span class="line">  println(<span class="string">s&quot;i * j = <span class="subst">$i</span> * <span class="subst">$j</span> = <span class="subst">$&#123;i * j&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for推导式, yield 接收返回的结果</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用大括号将生成器、守卫、定义包含在其中；并以换行的方式来隔开它们</span></span><br><span class="line"><span class="keyword">for</span> &#123; i &lt;- <span class="number">1</span> to <span class="number">3</span></span><br><span class="line">  from = <span class="number">4</span> - i</span><br><span class="line">  j &lt;- from to <span class="number">3</span> &#125;</span><br><span class="line">  println(<span class="string">s&quot;i = <span class="subst">$i</span>; j = <span class="subst">$j</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>while 表达式</strong></p>
<p>while语句的本身没有任何返回值类型，即while语句的返回结果是Unit类型的 () 。</p>
<p>Scala内置控制结构特地去掉了 break 和 continue。</p>
<p>终止循环的方式：</p>
<ul>
<li>使用Boolean类型的控制变量</li>
<li>使用 return</li>
<li>使用 breakable和break，需要导入scala.util.control.Breaks包</li>
</ul>
<h3 id="懒值"><a href="#懒值" class="headerlink" title="懒值"></a>懒值</h3><p>当 val 被声明为lazy时(var不能声明为lazy)，初始化将被推迟，直到首次对此取值，适用于初始化开销较大的场景。</p>
<p><strong>惰性求值</strong></p>
<p>可根据 if 短路求值，避免不必要的 expensive  计算操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(input: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s&quot;evaluate called with <span class="subst">$input</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; expensiveComputation())</span><br><span class="line">    println(<span class="string">&quot;doing work...&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    println(<span class="string">&quot;skipping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evaluate(<span class="number">0</span>)</span><br><span class="line">evaluate(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>通过 scala 的懒加载处理</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> perform = expensiveComputation() </span><br><span class="line"><span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; perform) </span><br><span class="line">  println(“doing work…”)</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>导入scala.io.Source后，可引用Source中的方法读取文本文件的内容</p>
<p>Scala没有内建的对写入文件的支持。要写入文本文件，可使用 java.io.PrintWriter</p>
<h2 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h2><p>使用ArrayBuffer时，需要导包 import scala.collection.mutable.ArrayBuffer；</p>
<p><strong>多维数组</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dim = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">dim(<span class="number">1</span>)(<span class="number">1</span>) = <span class="number">11.11</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">2</span>; j &lt;- <span class="number">0</span> to <span class="number">3</span>) &#123;</span><br><span class="line">  print(dim(i)(j) + <span class="string">&quot; &quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">3</span>) println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元组和操作</strong></p>
<p>内建了 22 个 Tuple 类</p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>在Scala中，类并不用声明为public；</p>
<ul>
<li>val修饰的变量（常量），值不能改变，只提供getter方法，没有setter方法；</li>
<li>var修饰的变量，值可以改变，对外提供getter、setter方法；</li>
</ul>
<p><strong>自定义getter和setter方法</strong></p>
<p>Scala 类中的每一个属性，编译后会有一个私有的字段和相应的getter、setter方法生成。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getter方法</span></span><br><span class="line">println(person age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//setter方法</span></span><br><span class="line">person age_= (<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter方法</span></span><br><span class="line">println(person.age)</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>默认情况下，Scala 不遵循 JavaBean 约定，必须要使用 <code>@scala.reflect.BeanProperty</code> 注解来生成满足 JavaBean 约定的 getter 和 setter 方法</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>没有定义构造器，Scala类中会有一个默认的无参构造器；</p>
<p>的构造器分为两种：主构造器和辅助构造器；</p>
<p>主构造器的定义与类的定义交织在一起，将主构造器的参数直接放在类名之后。</p>
<p>当主构造器的参数不用var或val修饰时，参数会生成类的私有val成员。</p>
<p>Scala中，所有的辅助构造器都必须调用另外一个构造器</p>
<h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>没有提供Java那样的静态方法或静态字段；</p>
<p>可以采用object关键字实现单例对象，具备和Java静态方法同样的功能；</p>
<p>使用object语法结构【object是Scala中的一个关键字】达到静态方法和静态字段的目的；对象本质上可以拥有类的所有特性，除了不能提供构造器参数；</p>
<p>任何在Java中用单例对象的地方，在Scala中都可以用object实现：</p>
<ul>
<li>作为存放工具函数或常量的地方</li>
<li>高效地共享单个不可变实例</li>
</ul>
<p>Scala中的单例对象具有如下特点：</p>
<ul>
<li>创建单例对象不需要使用new关键字</li>
<li>object中只有无参构造器</li>
<li>主构造代码块只能执行一次，因为它是单例的</li>
</ul>
<p><strong>应用程序对象</strong></p>
<p>可以扩展App特质（trait) 来运行。</p>
<h3 id="伴生类与伴生对象"><a href="#伴生类与伴生对象" class="headerlink" title="伴生类与伴生对象"></a>伴生类与伴生对象</h3><p>单例对象与某个类具有相同的名称时，它被称为这个类的“伴生对象”；</p>
<p>类和它的伴生对象必须存在于同一个文件中，而且可以相互访问私有成员（字段和方法）；</p>
<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h3><p>object 中的特殊方法</p>
<ul>
<li>apply方法通常定义在伴生对象中，目的是通过伴生类的构造函数功能，来实现伴生对象的构造函数功能；</li>
<li>当遇到类名(参数1,…参数n)时apply方法会被调用；</li>
<li>在创建伴生对象或伴生类的对象时，通常不会使用new class/class() 的方式，而是<strong>直接使用 class()隐式的调用伴生对象的 apply 方法</strong></li>
</ul>
<p><strong>借助 apply 实现工厂设计模式</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">Dog</span> <span class="title">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;woof&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(str: <span class="type">String</span>): <span class="type">Animal</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;dog&quot;</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Dog</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cat = <span class="type">Animal</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">  cat.speak</span><br><span class="line">  <span class="keyword">val</span> dog = <span class="type">Animal</span>(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">  dog.speak</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>override方法重写</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">coding</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;coding...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaProgrammer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, workNo: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Programmer</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">coding</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">super</span>.coding()</span><br><span class="line">    println(<span class="string">&quot;我在写Scala代码。。。&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型检查与转换"><a href="#类型检查与转换" class="headerlink" title="类型检查与转换"></a>类型检查与转换</h3><ul>
<li>isInstanceOf： 测试某个对象是否属于某个给定的类</li>
<li>getClass</li>
<li>classOf</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Person...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Student...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">InstanceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">    <span class="keyword">var</span> student: <span class="type">Student</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    println(student.isInstanceOf[<span class="type">Student</span>])</span><br><span class="line">    <span class="comment">// function check</span></span><br><span class="line">    <span class="keyword">if</span> (person.isInstanceOf[<span class="type">Student</span>]) &#123;</span><br><span class="line">      student = person.asInstanceOf[<span class="type">Student</span>]</span><br><span class="line">      student.say()</span><br><span class="line">    &#125;</span><br><span class="line">    println(student.isInstanceOf[<span class="type">Student</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getClass check</span></span><br><span class="line">    println(person.getClass == classOf[<span class="type">Person</span>])</span><br><span class="line">    println(person.getClass == classOf[<span class="type">Student</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern match check</span></span><br><span class="line">    person <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> s: <span class="type">Student</span> =&gt;</span><br><span class="line">        s.say()</span><br><span class="line">        println(<span class="string">&quot;Student2 type match&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;default...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><p><strong>作为接口使用</strong></p>
<ul>
<li>在trait中可以定义抽象方法，与抽象类中的抽象方法一样，只要不给出方法的具体实现即可。</li>
<li>类可以使用extends关键字继承trait。</li>
<li>在Scala中没有implement的概念，无论继承类还是trait特质，统一都是extends。</li>
<li>类继承trait特质后，必须实现其中的抽象方法，实现时可以省略 override 关键字。</li>
<li>Scala不支持对类进行多继承，但是<strong>支持多重继承trait特质</strong>，使用with关键字即可。</li>
</ul>
<p><strong>特质构造顺序</strong></p>
<ul>
<li>执行父类的构造器；</li>
<li>执行trait的构造器，多个trait从左到右依次执行；</li>
<li>构造trait时会先构造父trait，如果多个trait继承同一个父trait，则父trait只会构造一次；</li>
<li>所有trait构造完毕之后，子类的构造器才执行</li>
</ul>
<h3 id="Ordered和Ordering"><a href="#Ordered和Ordering" class="headerlink" title="Ordered和Ordering"></a>Ordered和Ordering</h3><p>Ordered 特质混入 Java 的 Comparable 接口，它定义了相同类型间的比较方式，但这种内部比较方式是单一的；</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordered</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">A</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;  <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;  <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;= <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;= <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compareTo</span></span>(that: <span class="type">A</span>): <span class="type">Int</span> = compare(that)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ordering 特质混入 Comparator 接口，提供第三方比较器，可以自定义多种比较方式，在实际开发中也是使用比较多的，灵活解耦合。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation</span>.implicitNotFound(msg = <span class="string">&quot;No implicit Ordering defined for $&#123;T&#125;.&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Comparator</span>[<span class="type">T</span>] <span class="keyword">with</span> <span class="title">PartialOrdering</span>[<span class="type">T</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  outer =&gt;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tryCompare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="type">Some</span>(compare(x, y))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Int</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &lt;= <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &gt;= <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &lt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) &gt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equiv</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = compare(x, y) == <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">if</span> (gteq(x, y)) x <span class="keyword">else</span> y</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">if</span> (lteq(x, y)) x <span class="keyword">else</span> y</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reverse</span> </span>= outer</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = outer.compare(y, x)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">on</span></span>[<span class="type">U</span>](f: <span class="type">U</span> =&gt; <span class="type">T</span>): <span class="type">Ordering</span>[<span class="type">U</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">U</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">U</span>, y: <span class="type">U</span>) = outer.compare(f(x), f(y))</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Ops</span>(<span class="params">lhs: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(rhs: <span class="type">T</span>) = lt(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(rhs: <span class="type">T</span>) = lteq(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(rhs: <span class="type">T</span>) = gt(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(rhs: <span class="type">T</span>) = gteq(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equiv</span></span>(rhs: <span class="type">T</span>) = <span class="type">Ordering</span>.<span class="keyword">this</span>.equiv(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(rhs: <span class="type">T</span>): <span class="type">T</span> = <span class="type">Ordering</span>.<span class="keyword">this</span>.max(lhs, rhs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(rhs: <span class="type">T</span>): <span class="type">T</span> = <span class="type">Ordering</span>.<span class="keyword">this</span>.min(lhs, rhs)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">mkOrderingOps</span></span>(lhs: <span class="type">T</span>): <span class="type">Ops</span> = <span class="keyword">new</span> <span class="type">Ops</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Ordering</span> <span class="keyword">extends</span> <span class="title">LowPriorityOrderingImplicits</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]) = ord</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">by</span></span>[<span class="type">T</span>, <span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">S</span>]): <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">T</span>] &#123;</span><br><span class="line">	    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>) = ord.compare(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.lt(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gt</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.gt(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">gteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.gteq(f(x), f(y))</span><br><span class="line">	    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">lteq</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">Boolean</span> = ord.lteq(f(x), f(y))</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Sorting</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span>(<span class="params">tag: <span class="type">String</span>, score: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Project</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Project</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    tag.compareTo(that.tag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">Project</span>(<span class="string">&quot;hadoop&quot;</span>, <span class="number">40</span>), <span class="type">Project</span>(<span class="string">&quot;flink&quot;</span>, <span class="number">90</span>), <span class="type">Project</span>(<span class="string">&quot;spark&quot;</span>, <span class="number">80</span>), <span class="type">Project</span>(<span class="string">&quot;hive&quot;</span>, <span class="number">60</span>))</span><br><span class="line">    println(list.sorted)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pairs = <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">7</span>, <span class="number">2</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">9</span>, <span class="number">1</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="comment">// Ordering.by[(String,Int,Int),Int](_._2) 从 Tuple3 转到 Int 型，根据 Tuple3 第二个元素进行排序</span></span><br><span class="line">    <span class="type">Sorting</span>.quickSort(pairs)(<span class="type">Ordering</span>.by[(<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>), <span class="type">Int</span>](_._2))</span><br><span class="line">    println(pairs.toBuffer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配和样例类"><a href="#模式匹配和样例类" class="headerlink" title="模式匹配和样例类"></a>模式匹配和样例类</h2><ul>
<li>Scala没有Java中的switch case</li>
<li>Scala的模式匹配可以匹配各种情况，比如变量的类型、集合的元素、有值或无值。</li>
<li>模式匹配match case中，只要有一个case分支满足并处理了，就不会继续判断下一个case分支了</li>
</ul>
<h3 id="守卫式匹配"><a href="#守卫式匹配" class="headerlink" title="守卫式匹配"></a>守卫式匹配</h3><p>可增加 if 条件判断</p>
<h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><ul>
<li>可以直接匹配类型，而不是值</li>
</ul>
<h3 id="匹配数组、元组、集合"><a href="#匹配数组、元组、集合" class="headerlink" title="匹配数组、元组、集合"></a>匹配数组、元组、集合</h3><h3 id="case-class"><a href="#case-class" class="headerlink" title="case class"></a>case class</h3><p>样例类 默认实现了常用的方法，如 getter/setter, 默认序列化</p>
<ul>
<li>主构造器函数结构的参数不需要显示 var/val 修饰，自动使用 val 修饰</li>
<li>自动定义了伴生对象，提供 apply 方法，无需 new 关键字就可构造出对象</li>
<li>生成 toString,equals,hashCode,copy 方法</li>
<li>继承了 Product, Serializable 两个特质</li>
<li>case class 为多例的， case object 为单例的</li>
</ul>
<h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><p>Option通常与模式匹配结合使用，用于判断某个变量是有值还是无值。</p>
<h2 id="函数与抽象化"><a href="#函数与抽象化" class="headerlink" title="函数与抽象化"></a>函数与抽象化</h2><ul>
<li>不仅可以定义一个函数然后调用它，还可以写一个未命名的函数字面量，然后可以把它当成一个值传递到其它函数或是赋值给其它变量。</li>
<li>函数字面量体现了函数式编程的核心理念。字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、函数字面量等。</li>
<li>函数类型：(输入参数类型列表) =&gt; (输出参数类型列表)只有一个参数时，小括号可省略；函数体中只有1行语句时</li>
</ul>
<h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><ul>
<li>使用 val 定义的是函数(function)，使用 def 定义的是方法(method)。</li>
<li>Scala 中的方法与 Java 的类似，方法是组成类的一部分</li>
<li>Scala 中的函数则是一个完整的对象。Scala 中用 22 个特质(从 Function1 到 Function22)抽象出了函数的概念</li>
<li>Scala 中用 val 语句定义函数，def 语句定义方法</li>
<li>方法不能作为单独的表达式而存在，而函数可以；</li>
<li>函数必须要有参数列表，而方法可以没有参数列表；</li>
<li>方法名是方法调用，而函数名只是代表函数对象本身；</li>
<li>在需要函数的地方，如果传递一个方法，会自动把方法转换为函数</li>
<li>一般情况下，不对二者做区分，认为都是函数，<strong>更多的时候使用def定义函数。</strong></li>
</ul>
<p><strong>方法转换成函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span></span>(x: <span class="type">Int</span>) = x*x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span> </span>= double _</span><br></pre></td></tr></table></figure>

<p><strong>匿名函数</strong></p>
<p>函数没有名字就是匿名函数；</p>
<p>匿名函数，又被称为 Lambda 表达式。</p>
<p><strong>占位符</strong></p>
<ul>
<li>第一个下划线代表第一个参数</li>
<li>第二个下划线代表第二个参数</li>
<li>第三个……，如此类推</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote>
<p>接收一个或多个函数作为输入或输出一个函数。</p>
</blockquote>
<p>常用的高阶函数：map、reduce、flatMap、foreach、filter、count。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包是一种函数，是<strong>在其上下文中引用了自由变量的函数</strong>；</p>
</blockquote>
<p>闭包引用到函数外面定义的变量，定义这个函数的过程就是将这个自由变量捕获而构成的一个封闭的函数，也可理解为”把函数外部的一个自由变量关闭进来“。</p>
<p>闭包满足的条件：</p>
<ul>
<li>闭包是一个函数</li>
<li>函数必须要有返回值</li>
<li>返回值依赖声明在函数外部的一个或多个变量，用 Java 的话说，就是返回值和定义全局变量有关</li>
</ul>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><blockquote>
<p>函数编程中，<strong>接收多个参数的函数都可以转化为接收单个参数的函数，</strong>这个转化过程就叫柯里化(Currying)。</p>
</blockquote>
<p>柯里化函数拥有多组参数列表，每组参数用小括号括起来。</p>
<p>Scala 源码中的柯里化</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraversableOnce</span>[+<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">GenTraversableOnce</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  self =&gt;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = foldLeft(z)(op)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">B</span>](z: =&gt;<span class="type">B</span>)(seqop: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>, combop: (<span class="type">B</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = foldLeft(z)(seqop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h3><blockquote>
<p>部分应用函数（Partial Applied Function）也叫偏应用函数，是指缺少部分（甚至全部）参数的函数</p>
</blockquote>
<p>如果一个函数有n个参数, 而为其提供少于n个参数, 那就得到了一个部分应用函数。</p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><blockquote>
<p>并不处理所有可能的输入，而只处理那些能与至少一个 case 语句匹配的输入；</p>
</blockquote>
<p>偏函数中只能使用 case 语句，整个函数必须用大括号包围。与普通的函数字面量不同，普通的函数字面量可以使用大括号，也可以用小括号；</p>
<p>Scala中的 Partial Function 是一个 trait。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PartialFunction</span>[-<span class="type">A</span>, +<span class="type">B</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">A</span> =&gt; <span class="type">B</span></span>) </span>&#123; self =&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PartialFunction</span>._</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">A</span>): <span class="type">Boolean</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>[<span class="type">A1</span> &lt;: <span class="type">A</span>, <span class="type">B1</span> &gt;: <span class="type">B</span>](that: <span class="type">PartialFunction</span>[<span class="type">A1</span>, <span class="type">B1</span>]): <span class="type">PartialFunction</span>[<span class="type">A1</span>, <span class="type">B1</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OrElse</span>[<span class="type">A1</span>, <span class="type">B1</span>] (<span class="keyword">this</span>, that)</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">C</span>](k: <span class="type">B</span> =&gt; <span class="type">C</span>): <span class="type">PartialFunction</span>[<span class="type">A</span>, <span class="type">C</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">AndThen</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>] (<span class="keyword">this</span>, k)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lift</span></span>: <span class="type">A</span> =&gt; <span class="type">Option</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Lifted</span>(<span class="keyword">this</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">applyOrElse</span></span>[<span class="type">A1</span> &lt;: <span class="type">A</span>, <span class="type">B1</span> &gt;: <span class="type">B</span>](x: <span class="type">A1</span>, <span class="keyword">default</span>: <span class="type">A1</span> =&gt; <span class="type">B1</span>): <span class="type">B1</span> =</span><br><span class="line">    <span class="keyword">if</span> (isDefinedAt(x)) apply(x) <span class="keyword">else</span> <span class="keyword">default</span>(x)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">runWith</span></span>[<span class="type">U</span>](action: <span class="type">B</span> =&gt; <span class="type">U</span>): <span class="type">A</span> =&gt; <span class="type">Boolean</span> = &#123; x =&gt;</span><br><span class="line">    <span class="keyword">val</span> z = applyOrElse(x, checkFallback[<span class="type">B</span>])</span><br><span class="line">    <span class="keyword">if</span> (!fallbackOccurred(z)) &#123; action(z); <span class="literal">true</span> &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 Int 类型的元素加 1</span></span><br><span class="line"><span class="keyword">val</span> partialFunction = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    x.isInstanceOf[<span class="type">Int</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    v1.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">10</span>, <span class="string">&quot;hadoop&quot;</span>, <span class="number">20</span>, <span class="string">&quot;spark&quot;</span>, <span class="number">30</span>, <span class="string">&quot;flink&quot;</span>)</span><br><span class="line">list.collect(partialFunction).foreach(println)</span><br><span class="line"><span class="comment">// simple    </span></span><br><span class="line">list.collect(&#123;<span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span>&#125;).foreach(println)</span><br></pre></td></tr></table></figure>

<h2 id="隐式机制"><a href="#隐式机制" class="headerlink" title="隐式机制"></a>隐式机制</h2><blockquote>
<p>根据隐式转换函数的签名，在程序中使用到隐式转换函数接收的参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回，这就是“隐式转换”</p>
</blockquote>
<p>隐式转换和隐式参数是Scala中两个非常强大的功能，利用隐式转换和隐式参数，可以提供类库，对类库的使用者隐匿掉具体的细节。</p>
<p>使用限制</p>
<ul>
<li>implicit 关键字只能用来修饰方法、变量、参数</li>
<li>隐式转换的函数只在当前范围内才有效。如果隐式转换不在当前范围内定义，那么必须通过 import 语句将其导入</li>
</ul>
<h3 id="隐式转换函数"><a href="#隐式转换函数" class="headerlink" title="隐式转换函数"></a>隐式转换函数</h3><p>定义的隐式转换函数，只要在编写的程序内引入，就会被Scala自动使用。</p>
<p>隐式转换函数由Scala自动调用，通常建议将隐式转换函数的名称命名为“one2one”的形式。</p>
<h3 id="隐式参数和隐式值"><a href="#隐式参数和隐式值" class="headerlink" title="隐式参数和隐式值"></a>隐式参数和隐式值</h3><p>在函数定义的时候，支持在<strong>最后一组参数</strong>中使用 implicit ，表明这是一组隐式参数。</p>
<p>在调用该函数的时候，可以不用传递隐式参数，而编译器会自动寻找一个implicit 标记过的合适的值作为参数。</p>
<p>查看范围</p>
<ul>
<li>当前作用域内可见的 val 或 var 定义隐式变量</li>
<li>隐式参数类型的伴生对象内隐式值</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://www.scala-lang.org/">The Scala Programming Language</a></p>
<p>Scala 官网</p>
<p><a target="_blank" rel="noopener" href="https://www.scala-lang.org/download/2.11.8.html">Scala 2.11.8</a></p>
<p>Scala官网下载Scala 2.11.8安装包</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vGLVmgcjK3jmK6ibYIONew">为什么 Haskell 是我们构建生产软件系统的首选</a></p>
<p>Haskell</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/Scala%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" data-id="ckm733ru10026ivvx5z4xg1tv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/09/Scala%E9%9B%86%E5%90%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Scala集合
        
      </div>
    </a>
  
  
    <a href="/2021/03/09/Vagrent/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Vagrent</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/" rel="tag">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hive/" rel="tag">Hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Hadoop/" style="font-size: 17.5px;">Hadoop</a> <a href="/tags/Hive/" style="font-size: 20px;">Hive</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/Scala/" style="font-size: 12.5px;">Scala</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-%E5%9F%BA%E7%A1%80/">Hive-基础</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-%E4%BC%98%E5%8C%96/">Hive-优化</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-%E5%87%BD%E6%95%B0/">Hive-函数</a>
          </li>
        
          <li>
            <a href="/2021/03/09/Hive-HQL/">Hive-HQL</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>